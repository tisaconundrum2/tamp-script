/**
 * SuiteScript module
 *
 * @private
 * @module N/nsobject
 * @NApiVersion 2.x
 */
define('N/nsobject',[], function (){
		/* NetSuite Javascript Object Marker */
		function NetSuiteObject() {}
		Object.freeze(NetSuiteObject);

		return {
			getNewInstance: function() { return new NetSuiteObject(); },
			isInstanceOfNSObject: function(obj) { return obj instanceof NetSuiteObject; }
		};
	}
);

/**
 * SuiteScript global context switching module
 *
 * @private
 * @module N/contextSwitch
 * @suiteScriptVersion 2.x
 *
 */
define('N/contextSwitch',[], function () {
	function renameTo(name, func) {
		if (typeof func === 'function') {
			try {
				Object.defineProperty(func, 'name', { value: name, configurable: true });
			} catch (e) {}
		}
		return func;
	}

	function isCrossOrigin(obj) {
		if (obj !== undefined && obj !== null)
		{
			try {
				void obj.propertyAccessWhichMightThrowPermissionError;
			} catch (e) {
				return true;
			}
		}
		return false;
	}

	var Context = (function () {
		var topLevelContext, currentContext;

		var Context = function Context(options) {
			var record = options.record;
			var scriptInfo = options.scriptInfo;
			var nlrumArgs = options.nlrumArgs;
			var awaitCall = options.awaitCall;

			this.record = record;
			this.scriptInfo = scriptInfo;
			this.nlrumArgs = nlrumArgs;
			this.awaitCall = awaitCall;
			this.id = String([record && record.getSystemId(), scriptInfo.scriptId]);
		};

		Context.prototype.apply = function apply(func, thisArg, argsArray) {
			if (monkeyPatchBuiltins !== undefined) {
				monkeyPatchBuiltins();
			}
			var previousContext = currentContext;
			currentContext = this;
			try {
				return func.apply(thisArg, argsArray);
			} finally {
				currentContext = previousContext;
				if (monkeyUnpatchBuiltins !== undefined) {
					monkeyUnpatchBuiltins();
				}
			}
		};

		var unwrapKey = '_contextSwitch_unwrap';

		function isWrapped(func) {
			return typeof func === 'function' && Object.prototype.hasOwnProperty.call(func, unwrapKey);
		}

		Context.prototype.wrap = function wrap(func, options) {
			if (isCrossOrigin(func) || isWrapped(func)) {
				return func;
			}

			if (options) {
				var coerce = options.coerce;
				var enableCallbacks = options.enableCallbacks;
				var identical = options.identical;
				if (enableCallbacks) {
					var postCallback = options.postCallback;
					var nlrumArgs = this.nlrumArgs;
				}
			}

			if (this.id === topLevelContext.id && nlrumArgs === undefined && postCallback === undefined) {
				return func;
			}
			if (typeof func !== 'function' && coerce !== undefined) {
				func = coerce(func);
			}
			if (typeof func !== 'function') {
				return func;
			}

			var suffix = '[SuiteScript:' + (nlrumArgs === undefined ? this.id : [this.id, nlrumArgs[0], nlrumArgs[2]]) + ']';

			var wrapKey = '_contextSwitch_wrap' + suffix;
			if (identical && Object.prototype.hasOwnProperty.call(func, wrapKey)) {
				return func[wrapKey];
			}

			var context = this;
			var wrappedFunc = renameTo((func.name || '(anonymous)') + suffix, function () {
				try {
					if (nlrumArgs !== undefined) {
						NLRUM.clientScriptAsyncCallbackBegin.apply(NLRUM, nlrumArgs);
					}
					try {
						return context.apply(func, this, arguments);
					} catch (e) {
						nlrumArgs = undefined;
						throw e;
					} finally {
						if (nlrumArgs !== undefined) {
							NLRUM.clientScriptAsyncCallbackEnd.apply(NLRUM, nlrumArgs);
						}
					}
				} finally {
					if (postCallback !== undefined) {
						postCallback();
					}
				}
			});

			if (identical) {
				func[wrapKey] = wrappedFunc;
			}
			wrappedFunc[unwrapKey] = func;

			return wrappedFunc;
		};

		topLevelContext = new Context({ scriptInfo: {} });
		currentContext = topLevelContext;

		Context.wrap = function wrap(func, options) {
			return currentContext.wrap(func, options);
		};

		Context.unwrap = function unwrap(func) {
			return isWrapped(func) ? func[unwrapKey] : func;
		};

		Context.awaitCall = function awaitCall() {
			if (currentContext.awaitCall) {
				return currentContext.awaitCall();
			}
		};

		Context.getRecord = function getRecord() {
			return currentContext.record;
		};

		Context.getScript = function getScript() {
			return currentContext.scriptInfo;
		};

		return Context;
	})();

	var monkeyPatchBuiltins, monkeyUnpatchBuiltins;

	(function () {
		if (typeof window === 'undefined' || typeof document === 'undefined' || typeof globalTestExposures !== 'undefined') {
			// not browser
			return;
		}

		var global = window;
		var wrap = Context.wrap;
		var unwrap = Context.unwrap;
		var awaitCall = Context.awaitCall;

		var monkeyPatch, monkeyPatchProperty;

		(function () {
			var patches = [];

			monkeyPatchProperty = function monkeyPatchProperty(obj, name, patch) {
				for (; obj !== null; obj = Object.getPrototypeOf(obj)) {
					if (Object.prototype.hasOwnProperty.call(obj, name)) {
						var desc = patch(Object.getOwnPropertyDescriptor(obj, name));
						try {
							Object.defineProperty(obj, name, desc);
						} catch (e) {}
						break;
					}
				}
			};

			monkeyPatch = function monkeyPatch(obj, name, patch, immediate) {
				for (; obj !== null; obj = Object.getPrototypeOf(obj)) {
					if (Object.prototype.hasOwnProperty.call(obj, name)) {
						var original = obj[name];
						var patched = renameTo((original.name || '(anonymous)') + '[SuiteScript]', patch(original));
						if (immediate) {
							try {
								obj[name] = patched;
							} catch (e) {}
						} else {
							patches.push({ obj: obj, name: name, original: original, patched: patched });
						}
						break;
					}
				}
			};

			var depth = 0;

			monkeyPatchBuiltins = function monkeyPatchBuiltins() {
				if (depth === 0) {
					for (var i = 0; i < patches.length; i++) {
						try {
							patches[i].obj[patches[i].name] = patches[i].patched;
						} catch (e) {}
					}
				}
				depth++;
			};

			monkeyUnpatchBuiltins = function monkeyUnpatchBuiltins() {
				depth--;
				if (depth === 0) {
					for (var i = 0; i < patches.length; i++) {
						try {
							patches[i].obj[patches[i].name] = patches[i].original;
						} catch (e) {}
					}
				}
			};
		}());

		(function monkeyPatchTimers() {
			function coerceCode(code) {
				return eval.bind(this, code);
			}

			var timers = {};

			function addTimer(timerId) {
				var settleCall = awaitCall();
				if (settleCall) {
					timers[timerId] = settleCall;
				}
			}

			function removeTimer(timerId) {
				if (timerId in timers) {
					timers[timerId]();
					delete timers[timerId];
				}
			}

			monkeyPatch(global, 'setTimeout', function (origSetTimeout) {
				return function patchedSetTimeout(func) {
					var removeSelf = function () { removeTimer(timeoutId); };
					var wrappedFunc = wrap(func, { coerce: coerceCode, enableCallbacks: true, postCallback: removeSelf });
					var timeoutId = origSetTimeout.apply(this, [wrappedFunc].concat(Array.prototype.slice.call(arguments, 1)));
					addTimer(timeoutId);
					return timeoutId;
				};
			});
			monkeyPatch(global, 'setInterval', function (origSetInterval) {
				return function patchedSetInterval(func) {
					var wrappedFunc = wrap(func, { coerce: coerceCode, enableCallbacks: true });
					var intervalId = origSetInterval.apply(this, [wrappedFunc].concat(Array.prototype.slice.call(arguments, 1)));
					addTimer(intervalId);
					return intervalId;
				};
			});
			monkeyPatch(global, 'clearTimeout', function (origClearTimeout) {
				return function patchedClearTimeout(timeoutId) {
					removeTimer(timeoutId);
					return origClearTimeout(timeoutId);
				}
			});
			monkeyPatch(global, 'clearInterval', function (origClearInterval) {
				return function patchedClearInterval(intervalId) {
					removeTimer(intervalId);
					return origClearInterval(intervalId);
				}
			});
		}());

		(function monkeyPatchPromise() {
			if (typeof Promise === 'undefined') {
				return;
			}

			function identity(value) {
				return value;
			}

			function thrower(exc) {
				throw exc;
			}

			function coerceIdentity() {
				return identity;
			}

			function coerceThrower() {
				return thrower;
			}

			var origThen = Promise.prototype.then;

			monkeyPatch(Promise.prototype, 'then', function () {
				return function patchedThen(onFulfilled, onRejected) {
					var settleCall = awaitCall();
					var wrappedOnFulfilled = wrap(onFulfilled, {
						coerce: coerceIdentity,
						enableCallbacks: true,
						postCallback: settleCall
					});
					var wrappedOnRejected = wrap(onRejected, {
						coerce: coerceThrower,
						enableCallbacks: true,
						postCallback: settleCall
					});
					return origThen.call(this, wrappedOnFulfilled, wrappedOnRejected);
				};
			});
			monkeyPatch(Promise.prototype, 'catch', function () {
				return function patchedCatch(onRejected) {
					var settleCall = awaitCall();
					var wrappedOnFulfilled = wrap(undefined, {
						coerce: coerceIdentity,
						enableCallbacks: true,
						postCallback: settleCall
					});
					var wrappedOnRejected = wrap(onRejected, {
						coerce: coerceThrower,
						enableCallbacks: true,
						postCallback: settleCall
					});
					return origThen.call(this, wrappedOnFulfilled, wrappedOnRejected);
				};
			});
			monkeyPatch(Promise.prototype, 'finally', function (origFinally) {
				return function patchedFinally(onFinally) {
					var settleCall = awaitCall();
					return origFinally.call(this, wrap(onFinally, { enableCallbacks: true, postCallback: settleCall }));
				};
			});
		}());

		(function monkeyPatchEventTarget() {
			var coerceEventListenerKey = '_contextSwitch_coerceEventListener';

			function coerceEventListener(listener) {
				if (typeof listener === 'object' && listener !== null && typeof listener.handleEvent === 'function') {
					if (Object.prototype.hasOwnProperty.call(listener, coerceEventListenerKey)) {
						return listener[coerceEventListenerKey];
					} else {
						var coercedListener = listener.handleEvent.bind(listener);
						Object.defineProperty(listener, coerceEventListenerKey, { value: coercedListener });
						return coercedListener;
					}
				}
				return listener;
			}

			function patchAddEventListener(origAddEventListener) {
				return function patchedAddEventListener(type, listener) {
					listener = wrap(listener, { coerce: coerceEventListener, identical: true });
					return origAddEventListener.apply(this, [type, listener].concat(Array.prototype.slice.call(arguments, 2)));
				};
			}

			function patchRemoveEventListener(origRemoveEventListener) {
				return function patchedRemoveEventListener(type, listener) {
					listener = wrap(listener, { coerce: coerceEventListener, identical: true });
					return origRemoveEventListener.apply(this, [type, listener].concat(Array.prototype.slice.call(arguments, 2)));
				}
			}

			var seenGlobalNames = ['content', 'webkitStorageInfo', 'webkitURL'];
			var seenObjs = [];
			var isEventTarget = typeof EventTarget === 'function'
				? function isEventTarget(obj) {
					return obj === EventTarget.prototype || obj instanceof EventTarget;
				}
				: function isEventTarget(obj) {
					return obj !== undefined
						&& obj !== null
						&& typeof obj.addEventListener === 'function'
						&& typeof obj.removeEventListener === 'function'
						&& typeof obj.dispatchEvent === 'function';
				};

			for (var globalObj = global; globalObj !== null; globalObj = Object.getPrototypeOf(globalObj)) {
				var globalNames = Object.getOwnPropertyNames(globalObj);
				for (var i = 0; i < globalNames.length; i++) {
					var globalName = globalNames[i];
					if (seenGlobalNames.indexOf(globalName) !== -1) {
						continue;
					}
					seenGlobalNames.push(globalName);

					var obj;
					try {
						obj = globalObj[globalName];
					} catch (e) {
						continue;
					}
					if (isCrossOrigin(obj)) {
						continue;
					}
					if (typeof obj === 'function' && obj.prototype !== undefined) {
						obj = obj.prototype;
					}
					if (!isEventTarget(obj)) {
						continue;
					}

					var seenNames = [];

					for (; obj !== null; obj = Object.getPrototypeOf(obj)) {
						if (seenObjs.indexOf(obj) !== -1 || obj === Object.prototype) {
							break;
						}
						seenObjs.push(obj);

						if (Object.prototype.hasOwnProperty.call(obj, 'addEventListener')) {
							monkeyPatch(obj, 'addEventListener', patchAddEventListener, true);
						}
						if (Object.prototype.hasOwnProperty.call(obj, 'removeEventListener')) {
							monkeyPatch(obj, 'removeEventListener', patchRemoveEventListener, true);
						}
						if (Object.prototype.hasOwnProperty.call(obj, 'attachEvent')) {
							monkeyPatch(obj, 'attachEvent', patchAddEventListener, true);
						}
						if (Object.prototype.hasOwnProperty.call(obj, 'detachEvent')) {
							monkeyPatch(obj, 'detachEvent', patchRemoveEventListener, true);
						}

						var names = Object.getOwnPropertyNames(obj);
						for (var j = 0; j < names.length; j++) {
							var name = names[j];
							if (seenNames.indexOf(name) !== -1 || name.indexOf('on') !== 0) {
								continue;
							}
							seenNames.push(name);

							monkeyPatchProperty(obj, name, function (desc) {
								if (desc.set !== undefined) {
									monkeyPatch(desc, 'set', function (origSet) {
										return function patchedSet(newValue) {
											origSet.call(this, wrap(newValue));
										};
									}, true);
									monkeyPatch(desc, 'get', function (origGet) {
										return function patchedGet() {
											return unwrap(origGet.call(this));
										};
									}, true);
								}
								return desc;
							});
						}
					}
				}
			}
		}());
	}());

	var execute = (function () {
		function createAwaitCall(settleCallback) {
			if (settleCallback === undefined) {
				return;
			}

			var wrappedSettleCallback = Context.wrap(settleCallback);
			var numPendingCalls = 0;

			function settleCall() {
				numPendingCalls--;
				if (numPendingCalls === 0) {
					setTimeout(wrappedSettleCallback);
				}
			}

			function awaitCall() {
				numPendingCalls++;
				return settleCall;
			}

			return awaitCall;
		}

		function execute(options, callback) {
			var context = new Context({
				record: options.record !== undefined ? options.record : Context.getRecord(),
				scriptInfo: options.scriptInfo !== undefined ? options.scriptInfo : Context.getScript(),
				nlrumArgs: typeof NLRUM !== 'undefined' ? options.nlrumArgs : undefined,
				awaitCall: createAwaitCall(options.settleCallback)
			});

			return context.apply(function () {
				var settleCall = Context.awaitCall();
				try {
					return callback();
				} finally {
					if (settleCall !== undefined) {
						settleCall();
					}
				}
			}, undefined, []);
		}

		return execute;
	})();

	return Object.freeze({
		execute: execute,
		getRecord: Context.getRecord,
		getScript: Context.getScript
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/reflet
 * @NApiVersion 2.x
 */
define('N/restricted/reflet',['N/contextSwitch'],
        function (contextSwitch)
        {
            var chargeMap = {};
            var usageCostMap = null;
            var recordTypes = null;
            var totalBundleUsage = {};
            var nsJSONProxyURL = '/app/common/scripting/nlapijsonhandler.nl';
            var warningMessages = [];

            function alert(msg) {
            	if (msg && typeof console !== 'undefined' && console.log) {
		            console.log('>>ALERT:' + msg);
	            }
            	warningMessages.push(msg);
            }

	        function confirm(msg) {
		        if (msg && typeof console !== 'undefined' && console.log) {
			        console.log('>>CONFIRM:' + msg);
		        }
		        return true; // autoconfirm
	        }

            function checkWarningMessageInSession() {
            	var count = warningMessages.length;
            	if (count > 0) {
		            var lastMsg = warningMessages.pop();
		            var warningMsg = lastMsg;
		            if (count > 1) {
		            	warningMsg = "Multiple Error Detected" + "\n" + lastMsg + "\n";
		            	for (var msgIndex in warningMessages) {
		            		var msg = warningMessages[msgIndex];
				            warningMsg = warningMsg + msg + "\n";
			            }
		            }
		            var error = new Error(warningMsg);
		            error.name = "USER_ERROR";
		            throw error;
	            }
            }

            function getCharges()
            {
                return chargeMap[getScript().scriptId] || 0;
            }

            function setupScript(thisObject)
            {
                chargeMap[thisObject.scriptId] = 0;
            }

	        var getScript = contextSwitch.getScript;

            function chargeUsage(method, type, args, governanceOverride) {
                var script = getScript().scriptId;
                if (script === "internal")
                    return;
	            if (usageCostMap === null)
		            usageCostMap = serverCallSync(nsJSONProxyURL, "getUsageUnits", []);
	            var cost = 0;
	            if (util.isNumber(governanceOverride))
		            cost = governanceOverride;
	            else
	            {
		            if (method === 'nlapiSendEmail' && args[8] /*notifySenderOnBounce*/)
			            cost = usageCostMap[method + '_trackBouncesUpcharge'] || 0;
		            /* TODO: Figure out a better way to deal with bulk action */
		            else if (method === 'executeAction' && args[0] === 'timesheet')
			            cost = usageCostMap[method + 'Bulk'] || 0;
		            else
			            cost = usageCostMap[method] || 0;
		            if (type != null) {
			            if (recordTypes === null)
			                recordTypes = serverCallSync(nsJSONProxyURL, "getRecordTypes", []);
			            var recType = recordTypes[type.toLowerCase()].type;
			            cost /= (recType === "RECORD") ? 5 : ( (recType === "BODY" ? 1 : 2) );
			            if (method === 'nlapiLookupFields_v1')
			                cost--; // compensate for v2 nlapiLookupFields being already charged
		            }
                }
                var thisKey = getScript().scriptId;
                chargeMap[thisKey] = (chargeMap[thisKey] || 0) + cost;
                //console.log("=======" + thisKey + "will be charged " + cost
                //            + " for using " + method + " (type = " + type + "). FYI, Total Charge is " + chargeMap[thisKey]);
                if (calculateRemainingUsage() < 0)
                {
                    var error = new Error(getErrorMsg("SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED"));
                    error.name = "SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED";
                    throw error;
                }
            }

            function createError(myCode, myDetails, suppressNotification)
            {
                var error = Error(myDetails);
                error.name = myCode;
                try
                {
                    throw error;
                }
                catch (e)
                {
                    error = e;
                }

                return {
                    getId: function () { return null },
                    getCode: function () { return error.name },
                    getDetails: function () { return error.message },
                    getStackTrace: function () { return error.stack.split("\n"); }
                };
            }

            function getTotalUsage()
            {
                var bundle = -1;
                var script = getScript().scriptId;
                if (script != null && script != "global" && script != "internal")
                {
                    bundle = getScript().bundleId;
                    if (bundle == null || bundle == '')  bundle = -1;
                }
                if (totalBundleUsage[bundle] == null)
                {
                    totalBundleUsage[bundle] = serverCallSync(nsJSONProxyURL, "getTotalScriptGovernance", [ bundle ] );
                }
                return totalBundleUsage[bundle];
            }

            function getErrorMsg(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
            {
                return serverCallSync(nsJSONProxyURL, "getErrorMessage", [errorCode, errorVal1, errorVal2, errorVal3, errorVal4]);
            }

            function calculateRemainingUsage()
            {
                return getTotalUsage() - parseInt(getCharges(), 10);
            }

            var theContext = null;

            function getContext()
            {
                try
                {
                    if (theContext === null)
                    {
                        if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null)
                            theContext = nsDefaultContextObj;
                        else
                        {
                            theContext = serverCallSync(nsJSONProxyURL, "getContext");
                            theContext.internal = true;
	                        if (theContext.contexttypes)
		                        theContext.contexttypes = JSON.parse(theContext.contexttypes);
                        }
                    }
                }
                catch (e)
                {
                    throw Error(e);
                }

                function getRecordType()
                {
                    if (theContext.recordType == null)
                    {
                        var wasSync = require.isSync();
                        require.forceSync(true);
                        try {
                            require(['N/currentRecord'], function (crMod) { theContext.recordType = crMod.get().type; });
                        }
                        finally {
                            require.forceSync(wasSync);
                        }
                    }
                    return theContext.recordType;
                }

                function getPref(name)
                {
                    if (name.toLowerCase().indexOf('custscript') == 0)
                    {
                        if (theContext.scriptprefs == null)
                        {
                            theContext.scriptprefs = serverCallSync(nsJSONProxyURL, "getScriptPrefs", [getRecordType()]);
                        }
                        return theContext.scriptprefs[name];
                    }

	                name = name.toUpperCase();
                    //Verify that the preferences global object has been already loaded
	                if(typeof preferencesCache === "undefined" || !preferencesCache ||typeof preferencesCache[name] === "undefined")
	                {
		                //cache miss or empty cache, load all preferences from the server into the global variable that's acting as a cache.
		                serverCallAsync(nsJSONProxyURL, "getPreferences", [], function(data){
			                if(data != null || data)
			                {
				                preferencesCache = data.result == null ? data : data.result;
			                }
		                });
		                // Cache loading has been triggered, now return the single result required using the old way.
		                return serverCallSync(nsJSONProxyURL, "getPref", [name]);
	                }

	                // return preference value from cached object, after handling  T/F -> true/false conversion if needed.
	                var prefValue = preferencesCache[name];
	                var prefType = getPrefType(name);
	                if (('T' === prefValue || 'F' === prefValue) && ('boolean' === prefType))
		                return 'T' === prefValue;
	                else
		                return prefValue;
                }

                function getPrefType(name)
                {
                    if (name.toLowerCase().indexOf('custscript') == 0)
                    {
                        if (theContext.scriptpreftypes == null)
                        {
                            theContext.scriptpreftypes = serverCallSync(nsJSONProxyURL, "getScriptPrefTypes", [getRecordType()]);
                        }
                        return theContext.scriptpreftypes[name];
                    }
	                name = name.toUpperCase();


	                if(typeof preferencesTypesCache === "undefined" || !preferencesTypesCache ||typeof preferencesTypesCache[name] === "undefined")
	                {
		                //cache miss or empty cache.
		                serverCallAsync(nsJSONProxyURL, "getAllPreferencesTypes", [], function(data){
			                if(data != null || data)
			                {
				                preferencesTypesCache = data.result == null ? data : data.result;
			                }
		                });
		                return serverCallSync(nsJSONProxyURL, "getPrefType", [name]);
	                }

					// return preference value from cached object.
	                return preferencesTypesCache[name];
                }

                return {
                    //Script
                    getLogLevel: function () { return undefined;}, // not supported for client scripts
                    getScriptId: function () { return !!getScript() ? getScript().scriptId : undefined},
                    getPercentComplete: function () { return undefined;}, // not supported for client scripts
                    setPercentComplete: function () { return undefined;}, // not supported for client scripts
                    getDeploymentId: function () { return !!getScript() ? getScript().deployId : undefined },
                    getBundleId: function () { return !!getScript() ? getScript().bundleId : undefined },
                    getBundleIds: function ()
					{
						var rc = !!getScript() && getScript().hasOwnProperty('bundleId') ? getScript().bundleId.split(',') : undefined;
						if (Array.isArray(rc) && rc.length === 1 && rc[0] === '')
							return [];
						return rc;
					},
                    getRemainingUsage: function () { return calculateRemainingUsage();},
                    getPreferenceObject: function (name) { return getPref(name);},
                    getPreference: function (name) { return getPref(name);},
                    getPreferenceType: function (name) { return getPrefType(name);},
                    //Session
                    getSessionObject: function (name) { return serverCallSync(nsJSONProxyURL, "getSessionObject", [name]);},
                    setSessionObject: function () { return undefined;}, // not supported for client scripts
                    //User
                    getEmail: function () { return theContext.email;},
                    getName: function () { return theContext.name;},
                    getLocation: function () { return parseInt(theContext.location, 10);},
                    getDepartment: function () { return parseInt(theContext.department, 10);},
                    getRole: function () { return parseInt(theContext.role, 10);},
                    getRoleCenter: function () { return theContext.rolecenter;},
                    getRoleId: function () { return theContext.roleid;},
                    getUser: function () { return parseInt(theContext.user, 10);},
                    getContact: function () { return parseInt(theContext.contact, 10);},
                    getSubsidiary: function () { return parseInt(theContext.subsidiary, 10);},
                    getPermission: function (name)
                    {
	                    name = name.toUpperCase();
	                    if(typeof permissionsCache === "undefined" || !permissionsCache ||typeof permissionsCache[name] === "undefined")
	                    {
		                    //cache miss or empty cache.
		                    serverCallAsync(nsJSONProxyURL, "getPermissions", [], function(data){
			                    if(data != null || data)
			                    {
				                    permissionsCache = data.result == null ? data : data.result;
			                    }
		                    });
		                    return serverCallSync(nsJSONProxyURL, "getPerm", [name]);
	                    }

						// return preference value from cached object.
	                    return permissionsCache[name];
                    },
                    //Base
                    getFeature: function (name)
                    {
	                    name = name.toUpperCase();
	                    //Verify that the features global object has been already loaded
	                    if(typeof featuresCache === "undefined" || !featuresCache || typeof featuresCache.set  === "undefined")
	                    {
		                    //cache miss or empty cache, load all features from the server into the global variable that's acting as a cache.
		                    serverCallAsync(nsJSONProxyURL, "getFeatures", [], function(data){
			                    if(data != null || data)
			                    {
				                    featuresCache = data.result == null ? data : data.result;
			                    }
		                    });
		                    return serverCallSync(nsJSONProxyURL, "getFeature", [name]);
	                    }

	                    return featuresCache.set == null ? featuresCache.hasOwnProperty(name) : featuresCache.set.hasOwnProperty(name);
                    },
                    getQueueCount: function () { return undefined;}, // not supported for client scripts
	                getProcessorCount: function () { return undefined;}, // not supported for client scripts
                    getVersion: function () { return theContext.version;},
                    getCompany: function () { return theContext.company;},
                    getEnvironment: function () { return theContext.environment;},
                    getExecutionContext: function () { return theContext.context;},
                    getExecutionContextTypes: function(){ return theContext.contexttypes;},
                    //Client Script Only
                    isInternal: function () { return theContext.internal; },
                    getScriptType: function () { return "CLIENT"; }
                }
            }

            function XMLtoString(xml)
            {
                if (!xml)
                {
                    var error = new Error(getErrorMsg("SSS_MISSING_REQD_ARGUMENT"));
                    error.name = "SSS_MISSING_REQD_ARGUMENT";
                    throw error;
                }

                try
                {
                    if (xml.nodeType === 2)    /* Special Handling for Attribute Node. XMLSerializer supports Nodes only */
                        return xml.name + '=' + xml.value;
                    else if (window.XMLSerializer && window.XPathEvaluator)
                        return new XMLSerializer().serializeToString(xml);
                    else
                        return xml.xml
                }
                catch (e)
                {
                    throw e;
                }
            }

            function wrap(node)
            {
                if (!node)
                {
                    return node
                }

                switch (node.nodeType)
                {
                    case 1:
                        return wrapElement(node);
                    case 2:
                        return wrapAttr(node);
                    case 9:
                        return wrapDocument(node);
                    default:
                        return wrapNode(node);
                }
            }

            function wrapAttr(attr)
            {
                var wrappedAttr = {};
                wrappedAttr.getName = function () { return attr.name; };
                wrappedAttr.getOwnerElement = function () { return wrap(attr.ownerElement); };
                wrappedAttr.getSpecified = function () { return attr.specified; };
                wrappedAttr.getValue = function () { return attr.value; };
                wrappedAttr.setValue = function (val) { attr.value = val; };
                return wrappedAttr;
            }

            function wrapDocument(doc)
            {
                var wrappedDoc = wrapNode(doc);
                wrappedDoc.hasAttributes = undefined;
                wrappedDoc.adoptNode = function (source) { return wrap(doc.adoptNode(source)) };
                wrappedDoc.createAttribute = function (name) { return wrapAttr(doc.createAttribute(name)) };
                wrappedDoc.createAttributeNS = function (qualifiedName) { return wrapAttr(doc.createAttributeNS(qualifiedName)) };
                wrappedDoc.createCDATASection = function (data) { return wrapNode(doc.createCDATASection(data)) };
                wrappedDoc.createComment = function (data) { return wrapNode(doc.createComment(data)) };
                wrappedDoc.createDocumentFragment = function () { return wrapNode(doc.createDocumentFragment()) };
                wrappedDoc.createElement = function (tagName) { return wrapElement(doc.createElement(tagName)) };
                wrappedDoc.createElementNS = function (namespaceURI, qualifiedName) { return wrapElement(doc.createElementNS(namespaceURI, qualifiedName)) };
                wrappedDoc.createProcessingInstruction = function (target, data) { return wrapNode(doc.createProcessingInstruction(target, data)) };
                wrappedDoc.createTextNode = function (data) { return wrapNode(doc.createTextNode(data)) };
                wrappedDoc.getElementById = function (elementId) { return wrapElement(doc.getElementById(elementId)) };
                wrappedDoc.getElementsByTagName = function (tagName) { return wrapElement(doc.getElementsByTagName(tagName)) };
                wrappedDoc.getElementsByTagNameNS = function (namespaceURI, localName) { return wrapElement(doc.getElementsByTagNameNS(namespaceURI, localName)) };
                wrappedDoc.importNode = function (importedNode, deep) { return wrap(doc.importNode(importedNode, deep)) };
                wrappedDoc.normalizeDocument = function () { return doc.normalize(); };
                wrappedDoc.getDoctype = function () { return wrapNode(doc.doctype) };
                wrappedDoc.getDocumentElement = function () { return wrapElement(doc.documentElement) };
                wrappedDoc.getDocumentURI = function () { return doc.documentURI };
                wrappedDoc.setDocumentURI = function (val) { doc.documentURI = val};
                wrappedDoc.getInputEncoding = function () { return doc.inputEncoding };
                wrappedDoc.getXmlEncoding = function () { return doc.xmlEncoding };
                wrappedDoc.getXmlStandalone = function () { return doc.xmlStandalone };
                wrappedDoc.setXmlStandalone = function (val) { doc.xmlStandalone = val };
                wrappedDoc.getXmlVersion = function () { return doc.xmlVersion };
                wrappedDoc.setXmlVersion = function (val) { doc.xmlVersion = val };
                return wrappedDoc;
            }

            function wrapElement(element)
            {
                var wrappedElem = wrapNode(element)
                wrappedElem.getAttribute = function (name) { return element.getAttribute(name); };
                wrappedElem.getAttributeNode = function (name) { return wrap(element.getAttributeNode(name)); };
                wrappedElem.getAttributeNodeNS = function (namespaceURI, localName) { return wrap(element.getAttributeNodeNS(namespaceURI, localName)); };
                wrappedElem.getAttributeNS = function (namespaceURI, localName) { return element.getAttributeNS(namespaceURI, localName); };
                wrappedElem.getElementsByTagName = function (tagName) { return wrapElement(element.getElementsByTagName(tagName)); };
                wrappedElem.getElementsByTagNameNS = function (namespaceURI, localName) { return wrapElement(element.getElementsByTagNameNS(namespaceURI, localName)); };
                wrappedElem.hasAttribute = function (name) { return element.hasAttribute(name); };
                wrappedElem.hasAttributeNS = function (namespaceURI, localName) { return element.hasAttributeNS(namespaceURI, localName); };
                wrappedElem.removeAttribute = function (name) { return element.removeAttribute(name); };
                wrappedElem.removeAttributeNode = function (oldAttr) { return wrap(element.removeAttributeNode(oldAttr)); };
                wrappedElem.removeAttributeNS = function (namespaceURI, localName) { return element.removeAttributeNS(namespaceURI, localName); };
                wrappedElem.setAttribute = function (name, value) { return element.setAttribute(name, value); };
                wrappedElem.setAttributeNode = function (newAttr) { return element.setAttributeNode(newAttr); };
                wrappedElem.setAttributeNodeNS = function (newAttr) { return element.setAttributeNodeNS(newAttr); };
                wrappedElem.setAttributeNS = function (namespaceURI, qualifiedName, value) { return element.setAttributeNS(namespaceURI, qualifiedName, value); };
                wrappedElem.getTagName = function () { return element.getTagName(); };
                return wrappedElem;
            }

            function wrapNode(node)
            {
                return {
                    appendChild: function (newChild) { return wrap(node.appendChild(newChild)); },
                    cloneNode: function (deep) { return wrap(node.cloneNode(deep)); },
                    compareDocumentPosition: function (other) { return node.compareDocumentPosition(other); },
                    hasAttributes: function () { return node.hasAttributes(); },
                    hasChildNodes: function () { return node.hasChildNodes(); },
                    insertBefore: function (newChild, refChild) { return wrap(node.insertBefore(newChild, refChild)); },
                    isDefaultNamespace: function (namespaceURI) { return node.isDefaultNamespace(namespaceURI); },
                    isEqualNode: function (other) { return node.isEqualNode(other); },
                    isSameNode: function (other) { return node.isSameNode(other); },
                    lookupNamespaceURI: function (prefix) { return node.lookupNamespaceURI(prefix); },
                    lookupPrefix: function (namespaceURI) { return node.lookupPrefix(namespaceURI); },
                    normalize: function () { return node.normalize(); },
                    removeChild: function (oldChild) { return wrap(node.removeChild(oldChild)); },
                    replaceChild: function (newChild, oldChild) { return wrap(node.replaceChild(newChild, oldChild)); },

                    getAttributes: function () { return node.attributes; },
                    getBaseURI: function () { return null; },
                    getFirstChild: function () { return wrap(node.firstChild); },
                    getLastChild: function () { return wrap(node.lastChild); },
                    getLocalName: function () { return node.localName; },
                    getNamespaceURI: function () { return node.namespaceURI; },
                    getNextSibling: function () { return wrap(node.nextSibling); },
                    getNodeName: function () { return node.nodeName; },
                    getNodeType: function () { return node.nodeType; },
                    getNodeValue: function () { return node.nodeValue; },
                    setNodeValue: function (val) { return node.nodeValue = val; },
                    getOwnerDocument: function () { return wrap(node.ownerDocument); },
                    getParentNode: function () { return wrap(node.parentNode); },
                    getPrefix: function () { return node.prefix; },
                    setPrefix: function (val) { return node.prefix = val; },
                    getPreviousSibling: function () { return wrap(node.previousSibling); },
                    getTextContent: function () { return node.textContent; },
                    setTextContent: function (val) { return node.textContent = val; },
                    _gd: function () { return node; }
                }
            }

            function createIEDoc()   //NLAppUtil:nsCreateDocument
            {
                var doc = null;
                if (document.implementation && document.implementation.createDocument && !(window.ActiveXObject !== undefined))
                    doc = document.implementation.createDocument("", "", null);
                else
                {
                    try
                    {
                        doc = new ActiveXObject("Msxml2.DOMDocument.6.0");
                    }
                    catch (e)
                    {
                        try
                        {
                            doc = new ActiveXObject("Msxml2.DOMDocument.3.0");
                        }
                        catch (e)
                        {
                            doc = new ActiveXObject("Msxml2.DOMDocument.4.0");
                        }
                    }
                    if (doc != null)
                    {
                        doc.async = false;
                        doc.resolveExternals = false;
                    }
                }
                return doc;
            }

            function stringToXML(text, dontThrow)
            {
                var nsDocument = null;
                if (window.DOMParser && window.XPathEvaluator)
                {
                    nsDocument = new DOMParser().parseFromString(text, 'text/xml')
                    if (!dontThrow)
                    {
                        var parserErrors = nsDocument.getElementsByTagName("parsererror")
                        if (parserErrors.length > 0)
                        {
                            var error = new Error(getErrorMsg("SSS_XML_DOM_EXCEPTION") + ' ' + parserErrors[0].innerHTML) ;
                            error.name = "SSS_XML_DOM_EXCEPTION";
                            throw error;
                        }
                    }
                }
                else if (!window.XPathEvaluator)
                {
                    nsDocument = createIEDoc();
                    nsDocument.loadXML(text);
                    if (!dontThrow)
                    {
                        if (nsDocument.parseError && nsDocument.parseError.errorCode !== 0)
                        {
                            var error = new Error(getErrorMsg("SSS_XML_DOM_EXCEPTION") + ' ' +nsDocument.parseError.reason) ;
                            error.name = "SSS_XML_DOM_EXCEPTION";
                            throw error;
                        }
                    }
                }
                else
                {
                    return null;
                }


                return nsDocument;
            }

            function selectNodes(node, expr)
            {
                if (!node || !node.hasChildNodes())
                    return [];

                var nodes = null;
                var owner = node.ownerDocument != null ? node.ownerDocument : node;
                if (window.XPathEvaluator)
                {
                    var xpe = new XPathEvaluator();
                    /* manually resolve default namespace URI in Firefox/Safari (if needed) */
                    var resolver = function (prefix)
                    {
                        return thisNameSpace[prefix];
                    }
                    var thisNameSpace = {};
                    if (XMLtoString(node).indexOf('xmlns') != -1)
                    {
                        var nodelist = owner.getElementsByTagName("*")
                        for (var j = 0; j < nodelist.length; j++)
                        {
                            var attributes = nodelist[j].attributes;
                            for (var i = 0; attributes != null && i < attributes.length; i++)
                            {
                                if (attributes[i].name == 'xmlns')
                                    thisNameSpace["nlapi"] = attributes[i].nodeValue;
                                else if (attributes[i].name.indexOf('xmlns:') == 0)
                                    thisNameSpace[attributes[i].name.substring(6)] = attributes[i].nodeValue;
                            }
                        }
                    }
                    var results = xpe.evaluate(expr, node, resolver, XPathResult.ANY_TYPE, null)
                    if (results != null)
                    {
                        nodes = new Array();
                        var result;
                        while (result = results.iterateNext())
                            nodes[nodes.length] = result;
                    }
                }
                else
                {
                    /* manually resolve name spaces in IE (if needed) */
                    if (XMLtoString(node).indexOf('xmlns') != -1)
                    {
                        var namespaces = null;
                        owner.setProperty("SelectionLanguage", "XPath");
                        var nodelist = owner.getElementsByTagName("*")
                        for (var j = 0; j < nodelist.length; j++)
                        {
                            var attributes = nodelist[j].attributes;
                            for (var i = 0; attributes != null && i < attributes.length; i++)
                            {
                                if (attributes[i].name.indexOf('xmlns:') == 0)
                                    namespaces = (namespaces != null ? namespaces + " " : "") + attributes[i].xml;
                                else if (attributes[i].name == 'xmlns')
                                    namespaces = (namespaces != null ? namespaces + " " : "") + "xmlns:nlapi=\"" + attributes[i].nodeValue + "\"";
                            }
                        }
                        if (namespaces != null)
                            owner.setProperty("SelectionNamespaces", namespaces)
                    }
                    nodes = node.selectNodes(expr);
                }
                return nodes;
            }

            function throwNotSupported()
            {
                var e = new Error(getErrorMsg("SSS_NOT_YET_SUPPORTED"))
                e.name = "SSS_NOT_YET_SUPPORTED";
                throw e;
            }

            return Object.freeze({
                nlapiCreateError: createError,
                getErrorMessage: getErrorMsg,
                transform: function (record) { return record },
                nlapiGetContext: function () { return getContext(); },
                nlapiXMLToString: function (xml) { return XMLtoString(xml); },
                nlapiStringToXML: function (text, dontThrow) { return stringToXML(text, dontThrow); },
                nlapiSelectNodes: selectNodes,
                nlapiValidateXML: function () { throwNotSupported(); },
                nsObjectToMap: function (obj) { return obj; },
                setupScript: setupScript,
	            getScript: getScript,
                chargeUsage: chargeUsage,
	            alert: alert,
	            confirm: confirm,
	            checkWarningMessageInSession: checkWarningMessageInSession
            });
        }
);

/**
 * @private
 */
define('N/restricted/xmlApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/errorApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/remoteApiBridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * IMPORTANT! Beware of introducing circular dependencies, almost every single module depends on the [error] and [invoker] modules.
 * Only simple dependencies such as Java api bridges (although client side bridges could be an issue) are safe here.
 * Also note that it is intentional that [error] module does not use invoker for that reason, which means that any intercepting
 * logic there will not be called.
 */
/**
 * SuiteScript error module
 *
 * @module N/error
 * @suiteScriptVersion 2.x
 *
 */
define('N/error',['N/restricted/xmlApi', 'N/restricted/errorApi', 'N/restricted/remoteApiBridge', 'N/nsobject'],
        function (xmlApi, errorApi, remoteUtil, nsobject)
        {

            var ERROR_TYPES = Object.freeze({
                MISSING_REQD_ARGUMENT: 'SSS_MISSING_REQD_ARGUMENT',
                READ_ONLY_PROPERTY: 'READ_ONLY_PROPERTY',
                WRONG_PARAMETER_TYPE: 'WRONG_PARAMETER_TYPE',
                UNKNOWN_PARAM: 'UNKNOWN_PARAM',
                INVALID_FLD_VALUE: 'INVALID_FLD_VALUE',
                INVALID_FIELD_VALUE: 'INVALID_FIELD_VALUE',
                VALUE_1_OUTSIDE_OF_VALID_MINMAX_RANGE_FOR_FIELD_2: 'VALUE_1_OUTSIDE_OF_VALID_MINMAX_RANGE_FOR_FIELD_2',
	            INVALID_NUMBER_MUST_BE_LOWER_THAN_1: 'INVALID_NUMBER_MUST_BE_LOWER_THAN_1',
	            INVALID_NUMBER_MUST_BE_GREATER_THAN_1: 'INVALID_NUMBER_MUST_BE_GREATER_THAN_1',
	            INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2: 'INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2',
                INVALID_KEY_OR_REF: 'WS_INVALID_REFERENCE_KEY_1',
                EMPTY_KEY_NOT_ALLOWED: 'EMPTY_KEY_NOT_ALLOWED',
                INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE: 'INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE',
                INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL: 'INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL',
                INVALID_NUMBER_OR_PERCENTAGE: 'INVALID_NUMBER_OR_PERCENTAGE',
                INVALID_EMAILS_FOUND: 'INVALID_EMAILS_FOUND',
                INVALID_RCRD_TYPE: 'INVALID_RCRD_TYPE',
                IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES: 'IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES',
                CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS: 'CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS',
                CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS: 'CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS',
                CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY: 'CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY',
                PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE: 'PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE',
                PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER: 'PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER',
                THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED: 'THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED', 
                PROPERTY_VALUE_CONFLICT: 'PROPERTY_VALUE_CONFLICT',
                FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD : 'FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD',
                FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD: 'FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD',
                PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT: 'PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT',
                PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT: 'PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT',
                NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT: 'NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT',
                FIELD_MUST_CONTAIN_A_VALUE: 'FIELD_MUST_CONTAIN_A_VALUE',
                NON_KATAKANA_DATA_FOUND: 'NON_KATAKANA_DATA_FOUND',
                COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED: 'COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED',
                INVALID_DATE_VALUE_MUST_BE_1: 'INVALID_DATE_VALUE_MUST_BE_1',
                INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE: 'INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE',
                INVALID_GETSELECTOPTION_FILTER_OPERATOR: 'SSS_INVALID_GETSELECTOPTION_FILTER_OPERATOR',
                INVALID_UI_OBJECT_TYPE: 'SSS_INVALID_UI_OBJECT_TYPE',
                INVALID_SUBLIST_OPERATION: 'SSS_INVALID_SUBLIST_OPERATION',
                INVALID_SUITEAPP_APPLICATION_ID: 'INVALID_SUITEAPP_APPLICATION_ID',
                INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD: 'A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD',
                WS_NO_PERMISSIONS_TO_SET_VALUE: 'WS_NO_PERMISSIONS_TO_SET_VALUE',
                SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED: 'SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED',
                NOT_SUPPORTED_ON_CURRENT_SUBRECORD: 'NOT_SUPPORTED_ON_CURRENT_SUBRECORD',
                FIELD_1_IS_NOT_A_SUBRECORD_FIELD: 'FIELD_1_IS_NOT_A_SUBRECORD_FIELD',
                THAT_RECORD_IS_NOT_EDITABLE: 'THAT_RECORD_IS_NOT_EDITABLE',
                SSS_INVALID_TYPE_ARG: 'SSS_INVALID_TYPE_ARG',
                SSS_INVALID_SRCH_OPERATOR: 'SSS_INVALID_SRCH_OPERATOR',
                SSS_INVALID_URL: 'SSS_INVALID_URL',
                SSS_INVALID_CURRENCY_ID: 'SSS_INVALID_CURRENCY_ID',
                SSS_INVALID_API_USAGE: 'SSS_INVALID_API_USAGE',
                FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD: 'FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD',
                BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE: 'BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE',
                SSS_INVALID_UI_OBJECT_TYPE: 'SSS_INVALID_UI_OBJECT_TYPE',
                INVALID_PAGE_RANGE: 'INVALID_PAGE_RANGE',
                SSS_UNSUPPORTED_METHOD: 'SSS_UNSUPPORTED_METHOD',
                SSS_TAX_REGISTRATION_REQUIRED: 'SSS_TAX_REGISTRATION_REQUIRED',
                INVALID_DIRECTION_FOR_SORTING : 'INVALID_DIRECTION_FOR_SORTING',
                INVALID_COLUMN_FOR_SORTING : 'INVALID_COLUMN_FOR_SORTING',
                INVALID_FILTER_FIELD_FOR_CURRENT_VIEW : 'INVALID_FILTER_FIELD_FOR_CURRENT_VIEW',
                INVALID_CUSTOM_VIEW_VALUE : 'INVALID_CUSTOM_VIEW_VALUE',
                INVALID_PAGE_INDEX : 'INVALID_PAGE_INDEX',
                INVALID_TASK_TYPE : 'INVALID_TASK_TYPE',
                METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD : 'SSS_METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD',
                SSS_METHOD_IS_ONLY_ALLOWED_FOR_MULTISELECT_FIELD: 'SSS_METHOD_IS_ONLY_ALLOWED_FOR_MULTISELECT_FIELD',
                SSS_METHOD_IS_ONLY_ALLOWED_FOR_SELECT_FIELD: 'SSS_METHOD_IS_ONLY_ALLOWED_FOR_SELECT_FIELD',
                SSS_RECORD_TYPE_MISMATCH:'SSS_RECORD_TYPE_MISMATCH' ,
	            SSS_INVALID_SUBLIST: 'SSS_INVALID_SUBLIST',
                SSS_INVALID_SUBLIST_OPERATION:'SSS_INVALID_SUBLIST_OPERATION',
                SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED: 'SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED',
                SSS_INVALID_SEARCH_RESULT_INDEX:'SSS_INVALID_SEARCH_RESULT_INDEX',
                SSS_SEARCH_RESULT_LIMIT_EXCEEDED:'SSS_SEARCH_RESULT_LIMIT_EXCEEDED',
                INVALID_FIELD_INDEX :'INVALID_FIELD_INDEX',
                INVALID_FIELD_ID :'INVALID_FIELD_ID',
                INVALID_SUBRECORD_REFEFAILED_AN_UNEXPECTED_ERROR_OCCURREDRENCE: 'INVALID_SUBRECORD_REFERENCE',
                FAILED_AN_UNEXPECTED_ERROR_OCCURRED: 'FAILED_AN_UNEXPECTED_ERROR_OCCURRED',
                CANNOT_CREATE_RECORD_INSTANCE : 'CANNOT_CREATE_RECORD_INSTANCE',
	            CANNOT_CREATE_RECORD_DRAFT_OF_EXISTING_RECORD : 'CANNOT_CREATE_RECORD_DRAFT_OF_EXISTING_RECORD',
                INVALID_SUBRECORD_MERGE: 'INVALID_SUBRECORD_MERGE',
                OPERATION_IS_NOT_ALLOWED: 'OPERATION_IS_NOT_ALLOWED',
                INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_FOR_1: 'INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_FOR_1',
                INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_WITHOUT_A_CONTEXT: 'INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_WITHOUT_A_CONTEXT',
                MUTUALLY_EXCLUSIVE_ARGUMENTS: 'MUTUALLY_EXCLUSIVE_ARGUMENTS',
                RELATIONSHIP_ALREADY_USED: 'RELATIONSHIP_ALREADY_USED',
                INVALID_SEARCH_TYPE: 'INVALID_SEARCH_TYPE',
                OPERATOR_ARITY_MISMATCH: 'OPERATOR_ARITY_MISMATCH',
                INVALID_SEARCH_OPERATOR: 'INVALID_SEARCH_OPERATOR',
                NEITHER_ARGUMENT_DEFINED: 'NEITHER_ARGUMENT_DEFINED',
                SSS_INVALID_MACRO_ID: 'SSS_INVALID_MACRO_ID',
                SSS_INVALID_ACTION_ID: 'SSS_INVALID_ACTION_ID',
	            SSS_RECORD_DOES_NOT_SATISFY_CONDITION: 'SSS_RECORD_DOES_NOT_SATISFY_CONDITION',
                SELECT_OPTION_ALREADY_PRESENT: 'SELECT_OPTION_ALREADY_PRESENT',
                SELECT_OPTION_NOT_FOUND: 'SELECT_OPTION_NOT_FOUND',
	            YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION: 'YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION',
	            INVALID_RETURN_TYPE_EXPECTED_1: 'INVALID_RETURN_TYPE_EXPECTED_1',
	            HISTORY_IS_ONLY_AVAILABLE_FOR_THE_LAST_30_DAYS: 'HISTORY_IS_ONLY_AVAILABLE_FOR_THE_LAST_30_DAYS',
	            SSS_ARGUMENT_DISCREPANCY: 'SSS_ARGUMENT_DISCREPANCY',
	            THE_OPTIONS_ARE_MUTUALLY_EXCLUSIVE_1_2_ARG2_ : 'THE_OPTIONS_ARE_MUTUALLY_EXCLUSIVE_1_2_ARG2_',
				INVALID_FORMULA_TYPE: 'INVALID_FORMULA_TYPE',
	            INVALID_AGGREGATE_TYPE: 'INVALID_AGGREGATE_TYPE',
	            INVALID_SORT_LOCALE: 'INVALID_SORT_LOCALE',
	            CANNOT_RESUBMIT_SUBMITTED_ASYNC_SEARCH_TASK: 'CANNOT_RESUBMIT_SUBMITTED_ASYNC_SEARCH_TASK',
	            SSS_INVALID_READ_SIZE: 'SSS_INVALID_READ_SIZE',
	            SSS_INVALID_SEGMENT_SEPARATOR: 'SSS_INVALID_SEGMENT_SEPARATOR',
	            INVALID_DATE_ID: 'INVALID_DATE_ID',
	            INVALID_LOCALE: 'INVALID_LOCALE',
	            TRANSLATION_HANDLE_IS_IN_AN_ILLEGAL_STATE: 'TRANSLATION_HANDLE_IS_IN_AN_ILLEGAL_STATE',
	            FIELD_1_CANNOT_BE_EMPTY: 'FIELD_1_CANNOT_BE_EMPTY',
	            SSS_TAG_CANNOT_BE_EMPTY: 'SSS_TAG_CANNOT_BE_EMPTY',
	            SSS_NOT_YET_SUPPORTED: 'SSS_NOT_YET_SUPPORTED',
	            SSS_DUPLICATE_ALIAS: 'SSS_DUPLICATE_ALIAS',
	            SSS_MISSING_ALIAS: 'SSS_MISSING_ALIAS',
	            INVALID_SIGNATURE_TAG: 'INVALID_SIGNATURE_TAG',
	            INVALID_ALGORITHM: 'INVALID_ALGORITHM',
	            SIGNATURE_VERIFICATION_FAILED: 'SIGNATURE_VERIFICATION_FAILED',
	            INVALID_CERTIFICATE_TYPE: 'INVALID_CERTIFICATE_TYPE',
	            INVALID_SIGNATURE: 'INVALID_SIGNATURE',
	            ID_CANNOT_HAVE_MORE_THAN_N_CHARACTERS: 'ID_CANNOT_HAVE_MORE_THAN_N_CHARACTERS',
	            NAME_CANNOT_HAVE_MORE_THAN_N_CHARACTERS: 'NAME_CANNOT_HAVE_MORE_THAN_N_CHARACTERS',
	            PASSWORD_CANNOT_HAVE_MORE_THAN_N_CHARACTERS: 'PASSWORD_CANNOT_HAVE_MORE_THAN_N_CHARACTERS',
	            NAME_CANNOT_BE_EMPTY: 'NAME_CANNOT_BE_EMPTY',
	            INVALID_KEY_TYPE: 'INVALID_KEY_TYPE',
	            INVALID_SORT: 'INVALID_SORT',
	            INVALID_ID_PREFIX: 'INVALID_ID_PREFIX',
	            TOO_MANY_RESULTS: 'TOO_MANY_RESULTS',
	            INVALID_HTTP_METHOD: 'INVALID_HTTP_METHOD',
	            INVALID_OPERATION: 'INVALID_OPERATION',
	            INVALID_PERIOD_TYPE: 'INVALID_PERIOD_TYPE',
	            INVALID_PERIOD_ADJUSTMENT: 'INVALID_PERIOD_ADJUSTMENT',
	            INVALID_PERIOD_CODE: 'INVALID_PERIOD_CODE'
            });

	        var isVersionTwoOne = xmlApi !== errorApi; // TODO: (P2) REMOVE THIS HACK! Inject apiVersion module that uses SuiteScriptRuntimeVersion

            /**
             *
             * @protected
             * @class SuiteScriptError
             * @classdesc Base class of SuiteScript errors
             * @constructor
             *
             * @since 2015.2
             */
            function SuiteScriptError(delegate)
            {
                var TYPE = 'error.SuiteScriptError';

                /**
                 * @name SuiteScriptError#type
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'type', {
                    get: function ()
                    {
                        return TYPE;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'type'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Error ID that is automatically generated when a new error is created
                 * @name SuiteScriptError#id
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return delegate.getId();
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'id'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * User-defined error code
                 * @name SuiteScriptError#name
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return delegate.name || (delegate.getCode) ? delegate.getCode() : '';
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'name'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Error message text displayed in the Details column of the Execution Log.
                 * @name SuiteScriptError#message
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'message', {
                    get: function ()
                    {
                        return delegate.message || (delegate.getDetails) ? delegate.getDetails() : '';
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'message'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * List of method calls that the script is executing when the error is thrown. The most recently executed method is listed at the top or the list.
                 * @name SuiteScriptError#stack
                 * @type {string[]}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'stack', {
                    get: function ()
                    {
                        return util.isFunction(delegate.getStackTrace) ? delegate.getStackTrace().slice(0) : '';
                    },
                    //'stack' must be settable in order to wrap a JS error with a SuiteScript error
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Cause of the SuiteScript error. It either returns the error itself, or another error, which caused this new error to happen.
                 * @name SuiteScriptError#cause
                 * @type Anything
                 * @readonly
                 *
                 * @since 2016.1
                 */
                Object.defineProperty(this, 'cause', {
                    get: function ()
                    {
                        return delegate.cause || this;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'cause'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Error email supression indicator
                 * @name SuiteScriptError#notifyOff
                 * @type {boolean}
                 * @readonly
                 *
                 * @since 2016.2
                 */
                Object.defineProperty(this, 'notifyOff', {
                    get: function ()
                    {
                        return delegate.notifyOff;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'notifyOff'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                this.userFacing = true;

                // Functions for debugger

	            /**
				 * get JSON format of the object
				 * @governance none
				 * @return {Object}
				 *
				 * @since 2015.2
				 */
                this.toJSON = function toJSON()
                {
                    var delegateType = typeof(delegate);
                    var cause = this;
                    if (delegateType === "function" || delegateType === "object" && !!delegate)
                    {
                    	if (!!delegate.cause && !!delegate.cause.getStackTrace && !!delegate.cause.getMessage)
	                    {
	                    	cause = {
	                    		message: delegate.cause.getMessage(),
			                    stack: delegate.cause.getStackTrace()
		                    };
	                    }
	                    else
	                    {
		                    cause = delegate.cause || delegate;
	                    }
                    }
                    return {
                        type: TYPE,
                        name: this.name,
                        message: this.message,
                        stack: this.stack,
                        cause: cause,
                        id: this.id,
                        notifyOff: this.notifyOff,
	                    data: this.data,
	                    userFacing : this.userFacing
                    };
                };

	            /**
				 * Returns stringified representation of this SuiteScriptError
				 * @governance none
				 * @return {string}
				 *
				 * @since 2015.2
				 */
                this.toString = function toString()
                {
                    return JSON.stringify(this);
                };
            }

            //inheritance TODO this is not working for Error, SuiteScriptError is not an instanceof Error
            var debuggable = nsobject.getNewInstance();
            var err = Object.create(Error.prototype);
            debuggable.prototype = err;
            SuiteScriptError.prototype = debuggable;
            SuiteScriptError.prototype.constructor = SuiteScriptError;

            /**
             *
             * @protected
             * @class UserEventError
             * @classdesc SuiteScript error class for user events
             * @constructor
             *
             * @since 2015.2
             */
            function UserEventError(delegate)
            {
                var TYPE = 'error.UserEventError';

                /**
                 * Internal ID of the submitted record that triggered the script. This property only holds a value when the error is thrown by an afterSubmit user event.
                 * @name UserEventError#recordId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'recordId', {
                    get: function ()
                    {
                        return delegate.getInternalId();
                    },

                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name UserEventError#eventType
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'eventType', {
                    get: function ()
                    {
                        return delegate.getUserEvent();
                    },

                    enumerable: true,
                    configurable: false
                });

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    var delegateType = typeof(delegate);
                    return {
                        type: TYPE,
                        name: delegate.getCode(),
                        message: delegate.getDetails(),
                        stack: this.stack,
                        eventType: delegate.getUserEvent(),
                        recordId: delegate.getInternalId(),
                        cause: delegateType === "function" || delegateType === "object" && !!delegate ? delegate.cause || delegate : this,
                        id: this.id
                    };
                };

	            /**
	             * Returns stringified representation of this error
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return JSON.stringify(this);
                };

            }

            UserEventError.prototype = new SuiteScriptError();

            function getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
            {
                return remoteUtil.getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4);
            }

			function prepareDelegate(apiError)
			{
				var stackTrace = isVersionTwoOne ? Error().stack.split("\n\t") : apiError.getStackTrace();
				var code = apiError.getCode();
				var details = apiError.getDetails();
				var id = apiError.getId();
				var userEvent = apiError.getUserEvent();
                var notifyOff = apiError.isSuppressNotification()||false;
				var delegate = {
					getStackTrace: function() { return stackTrace; },
					getDetails: function() { return details; },
					getCode: function() { return code; },
					getId: function() { return id; }
				};
                delegate.notifyOff = notifyOff;
				delegate.cause = {
					id: id,
					code: code,
					details: details,
					userEvent: userEvent,
					stackTrace: stackTrace.slice(0),
					toString: function() { return JSON.stringify(this); },
					toJSON: function()
					{
						return {
							type: "internal error",
							code: code,
							details: details,
							userEvent: userEvent,
							stackTrace: stackTrace.slice(0),
                            notifyOff: notifyOff
						};
					}
				};
				return delegate;
			}

	        function javaArrayToJsArray(javaArray)
	        {
		        var toRet = [];
		        for(var i = 0; javaArray && i < javaArray.length; i++)
			        toRet[i] = javaArray[i];

		        return toRet;
	        }

			// The result of this method will pass a potential call to JSON.stringify(), etc.
			function getSafeCause(errorObj)
			{
				var cause = errorObj.cause || errorObj;
				if (cause instanceof Error)
				{
					var safeCopy = {};
					Object.getOwnPropertyNames(cause).forEach(function (prop) {
						safeCopy[prop] = (prop === "stack" || prop === "rhinoException") ? cause[prop].toString() : cause[prop];
					});
					cause = safeCopy;
				}
				return cause;
			}

			function addCustomDataToError(suiteScriptError, data)
			{
				Object.defineProperty(suiteScriptError, 'data', {
					get: function ()
					{
						return data;
					},
					set: function (val)
					{
						throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY, 'data'),false));
					},
					enumerable: true,
					configurable: false
				});
			}

            function createError(options)
            {
	            var currentStackTrace = null;
	            if (isVersionTwoOne)
		            currentStackTrace = Error().stack.split("\n");

                if (!options)
                    throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.MISSING_REQD_ARGUMENT, getErrorMessage(ERROR_TYPES.MISSING_REQD_ARGUMENT, 'error.create', 'options'), false));
	            if (!!options['hasOwnProperty'] && options.hasOwnProperty('notifyOff') && !util.isBoolean(options.notifyOff))
		            throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.WRONG_PARAMETER_TYPE, getErrorMessage(ERROR_TYPES.WRONG_PARAMETER_TYPE, 'options.notifyOff', 'boolean'), false));

                var toRet = null;
                // Wrap internal Java exception
                if (options instanceof Object && options.constructor && options.constructor.name === 'JavaException')
                {
	                toRet = new SuiteScriptError(prepareDelegate(errorApi.nlapiCreateError(options, null, false)));
	                if (!!options.javaException && util.isFunction(options.javaException.getData))
		                addCustomDataToError(toRet, JSON.parse(options.javaException.getData()));
	                toRet.userFacing = false;
                }
                //TODO clean up this mess - class objects should not be exposed to scripts, left over from Nashorn - Graal checks are all duck-typing, however, need to evaluate if deterministic
                else if (
	                //TODO improve duck-typing if it must be the impl (make very specific)
                    !!options.getCode && !!options.getMessage)
                {
	                toRet = new SuiteScriptError(prepareDelegate(errorApi.nlapiCreateError(options, null, false)));
	                if (options.getClass().getName().endsWith('SuiteScriptError'))
		                addCustomDataToError(toRet, JSON.parse(options.getData()));
                }
                // [Rhino Only] Wrap nlobjError delegate
                else if (options instanceof Object && options.constructor.name === 'nlobjError')
                {
                    toRet = new SuiteScriptError(prepareDelegate(options));
                    toRet.userFacing = false;
                }
                // JS error is the "cause"
	            else if (util.isError(options) || options instanceof SuiteScriptError)
	            {
		            var apiError = errorApi.nlapiCreateError(options.name, options.message, options.notifyOff || false);
		            var delegate = {
			            getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
			            getDetails: function() { return options.message; },
			            getCode: function() { return options.name; },
			            getId: function() { return options.id; }
		            };
		            delegate.cause = getSafeCause(options);
		            delegate.notifyOff = options.notifyOff || false;
		            toRet = new SuiteScriptError(delegate);
	            }
                // Standard case, options are args to create SuiteScriptError, duck type the arg
                else if(options.hasOwnProperty // extends Object.prototype
	                && (options.hasOwnProperty('name') || options.hasOwnProperty('message') || options.hasOwnProperty('notifyOff')))
                {
	                var apiError = errorApi.nlapiCreateError(options.name, options.message, options.notifyOff || false);
	                var delegate = {
		                getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
		                getDetails: function() { return apiError.getDetails(); },
		                getCode: function() { return apiError.getCode(); },
		                getId: function() { return apiError.getId(); }
	                };
	                delegate.cause = getSafeCause(options);
	                delegate.notifyOff = options.notifyOff || false;
	                toRet = new SuiteScriptError(delegate);
                }
                else if(typeof options !== 'object') //convenience method. If string is passed in, set it to details.
                {
	                var apiError = errorApi.nlapiCreateError(options, null, false);
	                var delegate = {
		                getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
		                getDetails: function() { return options; },
		                getCode: function() { return ""; },
		                getId: function() { return apiError.getId(); }
	                };
	                delegate.cause = getSafeCause(options);
	                delegate.notifyOff = options.notifyOff || false;
	                toRet = new SuiteScriptError(delegate);
                }
	            else // nlobjError ctor logic tries to handle other cases (options is a java object)
	            {
		            var apiError = errorApi.nlapiCreateError(options, null, false);
		            var delegate = {
			            getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
			            getDetails: function() { return apiError.getDetails(); },
			            getCode: function() { return apiError.getCode(); },
			            getId: function() { return apiError.getId(); }
		            };
		            delegate.cause = getSafeCause(options);
		            delegate.notifyOff = options.notifyOff || false;
		            toRet = new SuiteScriptError(delegate);
	            }
	            if (options.userFacing !== undefined && options.userFacing !== null ) {
                	toRet.userFacing = options.userFacing;
	            }
                return toRet;
            }

            return Object.freeze({
                /**
                 * Create a new custom SuiteScript Error object
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name A user-defined error code. Sets the value for the SuiteSriptError.name property.
                 * @param {string} options.message The error message displayed in the Execution Log Details column. The default value is null. Sets the value for the SuiteScriptError.message property.
                 * @param {string} options.notifyOff Sets whether email notification is suppressed. If set to false, the system emails the users identified on the applicable script record's Unhandled Errors subtab (when the error is thrown). If set to true, users will not be notified. The default value is false.
                 * @return {SuiteScriptError}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some mandatory argument is missing
                 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument has incorrect type
                 *
                 * @since 2015.2
                 */
                create: createError,
	            /**
	             * @enum {string}
	             * @readonly
	             */
                Type: ERROR_TYPES
            });

        });

/**
 * SuiteScript module
 *
 * @private
 * @module N/util
 * @NApiVersion 2.x
 *
 */
define('N/util',[], function () {
    return util;
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/log
 * @NApiVersion 2.x
 *
 */
define('N/log',[], function () {
    return log;
});

/**
 * SuiteScript module
 *
 * @private
 * @module /.api/restricted/invoker
 * @NApiVersion 2.x
 */
define('N/restricted/invoker',['N/error'],
        function (error)
        {
            var callURL = '/app/common/scripting/ClientScriptHandler.nl?';
            var platformRequestURL = '/app/common/scripting/PlatformClientScriptHandler.nl?';

            var needsFirstArg = ['nlapiLoadRecord', 'loadRecord', 'nlapiCreateRecord', 'createRecord', 'nlapiCopyRecord', 'copyRecord', 'nlapiTransformRecord', 'transformRecord', 'nlapiSubmitField', 'nlapiDeleteRecord', 'nlapiSearchRecord', 'executeAction'];

            function checkForCharge(target, method, args, governanceOverride)
            {
                if (!!target && target.hasOwnProperty("chargeUsage"))
                {
                    var type;
                    if (method === "nlapiSubmitRecord")
                        type = args[0].getRecordType()
                    else if (!!args && needsFirstArg.indexOf(method) != -1)
                        type = args[0];
                    else
                        type = null;
                    target["chargeUsage"].apply(this, [method, type, args, governanceOverride]);
                }
            }

            function tryParsing(data)
            {
                var parsedData = {};
                try
                {
	                parsedData = util.isString(data) ? JSON.parse(data) : data;
                }
                catch (e)
                {
                    return data;
                }

                return parsedData;
            }

            function contextUrl(scriptInfo, url)
            {
            	var script = scriptInfo.scriptId || "";
            	var deploy = scriptInfo.deployId || "";
            	return url + "script=" + script + "&deploy=" + deploy;
            }

            return function invokeOn(target, method, args, callback, parseResult)
            {
                var result;
	            var governanceOverride;

                parseResult = parseResult === undefined || !!parseResult;

                if (!!target && (typeof target[method] !== "undefined"))
                {
                    try
                    {
                        result = target[method].apply(target, args);
                    }
                    catch (e)
                    {
                    	var exception = error.create(e);
                        if (!util.isFunction(callback))
		                    throw exception;
                        else
                        	return callback(undefined, exception);
                    }

                    if (!util.isFunction(callback))
                    	return result;
                    else
                        return callback(result);
                }
                else
                {
                    try
                    {
	                    var bridge = !!target ? target.bridge : null;
	                    var targetURL = !!bridge ? platformRequestURL : callURL;
	                    if (args === undefined || args === null)
	                    	args = [];
                        if (!util.isFunction(callback))
                        {
	                        if (!!bridge)
	                        {
		                        result = serverCallSync(contextUrl(target.getScript(), targetURL), "bridgeCall", [bridge, method].concat(JSON.stringify(args)));
		                        governanceOverride = result.governance;
		                        result = result.result;
	                        }
                            else
                            	result = serverCallSync(targetURL, method, args);
                            if (parseResult)
                            {
                                result = tryParsing(result);
                            }
                            checkForCharge(target, method, args, governanceOverride);
                        }
                        else
                        {
                            var myCallback = function (response)
                            {
                                var result, exception;
                                //noinspection JSUnresolvedVariable
	                            if (response instanceof Error)
	                            {
	                            	exception = error.create(response);
	                            }
                                else
                                {
                                    if (response.hasOwnProperty("nlError") && response.nlError)
                                    {
                                    	exception = error.create({ name: response.code, message: response.details });
                                    }
                                    else
                                    {
                                        result = response.result;

	                                    if (!!bridge)
	                                    {
		                                    governanceOverride = result.governance;
		                                    result = result.result;
	                                    }
                                        if (parseResult)
                                        {
                                            result = tryParsing(result);
                                        }
                                        checkForCharge(target, method, args, governanceOverride);
                                    }
                                }
                                return callback(result, exception);
                            };
                            if (!!bridge)
                            	serverCallAsync(contextUrl(target.getScript(), targetURL), "bridgeCall", [bridge, method].concat(JSON.stringify(args)), myCallback);
	                        else
	                            serverCallAsync(targetURL, method, args, myCallback);
                        }
                    }
                    catch (e)
                    {
                        var exception = error.create(e);
                        if (!util.isFunction(callback))
                        	throw exception;
                        else
                        	return callback(undefined, exception);
                    }
                }
                return result;
            };
        }
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/utilityFunctionsImpl
 * @NApiVersion 2.x
 */
define('N/utilityFunctionsImpl',[],
    function ()
    {
        var serverCallSyncImpl = null;
        var serverCallAsyncImpl = null;

        // When client script modules are imported on the server side during script analysis, serverCallSync will not exist as a global variable.
        if (typeof serverCallSync !== 'undefined') {
            // serverCallSync is defined in client bootstrap.js, we should remove it from global space.
            serverCallSyncImpl = serverCallSync;
        }
        else {
            var global = (function () {return this;})();
            serverCallSyncImpl = global.serverCallSync;
        }

        // When client script modules are imported on the server side during script analysis, serverCallAsyncImpl will not exist as a global variable.
        if (typeof serverCallAsync !== 'undefined') {
            // serverCallAsyncImpl is defined in client bootstrap.js, we should remove it from global space.
            serverCallAsyncImpl = serverCallAsync;
        }
        else {
            var global = (function () {return this;})();
            serverCallAsyncImpl = global.serverCallAsync;
        }

        return {
            serverCall: serverCallSyncImpl,
            serverCallAsync: serverCallAsyncImpl
        };
    });

/**
 * SuiteScript module
 *
 * @private
 * @module N/utilityFunctions
 * @NApiVersion 2.x
 */
define(
	'N/utilityFunctions',['N/utilityFunctionsImpl', 'N/error', 'N/restricted/invoker', 'N/restricted/remoteApiBridge'],
	function (utilImpl, error, invoker, remoteApi)
	{
		function getGlobalScope()
		{
			return (function () {return this;}());
		}

		function isObject(obj)
		{
			return obj === Object(obj);
		}

		/**
		 * check if the value is empty
		 * @param val String being tested for whether it is empty (null or "")
		 * @originalFrom NLRecordUtil.js
		 */
		function isValEmpty(val)
		{
			if (val === null || val === undefined)
				return true;

			val = String(val);
			return (val.length === 0) || !/\S/.test(val);
		}

		function isEmpty(val)
		{
			if (val === null || val === undefined)
				return true;

			val = String(val);
			return val.length === 0;
		}

		function isSignedXml(object)
		{
			if (object && util.isFunction(object.toString))
			{
				return (object.toString() === "certificate.SignedXml");
			}
			return false;
		}

		function isFile(object)
		{
			if (object && util.isFunction(object.toString))
			{
				return (object.toString() === "file.File");
			}
			return false;
		}

		function isInternalErrorCode(errorCode)
		{
			for (var code in error.Type)
			{
				if (error.Type[code] === errorCode)
					return true;
			}

			return false;
		}

		function getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
		{
			return invoker(remoteApi, 'getErrorMessage', [errorCode, errorVal1, errorVal2, errorVal3, errorVal4]);
		}

		function throwSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			var message = "";
			if (internalErrorMessageCode != null)
				message = getErrorMessage(internalErrorMessageCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			else if (isInternalErrorCode(errorCode))
				message = getErrorMessage(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			throw error.create({name: errorCode, message: message});
		}

		function createSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			var message = "";
			if (internalErrorMessageCode != null)
				message = getErrorMessage(internalErrorMessageCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			else if (isInternalErrorCode(errorCode))
				message = getErrorMessage(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4);
			return error.create({name: errorCode, message: message});
		}

		function checkArgs(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (!funcArgs[i] && funcArgs[i] !== 0)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		function checkArgsPresent(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (funcArgs[i] == null)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		function checkArgsAllowNull(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (!funcArgs[i] && funcArgs[i] !== 0 && funcArgs[i] !== null)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		function assertTrue(expression, errorCode, errorMessageVal1, errorMessageVal2)
		{
			if (!expression)
				throwSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2);
		}

		function checkMutuallyExclusiveArguments(arg1, arg2, arg1Name, arg2Name)
		{
			if (arg1 != undefined && arg2 != undefined)
				throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, arg1Name, arg2Name);
		}

		function ensureInteger(val, paramName)
		{
			if (isNaN(val = val != null ? parseInt(val, 10) : null))
				throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, paramName, 'integer');
			return val;
		}

		function freezeObjectIfPossible(obj)
		{
			return (Object.freeze && (obj || obj === "" || obj === 0)) ? Object.freeze(obj) : obj;
		}

		function wrapDelegates(array, type)
		{
			return (array && array.map)
				? array.map(function (el, idx, arr)
				{
					return new type(el);
				})
				: null;
		}

		function arrayIndexOf(array, val, ignoreCase)
		{
			for (var i = 0; array && i < array.length; i++)
			{
				if (val === array[i] || (ignoreCase && val && array[i] && val.toLowerCase() === array[i].toLowerCase()))
					return i;
			}
			return -1;
		}

		function assignDefaultOrCurrentValue(arg, defaultVal)
		{
			return arg || arg === 0 || arg === false ? arg : defaultVal;
		}

		function checkArgTypes(checkArgObjectArray)
		{
			for (var i = 0; i < checkArgObjectArray.length; i++)
			{
				var current = checkArgObjectArray[i];
				if ((current.value || current.value === 0 || current.value === false) &&
					((util.isNumber(current.value) && isNaN(current.value)) || !current.verifyFunction(current.value)))
				{
					throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, current.name);
				}
			}
		}

		function checkArgObject(value, name, verifyFunction)
		{
			return {
				value: value,
				name: name,
				verifyFunction: verifyFunction
			};
		}

		var serverCall = function (url, methodName, args)
		{
			return utilImpl.serverCall(url, methodName, args);
		};

		serverCall.promise = function (url, methodName, args)
		{
			var myPromise = new Promise(function (resolve, reject)
			{
				try
				{
					utilImpl.serverCallAsync(url, methodName, args, function (response)
					{
						(response instanceof Error) ? reject(response) : resolve(response);
					});
				}
				catch (e)
				{
					reject(e);
				}
			});
			return myPromise;
		};

		/**
		 * Search Util
		 */
		function unmarshalArray(payloadMap, prefix, unmarshalFunction)
		{
			var array = [];
			var count = payloadMap[prefix + 'count']; // TODO : investigate if count is used elsewhere
			for (var i = 0; i < count; ++i)
			{
				var attributeMap = payloadMap[prefix + i];
				var obj = unmarshalFunction(attributeMap);
				array.push(obj);
			}
			return array;
		}

		function arrayToMap(array, func)
		{
			var result = [];
			for (var i = 0; i < array.length; ++i)
			{
				result.push(func(array[i]));
			}
			return result;
		}

		function assertArrayElementsOfSameType(array, type, argName, errorCode)
		{
			if (!util.isArray(array))
				return;
			for (var i = 0; i < array.length; i++)
			{
				assertTrue(isElementSameType(array[i], type), errorCode || 'SSS_INVALID_ARRAY_ARGUMENT', argName + '[' + i + ']');
			}

		}

		function isElementSameType(element, type)
		{
			return (element || element === 0) &&
				((type === Object(type) && element instanceof type) ||
					typeof element === type ||
					(element.constructor && element.constructor.name && element.constructor.name === type));
		}

		function normalizeArrayOrSingularObjectArg(arg)
		{
			return util.isArray(arg) ? arg : arg != undefined ? [arg] : null;
		}

		function arrayContains(array, val)
		{
			return arrayIndexOf(array, val) >= 0;
		}

		function arrayAdd(array, val)
		{
			if (!arrayContains(array, val))
				array.push(val);
		}

		function addParameterToMap(map, params)
		{
			if (!map)
				map = {};

			for (var key in params)
			{
				if (params.hasOwnProperty(key))
					map[key] = params[key];
			}

			return map;
		}

		/*
		 * Supply additional information to the arguments being passed in,
		 * with care to possibility that the inputted args are flattened or in an object
		 */
		function augmentArguments(args, keyName, keyValue)
		{
			var returnMe = args;
			if (!!returnMe)
			{
				if (returnMe.length > 1 || !isObject(returnMe[0]))
					Array.prototype.push.call(returnMe, keyValue);
				else if (isObject(returnMe[0]))
					returnMe[0][keyName] = keyValue;
			}
			return returnMe;
		}

		function returnEmptyIfNull(str)
		{
			return str != null ? str : "";
		}

		function getAsArray(arg)
		{
			return arg != null ? (util.isArray(arg) ? arg : [arg]) : null;
		}

		function unwrapArray(arg)
		{
			return arg != null ? ((util.isArray(arg) || arg instanceof Array) ? arg : arg.list) : null;
		}

		function addReadOnlyProperty(target, propertyName, getter)
		{
			Object.defineProperty(target, propertyName, {
				get: function ()
				{
					return getter();
				},
				set: function ()
				{
					throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName);
				},
				enumerable: true,
				configurable: false
			});
		}

		function addReadOnlyNonEnumerableProperty(target, propertyName, getter)
		{
			Object.defineProperty(target, propertyName, {
				get: function ()
				{
					return getter();
				},
				set: function ()
				{
					throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName);
				},
				enumerable: false,
				configurable: false
			});
		}

		function promiseTo(fn, params, postProcess)
		{
			return new Promise(function (resolve, reject)
			{
				var callback = function(result, exception)
				{
					if (exception)
					{
						reject(exception);
						return;
					}
					try
					{
						resolve(util.isFunction(postProcess) ? postProcess({result: result, data: this}) : result);
					}
					catch (e)
					{
						reject(e);
					}
				};

				callback.promiseCallback = true;

				try
				{
					fn.apply(callback, Array.prototype.slice.call(params));
				}
				catch (e)
				{
					reject(e);
				}
			});
		}

		function isPromiseCallback(options)
		{
			return util.isFunction(options) && options.promiseCallback;
		}

		function deepFreeze(obj)
		{
			if (util.isObject(obj))
			{
				Object.freeze(obj);
				for (var p in obj)
				{
					if (obj.hasOwnProperty(p))
						deepFreeze(obj[p]);
				}
			}
			return obj;
		}

		function getFcFileContent(filePathOrId)
		{
			if (util.isNumber(filePathOrId))
				filePathOrId = String(filePathOrId);
			return invoker(remoteApi, 'nlapiLoadFileAsString', [filePathOrId]);
		}

		function unescape(obj)
		{
			if (typeof(obj) === 'string') {
				obj = obj.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/g, "&").replace(/<br>/g, '\n');
			}
			return obj;
		}

		function getConstructorName (obj) {
			if (obj.constructor.name !== undefined) return obj.constructor.name;
			// Property "name" is not supported in IE. It is non-standard until ECMAScript 6
			return obj.constructor.toString().trim().replace(/^\S+\s+(\w+)[\S\s]+$/, '$1');
		}

		return Object.freeze({
			getFcFileContent: getFcFileContent,
			getGlobalScope: getGlobalScope,
			isObject: isObject,
			isValEmpty: isValEmpty,
			isEmpty: isEmpty,
			assignDefaultOrCurrentValue: assignDefaultOrCurrentValue,
			checkArgTypes: checkArgTypes,
			checkArgObject: checkArgObject,
			wrapDelegates: wrapDelegates,
			freezeObjectIfPossible: freezeObjectIfPossible,
			isInternalErrorCode: isInternalErrorCode,
			getErrorMessage: getErrorMessage,
			throwSuiteScriptError: throwSuiteScriptError,
			createSuiteScriptError: createSuiteScriptError,
			arrayIndexOf: arrayIndexOf,
			arrayContains: arrayContains,
			arrayAdd: arrayAdd,
			checkArgs: checkArgs,
			checkArgsPresent: checkArgsPresent,
			checkArgsAllowNull: checkArgsAllowNull,
			assertTrue: assertTrue,
			checkMutuallyExclusiveArguments: checkMutuallyExclusiveArguments,
			ensureInteger: ensureInteger,
			serverCall: serverCall,
			unmarshalArray: unmarshalArray,
			arrayToMap: arrayToMap,
			assertArrayElementsOfSameType: assertArrayElementsOfSameType,
			normalizeArrayOrSingularObjectArg: normalizeArrayOrSingularObjectArg,
			addParameterToMap: addParameterToMap,
			augmentArguments: augmentArguments,
			returnEmptyIfNull: returnEmptyIfNull,
			getAsArray: getAsArray,
			addReadOnlyProperty: addReadOnlyProperty,
			addReadOnlyNonEnumerableProperty: addReadOnlyNonEnumerableProperty,
			promiseTo: promiseTo,
			isPromiseCallback: isPromiseCallback,
			deepFreeze: deepFreeze,
			isFile: isFile,
			isSignedXml: isSignedXml,
			unwrapArray: unwrapArray,
			unescape: unescape,
			getConstructorName: getConstructorName
		});
	}
);

/**
 * SuiteScript xml module
 *
 * @module N/xml
 * @NApiVersion 2.x
 *
 */
define('N/xml',['N/error', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/restricted/xmlApi'],
        function (error, nsobject, invoker, utilityFunctions, xmlApi)
        {
            var NODE_TYPES = Object.freeze([
                'ELEMENT_NODE',
                'ATTRIBUTE_NODE',
                'TEXT_NODE',
                'CDATA_SECTION_NODE',
                'ENTITY_REFERENCE_NODE',
                'ENTITY_NODE',
                'PROCESSING_INSTRUCTION_NODE',
                'COMMENT_NODE',
                'DOCUMENT_NODE',
                'DOCUMENT_TYPE_NODE',
                'DOCUMENT_FRAGMENT_NODE',
                'NOTATION_NODE'
            ]);

			// Unfortunately need to duplicate this const since stub generation static analysis requires object literal enum.
			// Can't derive array from object since iteration may be unordered.
            var NODE_TYPES_ENUM = Object.freeze({
                ELEMENT_NODE: 'ELEMENT_NODE',
                ATTRIBUTE_NODE: 'ATTRIBUTE_NODE',
                TEXT_NODE: 'TEXT_NODE',
                CDATA_SECTION_NODE: 'CDATA_SECTION_NODE',
                ENTITY_REFERENCE_NODE: 'ENTITY_REFERENCE_NODE',
                ENTITY_NODE: 'ENTITY_NODE',
                PROCESSING_INSTRUCTION_NODE: 'PROCESSING_INSTRUCTION_NODE',
                COMMENT_NODE: 'COMMENT_NODE',
                DOCUMENT_NODE: 'DOCUMENT_NODE',
                DOCUMENT_TYPE_NODE: 'DOCUMENT_TYPE_NODE',
                DOCUMENT_FRAGMENT_NODE: 'DOCUMENT_FRAGMENT_NODE',
                NOTATION_NODE: 'NOTATION_NODE'
            });

            var IE_CONVERSIONS = Object.freeze({
                getTextContent: 'text',
                getLocalName: 'baseName'
            });

            var CLIENT_SIDE_ATTR = Object.freeze({
                getName: 'name',
                getOwnerElement: 'ownerElement',
                getSpecified: 'specified',
                getValue: 'value',
                setValue: 'value',
                getDoctype: 'doctype',
                getDocumentElement: 'documentElement',
                getDocumentURI: 'documentURI',
                setDocumentURI: 'documentURI',
                getInputEncoding: 'inputEncoding',
                getXmlEncoding: 'xmlEncoding',
                getXmlStandalone: 'xmlStandalone',
                setXmlStandalone: 'xmlStandalone',
                getXmlVersion: 'xmlVersion',
                setXmlVersion: 'xmlVersion',
                getAttributes: 'attributes',
                getBaseURI: 'baseURI',
                getFirstChild: 'firstChild',
                getLastChild: 'lastChild',
                getLocalName: 'localName',
                getNamespaceURI: 'namespaceURI',
                getNextSibling: 'nextSibling',
                getNodeName: 'nodeName',
                getNodeType: 'nodeType',
                getNodeValue: 'nodeValue',
                setNodeValue: 'nodeValue',
                getOwnerDocument: 'ownerDocument',
                getParentNode: 'parentNode',
                getPrefix: 'prefix',
                setPrefix: 'prefix',
                getPreviousSibling: 'previousSibling',
                getTextContent: 'textContent',
                setTextContent: 'textContent'
            });

            function checkThenInvoke(target, method, args)
            {
                if (method === "getBaseURI" || method === "getDocumentURI")
                    return null;

                var targetMethodType = typeof target[method];

                if (targetMethodType === "undefined")
                {
                    if (typeof window !== "undefined" && !window.XPathEvaluator && IE_CONVERSIONS.hasOwnProperty(method))
                        return target[IE_CONVERSIONS[method]];
                    if (CLIENT_SIDE_ATTR.hasOwnProperty(method))
                    {
                        if (method.indexOf("set") === 0)
                            return target[CLIENT_SIDE_ATTR[method]] = args[0];
                        else
                            return target[CLIENT_SIDE_ATTR[method]];
                    }
                    else
                    {
                        return undefined;
                    }
                }

                // IE is unable to handle generic calls on the XML object.
                if (typeof window !== "undefined" && !window.XPathEvaluator)
                {
                    switch (args.length)
                    {
                        case 0:
                            return target[method]();
                        case 1:
                            return target[method](args[0]);
                        case 2:
                            return target[method](args[0], args[1]);
                        case 3:
                            return target[method](args[0], args[1], args[2]);
                        case 4:
                            return target[method](args[0], args[1], args[2], args[3]);
                        default:
                            return target[method](args[0], args[1], args[2], args[3], args[4]);
                    }
                }
                else
                {
                    try
                    {
                        return invoker(target, method, args)
                    }
                    catch (e)
                    {
                        if (e.name === "NotFoundError")
                        {
                            e = Error(e.message);
                            e.name = "SSS_XML_DOM_EXCEPTION";
                        }
                        throw e;
                    }
                }
            }

            /**
             * XML Parser Object
             */
            function Parser()
            {
                /**
                 * Generate XML Document object from a string.
                 *
                 * @param {string} options.text XML text
                 * @returns {Document}
                 *
                 * @since 2015.2
                 */
                this.fromString = function fromString(options)
                {
                    var text = (options && options.hasOwnProperty('text')) ? options.text : options;
                    checkArgs([text], ['text'], 'Parser.fromString');
                    assertString(text, 'text');

                    var document = invoker(xmlApi, 'nlapiStringToXML', [text]);
                    return new Document(document);
                };

                /**
                 * Generate a String from an XML Document object.
                 *
                 * @param {Document} options.document XML Document object
                 * @returns {string}
                 *
                 * @since 2015.2
                 */
                this.toString = function toString(options)
                {
                    var document = (options && options.hasOwnProperty('document')) ? options.document : options;
                    checkArgs([document], ['document'], 'Parser.toString');
                    if(!(document instanceof Document) )
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'document','xml.Document' );

                    return document._asString();
                };
            }

            /**
             * XPath Query Object
             */
            function XPath()
            {
                /**
                 * Returns an Array of Nodes matching the provided XPath expression.
                 *
                 * @param {string} options.xpath an XPath expression
                 * @param {Node} options.node XML node being queried
                 * @returns {Node[]} nodes associated with the current result
                 *
                 * @since 2015.2
                 */
                this.select = function select(options)
                {
                    var node = null, xpath = null;

                    if (options && (options.hasOwnProperty('node') || options.hasOwnProperty('xpath')))
                    {
                        node = options.node;
                        xpath = options.xpath;
                    }
                    else
                    {
                        node = options;
                        xpath = arguments[1];
                    }
                    checkArgs([node, xpath], ['node', 'xpath'], 'XPath.select');
                    assertNode(node, 'node');
                    assertString(xpath, 'xpath');

                    var nodes = invoker(xmlApi, 'nlapiSelectNodes', [node._gd(), xpath]);
                    var result = [];
                    for (var i = 0; i < nodes.length; i++)
                    {
                        result.push(wrap(nodes[i]));
                    }
                    return result;
                };
            }

            /**
             * Return a new instance of XML Node.
             *
             * @classDescription Encapsulation of W3C DOM Node
             * @return {Node}
             * @constructor
             *
             * @since 2015.2
             */
            function Node(xmlnode)
            {
                var TYPE = 'xml.Node';
                checkArgs([xmlnode], ['xmlnode'], 'xml.Node');

                var _deleg = xmlnode;

                // Node members

                /**
                 * Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.
                 *
                 * @param {Node} options.newChild the node to add
                 * @returns {Node} the node added
                 * @throws {SuiteScriptError} SSS_DOM_EXCEPTION if node cannot be appended for some reason
                 */
                this.appendChild = function appendChild(options)
                {
                    var newChild = (options && options.hasOwnProperty('newChild')) ? options.newChild : options;
                    checkArgs([newChild], ['newChild'], 'Node.appendChild');
                    assertNode(newChild, 'newChild');

                    var result = checkThenInvoke(_deleg, 'appendChild', [newChild._gd()]);
                    return wrap(result);
                };

                /**
                 * Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent.
                 *
                 * @param {boolean} options.deep if true, recursively clone the subtree under the specified node; if false, clone only the node itself (and its attributes, if it is an Element)
                 * @returns {Node} the duplicate node
                 */
                this.cloneNode = function cloneNode(options)
                {
                    var deep = (options && options.hasOwnProperty('deep')) ? options.deep : options;
                    checkArgs([deep], ['deep'], 'Node.cloneNode');

                    var result = checkThenInvoke(_deleg, 'cloneNode', [deep == true]);
                    return wrap(result);
                };

                /**
                 * Compares the reference node, i.e. the node on which this method is being called, with a node, i.e. the one passed as a parameter,
                 * with regard to their position in the document and according to the document order.
                 *
                 * @param {Node} options.other the node to compare against the reference node
                 * @returns {int} how the node is positioned relatively to the reference node
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION when the nodes cannot be compared
                 */
                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.compareDocumentPosition');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'compareDocumentPosition', [other._gd()]);
                };

                /**
                 * Returns whether this node (if it is an Element) has any attributes.
                 *
                 * @returns {boolean} true if this node has any attributes, false otherwise
                 */
                this.hasAttributes = function hasAttributes()
                {
                    return checkThenInvoke(_deleg, 'hasAttributes', []);
                };

                /**
                 * Returns whether this node has any children.
                 *
                 * @returns {boolean} true if this node has any children, false otherwise
                 */
                this.hasChildNodes = function hasChildNodes()
                {
                    return checkThenInvoke(_deleg, 'hasChildNodes', []);
                };

                /**
                 * Inserts the node newChild before the existing child node refChild. If refChild is null, insert newChild at the end of the list of children.
                 * If the newChild is already in the tree, it is first removed.
                 *
                 * @param {Node} options.newChild the node to insert
                 * @param {Node} options.refChild the reference node, i.e., the node before which the new node will be inserted
                 * @returns {Node} the node being inserted
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be inserted for some reason
                 */
                this.insertBefore = function insertBefore(options)
                {
                    var newChild = null, refChild = null;

                    if (options && (options.hasOwnProperty('newChild') || options.hasOwnProperty('refChild')))
                    {
                        newChild = options.newChild;
                        refChild = options.refChild;
                    }
                    else
                    {
                        newChild = options;
                        refChild = arguments[1];
                    }
                    checkArgs([newChild], ['newChild'], 'Node.insertBefore');
                    assertNode(newChild, 'newChild');
                    assertNodeNullable(refChild, 'refChild');

                    var result = checkThenInvoke(_deleg, 'insertBefore', [newChild._gd(), refChild == null ? null : refChild._gd()]);
                    return wrap(result);
                };

                /**
                 * This method checks if the specified namespaceURI is the default namespace or not.
                 *
                 * @param {string} options.namespaceURI the namespace URI to look for
                 * @returns {boolean} true if the specified namespaceURI is the default namespace, false otherwise
                 */
                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    var namespaceURI = (options && options.hasOwnProperty('namespaceURI')) ? options.namespaceURI : options;
                    checkArgs([namespaceURI], ['namespaceURI'], 'Node.isDefaultNamespace');
                    assertString(namespaceURI, 'namespaceURI');

                    return checkThenInvoke(_deleg, 'isDefaultNamespace', [namespaceURI]);
                };

                /**
                 * Tests whether two nodes are equal.
                 * This method tests for equality of nodes, not sameness (i.e., whether the two nodes are references to the same object) which can be tested
                 * with Node.isSameNode(). All nodes that are the same will also be equal, though the reverse may not be true.
                 * Two nodes are equal if and only if the following conditions are satisfied:
                 * - The two nodes are of the same type.
                 * - The following string attributes are equal: nodeName, localName, namespaceURI, prefix, nodeValue
                 * - The attributes maps are equal
                 * - The childNodes lists are equal
                 *
                 * @param {Node} options.other the node to compare equality with
                 * @returns {boolean} true if the nodes are equal, false otherwise
                 */
                this.isEqualNode = function isEqualNode(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.isEqualNode');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'isEqualNode', [other._gd()]);
                };

                /**
                 * Returns whether this node is the same node as the given one.
                 * This method provides a way to determine whether two Node references returned by the implementation reference the same object.
                 * When two Node references are references to the same object, even if through a proxy, the references may be used completely interchangeably,
                 * such that all attributes have the same values and calling the same DOM method on either reference always has exactly the same effect.
                 *
                 * @param {Node} options.other the node to test against
                 * @returns {boolean} true if the nodes are the same, false otherwise
                 */
                this.isSameNode = function isSameNode(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.isSameNode');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'isSameNode', [other._gd()]);
                };

                /**
                 * Look up the namespace URI associated to the given prefix, starting from this node.
                 *
                 * @param {string} options.prefix the prefix to look for; if this parameter is null, the method will return the default namespace URI if any
                 * @returns {string} the associated namespace URI or null if none is found
                 */
                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    var prefix = (options && options.hasOwnProperty('prefix')) ? options.prefix : options;
                    assertStringNullable(prefix, 'prefix');

                    return checkThenInvoke(_deleg, 'lookupNamespaceURI', [prefix == null ? null : prefix]);
                };

                /**
                 * Look up the prefix associated to the given namespace URI, starting from this node. The default namespace declarations are ignored by this method.
                 *
                 * @param {string} options.namespaceURI the namespace URI to look for
                 * @returns {string} an associated namespace prefix if found or null if none is found; if more than one prefix are associated to the namespace prefix, the returned namespace prefix is implementation dependent
                 */
                this.lookupPrefix = function lookupPrefix(options)
                {
                    var namespaceURI = (options && options.hasOwnProperty('namespaceURI')) ? options.namespaceURI : options;
                    checkArgs([namespaceURI], ['namespaceURI'], 'Node.lookupPrefix');
                    assertString(namespaceURI, 'namespaceURI');

                    return checkThenInvoke(_deleg, 'lookupPrefix', [namespaceURI]);
                };

                /**
                 * Puts all Text nodes in the full depth of the sub-tree underneath this Node, including attribute nodes, into a "normal" form
                 * where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates
                 * Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes.
                 *
                 * @returns {void}
                 */
                this.normalize = function normalize()
                {
                    checkThenInvoke(_deleg, 'normalize', []);
                };

                /**
                 * Removes the child node indicated by oldChild from the list of children, and returns it.
                 *
                 * @param {Node} options.oldChild the node being removed
                 * @returns {Node} the node removed
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be removed for some reason
                 */
                this.removeChild = function removeChild(options)
                {
                    var oldChild = (options && options.hasOwnProperty('oldChild')) ? options.oldChild : options;
                    checkArgs([oldChild], ['oldChild'], 'Node.removeChild');
                    assertNode(oldChild, 'oldChild');

                    var result = checkThenInvoke(_deleg, 'removeChild', [oldChild._gd()]);
                    return wrap(result);
                };

                /**
                 * Replaces the child node oldChild with newChild in the list of children, and returns the oldChild node.
                 * If the newChild is already in the tree, it is first removed.
                 *
                 * @param {Node} options.newChild the new node to put in the child list
                 * @param {Node} options.oldChild the node being replaced in the list
                 * @returns {Node} the node replaced
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be replaced for some reason
                 */
                this.replaceChild = function replaceChild(options)
                {
                    var newChild = null, oldChild = null;

                    if (options && (options.hasOwnProperty('newChild') || options.hasOwnProperty('oldChild')))
                    {
                        newChild = options.newChild;
                        oldChild = options.oldChild;
                    }
                    else
                    {
                        newChild = options;
                        oldChild = arguments[1];
                    }
                    checkArgs([newChild, oldChild], ['newChild', 'oldChild'], 'Node.replaceChild');
                    assertNode(newChild, 'newChild');
                    assertNode(oldChild, 'oldChild');

                    var result = checkThenInvoke(_deleg, 'replaceChild', [newChild._gd(), oldChild._gd()]);
                    return wrap(result);
                };

                /**
                 * A map of key/value (string->Attr) pairs containing the attributes of this node (if it is an Element) or null otherwise.
                 * @name Node#attributes
                 * @type Object
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        var attrs = checkThenInvoke(_deleg, 'getAttributes', []);
                        if (!attrs)
                            return null;
                        var attrsLength = attrs.length || checkThenInvoke(attrs, 'getLength', []);
                        var result = {};
                        for (i = 0; i < attrsLength; i++)
                        {
                            var item = checkThenInvoke(attrs, 'item', [i]);
                            var node = new Attr(item);
                            result[node.name.replace(':', '_')] = node;
                        }
                        return result;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The absolute base URI of this node or null if the implementation wasn't able to obtain an absolute URI.
                 * @name Node#baseURI
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getBaseURI', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An array of all children of this node. If there are no children, this is an empty array.
                 * @name Node#childNodes
                 * @type Node[]
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        var result = [];
                        var child = this.firstChild;

                        while (child !== null)
                        {
                            result.push(child);
                            child = child.nextSibling;
                        }
                        return result;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The first child of this node or null if there is no such node.
                 * @name Node#firstChild
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getFirstChild', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The last child of this node or null if there is no such node.
                 * @name Node#lastChild
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getLastChild', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The local part of the qualified name of this node.
                 * @name Node#localName
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getLocalName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The namespace URI of this node, or null if it is unspecified.
                 * @name Node#namespaceURI
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNamespaceURI', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The node immediately following this node or null if there is no such node.
                 * @name Node#nextSibling
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getNextSibling', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The name of this node, depending on its type.
                 * @name Node#nodeName
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNodeName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The type of the underlying object.
                 * @name Node#nodeType
                 * @type NodeType
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getNodeType', []);
                        return NODE_TYPES[result - 1];
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The value of this node, depending on its type. When it is defined to be null, setting it has no effect, including if the node is read-only.
                 * @name Node#nodeValue
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to get or set the property value
                 */
                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNodeValue', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setNodeValue', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * The Document object associated with this node. This is also the Document object used to create new nodes.
                 * @name Node#ownerDocument
                 * @type Document
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getOwnerDocument', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The parent of this node. All nodes, except Attr, Document, DocumentFragment, Entity, and Notation may have a parent.
                 * @name Node#parentNode
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getParentNode', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The namespace prefix of this node, or null if it is unspecified. When it is defined to be null, setting it has no effect, including if the node is read-only.
                 * @name Node#prefix
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to set the property value
                 */
                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getPrefix', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setPrefix', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * The node immediately preceding this node or null if there is no such node.
                 * @name Node#previousSibling
                 * @type Node
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getPreviousSibling', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * This attribute returns the text content of this node and its descendants. When it is defined to be null, setting it has no effect.
                 * @name Node#textContent
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to get or set the property value
                 */
                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getTextContent', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setTextContent', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return {
                        name: this.nodeName,
                        type: this.nodeType,
                        value: this.nodeValue,
                        textContent: this.textContent
                    };
                };
            }

            Node.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Document.
             *
             * @classDescription Encapsulation of W3C DOM Document
             * @return {Document}
             * @constructor
             *
             * @since 2015.2
             */
            function Document(xmldoc)
            {
                var TYPE = 'xml.Document';

                checkArgs([xmldoc], ['xmldoc'], 'xml.Document');

                var _deleg = xmldoc;
                var _node = new Node(xmldoc);

                // Document members

                /**
                 * Attempts to adopt a node from another document to this document. If supported, it changes the ownerDocument
                 * of the source node, its children, as well as the attached attribute nodes if there are any. If the source
                 * node has a parent it is first removed from the child list of its parent.
                 *
                 * @param {Node} options.source the node to move into this document
                 * @returns {Node} the adopted node, or null if this operation fails, such as when the source node comes from a different implementation
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the node cannot be adopted for some reason
                 */
                this.adoptNode = function adoptNode(options)
                {
                    var source = (options && options.hasOwnProperty('source')) ? options.source : options;
                    checkArgs([source], ['source'], 'Document.adoptNode');
                    assertNode(source, 'source');

                    var result = checkThenInvoke(_deleg, 'adoptNode', [source._gd()]);
                    return wrap(result);
                };

                /**
                 * Creates an attribute node of the given name.
                 *
                 * @param {string} options.name the name of the attribute
                 * @param {string} options.value (optional) the value of the attribute; if omitted, the value of the attribute will be empty string
                 * @returns {Attr} new attribute node object with name and attribute value set as expected and localName, prefix, and namespaceURI set to null
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be created
                 */
                this.createAttribute = function createAttribute(options)
                {
                    var name = null, value = null;

                    if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
                    {
                        name = options.name;
                        value = options.value;
                    }
                    else
                    {
                        name = options;
                        value = arguments[1];
                    }
                    checkArgs([name], ['name'], 'Node.createAttribute');
                    assertString(name, 'name');

                    var result = checkThenInvoke(_deleg, 'createAttribute', [name]);
                    result = new Attr(result);
                    if (value)
                    {
                        assertString(value, 'value');
                        result.value = value;
                    }
                    return result;
                };

                /**
                 * Creates an attribute of the given qualified name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to create; can be null
                 * @param {string} options.qualifiedName the qualified name of the attribute to instantiate
                 * @param {string} options.value (optional) the value of the attribute; if omitted, the value of the attribute will be empty string
                 * @returns {Attr} new attribute node object with name, attribute value, namespaceURI, prefix and localName set accordingly
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be created
                 */
                this.createAttributeNS = function createAttributeNS(options)
                {
                    var namespaceURI = null, qualifiedName = null, value = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName') || options.hasOwnProperty('value')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                        value = options.value;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                        value = arguments[2];
                    }
                    checkArgs([qualifiedName], ['qualifiedName'], 'Document.createAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');

                    var result = checkThenInvoke(_deleg, 'createAttributeNS', [namespaceURI == null ? null : namespaceURI, qualifiedName]);
                    result = new Attr(result);
                    if (value)
                    {
                        assertString(value, 'value');
                        result.value = value;
                    }
                    return result;
                };

                /**
                 * Creates a CDATASection node whose value is the specified string.
                 *
                 * @param {string} options.data the data for the CDATASection contents
                 * @returns {Node} the new CDATASection node
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the CDATASection node cannot be created
                 */
                this.createCDATASection = function createCDATASection(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createCDATASection');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createCDATASection', [data]);
                    return new Node(result);
                };

                /**
                 * Creates a Comment node given the specified string.
                 *
                 * @param {string} options.data the data for the node
                 * @returns {Node} the new Comment node
                 */
                this.createComment = function createComment(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createComment');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createComment', [data]);
                    return new Node(result);
                };

                /**
                 * Creates an empty DocumentFragment object.
                 *
                 * @returns {Node} a new DocumentFragment
                 */
                this.createDocumentFragment = function createDocumentFragment()
                {
                    var result = checkThenInvoke(_deleg, 'createDocumentFragment', []);
                    return new Node(result);
                };

                /**
                 * Creates an element of the type specified.
                 *
                 * @param {string} options.tagName the name of the element type to instantiate; for XML, this is case-sensitive
                 * @returns {Element} a new Element object with the nodeName attribute set to tagName, and localName, prefix, and namespaceURI set to null
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the Element node cannot be created
                 */
                this.createElement = function createElement(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Document.createElement');
                    assertString(tagName, 'tagName');

                    var result = checkThenInvoke(_deleg, 'createElement', [tagName]);
                    return new Element(result);
                };

                /**
                 * Creates an element of the given qualified name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the element to create; can be null
                 * @param {string} options.qualifiedName the qualified name of the element type to instantiate
                 * @returns {Element} a new Element object with the nodeName, localName, prefix, and namespaceURI set accordingly
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the Element node cannot be created
                 */
                this.createElementNS = function createElementNS(options)
                {
                    var namespaceURI = null, qualifiedName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                    }
                    checkArgs([qualifiedName], ['qualifiedName'], 'Document.createElementNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');

                    var result = checkThenInvoke(_deleg, 'createElementNS', [namespaceURI == null ? null : namespaceURI, qualifiedName]);
                    return new Element(result);
                };

                /**
                 * Creates a ProcessingInstruction node given the specified name and data strings.
                 *
                 * @param {string} options.target the target part of the processing instruction
                 * @param {string} options.data the data for the node
                 * @returns {Node} the new ProcessingInstruction object
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the ProcessingInstruction node cannot be created
                 */
                this.createProcessingInstruction = function createProcessingInstruction(options)
                {
                    var target = null, data = null;

                    if (options && (options.hasOwnProperty('target') || options.hasOwnProperty('data')))
                    {
                        target = options.target;
                        data = options.data;
                    }
                    else
                    {
                        target = options;
                        data = arguments[1];
                    }
                    checkArgs([target, data], ['target', 'data'], 'Document.createProcessingInstruction');
                    assertString(target, 'target');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createProcessingInstruction', [target, data]);
                    return new Node(result);
                };

                /**
                 * Creates a Text node given the specified string.
                 *
                 * @param {string} options.data the data for the node
                 * @returns {Node} the new Text node
                 */
                this.createTextNode = function createTextNode(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createTextNode');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createTextNode', [data]);
                    return new Node(result);
                };

                /**
                 * Returns the Element that has an ID attribute with the given value. If no such element exists, this returns null.
                 *
                 * @param {string} options.elementId the unique id value for an element
                 * @returns {Element} the matching Element or null if there is none
                 */
                this.getElementById = function getElementById(options)
                {
                    var elementId = (options && options.hasOwnProperty('elementId')) ? options.elementId : options;
                    checkArgs([elementId], ['elementId'], 'Document.getElementById');
                    assertString(elementId, 'elementId');

                    var result = checkThenInvoke(_deleg, 'getElementById', [elementId]);
                    return new Element(result);
                };

                /**
                 * Returns an array of all the Elements with a given tag name in document order.
                 *
                 * @param {string} options.tagName the name of the tag to match on; the special value "*" matches all tags; for XML, the tagName parameter is case-sensitive
                 * @returns {Element[]} an array containing all the matched Elements
                 */
                this.getElementsByTagName = function getElementsByTagName(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Document.getElementsByTagName');
                    assertString(tagName, 'tagName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagName', [tagName]);
	                var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
                    for (var i = 0; i < elemsLength; i++)
                    {
                        result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Returns an array of all the Elements with a given local name and namespace URI in document order.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the elements to match on; the special value "*" matches all namespaces
                 * @param {string} options.localName the local name of the elements to match on; the special value "*" matches all local names
                 * @returns {Element[]} an array containing all the matched Elements
                 */
                this.getElementsByTagNameNS = function getElementsByTagNameNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([namespaceURI, localName], ['namespaceURI', 'localName'], 'Document.getElementsByTagNameNS');
                    assertString(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagNameNS', [namespaceURI, localName]);
                    var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
                    for (var i = 0; i < elemsLength; i++)
                    {
                        result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Imports a node from another document to this document, without altering or removing the source node from the original document;
                 * this method creates a new copy of the source node.
                 *
                 * @param {Node} options.importedNode the node to import
                 * @param {boolean} options.deep if true, recursively import the subtree under the specified node; if false, import only the node itself, as explained above
                 * @returns {Node} the imported node that belongs to this Document
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the node cannot be imported for some reason
                 */
                this.importNode = function importNode(options)
                {
                    var importedNode = null, deep = null;

                    if (options && (options.hasOwnProperty('importedNode') || options.hasOwnProperty('deep')))
                    {
                        importedNode = options.importedNode;
                        deep = options.deep;
                    }
                    else
                    {
                        importedNode = options;
                        deep = arguments[1];
                    }
                    checkArgs([importedNode, deep], ['importedNode', 'deep'], 'Document.importNode');
                    assertNode(importedNode, 'importedNode');

                    var result = checkThenInvoke(_deleg, 'importNode', [importedNode._gd(), deep == true]);
                    return wrap(result);
                };

                /**
                 * The Document Type Declaration associated with this document.
                 * @name Document#doctype
                 * @type Object
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'doctype', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getDoctype', []);
                        if (result === null || result === undefined)
                            return null;
                        return new Node(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'doctype' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * This is a convenience attribute that allows direct access to the child node that is the document element of the document.
                 * @name Document#documentElement
                 * @type Element
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'documentElement', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getDocumentElement', []);
                        return new Element(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'documentElement' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The location of the document or null if undefined.
                 * @name Document#documentURI
                 * @type string
                 */
                Object.defineProperty(this, 'documentURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getDocumentURI', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setDocumentURI', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * An attribute specifying the encoding used for this document at the time of the parsing.
                 * @name Document#inputEncoding
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'inputEncoding', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getInputEncoding', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'inputEncoding' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An attribute specifying, as part of the XML declaration, the encoding of this document.
                 * @name Document#xmlEncoding
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'xmlEncoding', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlEncoding', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'xmlEncoding' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An attribute specifying, as part of the XML declaration, whether this document is standalone. This is false when unspecified.
                 * @name Document#xmlStandalone
                 * @type boolean
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the property cannot be set
                 */
                Object.defineProperty(this, 'xmlStandalone', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlStandalone', []);
                    },
                    set: function (val)
                    {
                        checkThenInvoke(_deleg, 'setXmlStandalone', [val == true]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * An attribute specifying, as part of the XML declaration, the version number of this document.
                 * @name Document#xmlVersion
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the property cannot be set
                 */
                Object.defineProperty(this, 'xmlVersion', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlVersion', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setXmlVersion', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Members inherited from Node

                this.appendChild = function appendChild(options)
                {
                    return _node.appendChild(options);
                };

                this.cloneNode = function cloneNode(options)
                {
                    return _node.cloneNode(options);
                };

                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    return _node.compareDocumentPosition(options);
                };

                this.hasChildNodes = function hasChildNodes()
                {
                    return _node.hasChildNodes();
                };

                this.insertBefore = function insertBefore()
                {
                    return _node.insertBefore.apply(_node, arguments);
                };

                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    return _node.isDefaultNamespace(options);
                };

                this.isEqualNode = function isEqualNode(options)
                {
                    return _node.isEqualNode(options);
                };

                this.isSameNode = function isSameNode(options)
                {
                    return _node.isSameNode(options);
                };

                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    return _node.lookupNamespaceURI(options);
                };

                this.lookupPrefix = function lookupPrefix(options)
                {
                    return _node.lookupPrefix(options);
                };

                this.normalize = function normalize()
                {
                    checkThenInvoke(_deleg, 'normalizeDocument', []);
                };

                this.removeChild = function removeChild(options)
                {
                    return _node.removeChild(options);
                };

                this.replaceChild = function replaceChild()
                {
                    return _node.replaceChild.apply(_node, arguments);
                };

                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        return _node.attributes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return _node.baseURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        return _node.childNodes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        return _node.firstChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        return _node.lastChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return _node.localName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return _node.namespaceURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        return _node.nextSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return _node.nodeName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        return _node.nodeType;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return _node.nodeValue;
                    },
                    set: function (val)
                    {
                        _node.nodeValue = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        return _node.ownerDocument;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        return _node.parentNode;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return _node.prefix;
                    },
                    set: function (val)
                    {
                        _node.prefix = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        return _node.previousSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return _node.textContent;
                    },
                    set: function (val)
                    {
                        _node.textContent = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._asString = function _asString()
                {
                    return invoker(xmlApi, 'nlapiXMLToString', [_deleg]);
                };

                this._gd = function _gd()
                {
                    return _deleg;
                };

                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return _node.toJSON();
                };
            }

            Document.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Element.
             *
             * @classDescription Encapsulation of W3C DOM Element
             * @return {Element}
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Element(xmlelem)
            {
                var TYPE = 'xml.Element';

                checkArgs([xmlelem], ['xmlelem'], 'xml.Element');

                var _deleg = xmlelem;
                var _node = new Node(xmlelem);

                // Element members

                /**
                 * Retrieves an attribute value by name.
                 *
                 * @param {string} options.name the name of the attribute to retrieve
                 * @returns {string} the Attr value as a string, or the empty string if that attribute does not have a specified or default value
                 */
                this.getAttribute = function getAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.getAttribute');
                    assertString(name, 'name');

                    return checkThenInvoke(_deleg, 'getAttribute', [name]);
                };

                /**
                 * Retrieves an attribute node by name.
                 *
                 * @param {string} options.name the name of the attribute to retrieve
                 * @returns {Attr} the Attr node with the specified name or null if there is no such attribute
                 */
                this.getAttributeNode = function getAttributeNode(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.getAttributeNode');
                    assertString(name, 'name');

                    var result = checkThenInvoke(_deleg, 'getAttributeNode', [name]);
                    return wrap(result);
                };

                /**
                 * Retrieves an attribute node by local name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to retrieve; can be null
                 * @param {string} options.localName the local name of the attribute to retrieve
                 * @returns {Attr} the Attr node with the specified attribute local name and namespace URI or null if there is no such attribute
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be retrieved for some reason
                 */
                this.getAttributeNodeNS = function getAttributeNodeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.getAttributeNodeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var result = checkThenInvoke(_deleg, 'getAttributeNodeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                    return wrap(result);
                };

                /**
                 * Retrieves an attribute value by local name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to retrieve; can be null
                 * @param {string} options.localName the local name of the attribute to retrieve
                 * @returns {string} the Attr value as a string, or the empty string if that attribute does not have a specified or default value
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be retrieved for some reason
                 */
                this.getAttributeNS = function getAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.getAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    return checkThenInvoke(_deleg, 'getAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Returns an array of all descendant Elements with a given tag name, in document order.
                 *
                 * @param {string} options.tagName the name of the tag to match on; the special value "*" matches all tags; for XML, the tagName parameter is case-sensitive
                 * @returns {Element[]} an array of matching Element nodes
                 */
                this.getElementsByTagName = function getElementsByTagName(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Element.getElementsByTagName');
                    assertString(tagName, 'tagName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagName', [tagName]);
	                var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
	                for (var i = 0; i < elemsLength; i++)
                    {
		                result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Returns an array of all descendant Elements with a given local name and namespace URI in document order.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the elements to match on; the special value "*" matches all namespaces
                 * @param {string} options.localName the local name of the elements to match on; the special value "*" matches all local names
                 * @returns {Element[]} an array of matching Element nodes
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the elements cannot be retrieved for some reason
                 */
                this.getElementsByTagNameNS = function getElementsByTagNameNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([namespaceURI, localName], ['namespaceURI', 'localName'], 'Element.getElementsByTagNameNS');
                    assertString(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagNameNS', [namespaceURI, localName]);
	                var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
	                for (var i = 0; i < elemsLength; i++)
                    {
		                result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Returns true when an attribute with a given name is specified on this element or has a default value, false otherwise.
                 *
                 * @param {string} options.name the name of the attribute to look for
                 * @returns {boolean} true if an attribute with the given name is specified on this element or has a default value, false otherwise
                 */
                this.hasAttribute = function hasAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.hasAttribute');
                    assertString(name, 'name');

                    return checkThenInvoke(_deleg, 'hasAttribute', [name]);
                };

                /**
                 * Returns true when an attribute with a given local name and namespace URI is specified on this element or has a default value, false otherwise.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to look for; can be null
                 * @param {string} options.localName the local name of the attribute to look for
                 * @returns {boolean} true if an attribute with the given local name and namespace URI is specified or has a default value on this element, false otherwise
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the command cannot be performed for some reason
                 */
                this.hasAttributeNS = function hasAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.hasAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    return checkThenInvoke(_deleg, 'hasAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Removes an attribute by name.
                 *
                 * @param {string} options.name the name of the attribute to remove
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be removed for some reason
                 */
                this.removeAttribute = function removeAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.removeAttribute');
                    assertString(name, 'name');

                    checkThenInvoke(_deleg, 'removeAttribute', [name]);
                };

                /**
                 * Removes the specified attribute node.
                 *
                 * @param {Attr} options.oldAttr the Attr node to remove from the attribute list
                 * @returns {Attr} the Attr node that was removed
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.removeAttributeNode = function removeAttributeNode(options)
                {
                    var oldAttr = (options && options.hasOwnProperty('oldAttr')) ? options.oldAttr : options;
                    checkArgs([oldAttr], ['oldAttr'], 'Element.removeAttributeNode');
                    assertNode(oldAttr, 'oldAttr');

                    var result = checkThenInvoke(_deleg, 'removeAttributeNode', [oldAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Removes an attribute by local name and namespace URI.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to remove; can be null
                 * @param {string} options.localName the local name of the attribute to remove
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be removed for some reason
                 */
                this.removeAttributeNS = function removeAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.removeAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    checkThenInvoke(_deleg, 'removeAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Adds a new attribute. If an attribute with that name is already present in the element, its value is changed to be that of the value parameter.
                 *
                 * @param {string} options.name the name of the attribute to create or alter
                 * @param {string} options.value value to set in string form
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttribute = function setAttribute(options)
                {
                    var name = null, value = null;

                    if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
                    {
                        name = options.name;
                        value = options.value;
                    }
                    else
                    {
                        name = options;
                        value = arguments[1];
                    }
                    checkArgs([name, value], ['name', 'value'], 'Element.setAttribute');
                    assertString(name, 'name');
                    assertString(value, 'value');

                    return checkThenInvoke(_deleg, 'setAttribute', [name, value]);
                };

                /**
                 * Adds a new attribute node. If an attribute with that name is already present in the element, it is replaced by the new one.
                 *
                 * @param {Attr} options.newAttr the Attr node to add to the attribute list
                 * @returns {Attr} if the newAttr attribute replaces an existing attribute, the replaced Attr node is returned, otherwise null is returned
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttributeNode = function setAttributeNode(options)
                {
                    var newAttr = (options && options.hasOwnProperty('newAttr')) ? options.newAttr : options;
                    checkArgs([newAttr], ['newAttr'], 'Element.setAttributeNode');
                    assertNode(newAttr, 'newAttr');

                    var result = checkThenInvoke(_deleg, 'setAttributeNode', [newAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Adds a new attribute node. If an attribute with that local name and that namespace URI is already present in the element, it is replaced by the new one.
                 *
                 * @param {Attr} options.newAttr the Attr node to add to the attribute list
                 * @returns {Attr} if the newAttr attribute replaces an existing attribute with the same local name and namespace URI, the replaced Attr node is returned, otherwise null is returned
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttributeNodeNS = function setAttributeNodeNS(options)
                {
                    var newAttr = (options && options.hasOwnProperty('newAttr')) ? options.newAttr : options;
                    checkArgs([newAttr], ['newAttr'], 'Element.setAttributeNodeNS');
                    assertNode(newAttr, 'newAttr');

                    var result = checkThenInvoke(_deleg, 'setAttributeNodeNS', [newAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Adds a new attribute. If an attribute with the same local name and namespace URI is already present on the element, its prefix is changed
                 * to be the prefix part of the qualifiedName, and its value is changed to be the value parameter.
                 *
                 * @param {string} options.namespaceURI the namespace URI of the attribute to create or alter; can be null
                 * @param {string} options.qualifiedName the qualified name of the attribute to create or alter
                 * @param {string} options.value value to set in string form
                 * @returns {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 */
                this.setAttributeNS = function setAttributeNS(options)
                {
                    var namespaceURI = null, qualifiedName = null, value = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName') || options.hasOwnProperty('value')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                        value = options.value;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                        value = arguments[2];
                    }
                    checkArgs([qualifiedName, value], ['qualifiedName', 'value'], 'Element.setAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');
                    assertString(value, 'value');

                    return checkThenInvoke(_deleg, 'setAttributeNS', [namespaceURI == null ? null : namespaceURI, qualifiedName, value]);
                };

                /**
                 * The name of the element.
                 * @name Element#tagName
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'tagName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getTagName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'tagName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                // Members inherited from Node

                this.appendChild = function appendChild(options)
                {
                    return _node.appendChild(options);
                };

                this.cloneNode = function cloneNode(options)
                {
                    return _node.cloneNode(options);
                };

                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    return _node.compareDocumentPosition(options);
                };

                this.hasAttributes = function hasAttributes()
                {
                    return _node.hasAttributes();
                };

                this.hasChildNodes = function hasChildNodes()
                {
                    return _node.hasChildNodes();
                };

                this.insertBefore = function insertBefore()
                {
                    return _node.insertBefore.apply(_node, arguments);
                };

                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    return _node.isDefaultNamespace(options);
                };

                this.isEqualNode = function isEqualNode(options)
                {
                    return _node.isEqualNode(options);
                };

                this.isSameNode = function isSameNode(options)
                {
                    return _node.isSameNode(options);
                };

                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    return _node.lookupNamespaceURI(options);
                };

                this.lookupPrefix = function lookupPrefix(options)
                {
                    return _node.lookupPrefix(options);
                };

                this.normalize = function normalize()
                {
                    _node.normalize();
                };

                this.removeChild = function removeChild(options)
                {
                    return _node.removeChild(options);
                };

                this.replaceChild = function replaceChild()
                {
                    return _node.replaceChild.apply(_node, arguments);
                };

                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        return _node.attributes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return _node.baseURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        return _node.childNodes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        return _node.firstChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        return _node.lastChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return _node.localName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return _node.namespaceURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        return _node.nextSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return _node.nodeName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        return _node.nodeType;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return _node.nodeValue;
                    },
                    set: function (val)
                    {
                        _node.nodeValue = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        return _node.ownerDocument;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        return _node.parentNode;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return _node.prefix;
                    },
                    set: function (val)
                    {
                        _node.prefix = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        return _node.previousSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return _node.textContent;
                    },
                    set: function (val)
                    {
                        _node.textContent = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return _node.toJSON();
                };
            }

            Element.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Attr.
             *
             * @classDescription Encapsulation of W3C DOM Attr
             * @return {Attr}
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Attr(xmlattr)
            {
                var TYPE = 'xml.Attr';

                checkArgs([xmlattr], ['xmlattr'], 'xml.Attr');

                var _deleg = xmlattr;

                // Attr members

                /**
                 * Returns the name of this attribute. If Node.localName is different from null, this property is a qualified name.
                 * @name Attr#name
                 * @type string
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The Element node this attribute is attached to or null if this attribute is not in use.
                 * @name Attr#ownerElement
                 * @type Element
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'ownerElement', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getOwnerElement', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerElement' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * True if this attribute was explicitly given a value in the instance document, false otherwise.
                 * @name Attr#specified
                 * @type boolean
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
                Object.defineProperty(this, 'specified', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getSpecified', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'specified' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The attribute value. On retrieval, the value of the attribute is returned as a string. Character and general entity
                 * references are replaced with their values. On setting, this creates a Text node with the unparsed contents of the string,
                 * i.e. any characters that an XML processor would recognize as markup are instead treated as literal text.
                 * @name Attr#value
                 * @type string
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the value cannot be set for some reason
                 */
                Object.defineProperty(this, 'value', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getValue', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setValue', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };
                this.toString = function toString()
                {
                    return TYPE;
                };
                this.toJSON = function toJSON()
                {
                    return {
                        name: this.name,
                        ownerElement: this.ownerElement,
                        specified: this.specified,
                        value: this.value
                    };
                };
            }

            Attr.prototype = nsobject.getNewInstance();

            //====== Utility functions (to be replaced by util module when available) ====

            function assertString(arg, argName)
            {
                if (!isString(arg))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, argName,'string' );
            }

            function assertStringNullable(arg, argName)
            {
                if (arg != null)
                    assertString(arg, argName);
            }

            function assertNode(arg, argName)
            {
                if (!isNode(arg))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, argName,'xml.Node or subclass' );
            }

            function assertNodeNullable(arg, argName)
            {
                if (arg != null)
                    assertNode(arg, argName);
            }

            function isString(obj)
            {
                return Object.prototype.toString.call(obj) === '[object String]';
            }

            function isNode(obj)
            {
                return obj instanceof Node || obj instanceof Element || obj instanceof Attr || obj instanceof Document;
            }

            function checkArgs(funcArgs, funcArgNames, funcName)
            {
                for (var i = 0; i < funcArgs.length; i++)
                    if (funcArgs[i] == null) // also catches 'undefined'
                        utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, (funcName ? funcName + ': ' : ''),funcArgNames[i] );
            }

            function wrap(node)
            {
                if (!node)
                    return node; // do nothing

                switch (node.nodeType || checkThenInvoke(node, 'getNodeType', []))
                {
                    case 1:
                        return new Element(node);
                    case 2:
                        return new Attr(node);
                    case 9:
                        return new Document(node);
                    default:
                        return new Node(node);
                }
            }

            //========================================================================

            function escape(options)
            {
                var xmlText = (options && options.hasOwnProperty('xmlText')) ? options.xmlText : options;
                checkArgs([xmlText], ['xmlText'], 'escape');
                assertString(xmlText, 'xmlText');

                return xmlText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&apos;').replace(/"/g, '&quot;');
            }

            function validate(options)
            {
                var xml = null, xsdFilePathOrId = null, importFolderPathOrId = null;

                if (options && (options.hasOwnProperty('xml') || options.hasOwnProperty('xsdFilePathOrId') || options.hasOwnProperty('importFolderPathOrId')))
                {
                    xml = options.xml;
                    xsdFilePathOrId = options.xsdFilePathOrId;
                    importFolderPathOrId = options.importFolderPathOrId;
                }
                else
                {
                    xml = options;
                    xsdFilePathOrId = arguments[1];
                    importFolderPathOrId = arguments[2];
                }
                checkArgs([xml, xsdFilePathOrId], ['xml', 'xsdFilePathOrId'], 'validate');
                assertNode(xml, 'xml');

                var schema = utilityFunctions.getFcFileContent(xsdFilePathOrId);
                var schemaDoc = this.Parser.fromString(schema);

                invoker(xmlApi, 'nlapiValidateXML', [xml._gd(), schemaDoc._gd(), importFolderPathOrId != null ? importFolderPathOrId : null]);
            }

            //========================================================================

            return Object.freeze({
                /**
                 * Prepares a String for use in XML by escaping XML markup (for example, angle brackets, quotation marks, and ampersands).
                 *
                 * @param {string} options.xmlText the XML text to be escaped
                 * @returns {string} the escaped XML
                 *
                 * @since 2015.2
                 */
                escape: escape,

                /**
                 * Validates a supplied XML document against a supplied XML Schema (XSD Document).
                 *
                 * @param {Document} options.xml the XML document object
                 * @param {int|string} options.xsdFilePathOrId ID or path to the XSD file to validate the XML object against
                 * @param {int|string} options.importFolderPathOrId (optional) ID or path to a folder in the file cabinet containing additional XSD schemas which are imported by the parent XSD provided via "xsdFilePathOrId"
                 * @throws {SuiteScriptError} SSS_XML_DOES_NOT_CONFORM_TO_SCHEMA if XML provided is invalid with respect to the provided schema
                 * @throws {SuiteScriptError} SSS_INVALID_XML_SCHEMA_OR_DEPENDENCY if schema is an incorrectly structured XSD, or a dependent schema could not be found
                 * @returns {void}
                 *
                 * @since 2015.2
                 */
                validate: validate,

                /**
                 * XML Parser Object
                 *
                 * @type Parser
                 */
                Parser: new Parser(),

                /**
                 * XPath Query Object
                 *
                 * @type XPath
                 */
                XPath: new XPath(),

                /**
                 * @enum
                 */
                NodeType: NODE_TYPES_ENUM
            });
        });

/**
 * This file is an alias for SystemScripts - NLCommonScripts.getCurrencyFunctions(null)
 *
 * @private
 * @module N/util/currencyUtility
 */
define('N/util/currencyUtility',['N/utilityFunctions'],
	function(utilityFunctions){
		/* imports */
	   /**
		* @alias CURRENCY2_AND_RATE_PRECISION (NLCurrencyUtil.java)
		*/
		var CURRENCY2_AND_RATE_PRECISION = 8;

		/**
		 * @alias getDefaultCurrencyPrecision (NLCurrencyUtil.java)
		 */
		function getDefaultCurrencyPrecision()
		{
			return 2;
		}

		/**
		 * @alias dollars_string (NLAppUtil.jsp)
		 *
		 */
		function dollars_string(amount)
		{
			var temp = amount;
			var DigitStrings = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
			var TeenStrings = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eightteen', 'nineteen'];
			var DecadeStrings = ['zero', 'ten', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
			var result = '';
			if (temp >= 1000)
			{
				result = result + dollars_string(Math.floor(temp/1000)) + 'thousand ';
				temp = temp % 1000;
			}
			if (temp >= 100)
			{
				result = result + DigitStrings[Math.floor(temp/100)] + ' hundred ';
				temp = temp % 100;
			}
			if (temp >= 20)
			{
				result = result + DecadeStrings[Math.floor(temp/10)] + ' ';
				temp = temp % 10;
			}
			if (temp >= 10)
			{
				result = result + TeenStrings[Math.floor(temp-10)] + ' ';
			}
			else if ((amount == 0) || (temp > 0))
			{
				result = result + DigitStrings[Math.floor(temp)] + ' ';
			}
			return result;
		}

		function amount_string(amount)
		{
			var cents = Math.floor((amount-Math.floor(amount))*100+0.5);
			var centstring = (cents < 10) ? '0'+cents.toString() : cents.toString();
			var dollarstring = dollars_string(Math.floor(amount));
			return dollarstring.charAt(0).toUpperCase() + dollarstring.substr(1) + 'and ' + centstring + '/100';
		}


		function format_rate(a,p, recordContext)
		{
			var s;
			var cs;
			var n;
			var returnMe;
			if (isNaN(parseFloat(a)))
			{
				returnMe= '';
			}
			else
			{
				var precision = get_precision(recordContext);

				if (precision>1 || p) /*precision is 2 or its a % */
				{
					s=(a<0);
					if (s) a=-a;
					var d=Math.floor(a);
					var c=Math.floor((a-d)*(p?10:100)+0.5);

					if (a == d+c/(p?10:100))
					{
						if (c==(p?10:100))
						{
							d++;
							c=0;
						}
						cs=p?c.toString():((c < 10)?'0'+c.toString():c.toString());
						returnMe = (s?'-':'')+d.toString()+'.'+cs+(p?'%':'');
					}
					else
						returnMe = (s?'-':'')+a+(p?'%':'');
				}
				else if (precision === 1)
				{
					s=(a<0);
					if (s) a=-a;
					cs = a.toString();
					n = cs.indexOf('.');
					if (n==-1) cs = cs.toString() + '.0';
					else if (n==0) cs = '0.' + cs.toString() ;
					else if (n==cs.length-1) cs = cs.toString() + '0' ;
					returnMe = (s?'-':'') + cs ;
				}
				else if (precision === 0)
				{
					s=(a<0);
					if (s) a=-a;
					cs = a.toString();
					n = cs.indexOf('.');
					if (n==0) cs = '0.' + cs.toString() ;
					else if (n==cs.length-1) cs = cs.substring(0, cs.length-2);
					returnMe = (s?'-':'') + cs ;
				}
			}
			return returnMe;
		}

		// Cannot assume that nlapiGetFieldValue is accessible to all.
		// Protect from JS errors, and assume the USD default (2 decimal places) if no value is specified
		function getCurrencyPrecisionFieldValue(recordContext)
		{
			var precision = 2;
			if (!!recordContext)
			{
				precision = recordContext.getFieldValue('currencyprecision');
			}
			else if (typeof nlapiGetFieldValue === "function")
			{
				precision = nlapiGetFieldValue('currencyprecision');
			}

			return precision;
		}

		/*
		The 38 bit oracle representation for floating point numbers does things differently than
		the IEEE754 Spec that is used for floating point math in Java/JavaScript.  In Java/Javascript

		233 * .075 = 17.474999999999998

		In Oracle

		233 * .075 = 17.475

		To fix this so that both values will be the same, we first round to 5 decimal places
		(agreed upon) internal representation.  And then round to the two decimal places that
		we present to the user.

		Extending the above to round to either 0,1 or 2 places of decimal
		WARNING !!! This works for rounding to 0, 1, 2 places of decimal only
		 */
		function get_precision(recordContext)
		{
			var cp = getCurrencyPrecisionFieldValue(recordContext);
			var precision = getDefaultCurrencyPrecision();
			if (cp != null)
			{
				var tprecision = parseFloat(cp.value);
				if (!isNaN(tprecision))
				{
					precision=tprecision;
				}
			}
			return precision;
		}

		function round_currency(amount, numofdecimals, method, recordContext)
		{
			var precision = numofdecimals;
			// Try reloading the precision if it wasnt passed in
			if ( precision == null )
				precision = get_precision(recordContext);
			var amountStr = amount + '';
			if ( amount > 1E10 && amountStr.indexOf('.') >= 0 && (amountStr.length - amountStr.indexOf('.') - 1 <= precision) ) //if it's already rounded, just return, don't go through the IEEE754 business
				return amount;
			var b = Math.abs(amount);// Take the abs, sign will be restored afterwards, this makes the rounding independant of sign

			// Round to five places (this is for the IEEE754 business described above)
			// Note we use Math.floor instead of Math.round to avoid problems switching from int to float.
			// This caused problems in the Safari browser, but didn't seem to affect IE.
			// See Bugs 65624 and 66338 - RGrisso, 4/1/04
			b = Math.floor((b * 100000.0)+0.5) / 100000.0 + 0.000001;

			// the + 0.000001 rounds up anything that's significant enough to affect the next rounding pass e.g. ####.459999999 (in binary)
			// e.g. a = 139.825

			// And now Round to the correct places
			var factor = Math.pow(10,precision);
			if (!method || method =='OFF') b = Math.floor((b * factor)+0.5) / factor;
			else if (method == 'UP')   b = Math.round(Math.ceil(Math.abs(amount) * factor)) / factor;
			else if (method == 'DOWN') b = Math.round(Math.floor(Math.abs(amount) * factor)) / factor;
			// return the sign
			b = b * (amount >= 0.0 ? 1.0 : -1.0);
			if( b === 0.0 )
				return 0.0;
			return b;
		}

		// Round to 8 decimal places
		function round_float(a)
		{
			return round_float_to_n_places(a,8);
		}

		// Round to n decimal places
		function round_float_to_n_places(a,n)
		{  // Take the abs, sign will be restored afterwards, this makes the rounding independant of sign
			var str = a + '';
			if(str.indexOf('.') < 0) // if it's an integer, just return
				return a;
			if(str.length-str.indexOf('.')-1 <= n) // if the decimal digits length after decimal point is less than the targeted precistion, just return
				return a;
			var b = Math.abs(a);
			b = b + 0.00000000000001; //SMALLER_NUMBER See NLRounding.round();
			var factor = Math.pow(10,n);
			b = Math.floor((b * factor)+0.5) / factor;
			// return the sign
			b = b * (a >= 0.0 ? 1.0 : -1.0);
			if( b == 0.0 )
				return 0.0;
			return b;
		}

		function pad_to_atleast_two_decimal_places(a)
		{
			var s;
			if(a == null)
			{
				s = '';
			}
			else
			{
				s = a.toString();
				var n = s.indexOf('.');
				if(n === -1)
				{
					s = s + '.00';
				}
				else if(n === s.length-1)
				{
					s = s + '00';
				}
				else if(n === s.length-2)
				{
					s = s + '0';
				}
				if (n === 0)
				{
					s = '0' + s;
				}
			}
			return s;
		}

		function pad_decimal_places(a, noOfDecimalPlaces)
		{
			var s;
			if(a == null)
			{
				s = '';
			}
			else
			{
				s = a.toString();
				var n = s.indexOf('.');
				if (noOfDecimalPlaces === 0)
				{
					if(a == 0.0)
					{
						s = '0';
					}
					else if(n > -1)
					{
						s = s.substring(0, n) ;
					}
				}
				else if (noOfDecimalPlaces ===1)
				{
					if(n == -1)
					{
						s = s + '.0';
					}
					else if(n == s.length-1)
					{
						s = s + '0';
					}
					else if (n == 0)
					{
						s = '0' + s;
					}
				}
				else
				{
					if(n == -1)
					{
						s = s + '.00';
					}
					else if(n == s.length-1)
					{
						s = s + '00';
					}
					else if(n == s.length-2)
					{
						s = s + '0';
					}
					if (n == 0)
					{
						s = '0' + s;
					}
				}
			}
			return s;
		}

		/**
		 *
		 * algorithm used should yield the same result as NLCurrency.Round...
		 * we should keep them consistent. There is now an additional param
		 * which will not attempt to round to 2 sig figures. All it does is
		 * to just add zeros at the end if it needs it. This is used for
		 * billing rates such as $0.4565 per gallon of paint and such.

		 * This method should optionally round the number passed in and then
		 * truncate it two digits past the decimal
		 */
		function format_currency(a, bDoNotRound, recordContext)
		{
			if(isNaN(a))
				return '';

			var cp = getCurrencyPrecisionFieldValue(recordContext);
			var noOfDecimalPlaces = getDefaultCurrencyPrecision();
			if (cp !== null)
			{
				noOfDecimalPlaces = parseFloat(cp);
				if (isNaN(noOfDecimalPlaces))
				{
					noOfDecimalPlaces = getDefaultCurrencyPrecision();
				}
			}
			var returnMe;
			if( !(bDoNotRound == true))   //This mess is necessary so that when do not round is not set it evaluates correctly
			{
				returnMe = round_currency(a, noOfDecimalPlaces);
			}
			else
			{
				returnMe = a;
			}
			returnMe = pad_decimal_places(returnMe, noOfDecimalPlaces);
			return returnMe;
		}

		//Use this for rounding Currency2
		function format_currency2(n, recordContext)
		{
			if(isNaN(n))
			{
				return '';
			}
			var returnMe;
			if( (n+'').indexOf('.') < 0 ) // if it's an integer, don't even try to do the rounding
				returnMe = n;
			else
				returnMe = round_float_to_n_places(n,CURRENCY2_AND_RATE_PRECISION);
			var precision = get_precision(recordContext);
			if (precision === 2) { //We pad zeros only if the precision on the currency is 2 (standard). For everything else, we show howsoevermany places you entered.
				returnMe = pad_to_atleast_two_decimal_places(returnMe);
			}

			return returnMe;
		}

		function format_percent(p) {
			if(typeof p == 'string')
				p = parseFloat(p);
			return p + ( p === Math.floor(p) ? '.0%' : '%');
		}

		function process_currency_field_value(value, fieldType, recordContext) {
			if (!fieldType || fieldType.indexOf('currency') == -1)
				return value;
			if (utilityFunctions.isValEmpty(value) || ('' + value).indexOf('.') != -1 || isNaN(parseFloat(value)))
				return value;
			var precision = fieldType.indexOf('currency2') >= 0 ? 2 : get_precision(recordContext);
			return pad_decimal_places('' + value, precision);
		}

		/* assign util.currency package */
		return Object.freeze({
			amount_string: amount_string,
			format_percent: format_percent,
			format_rate: format_rate,
			format_currency: format_currency,
			format_currency2: format_currency2,
			get_precision: get_precision,
			pad_decimal_places: pad_decimal_places,
			pad_to_atleast_two_decimal_places: pad_to_atleast_two_decimal_places,
			process_currency_field_value: process_currency_field_value,
			round_currency: round_currency,
			round_float: round_float,
			round_float_to_n_places: round_float_to_n_places
		});
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/date
 * @suiteScriptVersion 2.x
 */
define( 'N/util/date',['N/FieldValidationHelper'],
	function(FieldValidationHelper){
		var MONTHLENGTH = [[31,28,31,30,31,30,31,31,30,31,30,31],[31,29,31,30,31,30,31,31,30,31,30,31]];
		var OLDEST_VALID_DATE = new Date(1601, 3, 1); // Via Issue 139785, Any date before 4/1/1601 is invalid
		var yearCharCN = "年";
		var monthCharCN = "月";
		var dayCharCN = "日";
		var TIME_FORMAT_WITH_POSSIBLE_AMPM_SUFFIX = /^(\d+)(\D)(\d+)((\D)(\d+))?\s*([aApP][mM])?/;
		var TIME_FORMAT_WITH_POSSIBLE_AMPM_PREFIX = /^([aApP][mM])(\d+)(\D)(\d+)(\D)((\d+)(\D))?/;
		var TIME_FORMAT_WITH_ASIAN_FORMATTING	  = /^(\d+)(\D)(\d+)(\D)((\d+)(\D))?/;

		var oracleDateTimeFormatter = new OracleDateTimeFormatter(
			FieldValidationHelper,
			{
				getJapaneseImperialEra: getJapaneseImperialEra,
				getShortJapaneseImperialEra: getShortJapaneseImperialEra,
				getJapaneseImperialYear: getJapaneseImperialYear
			}
		);

        function getMonthIndexFromArray(array, val, ignorecase)
        {
            for ( var i = 0; array != null && i < array.length; i++ )
                if ( val == array[i] || (ignorecase && val != null && array[i] != null && val.toLowerCase() == array[i].toLowerCase()) )
                    return i;
            return -1;
        }

		/**
		 *
		 * @alias nlGetFullYear
		 *
		 * @param d
		 * @returns {*}
		 */
		function getFullYear(d)
		{
			if (typeof window !== 'undefined' && window.navigator != null && window.navigator.appName == "Netscape")
			{
				if (!d.getFullYear)
					return d.getYear();
			}
			return d.getFullYear();
		}

		var reiwaStartDate = new Date(2019, 4, 1);
		var heiseiStartDate = new Date(1989,0,8);
		var showaStartDate = new Date(1926,11,25);
		var taishoStartDate = new Date(1912,6,30);
		var meijiStartDate = new Date(1868,8,8);
		function getJapaneseImperialEra(d)
		{
			if (d >= reiwaStartDate)
				return "令和";
			else if (d >= heiseiStartDate)
				return "平成";
			else if(d >= showaStartDate)
				return "昭和";
			else if(d >= taishoStartDate)
				return "大正";
			else
				return "明治";
		}
		function getShortJapaneseImperialEra(d)
		{
			if (d >= reiwaStartDate)
				return "R";
			else if (d >= heiseiStartDate)
				return "H";
			else if(d >= showaStartDate)
				return "S";
			else if(d >= taishoStartDate)
				return "D";
			else
				return "M";
		}
		function getJapaneseImperialYear(d)
		{
			if (d >= reiwaStartDate)
				return getFullYear(d) - 2018;
			else if (d >= heiseiStartDate)
				return getFullYear(d) - 1988;
			else if(d >= showaStartDate)
				return getFullYear(d) - 1925;
			else if(d >= taishoStartDate)
				return getFullYear(d) - 1911;
			else
				return getFullYear(d) - 1867;
		}
		function getGregorianYear(japaneseImperialYear, era)
		{
			if (era === "令和" || era === "R")
				return japaneseImperialYear + 2018;
			else if(era === "平成" || era === "H")
				return japaneseImperialYear + 1988;
			else if(era === "昭和" || era === "S")
				return japaneseImperialYear + 1925;
			else if(era === "大正" || era === "D")
				return japaneseImperialYear + 1911;
			else
				return japaneseImperialYear + 1867;
		}
	
		function getMonthIndex(sMonth)
		{
			var m = -1;
			sMonth = sMonth.toUpperCase()
			for ( var i=0; i < FieldValidationHelper.datetime_short_months.length; i++ )
			{
				if ( FieldValidationHelper.datetime_short_months[i].toUpperCase() === sMonth )
				{
					m = i + 1; break;
				}
			}
			if(m !== -1)
				return m;
			for ( var i=0; i < FieldValidationHelper.datetime_months.length; i++ )
			{
				if ( FieldValidationHelper.datetime_months[i].toUpperCase() === sMonth )
				{
					m = i + 1; break;
				}
			}
	
			return m;
		}
		/**
		 *
		 * @alias nlSetFullYear
		 *
		 * @param d
		 * @param val
		 */
		function setFullYear(d,val)
		{
			if (typeof window !== 'undefined'  && window.navigator !== null && window.navigator.appName === "Netscape")
			{
				if (!d.setFullYear)
					d.setYear(val);
			}
			d.setFullYear(val);
		}
	
		function isLeapYear(year)
		{
			return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
		}
	
	
		function getMonthLength(year, month)
		{
			return MONTHLENGTH[isLeapYear(year) ? 1 : 0][month];
		}

		function addMonths(d, mtoadd)
		{
			if (mtoadd != 0)
			{
				var year = getFullYear(d);
				var dom = d.getDate();
				var month = d.getMonth() + mtoadd;
				if (month < 0)
				{
					month += 1;
					year = year + Math.ceil(month / 12) - 1;
					setFullYear(d, year);
					month = 11 + (month % 12);
				}
				else if (month > 11)
				{
					year = year + Math.floor(month / 12);
					setFullYear(d, year);
					month %= 12;

					// JS rounds leap days up (2/29/2016 + 1 yr = 3/1/2017),
					// whereas Java rounds them down (2/29/2016 + 1 yr = 2/28/2017).
					// Make JS behave like Java to be consistent with server side.
					if(dom === 29)
						d.setDate(dom); //This only works because we're setting the month later
				}
				var eom = getMonthLength(year, month);
				if (dom > eom)
					d.setDate(eom);

				d.setMonth(month);
			}
			return d;
		}

		function addDays(d, daystoadd)
		{
			if (!(d instanceof Date || Object.prototype.toString.call(d) === '[object Date]'))
				return d;
	
			var d2 = new Date(d.getTime() + 86400 * daystoadd * 1000);
			if (d2.getHours() !== d.getHours())
			{
				if ((d.getHours() > 0 && d2.getHours() < d.getHours()) || (d.getHours() === 0 && d2.getHours() === 23))
					d2.setTime(d2.getTime() + 3600*1000);
				else
					d2.setTime(d2.getTime() - 3600*1000);
			}
			d.setTime(d2.getTime());
			return d;
		}
	
		function isValidYearMonthDay(year, month, day)
		{
			return !(isNaN(year) || year < 0 || isNaN(month) || month < 0 || month > 11 || isNaN(day) || day < 1 || day > getMonthLength(year, month));
		}
	
		function trimString(str)
		{
			str = "" + str;
			return str.replace(/^\s+/,"").replace(/\s+$/,"");
		}
	
		// -- handle shorthand time notation i.e. 5p -> 5:00 pm, 18 -> 6:00 pm, 900 -> 9:00 am, 1433p -> 2:33 pm
		function hhmmToTimeString( hhmm )
		{
			//noinspection JSUnresolvedVariable
			var AM = FieldValidationHelper.datetime_am_string || "";
			//noinspection JSUnresolvedVariable
			var PM = FieldValidationHelper.datetime_pm_string || "";
			var fldvalue = hhmm;
			var hour, minute;
			if ( AM.charAt(0) === PM.charAt(0) )
				re = new RegExp("^[0-9]{1,4}("+AM+"|"+PM+")*$", "i");
			else
				re = new RegExp("^[0-9]{1,4}(["+AM.charAt(0)+"|"+PM.charAt(0)+"]?)$","i");
			if ( re.test(fldvalue) )
			{
				var aorp = '';
				if ( RegExp.$1 )
				{
					if ( AM.charAt(0) === PM.charAt(0) )
						aorp = RegExp.$1.toLowerCase() === PM ? PM : AM;
					else
						aorp = RegExp.$1.toLowerCase().charAt(0) === PM.charAt(0) ? PM : AM;
				}
				if ( fldvalue.length < 3 || ( fldvalue.length === 3 && RegExp.$1 ) )
				{
					var hh = RegExp.$1 ? fldvalue.substring(0,fldvalue.length-1) : fldvalue;
					hour = parseInt( hh, 10 ) == 0 ? 12 : ( parseInt( hh, 10 ) > 12 ? parseInt( hh, 10 ) % 12 : hh ) ;
					minute = 0;
					var ampm = RegExp.$1 ? aorp :
							   ( parseInt( fldvalue, 10 ) > 11 ? PM : AM );
				}
				else if (fldvalue.length === 3 || (fldvalue.length === 4 && RegExp.$1) )
				{
					var hh = fldvalue.substring(0,1) === "0" ? "12" : fldvalue.substring(0,1);
					hour = parseInt( hh, 10 );
					var mm = RegExp.$1 ? fldvalue.substring(1,3) : fldvalue.substring(1);
					minute = parseInt( mm, 10 );
					var ampm = RegExp.$1 ? aorp : AM;
				}
				else
				{
					var hh = fldvalue.substring(0,2);
					hour = parseInt( hh, 10 ) === 0 ? 12 : ( parseInt( hh, 10 ) > 12 ? parseInt( hh, 10 ) % 12 : hh );
					var mm = RegExp.$1 ? fldvalue.substring(2,4) : fldvalue.substring(2);
					minute = parseInt( mm, 10 );
					var ampm = parseInt( fldvalue.substring(0,2), 10 ) > 11 ? PM : AM;
					ampm = RegExp.$1 ? aorp : ampm;
				}
				if (ampm === AM && hour === 12)
					hour = 0;
				else if(ampm === PM && hour !== 12)
					hour = parseInt(hour) + 12;
				var time = new Date();
				time.setHours(hour,minute,0,0);
				fldvalue = getTimeString(time, AM, PM);
			}
			return fldvalue;
		}
	
		function regexStringToTime(date, time, includeSeconds, returnNullIfInvalid)
		{
			time = time != null ? trimString(time) : time;
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";
			//noinspection JSUnresolvedVariable
			var timeformatWithSeconds = FieldValidationHelper.timeformatwithseconds || "fmHH:fmMI:SS am";
			var flddate = date != null ? stringToDate(date, "", returnNullIfInvalid) : new Date();
            if (flddate == null)
                return null;
			if (time != null && String(time).length != 0 && String(time).search(/\S/) >= 0)
			{
				var hours = NaN;
				var minutes = NaN;
				var seconds = NaN;
	
				var delimitors;
				time = trimString(time);
	
				var TIME_FORMAT_MAP =
				{
					"HH:MI:SS am": { rcase: 0, hend: ':', mend: ':', send: ' '},
					"HH-MI-SS am": { rcase: 0, hend: '-', mend: '-', send: ' '},
					"HH24:MI:SS": { rcase: 0, hend: ':', mend: ':', send: null},
					"HH24-MI-SS": { rcase: 0, hend: '-', mend: '-', send: null},
					"amHH時MI分SS秒": { rcase:1, hend:'時', mend:'分', send:'秒'},
					"amHH点MI分SS秒": { rcase:1, hend:'点', mend:'分', send:'秒'},
					"amHH시MI분SS초": { rcase:1, hend:'시', mend:'분', send:'초'},
					"HH24時MI分SS秒": { rcase:2, hend:'時', mend:'分', send:'秒'},
					"HH24点MI分SS秒": { rcase:2, hend:'点', mend:'分', send:'秒'},
					"HH24시MI분SS초": { rcase:2, hend:'시', mend:'분', send:'초'},
					"HH:MI am": { rcase: 0, hend: ':', mend: ' ', send: null},
					"HH-MI am": { rcase: 0, hend: '-', mend: ' ', send: null},
					"HH24:MI": { rcase: 0, hend: ':', mend: null, send: null},
					"HH24-MI": { rcase: 0, hend: '-', mend: null, send: null},
					"amHH時MI分": { rcase:1, hend:'時', mend:'分', send:null},
					"amHH点MI分": { rcase:1, hend:'点', mend:'分', send:null},
					"amHH시MI분": { rcase:1, hend:'시', mend:'분', send:null},
					"HH24時MI分": { rcase:2, hend:'時', mend:'分', send:null},
					"HH24点MI分": { rcase:2, hend:'点', mend:'分', send:null},
					"HH24시MI분":{ rcase:2, hend:'시', mend:'분', send:null}
				};
	
				var format = oracleDateTimeFormatter.preprocessDateTimeFormat(includeSeconds ? timeformatWithSeconds : timeformat);
				delimitors = TIME_FORMAT_MAP[format];
	
				var m;
				var ampm = null;
				var hend = null;
				var mend = null;
				var send = null;
				if (delimitors != null)
				{
					switch (delimitors.rcase)
					{
						case 0:
						{
							m = TIME_FORMAT_WITH_POSSIBLE_AMPM_SUFFIX.exec(time);
							if (m !== null)
							{
								hours = parseInt(m[1], 10);
								hend = m[2];
								minutes = parseInt(m[3], 10);
								mend = m[5];
								if (includeSeconds && m[4] != null)
									seconds = parseInt(m[6], 10);
								else
									seconds = 0;
								ampm = m[7];
							}
							break;
						}
						case 1:
						{
							var amtime=time.replace(/午前|上午|오전/g,'am');
							amtime=amtime.replace(/午後|下午|오후/g,'pm');
							m = TIME_FORMAT_WITH_POSSIBLE_AMPM_PREFIX.exec(amtime);
							if (m !== null)
							{
								hours = parseInt(m[2], 10);
								hend = m[3];
								minutes = parseInt(m[4], 10);
								mend = m[5];
								if (includeSeconds && m[6] != null)
								{
									seconds = parseInt(m[7], 10);
									send = m[8];
								}
								else
									seconds = 0;
								ampm = m[1];
							}
							break;
						}
						case 2:
						{
							m = TIME_FORMAT_WITH_ASIAN_FORMATTING.exec(time);
							if (m !== null)
							{
								hours = parseInt(m[1], 10);
								hend = m[2];
								minutes = parseInt(m[3], 10);
								mend = m[4];
								if (includeSeconds && m[5] != null)
								{
									seconds = parseInt(m[6], 10);
									send = m[7];
								}
								else
									seconds = 0;
							}
							break;
						}
					}
					if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || hours >= 24 || hours < 0 || minutes >= 60 || minutes < 0 || seconds >= 60 || seconds < 0)
						return NaN;
	
					if (hend != delimitors.hend || (includeSeconds && (mend != null && mend != delimitors.mend) || (send != null && send != delimitors.send)))
						return NaN;
	
					if (ampm != null)
					{
						//noinspection JSUnresolvedVariable
						hours = getHoursIn24HourFormat((ampm.toLowerCase() == FieldValidationHelper.datetime_pm_string), hours);
					}
					flddate.setHours(hours, minutes, seconds, 0);
				} else
					flddate = NaN;
			}
			return flddate;
		}

		// to replace parseMMYYDateString (if possible)
		function stringToMMYYDate(arg, dateformat, returnNullIfInvalid)
		{
			if(!dateformat)
			{
				if(typeof(window.dateformat) !== "undefined")
					dateformat = window.dateformat;
				else
					dateformat = "MM/DD/YYYY";
			}
			var returnValIfError = returnNullIfInvalid ? null : new Date();
			dateformat = oracleDateTimeFormatter.preprocessDateTimeFormat(dateformat);
	
			var parts, mm, yy;
			var yearCharIndex, monthCharIndex, dayCharIndex, era;
			var comps = arg.split(/[\.\/-]/);
	
			if(!/^[0-9\-\/\.]+$/.test(arg)) // contains other characters
			{
				if (comps.length !== 2)
					return returnValIfError;
				else
				{
					mm = getMonthIndex(comps[0]) - 1;
					yy = parseInt(comps[1], 10);
				}
			}
			else // only contains numbers and - / or .
			{
				if (comps.length === 1)
				{
					if ((arg.length === 4) || (arg.length === 6))
					{
						mm = parseInt(arg.slice(0, 2), 10) - 1;
						yy = parseInt(arg.slice(2), 10)
					}
				}
				else if (comps.length === 2)
				{
					mm = parseInt(comps[0], 10) - 1;
					yy = parseInt(comps[1], 10);
				}
			}
	
			if (yy < 50)
				yy += 2000;
			else if (yy < 100)
				yy += 1900;
	
			if (!isValidYearMonthDay(yy, mm, 1))
				return returnValIfError;
			else
				return new Date(yy, mm);
		}
	
		function splitDateAndTime(dateTime)
		{
			var spaceCount = 0;
			var dateformat = oracleDateTimeFormatter.preprocessDateTimeFormat(FieldValidationHelper.dateformat || "MM/DD/YYYY");
			dateTime = trimString(dateTime);

			switch (dateformat)
			{
				case "MM/DD/YYYY":
				case "DD/MM/YYYY":
				case "DD.MM.YYYY":
				case "DD-Mon-YYYY":
				case "DD-MONTH-YYYY":
				case "YYYY/MM/DD":
				case "YYYY-MM-DD":
				case "EEYY年MM月DD日":
				case "YYYY年MM月DD日":
				case "EYY.MM.DD":
					spaceCount = 0;
					break;
	
				case "DD. MON YYYY":
				case "YYYY년 MM월 DD일":
				case "DD MONTH, YYYY":
				case "DD MONTH YYYY":
					spaceCount = 2;
					break;
	
				case "DD de MONTH de YYYY":
					spaceCount = 4;
					break;
	
				default:
					return {date: dateTime, time: null};
			}
	
			var myRegex = (spaceCount === 0) ? new RegExp("^(\\S+)\\s+(.*)$") : new RegExp("^(\\S+(\\s+\\S+){" + spaceCount + "})\\s+(.*)$");
			var matches = dateTime.match(myRegex);

			if (matches)
			{
				return {date: matches[1], time: (spaceCount === 0) ? matches[2] : matches[3]}
			}
			else // assume just date if not a match
			{
				return {date: dateTime, time: null};
			}
		}
	
		function stringToDate(d, dateformat, returnNullIfInvalid, formattype)
		{
			d = trimString(d);
			var comps;
			var month, day, year;
			var yearCharIndex, monthCharIndex, dayCharIndex, era;
			if(!dateformat)
			{
				//noinspection JSUnresolvedVariable
				dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			}
			var dateStrLength = d.length;
			var endStr; //the end segment in date string (mainly used for date seg since year string's length is always 4)
			var yearLength = 4;
			var returnValIfError = returnNullIfInvalid ? null : new Date();
			// for now remove the format/strict modifiers
			// fm influences only formatting and we do not yet use fx anywhere
			// also strip quoting characters until we think of some better way to parse this
			dateformat = oracleDateTimeFormatter.preprocessDateTimeFormat(dateformat);

			if(d.length > 0)
			{
				switch(dateformat)
				{
					case "MM/DD/YYYY":
						comps = d.split("/");
						if(comps.length < 3)	   // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						month = parseInt(comps[0], 10) - 1;
						day = parseInt(comps[1], 10);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD/MM/YYYY":
						comps = d.split("/");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD.MM.YYYY":
						comps = d.split(".");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD-Mon-YYYY":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = getMonthIndex(comps[1]) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD-MONTH-YYYY":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1], true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "YYYY/MM/DD":
						comps = d.split("/");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[0], 10);
						dateStrLength = comps[1].length + endStr.length + yearLength + 2;
						break;
					case "YYYY-MM-DD":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[0], 10);
						dateStrLength = comps[1].length + endStr.length + yearLength + 2;
						break;
					case "EEYY年MM月DD日":
						yearCharIndex = d.indexOf(yearCharCN);
						monthCharIndex = d.indexOf(monthCharCN);
						dayCharIndex = d.indexOf(dayCharCN);
						if(yearCharIndex < 0 || monthCharIndex < 0 || dayCharIndex < 0)
							return returnValIfError;
						day = parseInt(d.substring(monthCharIndex+1,dayCharIndex), 10);
						month = parseInt(d.substring(yearCharIndex+1,monthCharIndex), 10) - 1;
						era = d.substring(0, 2);
						year = getGregorianYear(parseInt(d.substring(2,yearCharIndex), 10), era);
						dateStrLength = dayCharIndex + 1;
						break;
					case "YYYY年MM月DD日":
						yearCharIndex = d.indexOf(yearCharCN);
						monthCharIndex = d.indexOf(monthCharCN);
						dayCharIndex = d.indexOf(dayCharCN);
						if(yearCharIndex < 0 || monthCharIndex < 0 || dayCharIndex < 0)
							return returnValIfError;
						day = parseInt(d.substring(monthCharIndex+1,dayCharIndex), 10);
						month = parseInt(d.substring(yearCharIndex+1,monthCharIndex), 10) - 1;
						year = parseInt(d.substring(0,yearCharIndex), 10);
						dateStrLength = dayCharIndex + 1;
						break;
					case "EYY.MM.DD":
						comps = d.split(".");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						era = comps[0].substring(0, 1);
						year = getGregorianYear(parseInt(comps[0].substring(1,comps[0].length), 10), era);
						dateStrLength = comps[0].length + comps[1].length + endStr.length + 2;
						break;
					case "DD. MON YYYY":
						comps = d.split(" ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0].substring(0, comps[0].length - 1), 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_short_months, comps[1]);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD de MONTH de YYYY":
						comps = d.split(" de ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = getMonthIndex(comps[1]) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 8;
						break;
					case "YYYY년 MM월 DD일":
						comps = d.split(" ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[2].substring(0, comps[2].length-1), 10);
						month = parseInt(comps[1].substring(0, comps[1].length-1), 10) - 1;
						year = parseInt(comps[0].substring(0, comps[0].length-1), 10);
						var whitespaceChars = 3;
						dateStrLength = comps[0].length + comps[1].length + comps[2].length + whitespaceChars;
						break;
					case "DD MONTH YYYY":
						comps = d.split(" ");
						if(comps.length < 3) //the format could be "DD MONTH YYYY HH:MI:SS AM" . length =4
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1], true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD MONTH, YYYY":
						comps = d.split(" ");
						if(comps.length < 3) //the format could be "DD MONTH YYYY HH:MI:SS PM" . length = 4
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1].substring(0, comps[1].length-1), true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
				}
			}
	
			if (!isValidYearMonthDay(year, month, day))
				return returnValIfError;
	
			// now handle the time segment
			var result;
			var t = d.substring(dateStrLength);
			if (t != null && t.length > 0)
			{
				if (formattype == 'datetimetz')
					result = regexStringToTime(d.substring(0,dateStrLength),t, true, returnNullIfInvalid);
				else if (formattype == 'datetime' || formattype == 'timeofday')
					result = regexStringToTime(d.substring(0,dateStrLength),t, false, returnNullIfInvalid);
				else
					result = stringToTime(d.substring(0,dateStrLength),t);
			}
			else
				result = new Date(year,month,day);
			if (result != null && !isNaN(result)) {
				if (year < 50)
					setFullYear(result, year + 2000);
				else if (year < 100)
					setFullYear(result, year + 1900);
            }
			return isNaN(result) && returnNullIfInvalid ? null : result;
		}
	
		function getHoursIn24HourFormat(isPM, hours)
		{
			if (!isPM && hours == 12)
				return 0;
			else if (isPM && hours < 12)
				return hours + 12;
			else
				return hours;
		}
	
		function stringToTime(date, time)
		{
			time = time != null ? trimString(time) : time;
			//noinspection JSUnresolvedVariable
			var timeformat = oracleDateTimeFormatter.preprocessDateTimeFormat(FieldValidationHelper.timeformat || "fmHH:fmMI am");
			//noinspection JSUnresolvedVariable
			var AM = FieldValidationHelper.datetime_am_string || "";
			//noinspection JSUnresolvedVariable
			var PM = FieldValidationHelper.datetime_pm_string || "";
			var flddate = date !== null ? stringToDate(date) : new Date();
			if (time !== null && String(time).length != 0 && String(time).search(/\S/) >= 0)
			{
				var hours;
				var minutes;
				var isPM;
				var hourCharIndex;
	
				var format = timeformat.replace(/fm/g, "").replace(/"/g, "");
				if (format === "HH:MI am" || format === "HH-MI am" || format === "HH24:MI" || format === "HH24-MI")
				{
					var m = /^\s*(\d+)[-:](\d+)\s*(.*)/.exec(time);
					if (!m) return NaN;
					hours = parseInt(m[1], 10);
					minutes = parseInt(m[2], 10);
					if (format.substring(6) === "am")
					{
						isPM = (m[3].toLowerCase() === PM);
						hours = getHoursIn24HourFormat(isPM, hours);
					}
				}
				else if(format === "amHH時MI分" || format === "amHH点MI分" || format === "amHH시MI분")
				{
					hourCharIndex = time.indexOf("時");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("点");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("시");
					var hour_start_index = 0;
					isPM = false;
	
					if(time.indexOf(AM) == 0)
						hour_start_index = AM.length;
					else if(time.indexOf(PM) == 0)
					{
						hour_start_index = PM.length;
						isPM = true;
					}
					hours = parseInt(time.substring(hour_start_index, hourCharIndex), 10);
					hours = getHoursIn24HourFormat(isPM, hours);
					minutes = parseInt(time.substring(hourCharIndex + 1, time.length - 1), 10);
				}
				else if(format === "HH24時MI分" || format === "HH24点MI分" || format === "HH24시MI분")
				{
					hourCharIndex = time.indexOf("時");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("点");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("시");
					hours = parseInt(time.substring(0, hourCharIndex), 10);
					minutes = parseInt(time.substring(hourCharIndex + 1, time.length - 1), 10);
				}
				if(isNaN(hours) || isNaN(minutes) || hours >= 24 || hours < 0 || minutes >= 60 || minutes < 0)
					return NaN;
				flddate.setHours(hours, minutes, 0, 0);
			}
			return flddate;
		}
	
	
		function getTimeString(time, amvar, pmvar)
		{
			if (!(time instanceof Date || Object.prototype.toString.call(time) === '[object Date]'))
				return time;
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";

			return oracleDateTimeFormatter.formatDateTime(time, timeformat);
		}
	
		function getDateString(d, format)
		{
			// if dateformat is specified, use it from the format parameter
			// else use the window property (set from user preference)
			var dateformat;
			if (format)
				dateformat = format;
			else
			{
				//noinspection JSUnresolvedVariable
				dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			}

			return oracleDateTimeFormatter.formatDateTime(d, dateformat);
		}
	
		function getTimeWithSecondsString(time,amvar,pmvar)
		{
			if (!(time instanceof Date || Object.prototype.toString.call(time) === '[object Date]'))
				return time;
			//noinspection JSUnresolvedVariable
			var timeformatWithSeconds = FieldValidationHelper.timeformatwithseconds || "fmHH:fmMI:SS am";

			return oracleDateTimeFormatter.formatDateTime(time, timeformatWithSeconds);
		}
	
		function getMMYYString(date)
		{
			var dateformat = FieldValidationHelper.dateformat || "fmMM/DDfm/YYYY";

			return oracleDateTimeFormatter.formatMMYYDateString(date, dateformat);
		}

		function getDatetimeString(date)
		{
			return getDateString(date) + " " + getTimeString(date);
		}
	
		function getDatetimetzString(date)
		{
			return getDateString(date) + " " + getTimeWithSecondsString(date);
		}
	
		var m_j_d = [[0,31,59,90,120,151,181,212,243,273,304,334],[0,31,60,91,121,152,182,213,244,274,305,335]];
	
		var j_d = [];
		j_d[1970]=0;
		j_d[1971]=365;
		j_d[1972]=730;
		j_d[1973]=1096;
		j_d[1974]=1461;
		j_d[1975]=1826;
		j_d[1976]=2191;
		j_d[1977]=2557;
		j_d[1978]=2922;
		j_d[1979]=3287;
		j_d[1980]=3652;
		j_d[1981]=4018;
		j_d[1982]=4383;
		j_d[1983]=4748;
		j_d[1984]=5113;
		j_d[1985]=5479;
		j_d[1986]=5844;
		j_d[1987]=6209;
		j_d[1988]=6574;
		j_d[1989]=6940;
		j_d[1990]=7305;
		j_d[1991]=7670;
		j_d[1992]=8035;
		j_d[1993]=8401;
		j_d[1994]=8766;
		j_d[1995]=9131;
		j_d[1996]=9496;
		j_d[1997]=9862;
		j_d[1998]=10227;
		j_d[1999]=10592;
		j_d[2000]=10957;
		j_d[2001]=11323;
		j_d[2002]=11688;
		j_d[2003]=12053;
		j_d[2004]=12418;
		j_d[2005]=12784;
		j_d[2006]=13149;
		j_d[2007]=13514;
		j_d[2008]=13879;
		j_d[2009]=14245;
		j_d[2010]=14610;
		j_d[2011]=14975;
		j_d[2012]=15340;
		j_d[2013]=15706;
		j_d[2014]=16071;
		j_d[2015]=16436;
		j_d[2016]=16801;
		j_d[2017]=17167;
		j_d[2018]=17532;
		j_d[2019]=17897;
		j_d[2020]=18262;
		j_d[2021]=18628;
		j_d[2022]=18993;
		j_d[2023]=19358;
		j_d[2024]=19723;
		j_d[2025]=20089;
		j_d[2026]=20454;
		j_d[2027]=20819;
		j_d[2028]=21184;
		j_d[2029]=21550;
		j_d[2030]=21915;
	
		function getMonthJulian(year, month)
		{
			return m_j_d[isLeapYear(year)?1:0][month];
		}
	
	
		function get_julian_date(d)
		{
			return j_d[d.getFullYear()]+getMonthJulian(d.getFullYear(),d.getMonth())+d.getDate()-1;
		}
	
		function isDateTooOld(timeString)
		{
			return timeString < OLDEST_VALID_DATE;
		}
	
		function getOldestDateString()
		{
			return getDateString(OLDEST_VALID_DATE);
		}
	
		function _hhmm_to_mins(time) {
			return time.hrs * 60 + time.mins;
		}

		function round_hhmm_nearest(hrs, mins, round_by) {
			var up_time = round_hhmm_up(hrs, mins, round_by);
			var down_time = round_hhmm_down(hrs, mins, round_by);

			orig_mins = _hhmm_to_mins({
				hrs: hrs,
				mins: mins
			});
			up_mins = _hhmm_to_mins(up_time);
			down_mins = _hhmm_to_mins(down_time);

			if (up_mins - orig_mins > orig_mins - down_mins) {
				return down_time;
			} else {
				return up_time;
			}
		}

		function round_hhmm_up(hrs, mins, round_by) {
			mins += (mins % round_by > 0 ? (round_by - (mins % round_by)) : 0);
			if (mins >= 60) {
				var _hhmm_delta = Math.floor(mins / 60);
				mins -= (_hhmm_delta * 60);
				hrs += _hhmm_delta;
			}
			return {
				hrs: hrs,
				mins: mins
			};
		}

		function round_hhmm_down(hrs, mins, round_by) {
			mins -= (mins > 0 ? (mins % round_by) : 0);
			return {
				hrs: hrs,
				mins: mins
			};
		}

		function round_hhmm(val, round_by, direction) {
			if (val == "") return val;
			var re = /^([0-9]+?):([0-9]+)$/;
			var result = re.exec(val);
			if (result == null) {
				result = format_hhmm(val);
				if (result == null) return val;
			}
			var hrs = parseFloat(result[1]);
			var mins = parseFloat(result[2]);
			var time;
			if (direction == 'UP') {
				time = round_hhmm_up(hrs, mins, round_by);
			} else if (direction == 'DOWN') {
				time = round_hhmm_down(hrs, mins, round_by);
			} else if (direction == 'NEAR') {
				time = round_hhmm_nearest(hrs, mins, round_by);
			} else {
				throw direction + ' is not vald direction: [UP,DOWN,NEAREST]';
			}
			if (time.mins < 10) time.mins = '0' + time.mins;
			return time.hrs + ':' + time.mins;
		}

		function format_hhmm(val) {
			var hours;
			var minutes;

			var re = /([0-9][0-9]?)?(:[0-9][0-9]+)?/
			var result = re.exec(val)
			if (result == null || result.index > 0 || result[0].length != val.length) {
				timeval = parseFloat(val);
				if (isNaN(timeval)) hours = -1;
				else {
					hours = Math.floor(timeval);
					minutes = Math.floor((timeval - hours) * 60 + 0.5);
				}
			} else {
				if (RegExp.$1.length > 0) hours = parseInt(RegExp.$1, 10);
				else hours = 0;
				if (typeof (RegExp.$2) != "undefined" && RegExp.$2.length > 0) {
					minutes = parseInt(RegExp.$2.substr(1), 10);
					// if the user entered a value >= 60 for minutes, add the extra hours to the hours var and reduce
					// minutes to be less than 60
					if (minutes >= 60) {
						var hours_delta = Math.floor(minutes / 60);
						minutes -= (hours_delta * 60);
						hours += hours_delta;
					}
				} else minutes = 0;
			}
			if (hours >= 0 && minutes >= 0 && minutes < 60) {
				return [val, hours, minutes];
			}
		}

		function parse_time(val) {

			if (val == null || val.trim().length == 0)
				return null;

			var time = {hours: 0, minutes: 0, negative: false};

			var rexp = /^(\-?)(\d*)(:(\d+))?$/;
			var rexpRes = rexp.exec(val);

			if (rexpRes == null) {
				var timeval = parseFloat(val);
				if (isNaN(timeval)) {
					return null;
				} else {
					if (timeval < 0) {
						timeval = Math.abs(timeval);
						time.negative = true;
					}
					time.hours = Math.floor(timeval);
					time.minutes = Math.round((timeval - time.hours) * 60);
				}
			} else {

				if (typeof rexpRes[2] != "undefined" && rexpRes[2].trim().length > 0) {
					time.hours = parseInt(rexpRes[2], 10);
				}

				if (typeof rexpRes[4] != "undefined" && rexpRes[4].trim().length > 0) {
					time.minutes = parseInt(rexpRes[4], 10);
					// if the user entered a value >= 60 for minutes, add the extra hours to the hours var and reduce minutes to be less than 60
					if (time.minutes >= 60) {
						var delta = Math.floor(time.minutes / 60);
						time.hours += delta;
						time.minutes -= delta * 60;
					}
				}
				if (rexpRes[1] == '-' && (time.hours > 0 || time.minutes > 0))
					time.negative = true;
			}
			return time;
		}

		function round_hhmm2(val, round_by, direction) {

			var result = parse_time(val);
			if (result == null) {
				return val;
			}
			var hrs = result.hours;
			var mins = result.minutes;
			var time;
			if (direction == 'UP') {
				time = round_hhmm_up(hrs, mins, round_by);
			} else if (direction == 'DOWN') {
				time = round_hhmm_down(hrs, mins, round_by);
			} else if (direction == 'NEAR') {
				time = round_hhmm_nearest(hrs, mins, round_by);
			} else {
				throw direction + ' is not vald direction: [UP,DOWN,NEAREST]';
			}
			if (time.mins < 10) time.mins = '0' + time.mins;
			return (result.negative ? '-' : '') + time.hrs + ':' + time.mins;
		}

		function OracleDateTimeFormatter(settingsContainer, japaneseEraHandlers, shortMonthsMap, longMonthsMap) {
			var that = this;
			this.settingsContainer = settingsContainer;
			this.shortMonthsMap = shortMonthsMap === undefined ? settingsContainer.datetime_short_months : shortMonthsMap;
			this.longMonthsMap = longMonthsMap === undefined ? settingsContainer.datetime_months : longMonthsMap;

			this.getJapaneseImperialEra = japaneseEraHandlers.getJapaneseImperialEra;
			this.getShortJapaneseImperialEra = japaneseEraHandlers.getShortJapaneseImperialEra;
			this.getJapaneseImperialYear = japaneseEraHandlers.getJapaneseImperialYear;

			function DateTimeElementType(matchPattern, formatterFunction) {
				this.matchRegexp = new RegExp('^' + matchPattern, 'i');
				this.formatterFunction = formatterFunction;
			}

			function DateTimeElement(elementType, value, isUnpadded, isStrict) {
				this.elementType = elementType;
				this.value = value;
				this.isUnpadded = isUnpadded;
				this.isStrict = isStrict;
				this.formatterFunction = elementType.formatterFunction;
			}

			this.padChar = function padChar(value, length, characterToPad) {
				while (value.length < length) {
					value = characterToPad + value;
				}
				return value;
			};

			this.padZeros = function padZeros(value, length) {
				return that.padChar(value, length, '0');
			};

			this.padSpace = function padSpace(value, length) {
				return that.padChar(value, length, ' ');
			};

			this.formatDateTimeElement = function formatDateTimeElement(element, valueFromDateObject, maxWidth) {
				var width = element.value.length;

				if (maxWidth !== undefined && width > maxWidth) {
					width = maxWidth;
				}
				var isUnpadded = element.isUnpadded;
				var padFunc = isNaN(valueFromDateObject) ? that.padSpace : that.padZeros;
				var valueAsString = valueFromDateObject.toString();

				return isUnpadded ? valueAsString : padFunc(valueAsString, width);
			};

			this.formatters = Object.freeze({
				formatMeridian: function formatMeridian(dateTimeElement, dateObject) {
					//noinspection JSUnresolvedVariable
					var amvar = that.settingsContainer.datetime_am_string || '';
					//noinspection JSUnresolvedVariable
					var pmvar = that.settingsContainer.datetime_pm_string || '';
					var hours = dateObject.getHours();
					return hours < 12 ? amvar : pmvar;
				},

				formatDayOfMonth: function formatDayOfMonth(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getDate())
				},

				formatDayOfWeek: function formatDayOfWeek(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getDay());
				},

				formatLongEra: function formatLongEra(dateTimeElement, dateObject) {
					return that.getJapaneseImperialEra(dateObject);
				},

				formatShortEra: function formatShortEra(dateTimeElement, dateObject) {
					return that.getShortJapaneseImperialEra(dateObject);
				},

				format24Hour: function format24Hour(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getHours(), 2);
				},

				format12Hour: function format12Hour(dateTimeElement, dateObject) {
					var valueIn12Hour = dateObject.getHours() % 12;
					// 00 in 24h corresponds to 12 am
					if (valueIn12Hour === 0) valueIn12Hour = 12;
					return that.formatDateTimeElement(dateTimeElement, valueIn12Hour, 2);
				},

				formatISOYear: function formatISOYear(dateTimeElement, dateObject) {
					return this.formatYear(dateTimeElement, dateObject);
				},

				formatMonth: function formatMonth(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getMonth() + 1);
				},

				formatMinute: function formatMinute(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getMinutes());
				},

				formatLongMonthName: function formatLongMonthName(dateTimeElement, dateObject) {
					return that.longMonthsMap[dateObject.getMonth()];
				},

				formatShortMonthName: function formatShortMonthName(dateTimeElement, dateObject) {
					return that.shortMonthsMap[dateObject.getMonth()];
				},

				formatSeconds: function formatSeconds(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getSeconds());
				},

				formatYear: function formatYear(dateTimeElement, dateObject) {
					var yearValue = that.getFullYear(dateObject);
					return that.formatDateTimeElement(dateTimeElement, yearValue);
				},

				formatLastDigitOfYear: function formatLastDigitOfYear(dateTimeElement, dateObject) {
					var yearAsString = that.getFullYear(dateObject).toString();
					return yearAsString.substr(-dateTimeElement.value.length);
				},

				formatText: function formatText(dateTimeElement, dateObject) {
					return dateTimeElement.value.replace(/"/g, "");
				},

				formatAsIs: function formatAsIs(dateTimeElement, dateObject) {
					return dateTimeElement.value;
				}
			});

			this.getFullYear = function getFullYearDefaultImpl(dateObject) {
				return dateObject.getFullYear();
			};

			this.dateTimeElementTypes = Object.freeze({
				AD_INDICATOR: new DateTimeElementType('A\.D\.|AD'),
				MERIDIAN: new DateTimeElementType('[AP]\.M\.|[AP]M', that.formatters.formatMeridian),
				ERA_INDICATOR: new DateTimeElementType('B\.C\.|BC'),
				CENTURY: new DateTimeElementType('S?CC'),
				DAY_NAME: new DateTimeElementType('DAY'),
				ABBREV_DAY_NAME: new DateTimeElementType('DY'),
				DAY_OF_YEAR: new DateTimeElementType('DDD'),
				DAY_OF_MONTH: new DateTimeElementType('DD', that.formatters.formatDayOfMonth),
				SHORT_DATE: new DateTimeElementType('DS'),
				LONG_DATE: new DateTimeElementType('DL'),
				DAY_OF_WEEK: new DateTimeElementType('D', that.formatters.formatDayOfWeek),
				FULL_ERA: new DateTimeElementType('EE', that.formatters.formatLongEra),
				ABBREV_ERA: new DateTimeElementType('E', that.formatters.formatShortEra),
				FRACTIONAL_SECONDS: new DateTimeElementType('FF[1-9]'),
				HOUR_OF_DAY_24: new DateTimeElementType('HH24', that.formatters.format24Hour),
				HOUR_OF_DAY_12: new DateTimeElementType('HH(12)?', that.formatters.format12Hour),
				ISO_WEEK_OF_YEAR: new DateTimeElementType('IW'),
				ISO_YEAR: new DateTimeElementType('IY{0,3}', that.formatters.formatISOYear),
				JULIAN_DAY: new DateTimeElementType('J'),
				MINUTE: new DateTimeElementType('MI', that.formatters.formatMinute),
				MONTH: new DateTimeElementType('MM', that.formatters.formatMonth),
				LONG_MONTH_NAME: new DateTimeElementType('Month', that.formatters.formatLongMonthName),
				SHORT_MONTH_NAME: new DateTimeElementType('Mon', that.formatters.formatShortMonthName),
				QUARTER_OF_YEAR: new DateTimeElementType('Q'),
				ROMAN_NUMERAL_MONTH: new DateTimeElementType('RM'),
				LONG_ROUNDED_YEAR: new DateTimeElementType('RRRR'),
				SHORT_ROUNDED_YEAR: new DateTimeElementType('RR'),
				SECONDS_PAST_MIDNIGHT: new DateTimeElementType('SSSSS'),
				SECONDS: new DateTimeElementType('SS', that.formatters.formatSeconds),
				SHORT_TIME: new DateTimeElementType('TS'),
				TZ_DAYLIGHT_SAVING: new DateTimeElementType('TZD'),
				TZ_HOUR: new DateTimeElementType('TZH'),
				TZ_MINUTE: new DateTimeElementType('TZM'),
				TZ_REGION: new DateTimeElementType('TZR'),
				WEEK_OF_YEAR: new DateTimeElementType('WW'),
				WEEK_OF_MONTH: new DateTimeElementType('W'),
				LOCAL_RADIX: new DateTimeElementType('X'),
				FOUR_DIGIT_YEAR: new DateTimeElementType('S?YYYY', that.formatters.formatYear),
				SPELLED_OUT_YEAR: new DateTimeElementType('S?YEAR'),
				LAST_DIGIT_OF_YEAR: new DateTimeElementType('Y{1,3}', that.formatters.formatLastDigitOfYear),
				TEXT: new DateTimeElementType('"[^"]*"', that.formatters.formatText),
				PUNCTUATION: new DateTimeElementType('[-/,.;:]+', that.formatters.formatAsIs),
				WHITESPACE: new DateTimeElementType('\\s+', that.formatters.formatAsIs),
				UNPAD_MOD: new DateTimeElementType('fm'),
				STRICT_MOD: new DateTimeElementType('fx'),
				SINGLE_QUOTE: new DateTimeElementType('\'\'', that.formatters.formatAsIs)
			});

			// Javascript does not guarantee ordering of object properties (obviously)
			// but we "resolve" parsing ambiguities by letting first match win
			// thus we have to explicitly order the element types to avoid parse aliasing
			this.matchOrder = [
				this.dateTimeElementTypes.AD_INDICATOR,
				this.dateTimeElementTypes.MERIDIAN,
				this.dateTimeElementTypes.ERA_INDICATOR,
				this.dateTimeElementTypes.CENTURY,
				this.dateTimeElementTypes.DAY_NAME,
				this.dateTimeElementTypes.ABBREV_DAY_NAME,
				this.dateTimeElementTypes.DAY_OF_YEAR,
				this.dateTimeElementTypes.DAY_OF_MONTH,
				this.dateTimeElementTypes.SHORT_DATE,
				this.dateTimeElementTypes.LONG_DATE,
				this.dateTimeElementTypes.DAY_OF_WEEK,
				this.dateTimeElementTypes.FULL_ERA,
				this.dateTimeElementTypes.ABBREV_ERA,
				this.dateTimeElementTypes.FRACTIONAL_SECONDS,
				this.dateTimeElementTypes.HOUR_OF_DAY_24,
				this.dateTimeElementTypes.HOUR_OF_DAY_12,
				this.dateTimeElementTypes.ISO_WEEK_OF_YEAR,
				this.dateTimeElementTypes.ISO_YEAR,
				this.dateTimeElementTypes.JULIAN_DAY,
				this.dateTimeElementTypes.MINUTE,
				this.dateTimeElementTypes.MONTH,
				this.dateTimeElementTypes.LONG_MONTH_NAME,
				this.dateTimeElementTypes.SHORT_MONTH_NAME,
				this.dateTimeElementTypes.QUARTER_OF_YEAR,
				this.dateTimeElementTypes.ROMAN_NUMERAL_MONTH,
				this.dateTimeElementTypes.LONG_ROUNDED_YEAR,
				this.dateTimeElementTypes.SHORT_ROUNDED_YEAR,
				this.dateTimeElementTypes.SECONDS_PAST_MIDNIGHT,
				this.dateTimeElementTypes.SECONDS,
				this.dateTimeElementTypes.SHORT_TIME,
				this.dateTimeElementTypes.TZ_DAYLIGHT_SAVING,
				this.dateTimeElementTypes.TZ_HOUR,
				this.dateTimeElementTypes.TZ_MINUTE,
				this.dateTimeElementTypes.TZ_REGION,
				this.dateTimeElementTypes.WEEK_OF_YEAR,
				this.dateTimeElementTypes.WEEK_OF_MONTH,
				this.dateTimeElementTypes.LOCAL_RADIX,
				this.dateTimeElementTypes.FOUR_DIGIT_YEAR,
				this.dateTimeElementTypes.SPELLED_OUT_YEAR,
				this.dateTimeElementTypes.LAST_DIGIT_OF_YEAR,
				this.dateTimeElementTypes.TEXT,
				this.dateTimeElementTypes.PUNCTUATION,
				this.dateTimeElementTypes.WHITESPACE,
				this.dateTimeElementTypes.UNPAD_MOD,
				this.dateTimeElementTypes.STRICT_MOD,
				this.dateTimeElementTypes.SINGLE_QUOTE
			];

			this.numericalMonthTypes = [
				this.dateTimeElementTypes.MONTH
			];

			this.textualMonthTypes = [
				this.dateTimeElementTypes.SHORT_MONTH_NAME,
				this.dateTimeElementTypes.LONG_MONTH_NAME
			];

			this.yearTypes = [
				this.dateTimeElementTypes.ISO_YEAR,
				this.dateTimeElementTypes.LAST_DIGIT_OF_YEAR,
				this.dateTimeElementTypes.FOUR_DIGIT_YEAR
			];

			this.separatorTypes = [
				this.dateTimeElementTypes.PUNCTUATION,
				this.dateTimeElementTypes.WHITESPACE,
				this.dateTimeElementTypes.TEXT
			];

			this.parseDateTimeFormat = function parseDateTimeFormat(formatSpecifier) {
				if (formatSpecifier === undefined) {
					formatSpecifier = this.settingsContainer.dateformat;
				}

				var elements = [];
				var isUnpadded = false;
				var isStrict = false;

				var index = 0;
				var specifierLength = formatSpecifier.length;

				while (index < specifierLength) {
					var remainder = formatSpecifier.substring(index, specifierLength);
					var matchResult = null;

					if (matchResult = this.matchDateTimeElement(this.dateTimeElementTypes.UNPAD_MOD, remainder)) {
						isUnpadded = !isUnpadded;
					} else if (matchResult = this.matchDateTimeElement(this.dateTimeElementTypes.STRICT_MOD, remainder)) {
						isStrict = !isStrict;
					} else {
						for (var i = 0; i < this.matchOrder.length; i++) {
							var dateTimeElementType = this.matchOrder[i];
							matchResult = this.matchDateTimeElement(dateTimeElementType, remainder);
							if (matchResult !== null) {
								elements.push(new DateTimeElement(dateTimeElementType, matchResult, isUnpadded, isStrict));
								break;
							}
						}
					}
					if (matchResult === null) {
						throw "Failed to parse format specifier '"+ formatSpecifier + "': Unrecognized element at position " + index;
					}
					index += matchResult.length;
				}

				return elements;
			};

			this.matchDateTimeElement = function matchDateTimeElement(dateTimeElementType, inputString) {
				var matchResult = dateTimeElementType.matchRegexp.exec(inputString);

				if (matchResult === null || matchResult.index !== 0) return null;

				return matchResult[0];
			};

			this.formatDateTime = function formatDateTime(date, formatSpecifier) {
				var elements = this.parseDateTimeFormat(formatSpecifier);

				// check if there is era among elements, if yes we have to reset the year getter to work with Japanese calendar
				var containsEra = elements.some(function (element) {
					return (
						element.elementType === that.dateTimeElementTypes.FULL_ERA ||
						element.elementType === that.dateTimeElementTypes.ABBREV_ERA
					);
				});

				if (containsEra) {
					this.getFullYear = this.getJapaneseImperialYear
				}

				return this.formatDateTimeFromElements(elements, date);
			};

			this.formatDateTimeFromElements = function formatDateTimeFromElements(elements, dateObject) {
				return elements.map(function (element) {
					var formatterFunction = element.formatterFunction;
					if (formatterFunction === undefined) {
						throw "No formatting function associated with element type " + element.elementType.toString();
					}
					return formatterFunction(element, dateObject);
				}).join('');
			};

			this.formatMMYYDateString = function formatMMYYDateString(dateObject, dateFormat) {
				var elements = this.extractMMYYElements(this.parseDateTimeFormat(dateFormat));
				return this.formatDateTimeFromElements(elements, dateObject);
			};

			this.extractMMYYElements = function extractMMYYElements(dateFormatElements) {

				var elementsLength = dateFormatElements.length;
				var index = 0;
				var monthElement = null,
					yearElement = null,
					separator = null;

				// this complex logic is needed to preserve the rules from the original code
				// namely long months are replaced by short month names and some separators (punctuation, whitespace) are replaced
				// by some long forgotten rules
				while (index < elementsLength && (monthElement === null || yearElement === null || separator === null)) {
					var currentElement = dateFormatElements[index];
					var currentType = currentElement.elementType;
					var currentValue = currentElement.value;
					var currentIsUnpadded = currentElement.isUnpadded;
					var currentIsStrict = currentElement.isStrict;

					var nextElementType = index + 1 !== elementsLength ? dateFormatElements[index + 1].elementType : undefined;

					if (monthElement === null && this.numericalMonthTypes.indexOf(currentType) !== -1) {
						monthElement = currentElement;
					} else if (monthElement === null && this.textualMonthTypes.indexOf(currentType) !== -1) {
						monthElement = new DateTimeElement(
							this.dateTimeElementTypes.SHORT_MONTH_NAME, 'Mon', currentIsUnpadded, currentIsStrict);
					} else if (yearElement === null && this.yearTypes.indexOf(currentType) !== -1) {
						yearElement = currentElement;
					} else if (separator === null && this.separatorTypes.indexOf(currentType) !== -1) {
						if (currentValue === '-' || (currentValue === '.' && nextElementType !== this.dateTimeElementTypes.WHITESPACE)) {
							separator = currentElement;
						} else {
							separator = new DateTimeElement(
								this.dateTimeElementTypes.PUNCTUATION, '/', currentIsUnpadded, currentIsStrict);
						}
					}
					index++;
				}

				return [monthElement, separator, yearElement].filter(function (value) { return value !== null });
			};

			// strip the incoming datetime format of elements that may trip up the parsing functions define here
			this.preprocessDateTimeFormat = function preprocessDateTimeFormat(inputFormat) {
				return inputFormat.replace(/f[mx]|"/ig, "");
			}
		}

		/* assign dateutil package */
		return Object.freeze({
			addMonths: addMonths,
			addDays: addDays,
			hhmmToTimeString: hhmmToTimeString,
			regexStringToTime: regexStringToTime,
			stringToTime: stringToTime,
			splitDateAndTime: splitDateAndTime,
			stringToDate: stringToDate,
			stringToMMYYDate: stringToMMYYDate,
			getTimeWithSecondsString: getTimeWithSecondsString,
			getTimeString: getTimeString,
			getDateString: getDateString,
			getMMYYString: getMMYYString,
			getDatetimeString: getDatetimeString,
			getDatetimetzString: getDatetimetzString,
			get_julian_date: get_julian_date,
			isDateTooOld: isDateTooOld,
			getOldestDateString: getOldestDateString,
			round_hhmm: round_hhmm,
			round_hhmm2: round_hhmm2
		});
	}
);

/**
 * @private
 */
define('N/restricted/dateTimeZoneApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/dateTimeZone
 * @NApiVersion 2.x
 *
 */
define('N/dateTimeZone',['N/restricted/dateTimeZoneApi', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error'],
   function(dateTimeZoneApi, invoker, utilityFunctions, error)
   {
   	    function isClient() { return typeof document !== 'undefined'; }

        var TIME_ZONES = Object.freeze({
                                           ETC_GMT_PLUS_12: 'Etc/GMT+12',
                                           PACIFIC_SAMOA: 'Pacific/Samoa',
                                           PACIFIC_HONOLULU: 'Pacific/Honolulu',
                                           AMERICA_ANCHORAGE: 'America/Anchorage',
                                           AMERICA_LOS_ANGELES: 'America/Los_Angeles',
                                           AMERICA_TIJUANA: 'America/Tijuana',
                                           AMERICA_DENVER: 'America/Denver',
                                           AMERICA_PHOENIX: 'America/Phoenix',
                                           AMERICA_CHIHUAHUA: 'America/Chihuahua',
                                           AMERICA_CHICAGO: 'America/Chicago',
                                           AMERICA_REGINA: 'America/Regina',
                                           AMERICA_GUATEMALA: 'America/Guatemala',
                                           AMERICA_MEXICO_CITY: 'America/Mexico_City',
                                           AMERICA_NEW_YORK: 'America/New_York',
                                           US_EAST_INDIANA: 'US/East-Indiana',
                                           AMERICA_BOGOTA: 'America/Bogota',
                                           AMERICA_CARACAS: 'America/Caracas',
                                           AMERICA_HALIFAX: 'America/Halifax',
                                           AMERICA_LA_PAZ: 'America/La_Paz',
                                           AMERICA_MANAUS: 'America/Manaus',
                                           AMERICA_SANTIAGO: 'America/Santiago',
                                           AMERICA_ST_JOHNS: 'America/St_Johns',
                                           AMERICA_SAO_PAULO: 'America/Sao_Paulo',
                                           AMERICA_BUENOS_AIRES: 'America/Buenos_Aires',
                                           ETC_GMT_PLUS_3: 'Etc/GMT+3',
                                           AMERICA_GODTHAB: 'America/Godthab',
                                           AMERICA_MONTEVIDEO: 'America/Montevideo',
                                           AMERICA_NORONHA: 'America/Noronha',
                                           ETC_GMT_PLUS_1: 'Etc/GMT+1',
                                           ATLANTIC_AZORES: 'Atlantic/Azores',
                                           EUROPE_LONDON: 'Europe/London',
                                           GMT: 'GMT',
                                           ATLANTIC_REYKJAVIK: 'Atlantic/Reykjavik',
                                           EUROPE_WARSAW: 'Europe/Warsaw',
                                           EUROPE_PARIS: 'Europe/Paris',
                                           ETC_GMT_MINUS_1: 'Etc/GMT-1',
                                           EUROPE_AMSTERDAM: 'Europe/Amsterdam',
                                           EUROPE_BUDAPEST: 'Europe/Budapest',
                                           AFRICA_CAIRO: 'Africa/Cairo',
                                           EUROPE_ISTANBUL: 'Europe/Istanbul',
                                           ASIA_JERUSALEM: 'Asia/Jerusalem',
                                           ASIA_AMMAN: 'Asia/Amman',
                                           ASIA_BEIRUT: 'Asia/Beirut',
                                           AFRICA_JOHANNESBURG: 'Africa/Johannesburg',
                                           EUROPE_KIEV: 'Europe/Kiev',
                                           EUROPE_MINSK: 'Europe/Minsk',
                                           AFRICA_WINDHOEK: 'Africa/Windhoek',
                                           ASIA_RIYADH: 'Asia/Riyadh',
                                           EUROPE_MOSCOW: 'Europe/Moscow',
                                           ASIA_BAGHDAD: 'Asia/Baghdad',
                                           AFRICA_NAIROBI: 'Africa/Nairobi',
                                           ASIA_TEHRAN: 'Asia/Tehran',
                                           ASIA_MUSCAT: 'Asia/Muscat',
                                           ASIA_BAKU: 'Asia/Baku',
                                           ASIA_YEREVAN: 'Asia/Yerevan',
                                           ETC_GMT_MINUS_3: 'Etc/GMT-3',
                                           ASIA_KABUL: 'Asia/Kabul',
                                           ASIA_KARACHI: 'Asia/Karachi',
                                           ASIA_YEKATERINBURG: 'Asia/Yekaterinburg',
                                           ASIA_TASHKENT: 'Asia/Tashkent',
                                           ASIA_CALCUTTA: 'Asia/Calcutta',
                                           ASIA_KATMANDU: 'Asia/Katmandu',
                                           ASIA_ALMATY: 'Asia/Almaty',
                                           ASIA_DHAKA: 'Asia/Dhaka',
                                           ASIA_RANGOON: 'Asia/Rangoon',
                                           ASIA_BANGKOK: 'Asia/Bangkok',
                                           ASIA_KRASNOYARSK: 'Asia/Krasnoyarsk',
                                           ASIA_HONG_KONG: 'Asia/Hong_Kong',
                                           ASIA_KUALA_LUMPUR: 'Asia/Kuala_Lumpur',
                                           ASIA_TAIPEI: 'Asia/Taipei',
                                           AUSTRALIA_PERTH: 'Australia/Perth',
                                           ASIA_IRKUTSK: 'Asia/Irkutsk',
                                           ASIA_MANILA: 'Asia/Manila',
                                           ASIA_SEOUL: 'Asia/Seoul',
                                           ASIA_TOKYO: 'Asia/Tokyo',
                                           ASIA_YAKUTSK: 'Asia/Yakutsk',
                                           AUSTRALIA_DARWIN: 'Australia/Darwin',
                                           AUSTRALIA_ADELAIDE: 'Australia/Adelaide',
                                           AUSTRALIA_SYDNEY: 'Australia/Sydney',
                                           AUSTRALIA_BRISBANE: 'Australia/Brisbane',
                                           AUSTRALIA_HOBART: 'Australia/Hobart',
                                           PACIFIC_GUAM: 'Pacific/Guam',
                                           ASIA_VLADIVOSTOK: 'Asia/Vladivostok',
                                           PACIFIC_GUADALCANAL: 'Pacific/Guadalcanal',
                                           PACIFIC_KWAJALEIN: 'Pacific/Kwajalein',
                                           PACIFIC_AUCKLAND: 'Pacific/Auckland',
                                           PACIFIC_TONGATAPU: 'Pacific/Tongatapu'
                                       });

        function checkValidTimezone(timezone)
        {
	        var valid = (timezone == null || util.isNumber(timezone));
	        if (!valid && util.isString(timezone))
	        {
		        Object.getOwnPropertyNames(TIME_ZONES).forEach(function (key) {
			        valid |= timezone === TIME_ZONES[key];
		        });
		        if (!valid) utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNEXPECTED_VALUE_1_FOR_2, timezone, 'format.Timezone');
	        }

	        return valid;
        }

        function getTimeZone(timezone)
        {
            if (timezone === null || timezone === undefined)
            {
                return null;
            }

            return isNaN(timezone) ? timezone : parseInt(timezone, 10);
        }

        function parse(strict, value, timezone)
        {
        	if (strict) {
		        utilityFunctions.checkArgTypes([
			        utilityFunctions.checkArgObject(value, 'value', util.isString),
			        utilityFunctions.checkArgObject(timezone, 'timezone', checkValidTimezone)
		        ]);
	        }
            timezone = getTimeZone(timezone);
            try {
	            var timeObject = invoker(dateTimeZoneApi, 'parseWithTimeZone', [value, timezone]);
	            var date = new Date(timeObject.timeSinceEpochInMS);
	            if (timeObject.isDST === false && isDST(date) === true)
	            {
		            date.setTime(date.getTime() + getDSTOffsetInMS(date))
	            }
	            else if (timeObject.isDST === true && isDST(date) === false)
	            {
		            date.setTime(date.getTime() - getDSTOffsetInMS(date))
	            }
	            return date;
            }
            catch (e)
            {
            	if (strict)
            		throw (e);
	            return value;
            }
        }

        function format(strict, value, timezone)
        {

            if (strict)
            {
	            utilityFunctions.checkArgTypes([
		            utilityFunctions.checkArgObject(value, 'value', util.isDate),
		            utilityFunctions.checkArgObject(timezone, 'timezone', checkValidTimezone)
	            ]);
            }
	        if (!util.isDate(value))
		        return value;

            timezone = getTimeZone(timezone);
            try {
	            return invoker(dateTimeZoneApi, 'formatWithTimeZone', [value.getTime(), timezone, isDST(value)]);
            }
            catch (e) {
	            if (strict)
	            	throw (e);
	            return value;
            }
        }

	    function isDST(theDate) {
        	// disable the DST check on client since the new browsers with ECMAScript 6 support do not have the issue
       	    return isClient() ? null : getDSTOffsetInMS(theDate) !== 0;
        }

	   function getDSTOffsetInMS (theDate) {
		   var jan = new Date(theDate.getFullYear(), 0, 1);
		   var jul = new Date(theDate.getFullYear(), 6, 1);
		   return (theDate.getTimezoneOffset() - Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset())) * 60000;
	   }


	   return Object.freeze({
			parse: parse.bind(this, false),
			format: format.bind(this, false),
			parseStrict: parse.bind(this, true),
            formatStrict: format.bind(this, true),

            /**
             * @enum
             */
            Timezone: TIME_ZONES
        });
    });

/**
 * SuiteScript module
 *
 * @private
 * @module N/fieldTypeConstants
 * @NApiVersion 2.x
 */
define('N/fieldTypeConstants',[],
       function ()
       {
           var FIELD_TYPES = Object.freeze({
                                               DATE: "date",
                                               TIME: "time",
                                               TIMETRACK: "timetrack",
                                               TIMEOFDAY: "timeofday",
                                               DATETIME: "datetime",
                                               DATETIMETZ: "datetimetz",
                                               INTEGER: "integer",
                                               POSINTEGER: "posinteger",
                                               PERCENT: "percent",
                                               RATE: "rate",
                                               RATEHIGHPRECISION: "ratehighprecision",
											   DYNAMICPRECISION:"dynamicprecision",
	                                           FLOAT: "float",
                                               POSFLOAT: "posfloat",
                                               NONNEGFLOAT: "nonnegfloat",
                                               POSCURRENCY: "poscurrency",
                                               NONNEGCURRENCY: "nonnegcurrency",
                                               CURRENCY: "currency",
                                               CURRENCY2: "currency2",
                                               EMAIL: "email",
                                               EMAILS: "emails",
                                               URL: "url",
                                               CHECKBOX: "checkbox",
                                               CCNUMBER: "ccnumber",
                                               RADIO: "radio",
                                               PHONE: "phone",
                                               FULLPHONE: "fullphone",
                                               IDENTIFIER: "identifier",
                                               IDENTIFIERANYCASE: "identifieranycase",
                                               FUNCTION: "function",
                                               QUOTEDFUNCTION: "'function'",
                                               MMYYDATE: "mmyydate",
                                               CCEXPDATE: "ccexpdate",
                                               CCVALIDFROM: "ccvalidfrom",
                                               COLOR: "color",
                                               PACKAGE: "package",
                                               FURIGANA: "furigana",
                                               ADDRESS: "address",
                                               TEXT: "text",
                                               TEXTAREA: "textarea",
                                               SELECT: "select",
                                               DOCUMENT: "document"
                                           });

	       /**
	        * Determine if given field type is a numeric type.
	        *
	        * @param {Type} fieldType
	        * @returns {boolean} true if fieldType is numeric
	        */
           function isNumeric(fieldType)
           {
           	   return (fieldType === FIELD_TYPES.INTEGER) || (fieldType === FIELD_TYPES.POSINTEGER)
	               || (fieldType === FIELD_TYPES.FLOAT)   || (fieldType === FIELD_TYPES.POSFLOAT)
	               || (fieldType === FIELD_TYPES.NONNEGFLOAT) || (fieldType === FIELD_TYPES.PERCENT)
	               || (fieldType === FIELD_TYPES.RATE) || (fieldType === FIELD_TYPES.RATEHIGHPRECISION);
           }

	       /**
	        * Determine if given field type is a currency type.
	        *
	        * @param {Type} fieldType
	        * @returns {boolean} true if fieldType is currency
	        */
           function isCurrency(fieldType)
           {
           	   return (fieldType === FIELD_TYPES.POSCURRENCY) || (fieldType === FIELD_TYPES.CURRENCY)
	               || (fieldType === FIELD_TYPES.CURRENCY2) || (fieldType === FIELD_TYPES.NONNEGCURRENCY);
           }

           return Object.freeze({
                                    /**
                                     * @enum
                                     */
                                    Type: FIELD_TYPES,

	                                isNumeric: isNumeric,
	                                isCurrency: isCurrency
                                });
    }
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/formatter
 * @suiteScriptVersion 2.x
 */
define(
	'N/util/formatter',['N/util/currencyUtility', 'N/util/date','N/FieldValidationHelper', 'N/dateTimeZone','N/error', 'N/utilityFunctions', 'N/fieldTypeConstants'],
	function (CurrencyUtil, DateUtil, FieldValidationHelper, dateTimeZone, error, utilityFunctions, fieldTypeConstants){
		/** FORMATTING FUNCTIONS - Used to convert INTO a user's preference format **/

		/**
		 * Takes in a numerical value and returns a string reformatted to match the user's format preference.
		 * (Negative representation, number groupings, decimal representation)
		 *
		 * Adapted/Improved from NLUtil.jsp's NLNumberToString
		 * @param num - a javascript friendly numerical value. Ex: -23456.93
		 * @param addPercentSign - adds a percent sign at the end of the string (or before the negative suffix)
		 * @returns a String version of the numerical value meeting the user's format preference. Ex: (23.456,93)
		 */
		function formatNumber(num, addPercentSign)
		{
			if (isNaN(num) || utilityFunctions.isValEmpty(num))
				return num;
	
			var str = '' + num;
			var parts = str.split(".");
			var integerPart = parts[0];
			var decimalPart = parts.length > 1 ? FieldValidationHelper.decimalseparator + parts[1] : '';
	
			if (FieldValidationHelper.groupseparator !== '')
			{
				var regex = /(\d+)(\d{3})/;
				while (regex.test(integerPart))
				{
					integerPart = integerPart.replace(regex, '$1' + FieldValidationHelper.groupseparator + '$2');
				}
			}
	
			if (num < 0 && FieldValidationHelper.negativeprefix !== '-')
			{
				return FieldValidationHelper.negativeprefix + integerPart.replace('-', '') + decimalPart
							   + (!!addPercentSign ? "%" : "") + FieldValidationHelper.negativesuffix;
			}
			else
			{
				return integerPart + decimalPart + (!!addPercentSign ? "%" : "");
			}
	
		}
	
		/**
		 * Takes in a string representing a phone number and attempts to format it in the set user preference
		 *
		 * Will only perform reformatting if ALL of the following are true:
		 *  - A user preference is set
		 *  - phoneStr consists of only digits, spaces, periods, dashes, and parentheses
		 *  - There are exactly 7 or 10 digits, or 11 digits and phoneStr begins with a 1
		 *  Otherwise it will return back the string, unmodified
		 *
		 * @param phoneStr - a string that contains a phone number
		 * @returns a string reformatted in the user's preference (if possible)
		 */
		function formatPhoneNumber(phoneStr)
		{
			if (utilityFunctions.isValEmpty(phoneStr))
				return phoneStr;
	
			var phoneFormatPref = FieldValidationHelper.phoneformat;
			var returnMe = "" + phoneStr;
			if (phoneFormatPref === null || typeof phoneFormatPref === "undefined" || /[A-Za-z]/.test(returnMe))
				return returnMe;
	
			var valueStripped = phoneStr.replace(/[\s\.\-\(\)]/g, "");
			if (/^[0-9]+$/.test(valueStripped))
			{
				var ETX_CHAR = String.fromCharCode(3);
				var phoneformat = phoneFormatPref.replace(new RegExp( "[360]", "g" ),ETX_CHAR);
				if (valueStripped.length === 7)
					returnMe = phoneformat.replace(phoneformat.substring(0,phoneformat.indexOf('4')),'')
										  .replace('45'+ETX_CHAR,valueStripped.substring(0,3))
										  .replace('789'+ETX_CHAR,valueStripped.substring(3));
				else if (valueStripped.length === 10)
					returnMe = phoneformat.replace('12'+ETX_CHAR,valueStripped.substring(0,3))
										  .replace('45'+ETX_CHAR,valueStripped.substring(3,6))
										  .replace('789'+ETX_CHAR,valueStripped.substring(6));
				else if (valueStripped.length === 11 && valueStripped.substring(0,1) === '1')
					returnMe = '1 ' + phoneformat.replace('12'+ETX_CHAR,valueStripped.substring(1,4))
												 .replace('45'+ETX_CHAR,valueStripped.substring(4,7))
												 .replace('789'+ETX_CHAR,valueStripped.substring(7));
			}
			return returnMe;
		}
	
		// changes a Date object into a String that follows the user's Date Preference
		function formatDate(dateObj)
		{
			if (dateObj instanceof Date || Object.prototype.toString.call(dateObj) === '[object Date]')
			{
				dateObj = new Date(dateObj);
				return DateUtil.getDateString(dateObj);
			}
			else
				return dateObj;
		}
	
		// changes a Date object into a String that follows the user's Time Preference
		function formatTime(timeObj)
		{
			if (timeObj instanceof Date || Object.prototype.toString.call(timeObj) === '[object Date]')
			{
				timeObj = new Date(timeObj);
				return DateUtil.getTimeString(timeObj);
			}
			else
				return timeObj;
		}

        // changes a Date object into a String that follows the user's Date+Time Preference
		function formatDateTimeTz(dateTimeObj)
		{
			if (dateTimeObj instanceof Date || Object.prototype.toString.call(dateTimeObj) === '[object Date]')
				return dateTimeZone.format(dateTimeObj);
			else
				return dateTimeObj;
		}
	
		// changes a Date object into a String that follows the user's Date Preference (but only the MM/YYYY portion)
		function formatMMYYDate(dateObj)
		{
			if (dateObj instanceof Date || Object.prototype.toString.call(dateObj) === '[object Date]')
				return DateUtil.getMMYYString(dateObj);
			else
				return dateObj;
		}
	
		// converts a numerical number (units: hours) into HH:MM format
		function formatToHHMM(numHrs)
		{
			if (isNaN(numHrs) || utilityFunctions.isValEmpty(numHrs))
				return numHrs;
	
			var isNeg = false;
			if (numHrs < 0)
			{
				isNeg = true;
				numHrs *= -1
			}
	
			var hrs = Math.floor((numHrs*60+0.5)/60);
			var mins = Math.floor((numHrs-hrs)*60+0.5);
			var sign = isNeg ? "-" : "";

			return sign + hrs + ":" + (mins < 10 ? "0" : "") + mins;
		}
	
		// formats currency based on precision / field type
		// isCurrency2 should be true for CURRENCY2 types
		function formatCurrency(num, isCurrency2)
		{
			if (utilityFunctions.isValEmpty(num))
				return num;
	
			var formattedCurrency = isCurrency2 ? CurrencyUtil.format_currency2(num)
												: CurrencyUtil.format_currency(num);
	
			return (formattedCurrency === '') ? num : formatNumber(formattedCurrency, false);
		}
	
		// Adds a % if specified, and pads with zeros to the precision defined by currencyprecision (...why?)
		// includePercentSign - Adds % if true, also pads with zeros to 10ths place if true, 100ths if false (... why?)
		function formatRate(rateNum, includePercentSign)
		{
			if (isNaN(rateNum) || utilityFunctions.isValEmpty(rateNum))
				return rateNum;

			var strRateNum = "" + rateNum;
			if (strRateNum.indexOf('%') !== -1)
			{
				rateNum = strRateNum.replace('%', '');
				includePercentSign = true;
			}

			var returnMe = CurrencyUtil.format_rate(rateNum, includePercentSign).replace("%", "");
			return (returnMe === '') ? rateNum : formatNumber(returnMe, includePercentSign);
		}
	
		// Adds a .0 if has no decimal places and will always add a % sign
		function formatPercent(percentNum)
		{
			if (isNaN(percentNum) || utilityFunctions.isValEmpty(percentNum))
				return percentNum;
	
			var returnMe = CurrencyUtil.format_percent(percentNum).replace("%", "");
			return formatNumber(returnMe, true);
		}

		function formatCheckbox(checkboxValue)
		{
			return (typeof checkboxValue === 'boolean' && checkboxValue) || checkboxValue === 'T' ? 'T' : 'F';
		}
	
		function format(value, type, isNum, isCurr)
		{
			var returnMe;
			var isNumeric = isNum || fieldTypeConstants.isNumeric(type);
			var isCurrency = isCurr || fieldTypeConstants.isCurrency(type);
	
			if (utilityFunctions.isValEmpty(value))
				return value;
			if (type === fieldTypeConstants.Type.DATE)
			{
				return formatDate(value);
			}
			else if (type === fieldTypeConstants.Type.TIMEOFDAY)
			{
				return formatTime(value);
			}
            else if ( (type === fieldTypeConstants.Type.DATETIME) || (type === fieldTypeConstants.Type.DATETIMETZ) )
			{
				return formatDateTimeTz(value);
			}
			else if (type === fieldTypeConstants.Type.MMYYDATE)
			{
				return formatMMYYDate(value);
			}
			else if ( (type === fieldTypeConstants.Type.TIME) || (type === fieldTypeConstants.Type.TIMETRACK) )
			{
				return formatToHHMM(value);
			}
			else if ( (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION) )
			{
				return formatRate(value);
			}
			else if (type === fieldTypeConstants.Type.PERCENT)
			{
				return formatPercent(value);
			}
			else if (type === fieldTypeConstants.Type.CHECKBOX)
			{
				return formatCheckbox(value);
			}
			else if (!!isNumeric)
			{
				return formatNumber(value, false);
			}
			else if (!!isCurrency)
			{
				return formatCurrency(value, type === fieldTypeConstants.Type.CURRENCY2 )
			}
			else if ( (type === fieldTypeConstants.Type.PHONE) || (type === fieldTypeConstants.Type.FULLPHONE) )
			{
				return formatPhoneNumber(value);
			}
	
			return value;
		}

		//keep this in sync with groupSeparatorPositionsValid in Formatter.java
		function groupSeparatorPositionsValid(str)
		{
			if(FieldValidationHelper.negativeprefix !== '-' && str.indexOf(FieldValidationHelper.negativeprefix) === 0)
				str = '-' + str.replace(FieldValidationHelper.negativeprefix, '').replace(FieldValidationHelper.negativesuffix, '');
			if (str.length < 3)
				return false;
			var lastDecimal = util.isString(FieldValidationHelper.decimalseparator) ? str.lastIndexOf(FieldValidationHelper.decimalseparator) : -1;
			if (lastDecimal >= 0)
				str = str.substr(0, lastDecimal);
			var parts = str.split(FieldValidationHelper.groupseparator);
			if (parts.length > 1)
			{
				for (var i = 1; i < parts.length; i++)
				{
					if (parts[i].length != 3)
						return false;
				}
			}
			return true;
		}
	
		/** PARSING FUNCTIONS - used to help make values into its appropriate format for validation **/
	
		/**
		 * Takes in a string formatted in the user's format preference and returns the numerical value
		 * (Negative representation, number groupings, decimal representation)
		 *
		 * Adapted/Improved from NLUtil.jsp's NLStringToNumber
		 * @param str - A number in a string in the user's format preference. Ex: "(23.456,93)"
		 * @param autoplace - boolean indicating whether to divide by 100 if no decimal separator is present.
		 * @param ignoreUserPrefs - ignore user's format preference
		 * @returns a Numerical value that Javascript can read (isNaN will return that it is a number). Ex: -23456.93
		 */
		function formatUserPrefStringToJSNumber(str, autoplace, ignoreUserPrefs)
		{
			str = "" + str;
			if(utilityFunctions.isValEmpty(str))
				return "";
			if (!ignoreUserPrefs)
			{
				if(FieldValidationHelper.groupseparator && FieldValidationHelper.groupseparator !== '' && groupSeparatorPositionsValid(str))
					str = str.replace(new RegExp( '\\' + FieldValidationHelper.groupseparator, 'g'), '');
				if(FieldValidationHelper.negativeprefix !== '-' && str.indexOf(FieldValidationHelper.negativeprefix) === 0)
					str = '-' + str.replace(FieldValidationHelper.negativeprefix, '').replace(FieldValidationHelper.negativesuffix, '');
				if(FieldValidationHelper.decimalseparator === ',')
					str = str.replace(FieldValidationHelper.decimalseparator, '.');
			}

			if (isNaN(str))
				return str;
			else if (autoplace && (str.indexOf(".") === -1))
				return parseFloat(str) / 100;
			else
				return parseFloat(str);
		}
	
		/**
		 * Takes in a timeStr (or a number) and converts it into a number in hours
		 *
		 * If in HH:MM format, it will return HH + MM/60
		 * If !isNaN, it will just return the parseFloat of the value
		 * Otherwise it will return null.
		 *
		 * @param timeStr - a time string in HH:MM format, or a number
		 */
		function convertTimeStringToHours(timeStr)
		{
			var isPositive = true;
            var convertedStr = "" + timeStr;
	
			if (convertedStr.slice(0, 1) === "-")
			{
				isPositive = false;
                convertedStr = convertedStr.slice(1);
			}
			var pattern = /([0-9]*)?:([0-9]+)?/;
			var result = pattern.exec(convertedStr);
	
			if (result === null) // not HH:MM format
			{
				if (isNaN(convertedStr)) // not a number
				{
					return timeStr;
				}
				else // a number
				{
					return (isPositive ? 1 : -1) * parseFloat(convertedStr);
				}
			}
			else // is in HH:MM format
			{
				var hours;
				var minutes;
				if (RegExp.$1.length > 0)
				{
					hours = parseInt(RegExp.$1, 10);
				}
				else
				{
					hours = 0;
				}
				if (typeof(RegExp.$2) !== "undefined" && RegExp.$2.length > 0)
				{
					minutes = parseInt(RegExp.$2, 10);
				}

				return (isNaN(hours) || isNaN(minutes)) ? timeStr : (isPositive ? 1 : -1) * (hours + minutes/60);
			}
		}
	
		/**
		 *  Attempts to evaluate a math equation
		 *
		 *  Will ignore a leading equals sign (=)
		 *  and perform addition(+), subtraction(-), multiplication(*), and division(/)\
		 *
		 *  Returns 'equation' back if it is empty, null, undefined, if it's a number already, or an invalid equation
		 *
		 *  @params equation: must only consist of + - * / . ( ) and digits
		 *  @returns the equation evaluated
		 */
		function evaluateMath(equation)
		{
			if (utilityFunctions.isValEmpty(equation) || !isNaN(equation))
				return equation;
	
			var calcMe = equation;
			if(equation.charAt(0) === '=')
				calcMe = equation.substr(1);
	
			if(!!FieldValidationHelper.groupseparator && !!FieldValidationHelper.decimalseparator)
				calcMe = calcMe.replace(new RegExp( '\\' + FieldValidationHelper.groupseparator, 'g'), '')
							   .replace(new RegExp( '\\' + FieldValidationHelper.decimalseparator, 'g'), '.');
	
			if (isNaN(calcMe) && calcMe.match(/[\+\-\*\/0-9\.\(\)\s]+/))
			{
				try
				{
					calcMe = eval.apply(utilityFunctions.getGlobalScope(), [calcMe]);
				}
				catch (e)
				{
					calcMe = equation;
				}
			}
			else
			{
				calcMe = equation;
			}
	
			return calcMe;
		}
	
		/**
		 *  Attempts to convert shorthanded time into time in the user's preference
		 *
		 *  Removes leading and trailing spaces
		 *  The Time portion of timeStr must be in the form of:
		 *	  1-4 digits followed by the first character of the user's AM/PM string
		 *  Will return an empty string if equation is empty, null, or undefined
		 *
		 *  Consult DateUtil.hhmmToTimeString for further details on how it is converted to proper form
		 *
		 *  @params timeStr - a string containing a time or a date and time (separated by a space)
		 *  @returns the string back with the time portion converted to the user's preference
		 */
		function formatShorthandedTime(timeStr)
		{
			timeStr = util.trim(timeStr);
			if (utilityFunctions.isValEmpty(timeStr))
				return "";
			var lastSpaceIdx = timeStr.lastIndexOf(" ");
			if (lastSpaceIdx > 0) // "date time" form
			{
				return timeStr.slice(0, lastSpaceIdx + 1) + DateUtil.hhmmToTimeString(timeStr.slice(lastSpaceIdx + 1))
			}
			else // "time" form
			{
				return DateUtil.hhmmToTimeString(timeStr);
			}
		}
	
		// If the string '://' is not found then pre-pend the default protocol prefix
		function addHTTPIfNecessary(urlString)
		{
			if (urlString.indexOf("://") === -1 && urlString.charAt(0) !== '/')
				urlString = "http://" + urlString;
	
			return urlString;
		}
	
		// Accepts 456?7890 or depending on user format [which is either (123) 456-7890 or 123?456?7890]
		// If matches and only numbers remain, returns a string that only contains digits.
		// Otherwise it will return back the original string.
		// Does nothing if no user preference format is selected
		function stripPhoneSeparators(phoneStr)
		{
			var phoneFormat = FieldValidationHelper.phoneformat;
			if ( typeof phoneFormat === "undefined" )
				return phoneStr;
	
			phoneStr = util.trim(phoneStr);
	
			var formatHasParens = (phoneFormat.indexOf("(") === 0);
			var formatDelimiter = phoneFormat.slice(-5, -4);
			var hasNoAreaCode   = (phoneStr.length === 8);

            if (formatDelimiter === ".")
                formatDelimiter = "\\.";
			var formatRegex = new RegExp("^(" + (formatHasParens ? "\\(" : "") + "(\\d{3})" + (formatHasParens ? "\\)\\ " : formatDelimiter) + ")?"
											  + "(\\d{3})" + formatDelimiter
											  + "(\\d{4})$");
	
			var matchResult = phoneStr.match(formatRegex);
	
			if (matchResult === null)
			{
				return phoneStr;
			}
			else
			{
				return (matchResult[2] ? matchResult[2] : "") + matchResult[3] + matchResult[4];
			}
		}
	
		function parseCCDateStr(ccStr)
		{
			var parts = ccStr.split("/");
			var returnStr = "";
			if (parts.length === 2)
			{
				if (isNaN(parts[0]) || isNaN(parts[1]))
					return ccStr;
				var monthPart = parseInt(parts[0], 10)
				var yearPart  = parseInt(parts[1], 10)
				if (isNaN(monthPart) || isNaN(yearPart) || monthPart <= 0 || monthPart > 12 || yearPart < 0)
					return ccStr;
	
				if (monthPart < 10)
					returnStr = "0" + monthPart + "/";
				else
					returnStr = monthPart + "/";
	
				if (yearPart < 50)
					returnStr += 2000 + yearPart;
				else if (yearPart < 100)
					returnStr += 1900 + yearPart;
				else
					returnStr += yearPart;
	
				return returnStr;
			}
			else
				return ccStr;
		}

        function convertToUserPreferenceTZDate(dateTimeObj)
        {
            return dateTimeZone.parse(dateTimeObj);
        }
	
		function parse(value, type, isNum, isCurr, validationType, autoplace, skipPercentage, ignoreUserPrefs)
		{
			var returnMe;
			var isNumeric = isNum || fieldTypeConstants.isNumeric(type);
			var isCurrency = isCurr || fieldTypeConstants.isCurrency(type);
	
			if (utilityFunctions.isValEmpty(value))
				return value;
	
			if ( (type !== fieldTypeConstants.Type.TEXT) && (type !== fieldTypeConstants.Type.IDENTIFIER) &&
				 (type !== fieldTypeConstants.Type.IDENTIFIERANYCASE) && (type !== fieldTypeConstants.Type.ADDRESS) &&
				 (type !== fieldTypeConstants.Type.TEXTAREA) &&
				 (/[\uff01-\uff5e]/.exec(value) !== null) )
				value = value.replace(/[\uff01-\uff5e]/g, function(ch) { return String.fromCharCode(ch.charCodeAt(0) - 0xfee0); });
	
			if (type === fieldTypeConstants.Type.DATE)
			{
				returnMe = DateUtil.regexStringToTime(value, null, false, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
			else if (type === fieldTypeConstants.Type.TIMEOFDAY)
			{
				returnMe = DateUtil.regexStringToTime(null, formatShorthandedTime(value), false, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
            else if ( (type === fieldTypeConstants.Type.DATETIME) || (type === fieldTypeConstants.Type.DATETIMETZ) )
            {
                returnMe = convertToUserPreferenceTZDate(value);
                return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
            }
			else if (type === fieldTypeConstants.Type.MMYYDATE)
			{
				returnMe = DateUtil.stringToMMYYDate(value, FieldValidationHelper.dateformat, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
			else if ( (type === fieldTypeConstants.Type.TIME) || (type === fieldTypeConstants.Type.TIMETRACK) )
			{
				return convertTimeStringToHours(value);
			}
			else if (!!isNumeric || !!isCurrency)
			{
				if (typeof value === 'number')
					return value;
                var strValue = "" + value;
				var isPercentage = false;
				if ( (type === fieldTypeConstants.Type.PERCENT) || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION) )
				{
					isPercentage = strValue.indexOf('%') !== -1;
					if (isPercentage)
                        strValue = strValue.replace('%', '');
				}
                var evalValue = strValue;
                var evalPerformed = false;
                if (!!isCurrency && ( strValue.substr(1).search(/[\+\-\*\/]/g) !== -1))
                {
                    evalValue = evaluateMath(strValue);
                    // autoplace does not happen if an equation has been evaluated (value (equation) is not the same evalValue)
                    if (evalValue !== strValue)
                        evalPerformed = true;
                }
                var performAutoPlace = (autoplace && ( !!isCurrency || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION)))
                returnMe = evalPerformed ? evalValue : formatUserPrefStringToJSNumber(evalValue, performAutoPlace, ignoreUserPrefs);
                if (isNaN(returnMe))
                	returnMe = value;
                if (((type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION)) && isPercentage && !skipPercentage)
                	returnMe = formatRate(returnMe, true);
				return returnMe;
			}
			else if ( (type === fieldTypeConstants.Type.URL) )
			{
				return addHTTPIfNecessary(value);
			}
			else if ( (type === fieldTypeConstants.Type.PHONE) || (type === fieldTypeConstants.Type.FULLPHONE) )
			{
				return stripPhoneSeparators(value);
			}
			else if (type === fieldTypeConstants.Type.CHECKBOX)
			{
				return value === 'T' || value === true;
			}
			else if (type === fieldTypeConstants.Type.IDENTIFIER)
			{
				return value.toLowerCase();
			}
			else if (type === fieldTypeConstants.Type.CCNUMBER )
			{
				return ("" + value).replace(/ /g, "").replace(/\-/g, "");
			}
			else if ( (type === fieldTypeConstants.Type.CCEXPDATE) || (type === fieldTypeConstants.Type.CCVALIDFROM) )
			{
				return parseCCDateStr(value);
			}
			else if (type === fieldTypeConstants.Type.COLOR)
			{
				return ( ((value.charAt(0) !== "#") && (value.length === 6)) ? "#" : "") + value;
			}
			else if ((type === fieldTypeConstants.Type.FUNCTION) ||
                     ( (validationType !== null) && (typeof validationType !== "undefined") &&
					  (validationType.toLowerCase() === fieldTypeConstants.Type.QUOTEDFUNCTION) ) )
			{
				if (value.indexOf('(') > 0)
					return value.substr(0,value.indexOf('('));
			}
	
			return value;
		}
	
		function formatValueAsString(value, fieldType)
		{
			if(util.isArray(value))
				return value.join(String.fromCharCode(5));
			/* if field does not exist or field is currency/numeric, return value */
			else if (value == null)
				return value;
			else if(!fieldType)
				return String(value);
			else
				return String(format(value, fieldType))
		}

		var comparators = (function Comparators() {

			function isEmpty(val) { return val == null || !String(val).trim(); }

			function compareIsNaN(val) { return util.isNumber(val) && isNaN(val); }

			function comparator(x, y) { return x === y ? 0 : (x > y) ? 1 : -1; }

			function textComparator(val1, val2) {
				val1 = isEmpty(val1) ? "" : (String(val1)).toUpperCase();
				val2 = isEmpty(val2) ? "" : (String(val2)).toUpperCase();
				return comparator(val1, val2);
			}

			function emailComaparator(val1, val2) {
				// split name and domain
				val1 = isEmpty(val1) ? [] : (String(val1)).split('@');
				val2 = isEmpty(val2) ? [] : (String(val2)).split('@');
				// compare by name first
				var cmpName = textComparator(val1[0], val2[0]);
				// compare by domain when name is identical
				return (cmpName !== 0) ? cmpName : textComparator(val1[1], val2[1]);
			}

			function numberComparator(val1, val2) {
				val1 = isEmpty(val1) ? -Infinity :
					util.isString(val1) ? Number(parse(val1, null, true)) :
						Number(val1);
				val2 = isEmpty(val2) ? -Infinity :
					util.isString(val2) ? Number(parse(val2, null, true)) :
						Number(val2);
				val1 = compareIsNaN(val1) ? -Infinity : val1;
				val2 = compareIsNaN(val2) ? -Infinity : val2;
				return comparator(val1, val2);
			}

			function dateComparator(val1, val2) {
				val1 = isEmpty(val1) ? -Infinity : (new Date(val1)).getTime();
				val2 = isEmpty(val2) ? -Infinity : (new Date(val2)).getTime();
				val1 = compareIsNaN(val1) ? -Infinity : val1;
				val2 = compareIsNaN(val2) ? -Infinity : val2;
				return comparator(val1, val2);
			}

			function fieldTypeBasedComparator(val1, val2, fieldType) {
				val1 = parse(val1, fieldType);
				val2 = parse(val2, fieldType);
				if ((isEmpty(val1) || util.isNumber(val1)) && (isEmpty(val2) || util.isNumber(val2)))
				{
					return numberComparator(val1, val2);
				}
				return textComparator(val1, val2);
			}

			return {
				textComparator: textComparator,
				emailComaparator: emailComaparator,
				numberComparator: numberComparator,
				dateComparator: dateComparator,
				fieldTypeBasedComparator: fieldTypeBasedComparator
			};
		})();

		/* assign util.formatter package */
		return Object.freeze({
			 format: format,
			 evaluateMath: evaluateMath,
			 formatValueAsString: formatValueAsString,
			 parse: parse,
			 convertTimeStringToHours: convertTimeStringToHours,
			 comparators : comparators
		});
	}
);

/**
 * @private
 */
define('N/restricted/formatApi',['N/restricted/reflet'],
	function (reflet)
	{
		return util.extend({bridge: 'formatApi'}, reflet);
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/restricted/creationFunctionWrapper
 * @NApiVersion 2.x
 *
 */
define('N/creationFunctionWrapper',[], function () {
    function ReflectiveSetterProxy(target) {
        return (function init(target) {
            if (!target || target === this)
                return target;
            var proxy = null;
            if (util.isFunction(target) && target.prototype && target.prototype.hasOwnProperty) {
                proxy = function () {
                    var targetFunction = target;
                    var retMe = targetFunction.apply(this, arguments);
                    var options = arguments[0];
                    for (var p in options)
                    {
                        if (options.hasOwnProperty(p))
                        {
                            var value = options[p];
                            if (retMe.hasOwnProperty(p) && !util.isFunction(retMe[p]) && retMe[p] != value)
                            {
                                try
                                {
                                    retMe[p] = value;
                                }
                                catch (err)
                                {
                                    if (err.name !== 'READ_ONLY_PROPERTY')
                                    {
                                        throw err;
                                    }
                                }
                            }
                        }
                    }
                    return retMe;
                };
                proxy.toString = function () {
                    return '';
                };
            }
            else if (Object.prototype.toString.call(target) === '[object Object]' && target.hasOwnProperty) {
                proxy = {};
                proxyObjChildren(target, proxy);
            }
            else
                proxy = target;

            function proxyObjChildren(target, proxy) {
                for (var p in target)
                    if (target.hasOwnProperty(p))
                        proxy[p] = init(target[p]);
            }
            return proxy;
        })(target);
    };
    function wrapFunction (f) {
        return new ReflectiveSetterProxy(f);
    }
    return Object.freeze({
        wrap : wrapFunction
    });
});

/**
 * SuiteScript formatI18nCommon module
 *
 * @module N/formatI18nCommon
 * @NApiVersion 2.x
 *
 */
define('N/formatI18nCommon',['N/restricted/invoker', 'N/utilityFunctions', 'N/restricted/formatApi', 'N/error', 'N/creationFunctionWrapper'],
	function (invoker, utilityFunctions, formatApi, error)
	{
		//enums
		var NEGATIVE_NUMBER_FORMATS = Object.freeze({ // constant names must be exactly the same as in Java code (INumberFormatParameters)
			BRACKETS: 'BRACKETS',
			MINUS: 'MINUS'
		});

		var ValidCurrencies = null;  // dynamically generated enum (values are found out in Java code, file FormatApi.java)

		function doSpellOut(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'format.i18n.spellOut');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var number, locale;

			if (options != null && options.hasOwnProperty("number"))
			{
				number = options.number;
			}

			utilityFunctions.checkArgs([number], ['number'], 'spellOut');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(number, 'number', util.isNumber)]);

			locale = options.locale;

			if (utilityFunctions.isEmpty(locale))
			{
				options.locale = null;
			}
			else
			{
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(locale, 'locale', util.isString)]);
			}

			return invoker(formatApi, 'spellOut', [number, locale], utilityFunctions.isPromiseCallback(this) ? this : null);
		}

		/**
		 * Return a new instance of NumberFormatter.
		 *
		 */
		function NumberFormatter(groupSeparator, decimalSeparator, precision, negativeNumberFormat)
		{
			Object.defineProperty(this, 'groupSeparator', {
				get: function () {
					return groupSeparator;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'groupSeparator');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			Object.defineProperty(this, 'decimalSeparator', {
				get: function () {
					return decimalSeparator;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'decimalSeparator');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			Object.defineProperty(this, 'precision', {
				get: function () {
					return precision;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'precision');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			Object.defineProperty(this, 'negativeNumberFormat', {
				get: function () {
					return negativeNumberFormat;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'negativeNumberFormat');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.format = function format(options)
			{
				utilityFunctions.checkArgs([options], ['options object'], 'NumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.number], ['number'], 'NumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', util.isNumber)]);

				var number = options.number;
				var signPrefix = "",
				    signPostfix = "";
				if (number < 0) {
					signPrefix = negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.MINUS ? "-" : "(";
					signPostfix = negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.MINUS ? "" : ")";
				}

				var wholePart = parseInt(number = Math.abs(+number || 0).toFixed(precision)) + "",
					cntCharsToFirstSep = (cntCharsToFirstSep = wholePart.length) > 3 ? cntCharsToFirstSep % 3 : 0;

				var wholePartProcessed = (cntCharsToFirstSep ? wholePart.substr(0, cntCharsToFirstSep) + groupSeparator : "")
					                     + wholePart.substr(cntCharsToFirstSep).replace(/(\d{3})(?=\d)/g, "$1" + groupSeparator);

				var fractionalPartProcessed = precision > 0 ? decimalSeparator + Math.abs(number - wholePart).toFixed(precision).slice(2) : "";

				return signPrefix + wholePartProcessed + fractionalPartProcessed + signPostfix;
			}
		}

		/**
		 * Return a new instance of CurrencyFormatter.
		 *
		 *   input arguments :     string    string  string  Boolean         Object
		 */
		function CurrencyFormatter(currency, locale, symbol, isPrefixSymbol, numberFormatter) {
			Object.defineProperty(this, 'currency', {
				get: function () {
					return currency;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'currency');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			Object.defineProperty(this, 'locale', {
				get: function () {
					return locale;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'locale');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			Object.defineProperty(this, 'symbol', {
				get: function () {
					return symbol;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'symbol');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			Object.defineProperty(this, 'numberFormatter', {
				get: function () {
					return numberFormatter;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'numberFormatter');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			this.format = function format(options)
			{
				utilityFunctions.checkArgs([options], ['options object'], 'CurrencyFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.number], ['number'], 'CurrencyFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', util.isNumber)]);

				return isPrefixSymbol.valueOf() ? symbol + numberFormatter.format(options) : numberFormatter.format(options) + symbol;
			}
		}

		/**
         * Returns CurrencyFormatter object, which can format numbers to currency strings
         * @param (Object) options
         * @param (string) options.currency (enum) Code of currency used by formatter
         * @governance 10
         * @throws (error.SuiteScriptError) MISSING_REQD_ARGUMENT if currency parameter is missing
		 * @throws (error.SuiteScriptError) SSS_INVALID_CURRENCY_ID if invalid currency is used
		*/
		function doGetCurrencyFormatter(options)
		{
			utilityFunctions.checkArgs([options], ['options object'], 'getCurrencyFormatter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.currency], ['currency'], 'getCurrencyFormatter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.currency, 'currency', util.isString)]);

			var currency = options.currency;
			// check if currency is in the list of valid currencies (dynamic enum)
			var validCurrencies = null;
			try {
				validCurrencies = getValidCurrencies(); // check if at least one valid currency exists
				if (validCurrencies === undefined || validCurrencies === null || !(currency in validCurrencies)) {
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_CURRENCY_ID, 'getCurrencyFormatter', currency);
				}
			} catch (e) {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_CURRENCY_ID, 'getCurrencyFormatter', currency);
			}

			var cfParams = invoker(formatApi, 'getCurrencyFormatParametersForSSClient', [currency], utilityFunctions.isPromiseCallback(this) ? this : undefined);
			if (!utilityFunctions.isPromiseCallback(this))
				return ppCurrencyFormatter({result: cfParams});
		}

		function ppCurrencyFormatter(options)
		{
			var cfParams = options.result; // all fields of cfParams are string type. so isPrefix must be re-typed to Boolean

			var currency = cfParams.currency;
			var locale = cfParams.locale;
			var displaySymbol = cfParams.symbol;
			var isPrefix = new Boolean(cfParams.isPrefixSymbol == 'true');
			var numberFormatter = new NumberFormatter(cfParams.nfGroupSeparator, cfParams.nfDecimalSeparator,
				                                      cfParams.nfPrecision, cfParams.nfNegativeNumberFormat);

			return new CurrencyFormatter(currency, locale, displaySymbol, isPrefix, numberFormatter);
		}

		/**
		 * Returns NumberFormatter object, which can format numbers tu number strings
		 * @param (Object) options
		 * @param (string) options.groupSeparator
		 * @param (string) options.decimalSeparator
		 * @param (number) options.precision
		 * @param (string) options.negativeNumberFormat (enum)
		 * @governance 10
		*/
		function doGetNumberFormatter(options)
		{
			// *** new implementation ***
			var groupSeparator = null;
			var decimalSeparator = null;
			var precision = null;
			var negativeNF = null;

			// Arguments which are given -> copy to local variables
			if (options !== undefined && options !== null) { // if at least one argument is present
				utilityFunctions.checkArgs([options], ['options object'], 'getNumberFormatter');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

				if (options.groupSeparator !== undefined && options.groupSeparator !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.groupSeparator, 'groupSeparator', util.isString)]);
					groupSeparator = options.groupSeparator;
				}

				if (options.decimalSeparator !== undefined && options.decimalSeparator !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.decimalSeparator, 'decimalSeparator', util.isString)]);
					decimalSeparator = options.decimalSeparator;
				}

				if (options.precision !== undefined && options.precision !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.precision, 'precision', util.isNumber)]);
					precision = Math.max(0, options.precision); // bugfix of entered negative precision
				}

				if (options.negativeNumberFormat !== undefined && options.negativeNumberFormat !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.negativeNumberFormat, 'negativeNumberFormat', util.isString || util.isObject)]);
					if (options.negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.MINUS || options.negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.BRACKETS) {
						negativeNF = options.negativeNumberFormat; // value outside enum is ignored
					}
				}
			}

			// check if exists any null value here -> then DB access has to be performed
			if (groupSeparator == null || decimalSeparator == null || precision == null || negativeNF == null)
			{
				var preProcData = {gs : groupSeparator, ds : decimalSeparator, prec: precision, nnf : negativeNF};
				var numberFormatParams = invoker(formatApi, 'getNumberFormatParametersForSSClient', [], utilityFunctions.isPromiseCallback(this) ? this.bind(preProcData) : undefined);

				if (utilityFunctions.isPromiseCallback(this))
					return;
				else
					return ppNumberFormatter({result: numberFormatParams, data: preProcData});

			}

			return new NumberFormatter(groupSeparator, decimalSeparator, precision, negativeNF);
		}

		function ppNumberFormatter(options)
		{
			var numberFormatParams = options.result;
			var preProcessedData = options.data;

			if (preProcessedData.gs == null) {
				preProcessedData.gs = numberFormatParams.groupSeparator;
			}
			if (preProcessedData.ds == null) {
				preProcessedData.ds = numberFormatParams.decimalSeparator;
			}
			if (preProcessedData.prec == null) {
				preProcessedData.prec = numberFormatParams.precision;
			}
			if (preProcessedData.nnf == null) {
				preProcessedData.nnf = numberFormatParams.negativeNumberFormat;
			}
			return new NumberFormatter(preProcessedData.gs, preProcessedData.ds, preProcessedData.prec, preProcessedData.nnf);
		}

		/**
		 *
		 * @returns {*}
		 */
		function getValidCurrencies()
		{
			if (! ValidCurrencies)
			{
				ValidCurrencies = invoker(formatApi, 'getValidCurrencies', []);
			}
			return ValidCurrencies;
		}

		return Object.freeze({
			/**
			 * Returns number spelled out as a string of words.
			 *
			 * @param {Object} options
			 * @param {number} options.number Number to be spelled out
			 * @param {string} options.locale Locale code as a string
			 *
			 * @return {string} Number described in words
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if name parameter is missing
			 *
			 * @since 2019.1
			 */
			spellOut: doSpellOut,

			/**
			 * Returns CurrencyFormatter object, which can format numbers to currency strings
			 * @param (Object) options
			 * @param (string) options.currency (enum) Code of currency used by formatter (is MANDATORY)
			 * @governance 10
			 * @throws (error.SuiteScriptError) MISSING_REQD_ARGUMENT if currency parameter is missing
			 * @throws (error.SuiteScriptError) SSS_INVALID_CURRENCY_ID if invalid currency is used
			 */
			getCurrencyFormatter: doGetCurrencyFormatter,

			/**SuiteScriptModuleLoaderError"
            * Returns NumberFormatter object, which can format numbers tu number strings
            * @param (Object) options
            * @param (string) options.groupSeparator
            * @param (string) options.decimalSeparator
            * @param (number) options.precision
            * @param (string) options.negativeNumberFormat (enum)
            * @governance 10
			* none of params is MANDATORY
            */
			getNumberFormatter: doGetNumberFormatter,

			// for post-processing
			ppCurrencyFormatter: ppCurrencyFormatter,
			ppNumberFormatter: ppNumberFormatter,

			// enums
			/**
			 * Values: BRACKETS: 'BRACKETS',
			 *         MINUS: 'MINUS'
			 */
			NegativeNumberFormat: NEGATIVE_NUMBER_FORMATS,   // fixed enum

			/**
			 * Values e.g.:  USD
			 *               EUR
			 *               GBP
			 *               JPY
			 *               ... etc depending on company of logged user
			 */
			get Currency() {                                // generated enum
				return getValidCurrencies();
			}
		})
	});

/**
 * SuiteScript format/i18n module
 *
 * @module N/format/i18n
 * @NApiVersion 2.x
 *
 */
define('N/format/i18n',['N/utilityFunctions', 'N/formatI18nCommon'],
	function (utilityFunctions, formatI18nCommon)
	{
		var spellOut = formatI18nCommon.spellOut;
		/**
		 * Returns number spelled out as a string of words.
		 * Asynchronous
		 *
		 * @param {Object} options
		 * @param {number} options.number Number to be spelled out
		 * @param {string} options.locale Locale code as a string
		 *
		 * @return {string} Number described in words
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if name parameter is missing
		 *
		 * @since 2019.1
		 */
		spellOut.promise = function()
		{
			return utilityFunctions.promiseTo(spellOut, arguments);
		};

		// --- Currency formatter
		var getCurrencyFormatter = formatI18nCommon.getCurrencyFormatter;

		getCurrencyFormatter.promise = function()
		{
			return utilityFunctions.promiseTo(getCurrencyFormatter, arguments, formatI18nCommon.ppCurrencyFormatter);
		};

		// --- Number formatter
		var getNumberFormatter = formatI18nCommon.getNumberFormatter;

		getNumberFormatter.promise = function()
		{
			return utilityFunctions.promiseTo(getNumberFormatter, arguments, formatI18nCommon.ppNumberFormatter);
		};


		return Object.freeze({
			spellOut: spellOut,
			getCurrencyFormatter: getCurrencyFormatter,
			getNumberFormatter: getNumberFormatter,
			// enums :
			NegativeNumberFormat: formatI18nCommon.NEGATIVE_NUMBER_FORMATS,
			get Currency() {
				return formatI18nCommon.Currency
			}
		})

	});

/**
 * SuiteScript format module
 *
 * @module N/format
 * @NApiVersion 2.x
 *
 */
define('N/format',['N/util/formatter', 'N/utilityFunctions', 'N/dateTimeZone', 'N/fieldTypeConstants', 'N/format/i18n'],
    function (formatter, utilityFunctions, dateTimeZone, fieldTypeConstants, i18n)
    {
        function doParse(options, type)
        {
            var value,
                timezone = null,
                undef = undefined;

            if (type !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                type = options.type;
                timezone = options.timezone || null;
            }

            utilityFunctions.checkArgs([value, type], ['value', 'type'], 'parse');

            switch (type)
            {
                case fieldTypeConstants.Type.DATE:
                case fieldTypeConstants.Type.TIME:
                case fieldTypeConstants.Type.TIMETRACK:
                case fieldTypeConstants.Type.TIMEOFDAY:
                case fieldTypeConstants.Type.URL:
                case fieldTypeConstants.Type.CHECKBOX:
                case fieldTypeConstants.Type.CCNUMBER:
                case fieldTypeConstants.Type.PHONE:
                case fieldTypeConstants.Type.FULLPHONE:
                case fieldTypeConstants.Type.IDENTIFIER:
                case fieldTypeConstants.Type.MMYYDATE:
                case fieldTypeConstants.Type.CCEXPDATE:
                case fieldTypeConstants.Type.CCVALIDFROM:
                case fieldTypeConstants.Type.COLOR:
                case fieldTypeConstants.Type.FUNCTION:
                    return formatter.parse(value, type);

                case fieldTypeConstants.Type.INTEGER:
                case fieldTypeConstants.Type.POSINTEGER:
                case fieldTypeConstants.Type.PERCENT:
                case fieldTypeConstants.Type.FLOAT:
                case fieldTypeConstants.Type.POSFLOAT:
                case fieldTypeConstants.Type.NONNEGFLOAT:
                case fieldTypeConstants.Type.RATE:
                case fieldTypeConstants.Type.RATEHIGHPRECISION:
                case fieldTypeConstants.Type.DYNAMICPRECISION:
         		return formatter.parse(value, type, true, undef, undef, undef, true);

                case fieldTypeConstants.Type.POSCURRENCY:
                case fieldTypeConstants.Type.NONNEGCURRENCY:
                case fieldTypeConstants.Type.CURRENCY:
                case fieldTypeConstants.Type.CURRENCY2:
                    return formatter.parse(value, type, false, true);

                case fieldTypeConstants.Type.DATETIME:
                case fieldTypeConstants.Type.DATETIMETZ:
                    return dateTimeZone.parse(value, timezone);

                default:
                    return value;
            }
        }

        function doFormat(options, type)
        {

            var value,
                timezone = null,
                undef = undefined;

            if (type !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                type = options.type;
                timezone = options.timezone || null;
            }

            utilityFunctions.checkArgs([value, type], ['value', 'type'], 'format');

            switch (type)
            {
                case fieldTypeConstants.Type.DATE:
                case fieldTypeConstants.Type.TIME:
                case fieldTypeConstants.Type.TIMETRACK:
                case fieldTypeConstants.Type.TIMEOFDAY:
                case fieldTypeConstants.Type.INTEGER:
                case fieldTypeConstants.Type.POSINTEGER:
                case fieldTypeConstants.Type.PERCENT:
                case fieldTypeConstants.Type.FLOAT:
                case fieldTypeConstants.Type.POSFLOAT:
                case fieldTypeConstants.Type.NONNEGFLOAT:
                case fieldTypeConstants.Type.POSCURRENCY:
                case fieldTypeConstants.Type.NONNEGCURRENCY:
                case fieldTypeConstants.Type.CURRENCY:
                case fieldTypeConstants.Type.CURRENCY2:
                case fieldTypeConstants.Type.CHECKBOX:
                case fieldTypeConstants.Type.PHONE:
                case fieldTypeConstants.Type.FULLPHONE:
                case fieldTypeConstants.Type.MMYYDATE:
                case fieldTypeConstants.Type.RATE:
                case fieldTypeConstants.Type.RATEHIGHPRECISION:
                    return formatter.format(value, type);

                case fieldTypeConstants.Type.DATETIME:
                case fieldTypeConstants.Type.DATETIMETZ:
                    return dateTimeZone.format(value, timezone);

                default:
                    return value;
            }
        }

        return Object.freeze({
	                            i18n: i18n,
                                 /**
                                  * Parse a value from the appropriate preference formatted-value to a raw value.
                                  *
                                  * @param {Object} options
                                  * @param {string} options.value the data you wish to parse
                                  * @param {string} options.type the field type i.e. DATE, CURRENCY, INTEGER
                                  * @param {string} options.timezone (optional & applicable to type DATETIME only) specifies which timezone the value is from.
                                  *                                  default is the timezone set in the user's preferences
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if either value or type is missing
                                  *
                                  * @return {Date|string|number} If parseable, the parsed value. If not or given an invalid Type, the value passed in options.value
                                  *
                                  * @since 2015.2
                                  */
                                parse: doParse,
                                 /**
                                  * Parse a value from the raw value to its appropriate preference formatted-value.
                                  *
                                  * @param {Object} options
                                  * @param {Date|string|number} options.value the data you wish to format
                                  * @param {string} options.type the field type i.e. DATE, CURRENCY, INTEGER
                                  * @param {string} options.timezone (optional & applicable to type DATETIME only) specifies which timezone to format to.
                                  *                                  default is the timezone set in the user's preferences
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if either value or type is missing
                                  *
                                  * @return {string} If format-able, the formatted value. If not or given an invalid Type, the value passed in options.value
                                  *
                                  * @since 2015.2
                                  */
                                format: doFormat,
                                 /**
                                  * Enum for field types.
                                  * @enum {string}
                                  */
                                 Type: fieldTypeConstants.Type,
                                 /**
                                  * Enum for Time Zones.
                                  * @enum {string}
                                  */
                                Timezone: dateTimeZone.Timezone
                             });
    });

/**
 * @private
 */
define('N/restricted/currencyApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript currency module
 *
 * @module N/currency
 * @NApiVersion 2.x
 *
 */
define('N/currency',['N/restricted/invoker', 'N/restricted/currencyApi', 'N/format', 'N/fieldTypeConstants', 'N/utilityFunctions', 'N/error'],
    function (invoker, currencyApi, format, fieldTypeConstants, utilityFunctions, error)
    {
        function getExchRate(options)
        {
            var sourceCurrency, targetCurrency;

            if (options != null && (options.hasOwnProperty('source') || options.hasOwnProperty('target')))
            {
                sourceCurrency = options.source;
                targetCurrency = options.target;
            }

            utilityFunctions.checkArgs([sourceCurrency, targetCurrency], ['source', 'target'], 'exchangeRate');
            var effectiveDate = options.date || new Date();

            if (!util.isDate(effectiveDate))
            {
                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.date', 'date');
            }
            else
            {
                effectiveDate = format.format(effectiveDate, fieldTypeConstants.Type.DATE);
            }

            try
            {
                return parseFloat(invoker(currencyApi, 'nlapiExchangeRate', [sourceCurrency, targetCurrency, effectiveDate], null, false));
            }
            catch (e)
            {
                var err = e;
                var msg = !!e.message ? e.message.replace("fromCurrency", "source").replace("toCurrency", "target") : "";
                if (e.name === "INVALID_CUR")
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_CURRENCY_ID, msg);
                }
                throw err;
            }
        }

        return Object.freeze({
                                 /**
                                  * Retrieves the exchange rate between two currencies based on the specified date.
                                  * The return value comes from the Exchange Rate column of the Currency Exchange Rates record.
                                  *
                                  * @governance 10 units
                                  *
                                  * @param {Object} options
                                  * @param {int|string} options.source The source currency ID or String
                                  * @param {int|string} options.target The target currency ID or String
                                  * @param {Date} options.date [optional] The date of the desired effective currency rate. Defaults to today.
                                  *
                                  * @return {number}
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
                                  * @throws {SuiteScriptError} SSS_INVALID_CURRENCY_ID if an invalid currency (source or target) is specified
                                  *
                                  * @since 2015.2
                                  */
                                exchangeRate: getExchRate
                             })
    });

/**
 * @private
 */
define('N/restricted/scriptSessionContext',['N/restricted/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});

/**
 * @private
 */
define('N/restricted/scriptDeploymentContext',['N/restricted/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});

/**
 * @private
 */
define('N/restricted/scriptSessionObjectService',['N/restricted/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});

/**
 * @private
 */
define('N/restricted/scriptWorkQueueContext',['N/restricted/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});

/**
 * SuiteScript module
 *
 * @module N/runtime
 * @suiteScriptVersion 2.x
 *
 */
define('N/runtime',['N/restricted/scriptSessionContext',
		'N/restricted/scriptDeploymentContext',
		'N/restricted/scriptSessionObjectService',
		'N/restricted/scriptWorkQueueContext',
		'N/error',
		'N/nsobject',
		'N/restricted/invoker',
		'N/utilityFunctions',
		'N/util/formatter',
		'N/util'
	],
        function (scriptSessionContext, scriptDeploymentContext, scriptSessionObjectService, scriptWorkQueueContext,
                  error, nsobject, invoker, utilityFunctions, formatter, util)
        {

            var ENV_TYPES = Object.freeze({
                SANDBOX: 'SANDBOX',
                PRODUCTION: 'PRODUCTION',
                BETA: 'BETA',
                INTERNAL: 'INTERNAL'
            });

            var PERMISSION = Object.freeze({
                FULL: 4,
                EDIT: 3,
                CREATE: 2,
                VIEW: 1,
                NONE: 0
            });

            /**
             * @class Script
             * @classdesc Class for retrieving information about currently running script
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Script()
            {
                /**
                 * The script logging level for the currently executing script. Returns one of the following values: DEBUG, AUDIT, ERROR, EMERGENCY.
                 * @name Script#logLevel
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'logLevel', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getLogLevel');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.logLevel' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The script ID for the currently executing script.
                 * @name Script#id
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getScriptId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.id' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The current script's runtime version
                 * @name Script#apiVersion
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'apiVersion', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getRuntimeVersion');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.apiVersion' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The deployment ID for the script deployment on the currently executing script.
                 * @name Script#deploymentId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'deploymentId', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getDeploymentId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.deploymentId' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * An array of bundle IDs for the bundles that include the currently executing script.
                 * @name Script#bundleIds
                 * @type {string[]}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'bundleIds', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getBundleIds').map(String);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.bundleIds' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Returns the number of usage units remaining for the currently executing script.
                 * @return {number}
                 *
                 * @since 2015.2
                 */
                this.getRemainingUsage = function getRemainingUsage()
                {
                    return invoker(scriptSessionContext, 'getRemainingUsage');
                };

                /**
                 * Returns the value of a script parameter for the currently executing script.
                 *
                 * @param {Object} options
                 * @param {string} options.name The name of the parameter
                 * @return {number|Date|string|boolean}
                 *
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 * @throws {SuiteScriptError} WRONG_PARAMETER_NAME when name is not string
                 *
                 * @since 2015.2
                 */
                this.getParameter = function getParameter(options)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'Script.getParameter');
                    if (!util.isString(name))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    var pValue = invoker(scriptDeploymentContext, 'getPreferenceObject', [name]);
                    var pType = invoker(scriptDeploymentContext, 'getPreferenceType', [name]);
                    return formatter.parse(pValue, pType);
                };

	            /**
	             * The percent complete specified for the current scheduled script execution. This value appears in the % Complete  column on the Scheduled Script Status page. This value can be set or retrieved.
	             * @name Script#percentComplete
	             * @type {number}
	             * @throws {SuiteScriptError} SSS_OPERATION_UNAVAILABLE Thrown if the currently executing script is not a scheduled script.
	             *
	             * @since 2015.2
	             */
	            Object.defineProperty(this, 'percentComplete', {
		            get: function ()
		            {
			            return invoker(scriptWorkQueueContext, 'getPercentComplete');
		            },
		            set: function (val)
		            {
			            return invoker(scriptWorkQueueContext, 'setPercentComplete', [val]);
		            },
		            enumerable: true,
		            configurable: false
	            });

                // Functions for debugger

	            /**
	             * JSON.stringify() implementation.
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {
                        'id': this.id,
                        'deploymentId': this.deploymentId,
                        'logLevel': this.logLevel,
                        'bundleIds': this.bundleIds
                    };
                };

	            /**
	             * Returns the object type name
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return 'runtime.Script';
                };
            }

            /**
             * @class Session
             * @classdesc Class representing current session
             * @protected
             * @constructor
             */
            function Session()
            {
                /**
                 * Returns the user-defined session object value associated with a session object key. Both the session object value and associated key are defined using Session.set(options). If the key does not exist, this method returns null.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The key used to store the session object
                 * @return {string}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 */
                this.get = function get(options)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'Session.get');
                    return invoker(scriptSessionObjectService, 'getSessionObject', [name]);
                };

                /**
                 * Add or set the value of a user-defined session object for the current user.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The key used to store the session object
                 * @param {string} options.value The value to associate with this key in the user's session
                 * @return {void}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 */
                this.set = function set(options, value)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                        value = options.value;
                    }

                    utilityFunctions.checkArgs([name], ['name'], 'Session.set');

                    return invoker(scriptSessionObjectService, 'setSessionObject', [name, value]);
                };

                // Functions for debugger

	            /**
	             * JSON.stringify() implementation.
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    var keys = invoker(scriptSessionObjectService, 'getAllSessionObjects');
                    var result = new Object();
                    for (var i = 0; i < keys.length; i++)
                    {
                        result[keys[i]] = invoker(scriptSessionObjectService, 'getSessionObject', [keys[i]]);
                    }
                    return result;
                };

	            /**
	             * Returns the object type name
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return "runtime.Session";
                };
            }

            /**
             * @class User
             * @classdesc Class representing current user
             * @protected
             * @constructor
             */
            function User()
            {
                /**
                 * The email address of the current user. To use this property, the email field on the user employee record must contain an email address.
                 * @name User#email
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'email', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getEmail');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.email' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The name of the current user.
                 * @name User#name
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getName');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.name' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the location of the current user.
                 * @name User#location
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'location', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getLocation');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.location' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the department for the current user.
                 * @name User#department
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'department', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getDepartment');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.department' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the role for the current user.
                 * @name User#role
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'role', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getRole');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.role' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The string value of the center type, or role center, for the current user.
                 * @name User#roleCenter  The string value of the logged in user's center - for example, SALES, ACCOUNTING, CLASSIC.
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'roleCenter', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getRoleCenter');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.roleCenter' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The custom scriptId of the role for the current user. You can use this value instead of User.role.
                 * @name User#roleId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'roleId', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getRoleId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.roleId' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the current user.
                 * @name User#id
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getUser');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.id' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

	            /**
	             * The internal ID of the currently logged-in contact. If no logged-in entity or other entity than contact is logged in, then 0 is returned
	             * @name User#contact
	             * @type {number}
	             * @readonly
	             *
	             * @since 2019.1
	             */
	            Object.defineProperty(this, 'contact', {
		            get: function ()
		            {
			            return invoker(scriptSessionContext, 'getContact');
		            },
		            set: function (val)
		            {
			            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.contact' );
		            },
		            enumerable: true,
		            configurable: false,
		            writeable: false
	            });

                /**
                 * The internal ID of the subsidiary for the current user.
                 * @name User#subsidiary
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'subsidiary', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getSubsidiary');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.subsidiary' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Get a user's permission level for a given permission, which is a value from runtime.Permission enum
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The internal ID of a permission
                 * @return {number} one value of the Permission
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 */
                this.getPermission = function getPermission(options)
                {
                    var name = options;

                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'User.getPermission');
                    if (typeof name != "string")
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    return invoker(scriptSessionContext, 'getPermission', [name]);
                };

                /**
                 * Returns the value set for a NetSuite preference. Currently only General Preferences and Accounting Preferences are exposed in SuiteScript.
                 * @governance none
                 * @param {Object} options
                 * @param {string} name The internal ID of the preference
                 * @return {string} The value of a NetSuite preference for the current user
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 *
                 */
                this.getPreference = function getPreference(options)
                {
                    var name = options;

                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'User.getPreference');
                    if (!util.isString(name))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    var pValue = invoker(scriptDeploymentContext, 'getPreference', [name]);
                    var pType = invoker(scriptDeploymentContext, 'getPreferenceType', [name]);
                    if (('T' === pValue || 'F' === pValue) && ('boolean' === pType))
                        return 'T' === pValue;
                    else
                        return pValue;
                };

                // Functions for debugger

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {
                        'id': this.id,
                        'name': this.name,
                        'email': this.email,
                        'location': this.location,
                        'department': this.department,
                        'role': this.role,
                        'roleId': this.roleId,
                        'roleCenter': this.roleCenter,
                        'subsidiary': this.subsidiary
                    };
                };

	            /**
	             * Returns stringified representation of this SuiteScriptError
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return 'runtime.User';
                };
            }

            Session.prototype = nsobject.getNewInstance();
            User.prototype = nsobject.getNewInstance();
            Script.prototype = nsobject.getNewInstance();

            function Runtime()
            {
            	var _contextTypes;
                /**
                 * Returns a runtime.User object that represents the properties and preferences for the user currently executing the script.
				 * Use this method to get session objects for the current user session. If you want to get properties for the script or session, use runtime.getCurrentScript() or runtime.getCurrentSession() instead.
                 * @governance none
                 * @return {User}
                 *
                 * @since 2015.2
                 */
                this.getCurrentUser = function getCurrentUser()
                {
                    return Object.freeze(new User());
                };

                /**
                 * Returns a runtime.Script object that represents the currently executing script.
                 * Use this method to get properties and parameters of the currently executing script and script deployment. If you want to get properties for the session or user, use runtime.getCurrentSession() or runtime.getCurrentUser() instead.
                 * @governance none
                 * @return {Script}
                 *
                 * @since 2015.2
                 */
                this.getCurrentScript = function getCurrentScript()
                {
                    return Object.freeze(new Script());
                };

                /**
                 * Returns a runtime.Session object that represents the user session for the currently executing script.
				 * Use this method to get session objects for the current user session. If you want to get properties for the script or user, use runtime.getCurrentScript() or runtime.getCurrentUser() instead.
                 * @governance none
                 * @return {Session}
                 *
                 * @since 2015.2
                 */
                this.getCurrentSession = function getCurrentSession()
                {
                    return Object.freeze(new Session());
                };

                /**
                 * Use this method to determine if a particular feature is enabled in a NetSuite account.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.feature id of the feature
                 * @return {boolean}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when feature argument is missing
                 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when feature is not string
                 *
                 * @since 2015.2
                 */
                this.isFeatureInEffect = function isFeatureInEffect(options)
                {
                    var feature = options;
                    if (utilityFunctions.isObject(options))
                    {
                        feature = options.feature;
                    }

                    utilityFunctions.checkArgs([options], ['options.feature'], 'runtime.isFeatureInEffect');

                    if (!util.isString(feature))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'feature', 'string' );
                    }
                    return invoker(scriptSessionContext, 'getFeature', [feature]);
                };

                /**
                 * The number of scheduled script queues available in the current account.
                 * @name Runtime#queueCount
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'queueCount', {
                    get: function ()
                    {
                        return invoker(scriptWorkQueueContext, 'getQueueCount');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'queueCount' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

	            /**
	             * The number of processors available to the current account.
	             * @name Runtime#processorCount
	             * @type {number}
	             * @readonly
	             *
	             * @since 2018.1
	             */
	            Object.defineProperty(this, 'processorCount', {
		            get: function ()
		            {
			            return invoker(scriptWorkQueueContext, 'getProcessorCount');
		            },
		            set: function (val)
		            {
			            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'processorCount' );
		            },
		            enumerable: true,
		            configurable: false,
		            writeable: false
	            });


                /**
                 * The version of NetSuite the current account is runnning.
                 *
                 * @name Runtime#version
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'version', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getVersion');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'version' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });


                /**
                 * The account ID for the current user.
                 * @name Runtime#accountId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'accountId', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getCompany');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'accountId' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The current environment in which the script is executing. This property uses values from the runtime.EnvType enum.
                 * @name Runtime#envType
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'envType', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getEnvironment');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'envType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The trigger of the current script. This property uses values from the runtime.ContextType enum.
                 * @name Runtime#executionContext
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'executionContext', {
                    get: function ()
                    {
                    	var toRet = invoker(scriptSessionContext, 'getExecutionContext');
                        return  toRet == null ? null : toRet.toUpperCase();
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'executionContext' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                // Functions for debugger
	            /**
	             * JSON.stringify() implementation.
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {};
                };

	            /**
	             * Returns the object type name
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return "runtime.Runtime";
                };

                /**
                 * Holds all possible environment types that the current script can execute in. This is the type for the runtime.envType property.
                 * @enum {string}
                 * @readonly
                 */
                this.EnvType = ENV_TYPES;

                /**
                 * Holds the context values for script triggers. This is the type for the runtime.executionContext property.
                 * @name runtime#ContextType
                 * @type {Object}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'ContextType', {
                    get: function ()
                    {
                        if (!_contextTypes)
                            _contextTypes = invoker(scriptSessionContext, 'getExecutionContextTypes');
                        return _contextTypes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ContextType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Holds the user permission level for a specific permission ID. User.gerPermission(options) returns a value from this enum.
                 * @enum {number}
                 * @readonly
                 */
                this.Permission = PERMISSION;
            };
            Runtime.prototype = nsobject.getNewInstance();
            /** @alias N/runtime */
            return Object.freeze(new Runtime());
        });

/**
 * @private
 */
define('N/restricted/actionApi',['N/restricted/reflet'], function(reflet){ return util.extend({bridge: 'actionApi'}, reflet); });

/**
 * SuiteScript record action task status module.
 *
 * @private
 * @module N/record/actionInternal
 * @suiteScriptVersion 2.x
 */
define('N/record/actionInternal',['N/restricted/actionApi', 'N/restricted/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'],
	function (actionApi, invoker, utilityFunctions, nsobject, error)
	{
		var ALL_QUALIFIED_INSTANCES = Object.freeze({});

		/**
		 * @class RecordActionTaskStatus
		 * @classdesc Encapsulates the status of a record action task in the NetSuite scheduling queue.
		 * @protected
		 * @constructor
		 *
		 * @since 2019.1
		 */
		function RecordActionTaskStatus(taskId)
		{
			var TYPE = 'task.RecordActionTaskStatus';

			var _data = null;
			
			function getData()
			{
				if (!_data)
					_data = JSON.parse(invoker(actionApi, 'getBulkStatus', [taskId], null, false));

				return _data;
			}

			/**
			 * The taskId associated with the specified task.
			 * @name RecordActionTaskStatus#taskId
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'taskId', {
				get: function ()
				{
					return taskId;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'taskId' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * Represents the task status. Returns one of the task.TaskStatus enum values.
			 * @name RecordActionTaskStatus#status
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'status', {
				get: function ()
				{
					return getData().status;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'status' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The results for successfully executed actions. The value of the property is a mapping from instance ID to
			 * the corresponding action result.
			 * @name RecordActionTaskStatus#results
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'results', {
				get: function ()
				{
					return Object.freeze(getData().results);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'results' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The error details for failed action executions. The value of the property is a mapping from record instance ID to
			 * the corresponding error detail. The error detail is an unnamed object with two properties - code and message.
			 * @name RecordActionTaskStatus#errors
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'errors', {
				get: function ()
				{
					return Object.freeze(getData().errors);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'errors' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions already executed (either failed or successful).
			 * @name RecordActionTaskStatus#complete
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'complete', {
				get: function ()
				{
					return getData().complete;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'complete' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions that executed successfully.
			 * @name RecordActionTaskStatus#succeeded
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'succeeded', {
				get: function ()
				{
					return getData().succeeded;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'succeeded' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions whose execution failed.
			 * @name RecordActionTaskStatus#failed
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'failed', {
				get: function ()
				{
					return getData().failed;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'failed' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions that are yet to be executed.
			 * @name RecordActionTaskStatus#pending
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'pending', {
				get: function ()
				{
					return getData().pending;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pending' );
				},
				enumerable: true,
				configurable: false
			});

			this.refresh = function refresh()
			{
				_data = null;
			};

			/**
			 * Returns the object type name (task.RecordActionTaskStatus).
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2019.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: TYPE,
					taskId: this.taskId,
					status: this.status,
					results: this.results,
					errors: this.errors,
					complete: this.complete,
					succeeded: this.succeeded,
					failed: this.failed,
					pending: this.pending
				}
			}
		}

		RecordActionTaskStatus.prototype = nsobject.getNewInstance();

		function processSubmitBulkOptions(recordType, actionId, params, condition, paramCallback, actionIdArgName, contextName)
		{
			utilityFunctions.checkArgs([recordType, actionId], ['recordType', actionIdArgName], contextName);

			if (params != null)
			{
				if (!Array.isArray(params) || params.some(function(v){return v !== Object(v)}))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'params', 'array of objects');
				if (condition != null || paramCallback != null)
					utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS);
			}
			else if (condition != null || paramCallback != null)
			{
				utilityFunctions.checkArgs([condition], ['condition'], contextName);
				if (paramCallback == null)
					paramCallback = function(v) { return {}; };
				else if (!util.isFunction(paramCallback) || !utilityFunctions.isObject(paramCallback(1)))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'paramCallback', 'function returning object');
				if (!utilityFunctions.isObject(condition))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'object');
				if (condition !== ALL_QUALIFIED_INSTANCES)
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				var instanceIds = JSON.parse(invoker(actionApi, 'findInstances', [recordType, actionId], null, false));
				params = instanceIds.map(paramCallback).map(function(v,i) { if (v.recordId==null) v.recordId = instanceIds[i]; return v; });
			}
			else
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'params', 'condition/paramCallback');

			return params;
		}

		return Object.freeze({
			RecordActionTaskStatus: RecordActionTaskStatus,

			getAllQualifiedInstancesSingleton: function() { return ALL_QUALIFIED_INSTANCES; },

			processSubmitBulkOptions: processSubmitBulkOptions
		});
	});

/**
 * SuiteScript record action module
 *
 * @module N/action
 * @suiteScriptVersion 2.x
 */
define('N/action',['N/restricted/actionApi', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error', 'N/record/actionInternal'],
	function (actionApi, invoker, utilityFunctions, error, actionInternal)
	{
		var actionCache = {};

		function recOrNull(obj)
		{
			return obj && obj.hasOwnProperty('type') && obj.hasOwnProperty('id') ? obj : null;
		}

		function doExecute(options, rec)
		{
			options = options || {};
			var recordType = rec ? rec.type : options.recordType;
			var params = utilityFunctions.isObject(options.params) ? util.extend({}, options.params) : {};
			var recordId = utilityFunctions.ensureInteger(rec ? rec.id : params.recordId, 'params.recordId');
			params.recordId = recordId;
			var actionId = options.id;
			var context = rec ? rec.getMissingArgumentErrorMessageFillerValue('executeAction') : 'action.execute';
			utilityFunctions.checkArgs([recordType, recordId, actionId], ['recordType', 'params.recordId', 'id'], context);

			var callback = utilityFunctions.isPromiseCallback(this) ? this : null;
			return invoker(actionApi, 'executeAction', [recordType, actionId, recordId, params], callback, false);
		}

		function execute(options)
		{
			return JSON.parse(doExecute(options, recOrNull(this)));
		}
		execute.promise = function(options)
		{
			return utilityFunctions.promiseTo(doExecute, [options, recOrNull(this)], function(ctx) { return JSON.parse(ctx.result); });
		};

		function createAction(options, recordId)
		{
			var TYPE = 'Action';

			var recordType = options.recordType.toLowerCase();
			var actionId = options.id;

			var Action = function(params)
			{
				return execute(combineOpts(params, recordType, recordId, actionId));
			};
			Action.execute = function(params)
			{
				return execute(combineOpts(params, recordType, recordId, actionId));
			};
			Action.promise = function(params)
			{
				return execute.promise(combineOpts(params, recordType, recordId, actionId));
			};
			Action.execute.promise = Action.promise;

			Action.executeBulk = function(options)
			{
				return executeBulk(util.extend({recordType: recordType, id: actionId}, options));
			};

			Action.id = actionId;
			Action.recordType = recordType;
			Action.recordId = recordId;
			Action.label = options.label || null;
			Action.description = options.description || null;
			var params = {};
			options.parameters.forEach(function(p) {
				params[p.id] = p;
				delete p.id;
			});
			Action.parameters = params;
			Action.toJSON = function toJSON(concise)
			{
				var res = {};
				for (var p in Action)
				{
					if (Action.hasOwnProperty(p) && typeof Action[p] !== 'function')
					{
						if (!concise || (Action[p] != null && (Action[p].constructor !== Object || Object.keys(Action[p]).length > 0)))
							res[p] = Action[p];
					}
				}
				return res;
			};
			Action.toString = function toString()
			{
				return TYPE + JSON.stringify(Action.toJSON(true));
			};

			return Object.freeze(Action);
		}

		function combineOpts(params, recordType, recordId, actionId)
		{
			var combinedOpts = {};
			combinedOpts.params = util.extend(recordId ? {recordId: recordId} : {}, params);
			combinedOpts.recordType = recordType;
			combinedOpts.id = actionId;
			return combinedOpts;
		}

		function processFindResult(ctx)
		{
			var metadata = JSON.parse(ctx.result);
			var options = ctx.data;
			if (!options.recordId) // do not cache if recordId is given (result is not static in this case)
				actionCache[options.recordType.toLowerCase()] = ctx.result;

			var actions = {};
			for (var i = 0; i < metadata.length; i++)
			{
				if (options.id && options.id !== metadata[i].id)
					continue;
				var action = createAction(metadata[i], options.recordId);
				actions[action.id] = action;
			}
			if (options.id && Object.keys(actions).length === 0)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_ACTION_ID);
			return Object.freeze(actions);
		}

		function doFind(options, rec)
		{
			if (rec)
				util.extend(options, {recordType: rec.type, recordId: rec.id});
			var recordType = options.recordType;
			var context = rec ? rec.getMissingArgumentErrorMessageFillerValue('getActions') : 'action.find';
			utilityFunctions.checkArgs([recordType], ['recordType'], context);
			recordType = recordType.toLowerCase();
			var actionId = options.id || null;
			var recordId = utilityFunctions.ensureInteger(options.recordId, 'recordId');
			var callback = utilityFunctions.isPromiseCallback(this) ? this.bind(options) : null;

			// actions available for a particular record instance may change over time -> ignore cache if recordId is given
			if (recordId || !actionCache[recordType])
				return invoker(actionApi, 'getRecordActions', [recordType, recordId, actionId], callback, false);

			if (callback)
				callback(actionCache[recordType]);
			else
				return actionCache[recordType];
		}

		function find(options)
		{
			options = util.extend({}, options);
			return processFindResult({result: doFind(options, recOrNull(this)), data: options});
		}
		find.promise = function(options)
		{
			options = util.extend({}, options);
			return utilityFunctions.promiseTo(doFind, [options, recOrNull(this)], processFindResult);
		};

		function processGetResult(ctx)
		{
			var metadata = JSON.parse(ctx.result);
			var options = ctx.data;
			if (!options.recordId) // do not cache if recordId is given (result is not static in this case)
				actionCache[options.recordType.toLowerCase()] = ctx.result;

			var result = null;
			for (var i = 0; i < metadata.length; i++)
			{
				if (options.id === metadata[i].id)
				{
					result = createAction(metadata[i], options.recordId);
					break;
				}
			}
			if (result === null)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_ACTION_ID);
			return result;
		}

		function doGet(options, rec)
		{
			options = options || {};
			var recordType = rec ? rec.type : options.recordType;
			var actionId = options.id;
			var context = rec ? rec.getMissingArgumentErrorMessageFillerValue('getAction') : 'action.get';
			utilityFunctions.checkArgs([recordType, actionId], ['recordType', 'id'], context);

			return doFind.call(this, options, rec);
		}

		function get(options)
		{
			return processGetResult({result: doGet(options, recOrNull(this)), data: options});
		}
		get.promise = function(options)
		{
			return utilityFunctions.promiseTo(doGet, [options, recOrNull(this)], processGetResult);
		};

		function executeBulk(options)
		{
			var recordType, actionId, params, condition, paramCallback;
			if (options)
			{
				recordType = options.recordType;
				actionId = options.id;
				params = options.params;
				condition = options.condition;
				paramCallback = options.paramCallback;
			}
			params = actionInternal.processSubmitBulkOptions(recordType, actionId, params, condition, paramCallback, 'id', 'action.executeBulk');

			return invoker(actionApi, 'submitBulkAction', [recordType, actionId, JSON.stringify(params)], null, false);
		}

		function getBulkStatus(options)
		{
			var taskId = utilityFunctions.isObject(options) ? options.taskId : options;
			utilityFunctions.checkArgs([taskId], ['taskId'], 'action.getBulkStatus');
			return new actionInternal.RecordActionTaskStatus(taskId);
		}

		return Object.freeze({
			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * If the Action object is qualified, i.e. it is a result of a get/find call where recordId was provided,
			 * then it is not required to provide a recordId again and the parameter is optional. If, however, recordId is
			 * provided again upon execution, then it takes precedence over the one already stored inside the Action object.
			 * @name Action
			 * @function
			 * @param {Object} params action arguments
			 * @param {string} params.recordId record instance ID
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if params.recordId is missing or undefined
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if the specified record instance doesn't exist
			 *
			 * @since 2018.2
			 */

			/**
			 * Performs a search for available record actions. If only the recordType parameter is specified, all actions available for the record type are returned. If the recordId parameter is also specified, then only actions that qualify for execution on the given record instance are returned. If the id parameter is specified, then only the action with the specified action ID is returned.
			 * This method returns a plain JavaScript object of NetSuite record actions available for the record type. The object contains one or more action.Action objects. If there are no available actions for the specified record type, an empty object is returned.
			 * If the recordId is specified in this call, the actions that are found are considered qualified. You do not have to provide the recordId to execute a qualified action.
			 *
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} (optional) options.recordId record instance ID
			 * @param {string} (optional) options.id action ID
			 * @returns {Object} a set of actions (@see Action) defined on the record type indexed by action ID
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if an action is specified and such action doesn't exist on the said record type
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if a record ID is specified and that record instance doesn't exist
			 *
			 * @since 2018.2
			 */
			find: find,

			/**
			 * Returns an executable record action for the given record type. If the recordId parameter is provided, then the
			 * action object is only returned if the given record instance qualifies for execution of the given record action.
			 * Also, if recordId is provided than the returned action is "qualified" and you don't have to provide the recordId
			 * again when executing the Action object.
			 *
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {string} (optional) options.recordId record instance ID
			 * @return {Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if the specified action doesn’t exist on the said record type OR
			 *                                                  the specified record instance does not qualify for executing the action
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if a record ID is specified and that record instance doesn't exist
			 *
			 * @since 2018.2
			 */
			get: get,

			/**
			 * Executes the record action and returns the action results in a plain JavaScript object.
			 * If the action fails, it is listed in the results object’s notifications property. If the action executes successfully, the notifications property is usually empty.
			 *
			 * @governance none
			 *
			 * Params objects represents parameters which are usually record type specific, only recordId parameter is common for every record type
			 * @typedef {Object} Params
			 * @property {string} recordId record instance ID
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {Params} options.params action arguments
			 * @return {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id or options.params.recordId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if the specified action doesn't exist on the said record type
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if the specified record instance doesn't exist
			 *
			 * @since 2018.2
			 */
			execute: execute,

			/**
			 * Executes an asynchronous bulk record action and returns its task ID for status queries. The options.params parameter
			 * is mutually exclusive to options.condition and options.paramCallback.
			 *
			 * @governance 50 units for timesheets, 10 for transactions, 2 for custom records, 5 for all other records
			 *
			 * Params objects represents parameters which are usually record type specific, only recordId parameter is common for every record type
			 * @typedef {Object} Params
			 * @property {string} recordId record instance ID
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {Object[]} [Params] array of parameter objects; each object corresponds to one record ID for which the action is to
			 *                                             be executed; the object has the following form: {recordId: 1, someParam: 'foo', otherParam: 'bar'}
			 *                                             recordId is always mandatory, other parameters are optional and specific to the particular action
			 * @param {string} [options.condition] condition used to select record IDs for which the action is to be executed; only the
			 *                                              action.ALL_QUALIFIED_INSTANCES constant is supported at the moment
			 * @param {string} options.paramCallback] function that takes record ID and returns the parameter object for the given record ID
			 * @return {string} task ID used in a later call to getBulkStatus
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if the specified action doesn't exist on the said record type
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if the specified record instance doesn't exist
			 *
			 * @since 2019.1
			 */
			executeBulk: executeBulk,

			/**
			 * Returns the current status of a bulk execution with the given task ID.
			 *
			 * @governance 50 units
			 *
			 * @param {Object} options
			 * @param {string} options.taskId a task ID that was returned by a previous call to executeBulk
			 * @return {RecordActionTaskStatus} a status object capturing the current state of the bulk action execution; see task module JSDoc
			 *
			 * @since 2019.1
			 */
			getBulkStatus: getBulkStatus,

			/**
			 * Singleton object to be used as condition parameter in executeBulk.
			 */
			ALL_QUALIFIED_INSTANCES: actionInternal.getAllQualifiedInstancesSingleton()
		});
	}
);

/**
 * @private
 */
define('N/restricted/queryApiBridge',['N/restricted/reflet'], function(reflet){ return util.extend({bridge :'queryApiBridge'}, reflet); });

/**
 * SuiteScript example util module
 *
 * @module N/queryInternal
 * @NApiVersion 2.x
 *
 */
define('N/queryInternal',['N/restricted/invoker', 'N/restricted/queryApiBridge', 'N/utilityFunctions', 'N/error'],
	function (invoker, queryApiBridge, utilityFunctions, error)
	{
		var searchTypes;
		var searchTypeValues;
		var sortLocales;

		function validateSearchType(type)
		{
			getSearchTypes();
			if (searchTypeValues.indexOf(type) < 0 && type.toUpperCase().substr(0,12) != "CUSTOMRECORD")
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SEARCH_TYPE, type);
		}

		function getSearchTypes()
		{
			if (!searchTypes)
			{
				searchTypes = invoker(queryApiBridge, "getSearchTypes", []);
				searchTypeValues = [];
				Object.getOwnPropertyNames(searchTypes).forEach(function(name){
					searchTypeValues.push(searchTypes[name]);
				});
			}
			return searchTypes;
		}

		function validateSortLocale(locale)
		{
			getSortLocales();
			if (!sortLocales[locale])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SORT_LOCALE, locale);
		}

		function getSortLocales()
		{
			if (!sortLocales)
				sortLocales = invoker(queryApiBridge, "getSortLocales", []);
			return sortLocales;
		}

		return {
			getSearchTypes: getSearchTypes,
			validateSearchType: validateSearchType,
			getSortLocales: getSortLocales,
			validateSortLocale: validateSortLocale
		}

	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/iterator
 * @NApiVersion 2.x
 */
define('N/common/pattern/iterator',['N/nsobject', 'N/utilityFunctions'], function (nsObject, utilityFunctions)
{

	/**
	 *
	 * @param {JavaLikeIterator} delegate
	 * @constructor
	 * @protected
	 */
	function Iterator(delegate)
	{

		/**
		 * ECMA 2015 style
		 *
		 * @return {{done: boolean, value: *}}
		 */
		this.next = function next()
		{
			var result = {done: !delegate.hasNext()};
			if (!result.done)
			{
				result.value = delegate.next();
			}
			return result;
		};

		/**
		 *
		 * @callback iteratorFunction
		 * @param {{value: *}} value
		 * @return {boolean} Should continue iteration?
		 */

		/**
		 * SuiteScript style
		 *
		 * @param {iteratorFunction} iteratorFunction
		 */
		this.each = function each(iteratorFunction)
		{
			utilityFunctions.checkArgs([iteratorFunction], ['iteratorFunction'], 'Iterator.each');

			var cont = true;
			while (delegate.hasNext() && cont)
			{
				cont = !!iteratorFunction({value: delegate.next()});
			}
		};

	}

	Iterator.prototype = nsObject.getNewInstance();

	return Object.freeze({
		/**
		 * @param {JavaLikeIterator} iterable
		 * @return {Iterator}
		 */
		create: function create(iterable)
		{
			return Object.freeze(new Iterator(iterable));
		}
	});

});

/**
 * SuiteScript search paging util module
 * @private Ignore for JSDoc stub generation
 * @module N/search/pagingUtil
 * @NApiVersion 2.x
 *
 */
define('N/search/pagingUtil',[], function (){
	var PAGE_SIZE_MIN = 5,
		PAGE_SIZE_MAX = 1000,
		PAGE_SIZE_DEFAULT = 50;

    function regulatePageSize(pageSize)
    {
	    var size = parseInt(pageSize);
	    var result = isNaN(size) ? PAGE_SIZE_DEFAULT : size;

        result = result < PAGE_SIZE_MIN ? PAGE_SIZE_MIN : result;
        result = result > PAGE_SIZE_MAX ? PAGE_SIZE_MAX : result;

        return result;
    }

    return {
        regulatePageSize: regulatePageSize
    };
});

/**
 * SuiteScript new-generation query common module
 * Load the N/query module to create and run queries using the SuiteAnalytics Workbook query engine.
 *
 * @module N/query
 * @suiteScriptVersion 2.x
 */
define('N/query',['N/restricted/queryApiBridge', 'N/queryInternal', 'N/restricted/invoker', 'N/nsobject', 'N/utilityFunctions', 'N/error', 'N/common/pattern/iterator', 'N/search/pagingUtil', 'N/format'],
	function (queryApi, queryInternal, invoker, nsobject, utilityFunctions, error, iteratorFactory, pagingUtil, format)
	{
		var MOD_PREFIX = 'query.';

		var OPERATOR = Object.freeze({
			AFTER: 'AFTER',
			AFTER_NOT: 'AFTER_NOT',
			ANY_OF: 'ANY_OF',
			ANY_OF_NOT: 'ANY_OF_NOT',
			BEFORE: 'BEFORE',
			BEFORE_NOT: 'BEFORE_NOT',
			BETWEEN: 'BETWEEN',
			BETWEEN_NOT: 'BETWEEN_NOT',
			CONTAIN: 'CONTAIN',
			CONTAIN_NOT: 'CONTAIN_NOT',
			EMPTY: 'EMPTY',
			EMPTY_NOT: 'EMPTY_NOT',
			ENDWITH: 'ENDWITH',
			ENDWITH_NOT: 'ENDWITH_NOT',
			EQUAL: 'EQUAL',
			EQUAL_NOT: 'EQUAL_NOT',
			GREATER: 'GREATER',
			GREATER_NOT: 'GREATER_NOT',
			GREATER_OR_EQUAL: 'GREATER_OR_EQUAL',
			GREATER_OR_EQUAL_NOT: 'GREATER_OR_EQUAL_NOT',
			IS: 'IS',
			IS_NOT: 'IS_NOT',
			LESS: 'LESS',
			LESS_NOT: 'LESS_NOT',
			LESS_OR_EQUAL: 'LESS_OR_EQUAL',
			LESS_OR_EQUAL_NOT: 'LESS_OR_EQUAL_NOT',
			ON: 'ON',
			ON_NOT: 'ON_NOT',
			ON_OR_AFTER: 'ON_OR_AFTER',
			ON_OR_AFTER_NOT: 'ON_OR_AFTER_NOT',
			ON_OR_BEFORE: 'ON_OR_BEFORE',
			ON_OR_BEFORE_NOT: 'ON_OR_BEFORE_NOT',
			START_WITH: 'START_WITH',
			START_WITH_NOT: 'START_WITH_NOT',
			WITHIN: 'WITHIN',
			WITHIN_NOT: 'WITHIN_NOT'
		});

		var ALLOWED_ARITY = Object.freeze({
			"AFTER" : [2, 2],
			"AFTER_NOT" : [2, 2],
			"ANY_OF" : [2, Number.MAX_VALUE],
			"ANY_OF_NOT" : [2, Number.MAX_VALUE],
			"BEFORE" : [2, 2],
			"BEFORE_NOT" : [2, 2],
			"BETWEEN" : [3, 3],
			"BETWEEN_NOT" : [3, 3],
			"CONTAIN" : [2, 2],
			"CONTAIN_NOT" : [2, 2],
			"EMPTY" : [1, 1],
			"EMPTY_NOT" : [1, 1],
			"ENDWITH" : [2, 2],
			"ENDWITH_NOT" : [2, 2],
			"EQUAL" : [2, 2],
			"EQUAL_NOT" : [2, 2],
			"GREATER" : [2, 2],
			"GREATER_NOT" : [2, 2],
			"GREATER_OR_EQUAL" : [2, 2],
			"GREATER_OR_EQUAL_NOT" : [2, 2],
			"IS" : [2, 2],
			"IS_NOT" : [2, 2],
			"LESS" : [2, 2],
			"LESS_NOT" : [2, 2],
			"LESS_OR_EQUAL" : [2, 2],
			"LESS_OR_EQUAL_NOT" : [2, 2],
			"ON" : [2, 2],
			"ON_NOT" : [2, 2],
			"ON_OR_AFTER" : [2, 2],
			"ON_OR_AFTER_NOT" : [2, 2],
			"ON_OR_BEFORE" : [2, 2],
			"ON_OR_BEFORE_NOT" : [2, 2],
			"START_WITH" : [2, 2],
			"START_WITH_NOT" : [2, 2],
			"WITHIN" : [3, 3],
			"WITHIN_NOT" : [3, 3]
		});

		var AGGREGATE = Object.freeze({
			AVERAGE: 'AVERAGE',
			AVERAGE_DISTINCT: 'AVERAGE_DISTINCT',
			COUNT: 'COUNT',
			COUNT_DISTINCT: 'COUNT_DISTINCT',
			MEDIAN: 'MEDIAN',
			MAXIMUM: 'MAXIMUM',
			MAXIMUM_DISTINCT: 'MAXIMUM_DISTINCT',
			MINIMUM: 'MINIMUM',
			MINIMUM_DISTINCT: 'MINIMUM_DISTINCT',
			SUM: 'SUM',
			SUM_DISTINCT: 'SUM_DISTINCT'
		});

		var RETURN_TYPE = Object.freeze({
			BOOLEAN: 'BOOLEAN',
			DATE: 'DATE',
			DATETIME: 'DATETIME',
			FLOAT: 'FLOAT',
			INTEGER: 'INTEGER',
			STRING: 'STRING',
			DURATION: 'DURATION',
			CURRENCY: 'CURRENCY',
			KEY: 'KEY',
			RELATIONSHIP: 'RELATIONSHIP',
			ANY: 'ANY',
			PERCENT: 'PERCENT',
			UNKNOWN: 'UNKNOWN'
		});

		var DATE_ID = Object.freeze({
			SECONDS_AGO : "sago",
			MINUTES_AGO : "nago",
			HOURS_AGO : "hago",
			DAYS_AGO : "dago",
			WEEKS_AGO : "wago",
			MONTHS_AGO : "mago",
			QUARTERS_AGO : "qago",
			YEARS_AGO : "yago",
			SECONDS_FROM_NOW : "sfn",
			MINUTES_FROM_NOW : "nfn",
			HOURS_FROM_NOW : "hfn",
			DAYS_FROM_NOW : "dfn",
			WEEKS_FROM_NOW : "wfn",
			MONTHS_FROM_NOW : "mfn",
			QUARTERS_FROM_NOW : "qfn",
			YEARS_FROM_NOW : "yfn"
		});

		var relativeDateCodes = [];
		Object.getOwnPropertyNames(DATE_ID).forEach(function(name){
			relativeDateCodes.push(DATE_ID[name]);
		});

		var DATE_RANGE_CODE = Object.freeze({
			NEXT_ONE_QUARTER : 'NOQ',
			NEXT_ONE_HALF : 'NOH',
			NEXT_ONE_YEAR : 'NOY',
			SAME_MONTH_LAST_FISCAL_QUARTER : 'SMLFQ',
			SAME_MONTH_LAST_FISCAL_YEAR : 'SMLFY',
			SAME_FISCAL_QUARTER_LAST_FISCAL_YEAR : 'SFQLFY',
			SAME_WEEK_LAST_FISCAL_YEAR : 'SWLFY',
			SAME_DAY_LAST_WEEK : 'SDLW',
			SAME_DAY_WEEK_BEFORE_LAST : 'SDWBL',
			SAME_DAY_LAST_MONTH : 'SDLM',
			SAME_DAY_MONTH_BEFORE_LAST : 'SDMBL',
			SAME_DAY_LAST_FISCAL_QUARTER : 'SDLFQ',
			SAME_DAY_FISCAL_QUARTER_BEFORE_LAST : 'SDFQBL',
			SAME_DAY_LAST_FISCAL_YEAR : 'SDLFY',
			SAME_FISCAL_HALF_LAST_FISCAL_YEAR : 'SFHLFY',
			SAME_MONTH_FISCAL_QUARTER_BEFORE_LAST : 'SMFQBL',
			SAME_MONTH_FISCAL_YEAR_BEFORE_LAST : 'SMFYBL',
			SAME_WEEK_FISCAL_YEAR_BEFORE_LAST : 'SWFYBL',
			SAME_DAY_FISCAL_YEAR_BEFORE_LAST : 'SDFYBL',
			SAME_FISCAL_QUARTER_FISCAL_YEAR_BEFORE_LAST : 'SFQFYBL',
			SAME_MONTH_LAST_FISCAL_QUARTER_TO_DATE : 'SMLFQTD',
			SAME_MONTH_LAST_FISCAL_YEAR_TO_DATE : 'SMLFYTD',
			SAME_FISCAL_QUARTER_LAST_FISCAL_YEAR_TO_DATE : 'SFQLFYTD',
			SAME_FISCAL_HALF_LAST_FISCAL_YEAR_TO_DATE : 'SFHLFYTD',
			WEEK_BEFORE_LAST : 'WBL',
			MONTH_BEFORE_LAST : 'MBL',
			WEEK_AFTER_NEXT : 'WAN',
			MONTH_AFTER_NEXT : 'MAN',
			FISCAL_QUARTER_BEFORE_LAST : 'FQBL',
			FISCAL_HALF_BEFORE_LAST : 'FHBL',
			FISCAL_YEAR_BEFORE_LAST : 'FYBL',
			THREE_MONTHS_AGO : 'MB',
			THREE_FISCAL_QUARTERS_AGO : 'FQB',
			THREE_FISCAL_YEARS_AGO : 'FYB',
			THREE_MONTHS_AGO_TO_DATE : 'MBTD',
			THREE_FISCAL_QUARTERS_AGO_TO_DATE : 'FQBTD',
			THREE_FISCAL_YEARS_AGO_TO_DATE : 'FYBTD',
			WEEK_BEFORE_LAST_TO_DATE : 'WBLTD',
			WEEK_AFTER_NEXT_TO_DATE : 'WANTD',
			MONTH_BEFORE_LAST_TO_DATE : 'MBLTD',
			MONTH_AFTER_NEXT_TO_DATE : 'MANTD',
			FISCAL_QUARTER_BEFORE_LAST_TO_DATE : 'FQBLTD',
			FISCAL_HALF_BEFORE_LAST_TO_DATE : 'FHBLTD',
			FISCAL_YEAR_BEFORE_LAST_TO_DATE : 'FYBLTD',
			LAST_MONTH_ONE_FISCAL_QUARTER_AGO : 'LMLFQ',
			LAST_MONTH_ONE_FISCAL_YEAR_AGO : 'LMLFY',
			LAST_FISCAL_QUARTER_ONE_FISCAL_YEAR_AGO : 'LFQLFY',
			LAST_FISCAL_HALF_ONE_FISCAL_YEAR_AGO : 'LFHLFY',
			LAST_MONTH_TWO_FISCAL_QUARTERS_AGO : 'LMFQBL',
			LAST_MONTH_TWO_FISCAL_YEARS_AGO : 'LMFYBL',
			LAST_FISCAL_QUARTER_TWO_FISCAL_YEARS_AGO : 'LFQFYBL',
			PREVIOUS_MONTHS_THIS_FISCAL_QUARTER : 'PMTFQ',
			PREVIOUS_MONTHS_LAST_FISCAL_QUARTER : 'PMLFQ',
			PREVIOUS_MONTHS_SAME_FISCAL_QUARTER_LAST_FISCAL_YEAR : 'PMSFQLFY',
			PREVIOUS_MONTHS_THIS_FISCAL_HALF : 'PMTFH',
			PREVIOUS_MONTHS_LAST_FISCAL_HALF : 'PMLFH',
			PREVIOUS_MONTHS_SAME_FISCAL_HALF_LAST_FISCAL_YEAR : 'PMSFHLFY',
			PREVIOUS_MONTHS_THIS_FISCAL_YEAR : 'PMTFY',
			PREVIOUS_MONTHS_LAST_FISCAL_YEAR : 'PMLFY',
			PREVIOUS_FISCAL_QUARTERS_THIS_FISCAL_YEAR : 'PQTFY',
			PREVIOUS_FISCAL_QUARTERS_LAST_FISCAL_YEAR : 'PQLFY',
			TODAY : 'TODAY',
			YESTERDAY : 'YESTERDAY',
			TWO_DAYS_AGO : 'DAGO2',
			THREE_DAYS_AGO : 'DAGO3',
			FOUR_DAYS_AGO : 'DAGO4',
			FIVE_DAYS_AGO : 'DAGO5',
			TEN_DAYS_AGO : 'DAGO10',
			THIRTY_DAYS_AGO : 'DAGO30',
			SIXTY_DAYS_AGO : 'DAGO60',
			NINETY_DAYS_AGO : 'DAGO90',
			TWO_DAYS_FROM_NOW : 'DFN2',
			THREE_DAYS_FROM_NOW : 'DFN3',
			FOUR_DAYS_FROM_NOW : 'DFN4',
			FIVE_DAYS_FROM_NOW : 'DFN5',
			TEN_DAYS_FROM_NOW : 'DFN10',
			THIRTY_DAYS_FROM_NOW : 'DFN30',
			SIXTY_DAYS_FROM_NOW : 'DFN60',
			NINETY_DAYS_FROM_NOW : 'DFN90',
			TOMORROW : 'TOMORROW',
			PREVIOUS_ONE_DAY : 'OD',
			LAST_WEEK : 'LW',
			LAST_BUSINESS_WEEK : 'LBW',
			LAST_WEEK_TO_DATE : 'LWTD',
			THIS_WEEK : 'TW',
			THIS_BUSINESS_WEEK : 'TBW',
			THIS_WEEK_TO_DATE : 'TWTD',
			PREVIOUS_ONE_WEEK : 'OW',
			NEXT_WEEK : 'NW',
			NEXT_BUSINESS_WEEK : 'NBW',
			LAST_MONTH : 'LM',
			LAST_MONTH_TO_DATE : 'LMTD',
			THIS_MONTH_TO_DATE : 'TMTD',
			THIS_MONTH : 'TM',
			TODAY_TO_END_OF_THIS_MONTH : 'TODAYTTM',
			PREVIOUS_ONE_MONTH : 'OM',
			NEXT_MONTH : 'NM',
			LAST_YEAR : 'LY',
			LAST_YEAR_TO_DATE : 'LYTD',
			THIS_YEAR : 'TY',
			THIS_YEAR_TO_DATE : 'TYTD',
			NEXT_FOUR_WEEKS : 'N4W',
			FOUR_WEEKS_STARTING_THIS_WEEK : 'TWN3W',
			LAST_FISCAL_QUARTER : 'LFQ',
			LAST_FISCAL_QUARTER_TO_DATE : 'LFQTD',
			THIS_FISCAL_QUARTER : 'TFQ',
			THIS_FISCAL_QUARTER_TO_DATE : 'TFQTD',
			NEXT_FISCAL_QUARTER : 'NFQ',
			LAST_FISCAL_HALF : 'LFH',
			LAST_FISCAL_HALF_TO_DATE : 'LFHTD',
			THIS_FISCAL_HALF : 'TFH',
			THIS_FISCAL_HALF_TO_DATE : 'TFHTD',
			NEXT_FISCAL_HALF : 'NFH',
			LAST_FISCAL_YEAR : 'LFY',
			LAST_FISCAL_YEAR_TO_DATE : 'LFYTD',
			THIS_FISCAL_YEAR : 'TFY',
			THIS_FISCAL_YEAR_TO_DATE : 'TFYTD',
			THIS_ROLLING_QUARTER : 'TRQ',
			PREVIOUS_ROLLING_QUARTER : 'PRQ',
			LAST_ROLLING_QUARTER : 'LRQ',
			THIS_ROLLING_HALF : 'TRH',
			PREVIOUS_ROLLING_HALF : 'PRH',
			LAST_ROLLING_HALF : 'LRH',
			THIS_ROLLING_YEAR : 'TRY',
			PREVIOUS_ROLLING_YEAR : 'PRY',
			LAST_ROLLING_YEAR : 'LRY',
			PREVIOUS_ONE_QUARTER : 'OQ',
			PREVIOUS_ONE_HALF : 'OH',
			PREVIOUS_ONE_YEAR : 'OY',
			ONE_YEAR_BEFORE_LAST : 'OYBL',
			NEXT_FISCAL_YEAR : 'NFY',
			NEXT_ONE_WEEK : 'NOW',
			NEXT_ONE_MONTH : 'NOM'
		});

		var FIELD_CONTEXT = Object.freeze({
			RAW : "RAW",
			DISPLAY : "DISPLAY",
			HIERARCHY : "HIERARCHY",
			HIERARCHY_IDENTIFIER : "HIERARCHY_IDENTIFIER",
			SIGN_CONSOLIDATED : "SIGN_CONSOLIDATED",
			CURRENCY_CONSOLIDATED : "CURRENCY_CONSOLIDATED",
			CONVERTED : "CONVERTED"
		});

		var PERIOD_ADJUSTMENT = Object.freeze({
			NOT_LAST : "NOT_LAST",
			ALL : "ALL"
		});

		var PERIOD_TYPE = Object.freeze({
			START: "START",
			END: "END"
		});

		var PERIOD_CODE = Object.freeze({
			FIRST_FISCAL_QUARTER_LAST_FY : "Q1LFY",
			FIRST_FISCAL_QUARTER_THIS_FY : "Q1TFY",
			FISCAL_QUARTER_BEFORE_LAST : "QBL",
			FISCAL_YEAR_BEFORE_LAST : "FYBL",
			FOURTH_FISCAL_QUARTER_LAST_FY : "Q4LFY",
			FOURTH_FISCAL_QUARTER_THIS_FY : "Q4TFY",
			LAST_FISCAL_QUARTER : "LQ",
			LAST_FISCAL_QUARTER_ONE_FISCAL_YEAR_AGO : "LQOLFY",
			LAST_FISCAL_QUARTER_TO_PERIOD : "LFQTP",
			LAST_FISCAL_YEAR : "LFY",
			LAST_FISCAL_YEAR_TO_PERIOD : "LFYTP",
			LAST_PERIOD : "LP",
			LAST_PERIOD_ONE_FISCAL_QUARTER_AGO : "LPOLQ",
			LAST_PERIOD_ONE_FISCAL_YEAR_AGO : "LPOLFY",
			LAST_ROLLING_18_PERIODS : "LR18FP",
			LAST_ROLLING_6_FISCAL_QUARTERS : "LR6FQ",
			PERIOD_BEFORE_LAST : "PBL",
			SAME_FISCAL_QUARTER_LAST_FY : "TQOLFY",
			SAME_FISCAL_QUARTER_LAST_FY_TO_PERIOD: "TFQOLFYTP",
			SAME_PERIOD_LAST_FY : "TPOLFY",
			SAME_PERIOD_LAST_FISCAL_QUARTER : "TPOLQ",
			SECOND_FISCAL_QUARTER_LAST_FY : "Q2LFY",
			SECOND_FISCAL_QUARTER_THIS_FY: "Q2TFY",
			THIRD_FISCAL_QUARTER_LAST_FY : "Q3LFY",
			THIRD_FISCAL_QUARTER_THIS_FY : "Q3TFY",
			THIS_FISCAL_QUARTER : "TQ",
			THIS_FISCAL_QUARTER_TO_PERIOD : "TFQTP",
			THIS_FISCAL_YEAR : "TFY",
			THIS_FISCAL_YEAR_TO_PERIOD : "TFYTP",
			THIS_PERIOD : "TP"
		});

		var periodCodes = [];
		Object.getOwnPropertyNames(PERIOD_CODE).forEach(function(name){
			periodCodes.push(PERIOD_CODE[name]);
		});

		/**
		 * @class Period
		 * @classDescription Special object which can be used as a condition while querying periods
		 * @constructor
		 *
		 * @since 2020.1
		 */
		function Period(code, type, adjustment)
		{
			var TYPE = MOD_PREFIX + 'Period';

			var _code = code;
			var _type = type;
			var _adjustment = adjustment;

			/**
			 * Code of the Period
			 * @name Period#code
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.1
			 */
			Object.defineProperty(this, 'code', {
				get: function ()
				{
					return _code;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'code');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Type of the Period
			 * @name Period#type
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Adjustment of the Period
			 * @name Period#adjustment
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.1
			 */
			Object.defineProperty(this, 'adjustment', {
				get: function ()
				{
					return _adjustment;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'adjustment');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (query.Period)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					code: _code,
					type: _type,
					adjustment: _adjustment
				};
			};
		}

		/**
		 * @class RelativeDate
		 * @classDescription Special object which can be used as a condition while querying dates
		 * @constructor
		 * @protected
		 *
		 * @since 2019.1
		 */
		function RelativeDate(dateId, value)
		{
			var TYPE = MOD_PREFIX + 'RelativeDate';

			var _dateId = dateId;
			var _value = value;

			/**
			 * Start of relative date
			 * @name RelativeDate#start
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'start', {
				get: function ()
				{
					return {
						type: 'start',
						value: _value,
						dateId: _dateId
					};
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'start');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * End of relative date
			 * @name RelativeDate#end
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'end', {
				get: function ()
				{
					return {
						type: 'end',
						value: _value,
						dateId: _dateId
					};
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'end');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Interval of relative date
			 * @name RelativeDate#interval
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'interval', {
				get: function ()
				{
					return {
						type: 'interval',
						value: _value,
						dateId: _dateId
					};
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'interval');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Value of relative date
			 * @name RelativeDate#value
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'value', {
				get: function ()
				{
					return _value;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Flag if this relative date represents range
			 * @name RelativeDate#isRange
			 * @type {Boolean}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'isRange', {
				get: function ()
				{
					return !_value;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isRange');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Id of relative date
			 * @name RelativeDate#dateId
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'dateId', {
				get: function ()
				{
					return _dateId;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'dateId');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (query.RelativeDate)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2019.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					value: _value,
					dateId: _dateId
				};
			};
		}

		var RELATIVE_DATE_RANGES = {};
		Object.getOwnPropertyNames(DATE_RANGE_CODE).forEach(function(name){
			Object.defineProperty(RELATIVE_DATE_RANGES, name, {
				get: function ()
				{
					return new RelativeDate(DATE_RANGE_CODE[name]);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, name);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
		});

		/**
		 * @class SuiteQL
		 * @classDescription Object representing query in SuiteQL
		 * @constructor
		 * @protected
		 *
		 * @since 2018.2
		 */
		function SuiteQL(options)
		{
			var TYPE = MOD_PREFIX + 'SuiteQL';

			var _query = options.query;
			var _params = options.params;
			var _columns = options.columns;
			var _type = options.type;


			/**
			 * String representation of SuiteQL
			 * @name SuiteQL#query
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'query', {
				get: function ()
				{
					return _query;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'query');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Parameters
			 * @name SuiteQL#params
			 * @type {string[]|number[]|boolean[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'params', {
				get: function ()
				{
					return _params;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'params');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Columns to be returned from the query.
			 * @name SuiteQL#columns
			 * @type {Column[]}
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Type of this SuiteQL query.
			 * @name SuiteQL#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Execute the query and return results.
			 * @governance 10 units
			 * @return {ResultSet} the result set object
			 *
			 * @since 2018.2
			 */
			this.run = function run()
			{
				return runSuiteQLInternal(_query, _params, _columns, _type);
			};

			/**
			 * Execute the suiteQL query and return paged results.
			 * @governance 10 units
			 * @return {PagedData} the paged query object
			 *
			 * @since 2018.2
			 */
			this.runPaged = function runPaged(options)
			{
				var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
				return runSuiteQLPagedInternal(pageSize, _query, _params, _columns, _type);
			};

			function promiseToRun() {
				return promiseToRunSuiteQLInternal(this.query, this.params, this.columns, this.type);
			}

			function promiseToRunPaged(options) {
				var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
				return promiseToRunSuiteQLPagedInternal(pageSize, this.query, this.params, this.columns, this.type);
			}

			/**
			 * Asynchronously execute the query and return results.
			 * @governance 10 units
			 * @return {Promise} the result set object
			 *
			 * @since 2020.1
			 */
			this.run.promise = promiseToRun.bind(this);


			/**
			 * Asynchronously execute the suiteQL query and return results.
			 * @governance 10 units
			 * @return {Promise} the result set object
			 *
			 * @since 2020.1
			 */
			this.runPaged.promise = promiseToRunPaged.bind(this);

			/**
			 * Returns the object type name (query.Columns)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.2
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					query: _query,
					params: _params,
					columns: _columns,
					type: _type
				};
			};
		}

		/**
		 * @class Query
		 * @classDescription Encapsulates the query definition. Use query.create(options) or query.load(options) to create this object. The creation of this object is the first step in creating a query with the N/query Module.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Query(type, id, name)
		{
			var TYPE = MOD_PREFIX + 'Query';

			/* private vars */
			var _type = type;
			var _queryId = id || null;
			var _name = name || null;
			var _condition = null;
			var _columns = [];
			var _sort = [];
			var _root = new Component(type, null, null, null);

			/**
			 * Describes the initial query type of the query definition.
			 * @name Query#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * References the simple or nested condition (a query.Condition object) that narrows the query results.
			 * @name Query#condition
			 * @type {Condition}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than Query.Condition
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'condition', {
				get: function ()
				{
					return _condition;
				},
				set: function (condition)
				{
					if (!(condition instanceof Condition) && condition !== null)
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'Condition');
					_condition = condition;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds an array of result columns (query.Column objects) returned from the query.
			 * @name Query#columns
			 * @type {Column[]}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than Query.Column array
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function (columns)
				{
					if (!util.isArray(columns))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
					for (var i = 0; i < columns.length; i++)
					{
						if (!(columns[i] instanceof Column))
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
					}
					_columns = columns;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds an array of query result columns (query.Column objects) used for sorting.
			 * @name Query#sort
			 * @type {Sort[]}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than Query.Sort array
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'sort', {
				get: function ()
				{
					return _sort;
				},
				set: function (sort)
				{
					if (!util.isArray(sort))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sort', 'Sort[]');
					for (var i = 0; i < sort.length; i++)
					{
						if (!(sort[i] instanceof Sort))
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Sort[]');
					}
					_sort = sort;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds a references to children of this component. The value of this property is an object of key/value pairs. Each key is the name of a child component. Each respective value is the corresponding query.Component object.
			 * @name Query#child
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'child', {
				get: function ()
				{
					return _root.child;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'child');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds the ID of the query definition.
			 * @name Query#id
			 * @type {Number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return _queryId;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds the name of the query definition.
			 * @name Query#name
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return _name;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * References the root component of the query definition.
			 * @name Query#root
			 * @type {Component}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'root', {
				get: function ()
				{
					return _root;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'root');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Executes the query and returns the query result set.
			 * @governance 10 units
			 * @return {ResultSet} the result set object
			 *
			 * @since 2018.1
			 */
			this.run = function run()
			{
				var data = invoker(queryApi, 'runQuery', [this.marshal()]);
				var resultSet = new ResultSet(data, _columns);
				return resultSet;
			};

		/**
	     * Executes the query and returns a set of paged results.
	     * @governance 10 units
		 * @param {Object} options the options object
		 * @param {Number} options.pageSize
	     * @return {PagedData} the paged query object
		 *
		 * @since 2018.1
	     */
	    this.runPaged = function runPaged(options)
	    {
		    var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
		    pageSize = pagingUtil.regulatePageSize(pageSize);
		    utilityFunctions.checkArgs([pageSize], ['pageSize'], 'Query.runPaged');
		    var queryDefinition = this.marshal();
		    var queryData = invoker(queryApi, "pagedQuery", [pageSize, queryDefinition]);
		    return new PagedData({
			   pageSize: pageSize,
			   queryDefinition: queryDefinition,
			   queryData: queryData,
			   columns: _columns
		    });
	    };

	    function promiseToQuery()
	    {
		    var marshalled = this.marshal();
		    return new Promise(
			    function(resolve, reject) {
				    try {
					    invoker(queryApi, 'runQuery', [marshalled], callback);
				    }
				    catch (e) {
					    reject(e);
				    }

				    function callback(result, exception) {
					    if (exception) {
						    reject(exception);
						    return;
					    }
					    try {
						    var resultSet = new ResultSet(result, _columns);
						    resolve(resultSet);
					    }
					    catch (e) {
						    reject(e);
					    }
				    }
			    }
		    );
	    }

	    function promiseToPaged(options)
	    {
		    var marshalled = this.marshal();
		    var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
		    pageSize = pagingUtil.regulatePageSize(pageSize);
		    var cols = this.columns;
		    return new Promise(
			    function(resolve, reject) {
				    try {
					    utilityFunctions.checkArgs([pageSize], ['pageSize'], 'Query.runPaged');
					    invoker(queryApi, "pagedQuery", [pageSize, marshalled], callback);
				    }
				    catch (e) {
					    reject(e);
				    }

				    function callback(result, exception) {
					    if (exception) {
						    reject(exception);
						    return;
					    }
					    try {
						    resolve(new PagedData({
							    pageSize: pageSize,
							    queryDefinition: marshalled,
							    queryData: result,
							    columns: cols
						    }));
					    }
					    catch (e) {
						    reject(e);
					    }
				    }
			    }
		    );
	    }

			/**
			 * Executes the query asynchronously and returns the query result set.
			 * @governance 10 units
			 * @return {Promise} the result set object
			 *
			 * @since 2018.1
			 */
			this.run.promise = promiseToQuery.bind(this);

			/**
			 * Executes the query asynchronously and returns a set of paged results.
			 * @governance 10 units
			 * @param {Object} options the options object
			 * @param {Number} options.pageSize
			 * @return {Promise} the result set object
			 *
			 * @since 2018.1
			 */
			this.runPaged.promise = promiseToPaged.bind(this);

			/**
			 * Creates a join relationship.
			 * @link Component.autoJoin
			 */
			this.autoJoin = function autoJoin(options)
			{
				return _root.autoJoin(options);
			};

			/**
			 * Creates a join relationship.
			 * @link Component.join
			 */
			this.join = function join(options)
			{
				return _root.join(options);
			};

			/**
			 * Creates an explicit directional join relationship to another component from this component (a polymorphic join). This method sets the Component.target property on the returned query.Component object.
			 * @link Component.joinTo
			 */
			this.joinTo = function joinTo(options)
			{
				return _root.joinTo(options);
			};

			/**
			 * Creates an explicit directional join relationship from another component to this component (an inverse join). This method sets the Component.source property on the returned query.Component object.
			 * @link Component.joinFrom
			 */
			this.joinFrom = function joinFrom(options)
			{
				return _root.joinFrom(options);
			};

			/**
			 * This method creates a condition (query filter) based on the query.Query object.
			 * @link Component.createCondition
			 */
			this.createCondition = function createCondition(options)
			{
				return _root.createCondition(options);
			};

			/**
			 * This method creates a query result column based on the query.Query object.
			 * @link Component.createColumn
			 */
			this.createColumn = function createColumn(options)
			{
				return _root.createColumn(options);
			};

			/**
			 * This method creates a sort based on the query.Query object. The query.Sort object describes a sort that is placed on a particular query result column.
			 * @link Component.createSort
			 */
			this.createSort = function createSort(options)
			{
				return _root.createSort(options);
			};

			function convertConditions(options)
			{
				var newArguments = null;
				if (util.isObject(options) && options.hasOwnProperty("conditions"))
					newArguments = options.conditions;
				else if (util.isArray(options))
					newArguments = options;
				else
					newArguments = Array.prototype.slice.call(arguments);
				return newArguments;
			}

			/**
			 * Creates a new condition (a query.Condition object) that corresponds to a logical conjunction (AND) of the arguments passed to the method. The arguments must be one or more query.Condition objects.
			 * @governance none
			 * @param {Object} options The options object
			 * @param {Condition[]} options.condition One or more condition objects. There is no limit on the number of conditions you can specify.
			 * @return {Condition}
			 *
			 * @since 2018.1
			 */
			this.and = function and()
			{
				utilityFunctions.checkArgs([arguments.length > 0], ['argument count'], 'Query.and');
				return new Condition(convertConditions.apply(null, arguments), 'AND', null);
			};

			/**
			 * Creates a new condition (a query.Condition object) that corresponds to a logical disjunction (OR) of the arguments passed to the method. The arguments must be one or more query.Condition objects.
			 * @governance none
			 * @param {Object} options The options object
			 * @param {Condition[]} options.condition One or more condition objects. There is no limit on the number of conditions you can specify.
			 * @return {Condition}
			 *
			 * @since 2018.1
			 */
			this.or = function or()
			{
				utilityFunctions.checkArgs([arguments.length > 0], ['argument count'], 'Query.or');
				return new Condition(convertConditions.apply(null, arguments), 'OR', null);
			};

			/**
			 * Creates a new condition (a query.Condition object) that corresponds to a logical negation (NOT) of the argument passed to the method. The argument must be a query.Condition object.
			 * @governance 0 units
			 * @param {Condition} One condition object.
			 * @return {Condition}
			 *
			 * @since 2018.1
			 */
			this.not = function not()
			{
				utilityFunctions.checkArgs([arguments.length == 1], ['argument count'], 'Query.not');
				return new Condition(convertConditions.apply(null, arguments), 'NOT', null);
			};

			/**
			 * Converts a Query object to corresponding SuiteQL representation
			 * @governance none
			 * @return {SuiteQL}
			 *
			 * @since 2018.1
			 */
			this.toSuiteQL = function toSuiteQL()
			{
				var sql = invoker(queryApi, 'toSuiteQL', [this.marshal()]);
				sql.columns = _columns;
				sql.type = _type;
				return new SuiteQL(sql);
			};

			/**
			 * Asynchronously converts a Query object to corresponding SuiteQL representation
			 * @governance none
			 * @return {Promise}
			 *
			 * @since 2019.2
			 */
			this.toSuiteQL.promise = function () {
				var marshalled = this.marshal();
				return new Promise(
					function(resolve, reject) {
						try {
							invoker(queryApi, 'toSuiteQL', [marshalled], callback);
						}
						catch (e) {
							reject(e);
						}

						function callback(result, exception) {
							if (exception) {
								reject(exception);
								return;
							}
							try {
								result.columns = _columns;
								result.type = _type;
								resolve(new SuiteQL(result));
							}
							catch (e) {
								reject(e);
							}
						}
					}
				);
			}.bind(this);

			/**
			 * Returns the object type name (query)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: _type,
					id: _queryId,
					name: _name,
					condition: _condition ? _condition.toJSON() : null,
					columns: jsonifyArray(_columns),
					sort: jsonifyArray(_sort),
					child: _root ? jsonifyObject(_root.child) : null,
					root: _root ? _root.toJSON() : null
				};
			};

			this.marshal = function marshal()
			{
				var col = [];
				for (var i = 0; i < _columns.length; i++)
					col.push(_columns[i].marshal());
				return JSON.stringify({
					type: _type,
					id: _queryId,
					name: _name,
					condition: _condition ? _condition.marshal() : null,
					columns: col,
					sort: jsonifyArray(_sort, true, _columns)
				});
			};
		}

		Query.prototype = nsobject.getNewInstance();

		function jsonifyArray(arr, marshal, aux)
		{
			if (arr == null)
				return null;
			var result = [];
			for (var i = 0; i < arr.length; i++)
			{
				result.push(marshal ? arr[i].marshal(aux) : arr[i].toJSON());
			}
			return result;
		}

		function jsonifyObject(obj, marshal)
		{
			if (obj == null)
				return null;
			var result = {};
			for (var i in obj)
			{
				if (obj.hasOwnProperty(i))
					result[i] = marshal ? obj[i].marshal() : obj[i].toJSON();
			}
			return result;
		}

		/**
		 * @class Component
		 * @classDescription Encapsulates one component of the query definition. Each new component is created as a child to the previous component. All components exist as children to the query definition (query.Query).
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Component(type, target, source, parent)
		{
			var TYPE = MOD_PREFIX + 'Component';

			var _type = type;
			var _parent = parent;
			var _target = target;
			var _source = source;
			var _children = {};

			/**
			 * Describes the query type of this component.
			 * @name Component#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the query type of the component joined to this component. This property can also be described as the inverse relationship of this component.
			 * @name Component#source
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'source', {
				get: function ()
				{
					return _source;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'source');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the query type of this component. This property can also be described as the polymorphic relationship of this component.
			 * @name Component#target
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'target', {
				get: function ()
				{
					return _target;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'target');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds a references to the parent query.Component object of this component.
			 * @name Component#parent
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'parent', {
				get: function ()
				{
					return _parent;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parent');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds a references to children of this component. The value of this property is an object of key/value pairs. Each key is the name of a child component. Each respective value refers to the corresponding query.Component object.
			 * @name Component#child
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'child', {
				get: function ()
				{
					return _children;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'child');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Creates a join relationship.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if fieldId is undefined
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED if relationship is already used
			 * @return {Component}
			 *
			 * @since 2018.2
			 */
			this.autoJoin = function autoJoin(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				utilityFunctions.checkArgs([type], ['fieldId'], 'Component.autoJoin');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, null, null, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates a join relationship. This method is an alias to Component.autoJoin(options).
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component. This value determines the columns on which the components are joined and the type of the newly joined component.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If fieldId is undefined.
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED The specified join relationship already exists.
			 * @return {Component}
			 *
			 * @since 2018.2
			 */
			this.join = function join(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				utilityFunctions.checkArgs([type], ['fieldId'], 'Component.join');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, null, null, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates an explicit directional join relationship to another component from this component (a polymorphic join). This method sets the Component.target property on the returned query.Component object.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component.
			 * @param {string} options.target The query type of the component joined to this component. This value sets the Component.target property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If fieldId is undefined.
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED The specified join relationship already exists.
			 * @return {Component}
			 *
			 * @since 2018.2
			 */
			this.joinTo = function joinTo(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				var target = (options && options.hasOwnProperty('target')) ? options.target : arguments[1];
				utilityFunctions.checkArgs([type, target], ['fieldId', 'target'], 'Component.joinTo');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(target, 'options.target', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, target, null, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates an explicit directional join relationship from another component to this component (an inverse join). This method sets the Component.source property on the returned query.Component object.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component.
			 * @param {string} options.source The query type of the component joined to this component.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If relationship is undefined
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED The specified join relationship already exists.
			 * @return {Component}
			 * 
			 * @since 2018.1
			 */
			this.joinFrom = function joinFrom(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				var source = (options && options.hasOwnProperty('source')) ? options.source : arguments[1];
				utilityFunctions.checkArgs([type, source], ['fieldId', 'source'], 'Component.joinFrom');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(target, 'options.source', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, null, source, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates a condition (query filter) based on the query.Component object.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.fieldId The name of the condition. This value sets the Condition.fieldId property.
			 * @param {string} options.operator The operator used by the condition. This value sets the Condition.operator parameter.
			 * @param {string[]|Date[]} options.values An array of values to use for the condition. This value sets the Condition.values property.
			 * @param {string} options.formula The formula used to create the condition. This value sets the Condition.formula property.
			 * @param {string} options.type If you use the options.formula parameter, use this parameter to explicitly define the formula’s return type. Defining the formula’s return type might be required if the return type cannot be determined correctly based on the specified formula. This value sets the Condition.type property.
			 * @param {string} [options.aggregate] Use this parameter to run an aggregate function on a condition. An aggregate function performs a calculation on the condition values and returns a single value. This value sets the Condition.aggregate property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object.
			 * @throws {SuiteScriptError} OPERATOR_ARITY_MISMATCH If requested operator cannot work with specified number of.
			 * @throws {SuiteScriptError} INVALID_SEARCH_OPERATOR If wrong query operator is used.
			 * @return {Condition}
			 * 
			 * @since 2018.1
			 */
			this.createCondition = function createCondition(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createCondition');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');
				return new Condition(null, options, this);
			};

			/**
			 * Creates a query result column based on the query.Component object.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.fieldId The name of the query result column. This value sets the Column.fieldId property.
			 * @param {string} options.formula The formula used to create the query result column. This value sets the Column.formula property.
			 * @param {string} options.type If you use the options.formula parameter, use this parameter to explicitly define the formula’s return type. Defining the formula’s return type might be required if the return type cannot be determined correctly based on the specified formula. This value sets the Column.type property.
			 * @param {string} options.label Field (column) label
			 * @param {string} [options.aggregate] Use this parameter to run an aggregate function on your query result column. An aggregate function performs a calculation on the column values and returns a single value. This value sets the Column.aggregate property.
			 * @param {boolean} [options.groupBy] Indicates whether the query results are grouped by this query result column. This value sets the Column.groupBy property.
			 * @param {Object} [options.context] The field context for values in the query result column. This value sets the Column.context property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS When two mutually arguments are defined
			 * @throws {SuiteScriptError} NEITHER_ARGUMENT_DEFINED When neither of two mandatory arguments is defined
			 * @return {Column}
			 * 
			 * @since 2018.1
			 */
			this.createColumn = function createColumn(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createColumn');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');
				return new Column(options, this);
			};

			/**
			 * Creates a sort based on the query.Component object. The query.Sort object describes a sort that is placed on a particular query result column or condition.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.column The query result column that you want to sort by. This value sets the Sort.column property.
			 * @param {boolean} [options.ascending] Indicates whether the sort direction is ascending. This value sets the Sort.ascending property.
			 * @param {boolean} [options.nullsLast] Where to put results with null value. Defaults to value of ascending flag
			 * @param {boolean} [options.caseSensitive] Indicates whether query results with null values are listed at the end of the query results. This value sets the Sort.nullsLast property.
			 * @param {string} [options.locale] The locale to use for the sort. This value sets the Sort.locale property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object
			 * @return {Sort}
			 *
			 * @since 2018.1
			 */
			this.createSort = function createSort(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createColumn');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');

				var	column = options.column;
				utilityFunctions.checkArgs([column], ['column'], 'Component.createSort');
				if (!(column instanceof Column))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'column', 'Column');

				var locale;
				if (!util.isString(options.locale))
					locale = null;
				else
				{
					queryInternal.validateSortLocale(options.locale);
					locale = options.locale;
				}

				var	ascending = options.ascending == null ? true : !!options.ascending;
				var	nullsLast = options.nullsLast == null ? ascending : !!options.nullsLast;
				var	caseSensitive = !!options.caseSensitive;

				return new Sort(column, ascending, nullsLast, caseSensitive, locale);
			};

			/**
			 * Returns the object type name (query.Component)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: _type,
					source: _source,
					target: _target,
					parent: _parent
				};
			};

			this.getJoins = function getJoins(field, includeRoot)
			{
				var result = field;
				for (var comp = this; (includeRoot ? comp : comp.parent) != null; comp = comp.parent)
				{
					if (comp.source)
						result = comp.type + "<" + comp.source + '.' + result;
					else if (comp.target)
						result = comp.type + "^" + comp.target + '.' + result;
					else
						result = comp.type + '.' + result;
				}
				return String(result);
			}
		}

		Component.prototype = nsobject.getNewInstance();

		/**
		 * Specifies a return column.
		 *
		 * @class Column
		 * @classDescription Encapsulates a query result column.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Column(options, component)
		{
			var TYPE = MOD_PREFIX + 'Column';

			var _fieldId = options.fieldId ? options.fieldId : null;
			var _component = component;
			var _formula = options.formula ? options.formula : null;
			var _type = options.type ? options.type : null;
			var _aggregate = options.aggregate ? options.aggregate : null;
			var _groupBy = options.groupBy === true;
			var _label = options.label;
			var _context = options.context;
			var _alias = options.alias;

			if (_context)
			{
				if (util.isString(_context))
					_context = {name: _context};
				if (!util.isObject(_context))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'context', 'Object');
				utilityFunctions.checkArgs([_context], ['context'], 'Component.createColumn');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(_context.name, 'context.name', util.isString)]);
				if (_context.name == FIELD_CONTEXT.CONVERTED) {
					utilityFunctions.checkArgs([_context.params], ['context.params'], 'Component.createColumn');
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(_context.params, 'context.params', util.isObject)]);
					utilityFunctions.checkArgs([_context.params.currencyId], ['context.params.currencyId'], 'Component.createColumn');
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(_context.params.currencyId, 'context.params.currencyId', util.isNumber)]);
					utilityFunctions.checkArgs([_context.params.date], ['context.params.date'], 'Component.createColumn');
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(_context.params.date, 'context.value.date', function (options) {
						return util.isDate(options) || util.isString(options) || (options instanceof RelativeDate && options.isRange) ||
							(util.isObject(options) && options.dateId);
					})]);
				}
			}
			else
			{
				_context = {name: FIELD_CONTEXT.RAW};
			}
			if (!_fieldId && !_formula)
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'fieldId', 'formula');
			else if (_fieldId && _formula)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'fieldId', 'formula');
			if (_aggregate && _groupBy)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'aggregate', 'groupBy');
			if (_formula && !RETURN_TYPE[_type])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FORMULA_TYPE, _type);
			if (_aggregate && !AGGREGATE[_aggregate])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_AGGREGATE_TYPE, _aggregate);

			/**
			 * Holds the name of the query result column.
			 * @name Column#fieldId
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'fieldId', {
				get: function ()
				{
					return _fieldId;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fieldId');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Represents an alias for this column. An alias is an alternate name for a column, and the alias is used in mapped results.
			 * @name Column#alias
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-string is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'alias', {
				get: function ()
				{
					return _alias;
				},
				set: function (val)
				{
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(val, 'Column.alias', util.isString)]);
					_alias = val;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds a reference to the query.Component object to which this query result column belongs.
			 * @name Column#component
			 * @type {Component}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'component', {
				get: function ()
				{
					return _component;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'component');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes a formula used to create the query result column.
			 * @name Column#formula
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'formula', {
				get: function ()
				{
					return _formula;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the return type of the formula used to create the query result column.
			 * @name Column#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes an aggregate function that is performed on the query result column. An aggregate function performs a calculation on the column values and returns a single value.
			 * @name Column#aggregate
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'aggregate', {
				get: function ()
				{
					return _aggregate;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'aggregate');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the query results are grouped by this query result column.
			 * @name Column#groupBy
			 * @type {Boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'groupBy', {
				get: function ()
				{
					return _groupBy;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'groupBy');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the field context for values in the query result column.
			 * @name Column#context
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'context', {
				get: function ()
				{
					return _context;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'context');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Label.
			 * @name Column#label
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-string is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return _label;
				},
				set: function (val)
				{
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(val, 'Column.label', util.isString)])
					_label = val
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Column)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				var ctx = _context;
				if (ctx && ctx.name == FIELD_CONTEXT.CONVERTED && ctx.params.date instanceof RelativeDate)
					ctx.params.date = ctx.params.date.toJSON();

				return {
					fieldId: _formula ? null : _component ? _component.getJoins(_fieldId, true) : _fieldId,
					component: _component ? _component.toJSON() : null,
					formula: _formula,
					type: _type,
					aggregate: _aggregate,
					groupBy: _groupBy,
					label: _label,
					context: ctx
				};
			};

			this.marshal = function marshal()
			{
				var res = {};
				if (_formula)
				{
					res.formula = _formula;
					if (_type)
						res.type = _type;
				}
				else
				{
					res.name = this.getJoins();
				}
				if (_aggregate)
					res.aggregate = _aggregate;
				if (_groupBy)
					res.groupBy = _groupBy;
				if (_label)
					res.label = _label;
				if (_context)
				{
					if (_context.name == FIELD_CONTEXT.CONVERTED)
					{
						var ctx = _context;
						if (util.isDate(ctx.params.date))
							ctx.params.date = format.format({type: format.Type.DATE, value: ctx.params.date});
						else if (ctx.params.date instanceof RelativeDate)
							ctx.params.date = ctx.params.date.toJSON();
						res.context = ctx;
					}
					else
						res.context = _context;
				}
				if (_component)
				{
					if (_component.target)
						res.target = _component.target;
					if (_component.source)
						res.source = _component.source;
				}
				return res;
			};

			this.getJoins = function getJoins()
			{
				return _component ? _component.getJoins(_fieldId) : _fieldId;
			}
		}

		Column.prototype = nsobject.getNewInstance();

		/**
		 * @class Sort
		 * @classDescription Encapsulates a sort based on the query.Query or query.Component object. The query.Sort object describes a sort that is placed on a particular query result column.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Sort(column, ascending, nullsLast, caseSensitive, locale)
		{
			var TYPE = MOD_PREFIX + 'Sort';

			var _column = column;
			var _ascending = ascending;
			var _nullsLast = nullsLast;
			var _caseSensitive = caseSensitive;
			var _locale = locale;
			/**
			 * Describes the query result column that the query results are sorted by.
			 * @name Sort#column
			 * @type {Column}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'column', {
				get: function ()
				{
					return _column;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'column');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the sort direction is ascending.
			 * @name Sort#ascending
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting wrong sort order is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'ascending', {
				get: function ()
				{
					return _ascending;
				},
				set: function (ascending)
				{
					if (!util.isBoolean(ascending))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'ascending', 'Boolean');
					_ascending = ascending;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the sort is case sensitive.
			 * @name Sort#caseSensitive
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'caseSensitive', {
				get: function ()
				{
					return _caseSensitive;
				},
				set: function (caseSensitive)
				{
					if (!util.isBoolean(caseSensitive))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'caseSensitive', 'Boolean');
					_caseSensitive = caseSensitive;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether query results with null values are listed at the end of the query results.
			 * @name Sort#nullsLast
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'nullsLast', {
				get: function ()
				{
					return _nullsLast;
				},
				set: function (nullsLast)
				{
					if (!util.isBoolean(nullsLast))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'nullsLast', 'Boolean');
					_nullsLast = nullsLast;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Sort locale
			 * @name Sort#locale
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'locale', {
				get: function ()
				{
					return _locale;
				},
				set: function (locale)
				{
					if (!util.isString(locale))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'locale', 'String');
					queryInternal.validateSortLocale(locale);
					_locale = locale;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Sort)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					column: _column ? _column.toJSON() : null,
					ascending: _ascending,
					nullsLast: _nullsLast,
					caseSensitive: _caseSensitive,
					locale: _locale
				};
			};

			this.marshal = function marshal(columns)
			{
				var colOfs = -1;
				for (var i = 0; i < columns.length; i++)
				{
					if (columns[i] === _column)
					{
						colOfs = i;
						break;
					}
				}
				var res = {
					col: colOfs,
					ascending: _ascending,
					caseSensitive: _caseSensitive,
					nullsLast: _nullsLast,
					locale: _locale
				};

				if (_column.component.target)
					res.target = _column.component.target;
				if (_column.component.source)
					res.source = _column.component.source;

				return res;
			};
		}

		Sort.prototype = nsobject.getNewInstance();

		/**
		 * Specifies the condition used to filter the results. It can consist of other Condition objects.
		 * @class Condition
		 * @classDescription A condition narrows the query results. The query.Condition object acts in the same capacity as the search.Filter object in the N/search Module. The primary difference is that query.Condition objects can contain other query.Condition objects.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Condition(children, options, component)
		{
			var TYPE = MOD_PREFIX + 'Condition';

			var undef = undefined;
			var _children = null;
			var _fieldId = null;
			var _op = null;
			var _values = null;
			var _formula = null;
			var _type = null;
			var _aggregate = null;
			var _component = null;

			if (children)
			{
				_children = children;
				_op = options;
			}
			else
			{
				_fieldId = options.fieldId ? options.fieldId : null;
				_op = options.operator ? options.operator : null;
				_values = options.values === undef ? null : options.values;
				_formula = options.formula ? options.formula : null;
				_type = options.type ? options.type : null;
				_aggregate = options.aggregate ? options.aggregate : null;
				_component = component;

				if (!_fieldId && !_formula)
					utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'fieldId', 'formula');
				else if (_fieldId && _formula)
					utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'fieldId', 'formula');
				utilityFunctions.checkArgs([_op], ['operator'], 'Component.createCondition');
				if (!OPERATOR[_op])
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SEARCH_OPERATOR, _op);
				if (_formula && !RETURN_TYPE[_type])
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FORMULA_TYPE, _type);
				if (_aggregate && !AGGREGATE[_aggregate])
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_AGGREGATE_TYPE, _aggregate);

				if (util.isArray(_values))
				{
					for (var i = 0; i < _values.length; i++)
					{
						if (_values[i] === undef)
							_values[i] = null;
					}
				}
				var numValues = util.isArray(_values) ? _values.length : _values === null ? 0 : 1;
				var arity = ALLOWED_ARITY[_op];
				if (numValues + 1 > arity[1] || numValues + 1 < arity[0])
				{
					if (!(numValues == 1 && (_op == "WITHIN" || _op == "WITHIN_NOT") && ((_values instanceof RelativeDate || _values[0] instanceof RelativeDate) || (_values instanceof Period || _values[0] instanceof Period))))
						utilityFunctions.throwSuiteScriptError(error.Type.OPERATOR_ARITY_MISMATCH, _op);
				}
			}

			/**
			 * Holds an array of child conditions used to create the parent condition.
			 * @name Condition#children
			 * @type {Condition[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'children', {
				get: function ()
				{
					return _children;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'children');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds the name of the condition.
			 * @name Condition#fieldId
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'fieldId', {
				get: function ()
				{
					return _fieldId;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fieldId');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds the name of the operator used to create the condition.
			 * @name Condition#operator
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'operator', {
				get: function ()
				{
					return _op;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds an array of values used by an operator to create the condition.
			 * @name Condition#values
			 * @type {string[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return _values;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the formula used to create the condition.
			 * @name Condition#formula
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'formula', {
				get: function ()
				{
					return _formula;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the return type of the formula used to create the condition.
			 * @name Condition#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes an aggregate function that is performed on the condition. An aggregate function performs a calculation on the condition values and returns a single value.
			 * @name Condition#aggregate
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'aggregate', {
				get: function ()
				{
					return _aggregate;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'aggregate');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the component used to created the condition
			 * @name Condition#component
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'component', {
				get: function ()
				{
					return _component;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'component');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Condition)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					children: jsonifyArray(_children),
					fieldId: _fieldId,
					operator: _op,
					formula: _formula,
					type: _type,
					aggregate: _aggregate,
					values: _values,
					component: _component ? _component.toJSON() : null
				};
			};

			this.marshal = function marshal()
			{
				var res = {};
				if (_children)
				{
					res.children = jsonifyArray(_children, true);
					res.operator = _op;
				}
				else
				{
					if (_formula)
					{
						res.formula = _formula;
						res.type = _type;
					}
					else
						res.field = _component ? _component.getJoins(_fieldId) : _fieldId;

					res.operator = _op;
					if (_values instanceof RelativeDate || _values instanceof Period)
						res.values = _values.toJSON();
					else if (util.isDate(_values))
						res.values = format.format({type: format.Type.DATE, value: _values});
					else if (util.isArray(_values))
						res.values = _values.map(function(elem){ return (elem instanceof RelativeDate || elem instanceof Period) ? elem.toJSON() : util.isDate(elem) ? format.format({type: format.Type.DATE, value: elem}) : elem;});
					else
						res.values = _values;

					if (_component)
					{
						if (_component.target)
							res.target = _component.target;
						if (_component.source)
							res.source = _component.source;
					}

					if (_aggregate)
						res.aggregate = _aggregate;
				}
				return res;
			};
		}

		Condition.prototype = nsobject.getNewInstance();

		/**
		 * Set of results returned by the query.
		 * @class ResultSet
		 * @classDescription Encapsulates the set of results returned by the query. Use Query.run() or Query.run.promise() to create this object.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function ResultSet(data, columns)
		{
			var TYPE = MOD_PREFIX + 'ResultSet';

			var _columns = columns;
			var _results = [];
			var _mappedResults = null;
			var _types = [];
			for (var i = 0; i < data.types.length; i++)
				_types.push(data.types[i]);

			var _aliases = data.aliases ? [] : undefined;
			if (_aliases)
			{
				for (var i = 0; i < data.aliases.length; i++)
					_aliases.push(data.aliases[i]);
			}

			for (var i = 0; i < data.count; i++)
				_results.push(new Result(Array.prototype.slice.call(data['v' + i]), _columns, _aliases));

			/**
			 * Standard SuiteScript 2.0 object for iterating through results
			 * @governance 10 units for each page returned
			 * @return {Iterator}
			 *
			 * @since 2018.1
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new ResultsIterator(_results));
			};

			/**
			 * Standard SuiteScript 2.0 object for iterating through results
			 * @return {Object[]}
			 *
			 * @since 2018.1
			 */
			this.asMappedResults = function()
			{
				if (_mappedResults === null)
				{
					_mappedResults = [];
					for (var i in _results)
						_mappedResults.push(_results[i].asMap());
				}
				return _mappedResults;
			};

			/**
			 * Holds an array of query.Result objects.
			 * @name ResultSet#results
			 * @type {Result[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'results', {
				get: function ()
				{
					return _results;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'results' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds an array of the return types for ResultSet.results.
			 * @name ResultSet#types
			 * @type {string[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'types', {
				get: function ()
				{
					return _types;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'types' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds an array of query return column references. The ResultSet.columns array values correspond with the ResultSet.types array values.
			 * @name ResultSet#columns
			 * @type {Column[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.ResultSet)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					columns: _columns,
					types: _types,
					results: _results
				};
			}
		}

		ResultSet.prototype = nsobject.getNewInstance();

		function ResultsIterator(results) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < results.length;
			};

			this.next = function next() {
				return results[i++];
			}
		}
		ResultsIterator.prototype = nsobject.getNewInstance();

		/**
		 * Corresponds to a single row of the ResultSet.
		 * @class Result
		 * @classDescription Encapsulates a single row of the result set (query.ResultSet).
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Result(values, columns, aliases)
		{
			var TYPE = MOD_PREFIX + 'Result';

			var _values = values;
			var _mappedValues = null;

			this.getValue = function getValue(options)
			{
				return _values[options];
			};

			/**
	         * Returns the query result as a mapped result. A mapped result is a JavaScript object with key-value pairs. In this object, the key is either the field ID or the alias that was used for the corresponding query.Column object.
	         * @return {Object}
			 *
	         * @since 2019.2
	         */
			this.asMap = function()
			{
				if (_mappedValues === null)
				{
					if (columns)
					{
						_mappedValues = {};
						for (var i in columns)
						{
							var column = columns[i];
							var alias = column.alias || column.fieldId;
							if (!alias)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_MISSING_ALIAS);
							else if (_mappedValues[alias] !== undefined)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_DUPLICATE_ALIAS, alias);
							else
								_mappedValues[alias] = _values[i];
						}
					}
					else if (aliases)
					{
						_mappedValues = {};
						for (var i in aliases)
						{
							var alias = aliases[i];
							if (_mappedValues[alias] !== undefined)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_DUPLICATE_ALIAS, alias);
							_mappedValues[alias] = _values[i];
						}
					}
				}
				return _mappedValues;
			};

			/**
			 * Describes the result values. Value types correspond to the ResultSet.types property. Array values correspond to the array values for ResultSet.columns.
			 * @name Result#values
			 * @type {string[]|number[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return _values;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Result)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					values: _values
				};
			};
		}

		Result.prototype = nsobject.getNewInstance();

		function createQuery(options)
		{
			var type = (options && options.hasOwnProperty('type')) ? options.type : options;
			utilityFunctions.checkArgs([type], ['type'], 'createQuery');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.type', util.isString)]);
			queryInternal.validateSearchType(type);
			var result = new Query(type);
			if (util.isObject(options.condition))
				result.condition = result.createCondition(options.condition);
			if (util.isArray(options.columns))
			{
				var cols = [];
				for (var i in options.columns)
					cols.push(result.createColumn(options.columns[i]));
				result.columns = cols;
			}
			if (util.isArray(options.sort))
			{
				var sorts = [];
				for (var i in options.sort)
				{
					var sort = options.sort[i];
					sort.column = result.createColumn(sort);
					sorts.push(result.createSort(sort));
				}
				result.sort = sorts;
			}
			return result;
		}

		/**
		 * Object for handling paged queries
		 * @class PagedData
		 * @classDescription Encapsulates a set of paged query results. This object also contains information about the set of paged results it encapsulates.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function PagedData(options)
		{
			var TYPE = MOD_PREFIX + 'PagedData';

			var pageSize = options.pageSize;
			var query = options.queryDefinition;
			var queryData = options.queryData;
			var columns = options.columns;
			var pageRanges = function()
			{
				var ranges = [];
				for (var i = 0; i < queryData.numPages; i++)
					ranges.push(new PageRange({index:i, size: pageSize > 0 ? pageSize * (i + 1) > queryData.total ? queryData.total % pageSize : pageSize : 0}));
				return ranges;
			}();

			function validateAndGetIndex(options, length)
			{
				var index = (options && options.hasOwnProperty('index')) ? options.index : options;
				utilityFunctions.checkArgs([index], ['index'], 'PagedData.fetch');
				index = parseInt(index);
				if (isNaN(index))
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);
				if(index < 0 || index >= length)
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch');
				return index;
			}

			/**
			 * Get page with given index
			 * @param {Object} options
			 * @param {string} options.index Index of page to return
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 * @governance 10 units
			 *
			 * @return {Page}
			 */
			this.fetch = function(options)
			{
				var index = validateAndGetIndex(options, queryData.pages.length);
				return new Page({resultSet: new ResultSet(util.isObject(query) ? invoker(queryApi, 'getSuiteQLQueryPage', [queryData.pages[index], query.query, JSON.stringify(query.params ? query.params : []), JSON.stringify(query.columns ? query.columns.map(function(column){return column.marshal()}) : []), query.type ? query.type : null]) : invoker(queryApi, 'getQueryPage', [queryData.pages[index], query]), columns), index: index, size: pageSize, total: queryData.total, pagedData: this, pageRange: pageRanges[index]});
			};

			function pagedPromise(query, queryData, columns, pageSize, options)
			{
				var pagedData = this;
				return new Promise(
					function(resolve, reject) {
						try {
							var index = validateAndGetIndex(options, queryData.pages.length);
							if (util.isObject(query))
								invoker(queryApi, 'getSuiteQLQueryPage', [queryData.pages[index], query.query, JSON.stringify(query.params ? query.params : []), JSON.stringify(columns ? columns.map(function(column){return column.marshal()}) : []), query.type ? query.type : null], callback);
							else
								invoker(queryApi, 'getQueryPage', [queryData.pages[index], query], callback);
						}
						catch (e) {
							reject(e);
						}

						function callback(result, exception) {
							if (exception) {
								reject(exception);
								return;
							}
							try {
								resolve(new Page({resultSet:new ResultSet(result, columns), index: index, size: pageSize, total: queryData.total, pagedData: pagedData, pageRange: pageRanges[index]}));
							}
							catch (e) {
								reject(e);
							}
						}
					}
				);
			}

			/**
			 * Asynchronously get page with given index
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.index Index of page to return
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 *
			 * @return {Promise}
			 *
			 * @since 2018.1
			 */
			this.fetch.promise = pagedPromise.bind(this, query, queryData, columns, pageSize);

			/**
			 * Standard object for iterating through pages.
			 * @governance 10 units for each page returned
			 * @return {Iterator}
			 *
			 * @since 2018.1
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new PageIterator(this, queryData));
			};

			/**
			 * Size of the page
			 * @name PageData#pageSize
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pageSize', {
				get: function ()
				{
					return pageSize;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Total number of results
			 * @name PagedData#count
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'count', {
				get: function ()
				{
					return queryData.total;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'totalResults' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/*
			 * Stringified definition of underlying query
			 * @name PagedData#queryDefinition
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'queryDefinition', {
				get: function ()
				{
					return query;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'queryDefinition' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * PageRanges of PagedData
			 * @name PagedData#pageRanges
			 * @type {PageRange[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pageRanges', {
				get: function ()
				{
					return pageRanges;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.PagedData)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					pageRanges: pageRanges,
					count: queryData.total,
					pageSize: pageSize,
					queryDefinition: query
				};
			};
		}

		PagedData.prototype = nsobject.getNewInstance();

		function PageIterator(query, queryData) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < queryData.numPages;
			};

			this.next = function next() {
				return query.fetch(i++);
			}
		}

		PageIterator.prototype = nsobject.getNewInstance();

		/**
		 * PageRange object
		 * @class PageRange
		 * @classDescription Encapsulates the range of query results for a page.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function PageRange(options)
		{
			var index = options.index;
			var size = options.size;
			/**
			 * Describes the array index for this page range.
			 * @name PageRange#index
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'index', {
				get: function ()
				{
					return index;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of results in this page range
			 * @name PageRange#size
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return size;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
		}

		/**
		 * Object corresponding to one page of results
		 * @class Page
		 * @classDescription One page of the paged query results.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Page(options)
		{
			var TYPE = MOD_PREFIX + 'Page';

			var resultSet = options.resultSet;
			var pagedData = options.pagedData;
			var pageRange = options.pageRange;
			var isFirst = !!pageRange && pageRange.index == 0;
			var isLast = !!pageRange && pagedData.pageRanges[pagedData.pageRanges.length - 1] == pageRange;

			/**
			 * ResultSet of the page
			 * @name Page#data
			 * @type {ResultSet}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'data', {
				get: function ()
				{
					return resultSet;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * References the query results contained in this page.
			 * @name QueryPage#pagedData
			 * @type {PagedData}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pagedData', {
				get: function ()
				{
					return pagedData;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedData' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The range of query results for this page.
			 * @name QueryPage#pageRange
			 * @type {PageRange}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pageRange', {
				get: function ()
				{
					return pageRange;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the page is the first of the paged query results.
			 * @name Page#isFirst
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'isFirst', {
				get: function ()
				{
					return isFirst;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indication whether this page is the last one
			 * @name Page#isLast
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'isLast', {
				get: function ()
				{
					return isLast;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Page)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};
			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					pagedData: pagedData,
					data: resultSet,
					isFirst: isFirst,
					isLast: isLast,
					pageRange: pageRange
				};
			};
		}

		Page.prototype = nsobject.getNewInstance();

		function handleJoins(fieldId, joinsMap, search)
		{
			var joins = fieldId.split(".");
			var lastJoin = search;
			var joinId = "";
			if (joins.length > 1) {
				for (var j = 0; j < joins.length - 1; j++) {
					var join = joins[j];
					joinId += join;
					var sourcePos = join.indexOf("<");
					var targetPos = join.indexOf("^");
					if (sourcePos > 0) {
						var field = join.substr(0, sourcePos);
						var src = join.substr(sourcePos + 1);
						if (!joinsMap[joinId])
							joinsMap[joinId] = lastJoin.joinFrom({fieldId: field, source: src});
					}
					else if (targetPos > 0) {
						var field = join.substr(0, targetPos);
						var tgt = join.substr(targetPos + 1);
						if (!joinsMap[joinId])
							joinsMap[joinId] = lastJoin.joinTo({fieldId: field, target: tgt});
					}
					else if (!joinsMap[joinId])
						joinsMap[joinId] = lastJoin.autoJoin({fieldId: join});

					lastJoin = joinsMap[joinId];
					joinId += ".";
				}
			}
			return {join: lastJoin, fieldId: joins[joins.length -1]};
		}

		function listTables(options)
		{
			var id = listTablesPreProcess(options);
			var useString = invoker(queryApi, 'listTables', [id], utilityFunctions.isPromiseCallback(this) ? this : undefined);
			if (!utilityFunctions.isPromiseCallback(this))
				return useString;
		}

		function listTablesPreProcess(options)
		{
			var workbookId = (options && options.hasOwnProperty('workbookId')) ? options.workbookId : options;
			utilityFunctions.checkArgs([workbookId], ['workbookId'], 'query.listTables');
			if (!util.isString(workbookId))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'workbookId', 'string');
			return workbookId;
		}

		/**
		 * Asynchronously lists table views for specified workbook
		 * @governance 5 units
		 * @typedef {Object} TableDefinition
		 * @property {string} name - Name of the table view
		 * @property {string} scriptId - Script id of the table view
		 * @param {string} workbookId Script id of a workbook
		 * @return {TableDefinition[]} Array of table views present in workbook with given script id
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If workbookId parameter is missing
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If workbookId parameter isn't string
		 *
		 * @since 2020.1
		 */
		listTables.promise = function()
		{
			return utilityFunctions.promiseTo(listTables, arguments);
		};

		function loadQuery(options)
		{
			var id = loadPreProcess(options);
			var data = invoker(queryApi, 'loadSearch', [id]);
			return loadPostProcess(data, id);
		}

		function loadPreProcess(options)
		{
			var id = (options && options.hasOwnProperty('id')) ? options.id : options;
			utilityFunctions.checkArgs([id], ['id'], 'query.load');
			if (!util.isString(id))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'String');
			return id;
		}

		function loadPostProcess(data, id)
		{
			var search = new Query(data.type, id, data.name);
			var joinsMap = {};
			var columnMap = {};

			for (var i = 0; i < data.columns.length; i++)
			{
				var column = data.columns[i];
				if (column.formula)
				{
					var col = search.createColumn({formula: column.formula, type: column.type, aggregate: column.aggregate, groupBy: column.groupBy, label: column.label});
					search.columns.push(col);
					columnMap[column.formula] = col;
				}
				else
				{
					var handle = handleJoins(column.fieldId, joinsMap, search);
					var col = handle.join.createColumn({fieldId: handle.fieldId,  aggregate: column.aggregate, groupBy: column.groupBy, label: column.label, context: column.context});
					search.columns.push(col);
					columnMap[column.fieldId] = col;
				}
			}

			for (var i = 0; i < data.sorts.length; i++)
			{
				var column = data.sorts[i].column;
				var direction = data.sorts[i].direction;
				var ascending, nullsLast, caseSensitive, locale;

				if (direction == "DESCENDING_NULLS_LAST")
				{
					ascending = false;
					nullsLast = true;
				}
				else if (direction == "DESCENDING")
				{
					ascending = false;
					nullsLast = false;
				}
				else if (direction == "ASCENDING_NULLS_FIRST")
				{
					ascending = true;
					nullsLast = false;
				}
				else
				{
					ascending = true;
					nullsLast = true;
				}
				caseSensitive = data.sorts[i].caseSensitive;
				locale = data.sorts[i].locale;

				if (column.formula)
				{
					if (columnMap[column.formula])
						search.sort.push(search.createSort({column: columnMap[column.formula], ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					else
					{
						var sortCol = search.createColumn({formula: column.formula, type: column.type, aggregate: column.aggregate, groupBy: column.groupBy});
						search.sort.push(search.createSort({column: sortCol, ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					}
				}
				else
				{
					var handle = handleJoins(column.fieldId, joinsMap, search);
					if (columnMap[handle.fieldId])
						search.sort.push(handle.join.createSort({column: columnMap[handle.fieldId], ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					else
					{
						var sortCol = handle.join.createColumn({fieldId: handle.fieldId, aggregate: column.aggregate,	groupBy: column.groupBy});
						search.sort.push(search.createSort({column: sortCol, ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					}
				}
			}

			search.condition = data.condition != null ? loadCondition(data.condition, joinsMap, search) : null;

			return search;
		}

		function promiseToLoad(options)
		{
			var id = loadPreProcess(options);
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'loadSearch', [id], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							var query = loadPostProcess(result, id);
							resolve(query);
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		/**
		 * Asynchronously loads an existing query as a query.Query object.
		 * @governance 5 units
		 * @param {Object} options The options object.
		 * @param {string} options.id The script ID of the query to load.
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
		 * @throws {SuiteScriptError} A query with the specified ID cannot be loaded because the query does not exist or you do not have permission to load it.
		 * @return {Promise}
		 *
		 * @since 2019.2
		 */
		loadQuery.promise = promiseToLoad;

		function loadCondition(condition, joinsMap, search)
		{

			var components = [];
			if (condition.children)
			{
				for (var i in condition.children)
				{
					var nestedCondition = loadCondition(condition.children[i], joinsMap, search);
					if (nestedCondition !== null)
						components.push(nestedCondition);
				}
			}
			if (condition.filters)
			{
				for (var i in condition.filters)
				{
					var vals = condition.filters[i].values;
					if (util.isArray(vals))
					{
						var newVals = [];
						for (var j = 0; j < vals.length; j++)
						{
							if (util.isObject(vals[j]) && vals[j].hasOwnProperty("dateId") && !vals[j].hasOwnProperty("type"))
								newVals.push(new RelativeDate(vals[j].dateId, vals[j].value));
							else if (util.isObject(vals[j]) && vals[j].hasOwnProperty("adjustment"))
								newVals.push(new Period(vals[j].code, vals[j].type, vals[j].adjustment));
							else
								newVals.push(vals[j]);
						}
						vals = newVals;
					}
					else if (util.isObject(vals) && vals.hasOwnProperty("dateId") && !vals[j].hasOwnProperty("type"))
						vals = new RelativeDate(vals.dateId, vals.value);
					if (util.isObject(vals[j]) && vals[j].hasOwnProperty("adjustment"))
						vals = new Period(vals.code, vals.type, vals.adjustment);

					if (condition.filters[i].formula)
					{
						var filter = search.createCondition({formula: condition.filters[i].formula, values: vals, operator: condition.filters[i].operator, type: condition.filters[i].type, aggregate: condition.filters[i].aggregate});
						components.push(filter);
					}
					else
					{
						var handle = handleJoins(condition.filters[i].fieldId, joinsMap, search);
						var filter = handle.join.createCondition({fieldId: handle.fieldId, values: vals, operator: condition.filters[i].operator, aggregate: condition.filters[i].aggregate});
						components.push(filter);
					}
				}
			}
			if (components.length == 0)
				return null;
			else if (components.length == 1)
				return components[0];

			var rc = condition.operator === "AND" ? search.and(components) : search.or(components);
			if (condition.negation)
				rc = search.not(rc);
			return rc;
		}

		function deleteQuery(options)
		{
			var id = deletePreProcess(options);
			invoker(queryApi, 'deleteSearch', [id]);
		}

		function deletePreProcess(options)
		{
			var id = (options && options.hasOwnProperty('id')) ? options.id : options;
			utilityFunctions.checkArgs([id], ['id'], 'query.delete');

			if (!util.isString(id))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'String');
			return id;
		}

		function promiseToDelete(options)
		{
			var id = deletePreProcess(options);
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'deleteSearch', [id], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							resolve(result);
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		/**
		 * Asynchronously deletes query by id
		 * @governance 5 units
		 * @param {Object} options
		 * @param {string} options.id Id of query to be delete
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
		 * @throws {SuiteScriptError} UNABLE_TO_DELETE_QUERY A query with the specified ID cannot be deleted because the query does not exist or you do not have permission to delete it.
		 * @return {Promise}
		 *
		 * @since 2018.2
		 */
		deleteQuery.promise = promiseToDelete;

		function runSuiteQL(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQL");
			var input = preProcessFunction(options);
			return runSuiteQLInternal(input.query, input.params);
		}

		function runSuiteQLInternal(query, params, columns, type)
		{
			var data = invoker(queryApi, 'runSuiteQL', [query, JSON.stringify(params ? params : []), JSON.stringify(columns ? columns.map(function(column){return column.marshal()}) : []), type ? type : null]);
			return new ResultSet(data, columns);
		}

		function runSuiteQLPaged(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQLPaged");
			var input = preProcessFunction(options);
			var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
			return runSuiteQLPagedInternal(pageSize, input.query, input.params);
		}

		function runSuiteQLPagedInternal(pageSize, query, params, columns, type)
		{
			var size = pagingUtil.regulatePageSize(pageSize);
			var queryData = invoker(queryApi, "suiteQLPagedQuery", [size, query, JSON.stringify(params ? params : [])]);
			return new PagedData({
				pageSize: size,
				queryDefinition: {query: query, params: params, columns: columns, type:type},
				queryData: queryData,
				columns: columns
			});
		}

		function runSuiteQLPreProcess(options)
		{
			utilityFunctions.checkArgs([options], ['options'], this);
			var query = (options && options.hasOwnProperty('query')) ? options.query : options;
			var params = (options && options.hasOwnProperty('params')) ? options.params : [];
			utilityFunctions.checkArgs([query], ['query'], this);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(query, 'options.query', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(params, 'options.params', util.isArray)]);
			for (var i in params)
			{
				if (!util.isNumber(params[i]) && !util.isString(params[i]) && !util.isBoolean(params[i]))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options.params[' + i + ']');
			}
			return {
				query: query,
				params: params
			}
		}

		function promiseToRunSuiteQL(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQL");
			var input = preProcessFunction(options);
			return promiseToRunSuiteQLInternal(input.query, input.params)
		}

		function promiseToRunSuiteQLInternal(query, params, columns, type)
		{
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'runSuiteQL', [query, JSON.stringify(params ? params : []), JSON.stringify(columns ? columns.map(function(column){return column.marshal()}) : []), type ? type : null], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							resolve(new ResultSet(result, columns));
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		function promiseToRunSuiteQLPaged(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQLPaged");
			var input = preProcessFunction(options);
			var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
			return promiseToRunSuiteQLPagedInternal(pageSize, input.query, input.params);
		}

		function promiseToRunSuiteQLPagedInternal(pageSize, query, params, columns, type)
		{
			var size = pagingUtil.regulatePageSize(pageSize);
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'suiteQLPagedQuery', [size, query, JSON.stringify(params ? params : [])], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							resolve(new PagedData({
								pageSize: size,
								queryDefinition: {query: query, params: params, columns: columns, type:type},
								queryData: result,
								columns: columns
							}));
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		/**
		 * Asynchronously runs suiteQL query, parameter can be string, suiteQL object or object containing properties query and (optionally) params
		 * @governance 10 units
		 * @param {Object} options
		 * @param {String} options.query String representation of SuiteQL query
		 * @param {string[]|number[]|boolean[]} [options.params]
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
		 * @return {Promise}
		 *
		 * @since 2019.2
		 */
		runSuiteQL.promise = promiseToRunSuiteQL;
		/**
		 * Asynchronously execute the suiteQL query and return paged results.
		 * @governance 10 units
		 * @param {Object} options
		 * @param {String} options.query String representation of SuiteQL query
		 * @param {string[]|number[]|boolean[]} [options.params]
		 * @return {Promise}
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
		 *
		 * @since 2020.1
		 */
		runSuiteQLPaged.promise = promiseToRunSuiteQLPaged;

		function createRelativeDate(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'query.createRelativeDate');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			var dateId = options.dateId;
			var value = options.value;
			utilityFunctions.checkArgs([dateId], ['dateId'], 'query.createRelativeDate');
			utilityFunctions.checkArgs([value], ['value'], 'query.createRelativeDate');
			utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(relativeDateCodes, dateId, false), error.Type.INVALID_DATE_ID, dateId);
			if (!util.isNumber(value))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'value', 'number');
			return new RelativeDate(dateId, value);
		}

		function createPeriod(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'query.createPeriod');
			var code, type, adjustment;
			if (util.isString(options))
			{
				code = options;
				type = PERIOD_TYPE.START;
				adjustment = PERIOD_ADJUSTMENT.NOT_LAST;
			}
			else
			{
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.code], ['options.code'], 'query.createPeriod');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.code, 'options.code', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.type, 'options.type', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.adjustment, 'options.adjustment', util.isString)]);
				code = options.code;
				type = options.type || PERIOD_TYPE.START;
				adjustment = options.adjustment || PERIOD_ADJUSTMENT.NOT_LAST;
			}

			if (type != PERIOD_TYPE.START && type != PERIOD_TYPE.END)
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PERIOD_TYPE, type);
			if (adjustment != PERIOD_ADJUSTMENT.NOT_LAST && adjustment != PERIOD_ADJUSTMENT.ALL)
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PERIOD_ADJUSTMENT, adjustment);
			utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(periodCodes, code, false), error.Type.INVALID_PERIOD_CODE, code);
			return new Period(code, type, adjustment);
		}

		return Object.freeze({
			/**
			 * Creates a query.Query object.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.type The query type that you want to use for the initial query definition.
			 * @param {Object[]} [options.columns] Array of objects to be used as query columns (createColumn method will be called on all of them).
			 * @param {Object[]} [options.sort] Array of objects representing sort options (createColumn and createSort methods will be called on all of them).
			 * @param {Object} [options.condition] Condition of query (createCondition method will be called on supplied object).
			 * @return {Query}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or type are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 * @throws {SuiteScriptError} INVALID_RCRD_TYPE The specified query type is invalid.
			 *
			 * @since 2018.1
			 */
			create: createQuery,
			/**
			 * Runs suiteQL query, parameter can be string, suiteQL object or object containing properties query and (optionally) params
			 * @governance 10 units
			 * @param {Object} options
			 * @param {String} options.query String representation of SuiteQL query
			 * @param {string[]|number[]|boolean[]} [options.params]
			 * @return {ResultSet}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
			 *
			 * @since 2018.2
			 */
			runSuiteQL: runSuiteQL,

			/**
			 * Execute the suiteQL query and return paged results.
			 * @governance 10 units
			 * @param {Object} options
			 * @param {String} options.query String representation of SuiteQL query
			 * @param {string[]|number[]|boolean[]} [options.params]
			 * @return {PagedData}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
			 *
			 * @since 2020.1
			 */
			runSuiteQLPaged: runSuiteQLPaged,

			/**
			 * Loads an existing query as a query.Query object.
			 * @governance 5 units
			 * @param {Object} options The options object.
			 * @param {string} options.id The script ID of the query to load.
			 * @return {Query}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 * @throws {SuiteScriptError} A query with the specified ID cannot be loaded because the query does not exist or you do not have permission to load it.
			 *
			 * @since 2018.1
			 */
			load: loadQuery,
			/**
			 * Lists table views for specified workbook
			 * @governance 5 units
			 * @typedef {Object} TableDefinition
			 * @property {string} name - Name of the table view
			 * @property {string} scriptId - Script id of the table view
			 * @param {string} workbookId Script id of a workbook
			 * @return {TableDefinition[]} Array of table views present in workbook with given script id
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If workbookId parameter is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If workbookId parameter isn't string
			 *
			 * @since 2020.1
			 */
			listTables: listTables,

			/**
			 * Deletes query by id
			 * @governance 5 units
			 * @param {Object} options
			 * @param {string} options.id Id of query to be delete
			 * @return {void}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 * @throws {SuiteScriptError} UNABLE_TO_DELETE_QUERY A query with the specified ID cannot be deleted because the query does not exist or you do not have permission to delete it.
			 *
			 * @since 2018.2
			 */
			'delete': deleteQuery,

			/**
			 * Creates a query.RelativeDate object that represents a date relative to the current date.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.dateId The ID of the relative date to create.
			 * @param {number} options.value The value to use to create the relative date.
			 * @return {RelativeDate}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 *
			 * @since 2019.2
			 */
			createRelativeDate: createRelativeDate,

			/**
			 * Creates a query.Period object, which can be used as a filter value
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.code code of the period
			 * @param {string} [options.type] type of the period
			 * @param {string} [options.adjustment] adjustment of the period
			 * @return {Period}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or code are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If any of the parameters is not string
			 * @throws {SuiteScriptError} INVALID_PERIOD_TYPE If type is a value outside of PeriodType enum
			 * @throws {SuiteScriptError} INVALID_PERIOD_ADJUSTMENT If adjustment is a value outside of PeriodAdjustment enum
			 * @throws {SuiteScriptError} INVALID_PERIOD_CODE If code is a value outside of PediodCode enum
			 *
			 * @since 2020.1
			 */
			createPeriod: createPeriod,

			/**
			 * Holds the string values for operators supported with the N/query Module. This enum is used to pass the operator argument to Query.createCondition(options) and Component.createCondition(options).
			 * @enum {string}
			 * @readonly
			 */
			Operator: OPERATOR,

			/**
			 * Holds the string values for aggregate functions supported with the N/query Module. An aggregate function performs a calculation on the column or condition values and returns a single value.
			 * @enum {string}
			 * @readonly
			 */
			Aggregate: AGGREGATE,

			/**
			 * Holds the string values for the formula return types supported with the N/query Module.
			 * @enum {string}
			 * @readonly
			 */
			ReturnType: RETURN_TYPE,

			/**
			 * Holds query.RelativeDate object values for supported date ranges in relative dates.
			 * @enum {string}
			 * @readonly
			 */
			RelativeDateRange: Object.freeze(RELATIVE_DATE_RANGES),

			/**
			 * Holds the string values for supported date codes in relative dates.
			 * @enum {string}
			 * @readonly
			 */
			DateId: DATE_ID,

			/**
			 * Holds the string values for the field context to use when creating a column using Query.createColumn(options) or Component.createColumn(options).
			 * @enum {string}
			 * @readonly
			 */
			FieldContext: FIELD_CONTEXT,

			/**
			 * Holds the string values for possible period types (START, END)
			 * @enum {string}
			 * @readonly
			 */
			PeriodType: PERIOD_TYPE,
			/**
			 * Holds the string values for possible period adjustments (NOT_LAST, ALL)
			 * @enum {string}
			 * @readonly
			 */
			PeriodAdjustment: PERIOD_ADJUSTMENT,
			/**
			 * Holds the string values for possible period codes
			 * @enum {string}
			 * @readonly
			 */
			PeriodCode: PERIOD_CODE,

			/**
			 * Holds the string values for sort locales supported with the N/query Module. This enum is used to pass the locale argument to Query.createSort(options) and Component.createSort(options).
			 * @enum {string}
			 * @readonly
			 */
			get SortLocale()
			{
				return queryInternal.getSortLocales();
			},

			/**
			 * Holds the string values for query types used in the query definition. This enum is used to pass the initial query type argument to query.create(options).
			 * @enum {string}
			 * @readonly
			 */
			get Type()
			{
				return queryInternal.getSearchTypes();
			}
		});
	});

/**
 * @private
 */
define('N/restricted/scriptArguments',[], function (){ return {}; });

/**
 * @private
 */
define('N/restricted/fileApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript file module
 *
 * @module N/file
 * @NApiVersion 2.x
 *
 */
define('N/file',['N/restricted/fileApi', 'N/error', 'N/nsobject', 'N/utilityFunctions', 'N/restricted/invoker','N/creationFunctionWrapper', 'N/common/pattern/iterator'],
	function (fileApi, error, nsobject, utilityFunctions, invoker, funcWrapper, iteratorFactory)
	{
		//enums
		var FILE_TYPES = Object.freeze({
			APPCACHE: 'APPCACHE',
			AUTOCAD: 'AUTOCAD',
			BMPIMAGE: 'BMPIMAGE',
			CERTIFICATE : 'CERTIFICATE',
			CONFIG : 'CONFIG',
			CSV: 'CSV',
			EXCEL: 'EXCEL',
			FLASH: 'FLASH',
			FREEMARKER: 'FREEMARKER',
			GIFIMAGE: 'GIFIMAGE',
			GZIP: 'GZIP',
			HTMLDOC: 'HTMLDOC',
			ICON: 'ICON',
			JAVASCRIPT: 'JAVASCRIPT',
			JPGIMAGE: 'JPGIMAGE',
			JSON: 'JSON',
			MESSAGERFC: 'MESSAGERFC',
			MP3: 'MP3',
			MPEGMOVIE: 'MPEGMOVIE',
			MSPROJECT: 'MSPROJECT',
			PDF: 'PDF',
			PJPGIMAGE: 'PJPGIMAGE',
			PLAINTEXT: 'PLAINTEXT',
			PNGIMAGE: 'PNGIMAGE',
			POSTSCRIPT: 'POSTSCRIPT',
			POWERPOINT: 'POWERPOINT',
			QUICKTIME: 'QUICKTIME',
			RTF: 'RTF',
			SCSS: 'SCSS',
			SMS: 'SMS',
			STYLESHEET: 'STYLESHEET',
			SVG : 'SVG',
			TAR: 'TAR',
			TIFFIMAGE: 'TIFFIMAGE',
			VISIO: 'VISIO',
			WEBAPPPAGE: 'WEBAPPPAGE',
			WEBAPPSCRIPT: 'WEBAPPSCRIPT',
			WORD: 'WORD',
			XMLDOC: 'XMLDOC',
			XSD : 'XSD',
			ZIP: 'ZIP'
		});
		var ENCODINGS = Object.freeze({
			UTF_8: 'UTF-8',
			WINDOWS_1252: 'windows-1252',
			ISO_8859_1: 'ISO-8859-1',
			GB18030: 'GB18030',
			SHIFT_JIS: 'SHIFT_JIS',
			MAC_ROMAN: 'MacRoman',
			GB2312: 'GB2312',
			BIG5: 'Big5'
		});

		var fileLinesObjectsCreated = [];
		var fileSegmentsObjectsCreated = [];
		var fileReaderObjectsCreated = [];

		/**
		 * Return a new instance of file.File used for accessing and manipulating files in the file cabinet.
		 *
		 * @protected
		 * @class File
		 * @classdesc Encapsulation of files (media items) in the file cabinet.
		 * @alias file.File
		 *
		 * @since 2015.2
		 */
		function File(delegate, folder)
		{
			var TYPE = 'file.File';
			/**
			 The id of the file (if stored in the FC).
			 * @name File#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return delegate.getId();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The size of the file in bytes.
			 * @name File#size
			 * @type number
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return delegate.getSize();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 Return the URL of the file (if stored in the FC).
			 * @name File#url
			 * @type string
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'url', {
				get: function ()
				{
					return delegate.getURL();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'url');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The path to the file in the file cabinet.
			 * @name File#path
			 * @type string
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'path', {
				get: function ()
				{
					return delegate.getPath();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'path');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The type of the file.
			 * @name File#fileType
			 * @type string
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'fileType', {
				get: function ()
				{
					return delegate.getType();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fileType');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 * Indicates whether or not the file is text-based or binary.
			 * @name File#isText
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'isText', {
				get: function ()
				{
					return delegate.isText();
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isText');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 * The character encoding for the file.
			 * @name File#encoding
			 * @type string
			 */
			Object.defineProperty(this, 'encoding', {
				get: function ()
				{
					return delegate.getEncoding();
				},
				set: function (val)
				{
					delegate.setEncoding(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The name of the file.
			 * @name File#name
			 * @type string
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return delegate.getName();
				},
				set: function (val)
				{
					delegate.setName(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The internal ID of the folder that this file is in.
			 * @name File#folder
			 * @type number
			 */
			Object.defineProperty(this, 'folder', {
				get: function ()
				{
					return delegate.getFolder();
				},
				set: function (val)
				{
					var folder = util.isString(val) ? parseInt(val, 10) : val;
					delegate.setFolder(folder);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file description.
			 * @name File#description
			 * @type string
			 */
			Object.defineProperty(this, 'description', {
				get: function ()
				{
					return delegate.getDescription();
				},
				set: function (val)
				{
					delegate.setDescription(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file's inactive status.
			 * @name File#isInactive
			 * @type boolean
			 */
			Object.defineProperty(this, 'isInactive', {
				get: function ()
				{
					return delegate.isInactive();
				},
				set: function (val)
				{
					delegate.setIsInactive(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file's "Available without Login" status.
			 * @name File#isOnline
			 * @type boolean
			 */
			Object.defineProperty(this, 'isOnline', {
				get: function ()
				{
					return delegate.isOnline();
				},
				set: function (val)
				{
					delegate.setIsOnline(val);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * @name File#lines
			 * @type {Iterator} iterator - Iterator which provides the next line of text from the text file to the iterator function.
			 *      <pre> file.lines.iterator().each(function(lineContext){...}); </pre>
			 *
			 * @throws {SuiteScriptError} YOU_CANNOT_READ_FROM_A_FILE_AFTER_YOU_BEGAN_WRITING_TO_IT if you call after having called appendLine
			 * @readonly
			 */
			Object.defineProperty(this, 'lines', {
				get: function ()
				{
					return Object.freeze({
						iterator: function iterator()
						{
							var fileContents = invoker(delegate, 'createStreamingFileContents', []);
							var fileLines = new FileLines(fileContents);
							fileLinesObjectsCreated.push(fileLines);
							return iteratorFactory.create(fileLines);
						}
					});
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'output');
				},
				enumerable: true,
				configurable: false
			});


			/*
			 * Helper function for http.writeFile()
			 */
			Object.defineProperty(this, '_writeTo', {
				set: function (val)
				{
					invoker(val.delegate, 'writeFile', [delegate, val.isInline ? true : false]);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});
			/*
			 * Helper function for task.CsvImportTask
			 */
			Object.defineProperty(this, '_sd', {
				set: function (val)
				{
					if (val.toString() === 'task.CsvImportTask')
						val._fd = delegate;
					else if (val.toString() === 'FileDelegateContainer')
						val.set(delegate);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * Helper function for sftp.upload
			 */
			Object.defineProperty(this, '_upload', {
				set: function (val)
				{
					invoker(val.delegate, 'upload', [delegate, val.filename, val.directory, val.timeout, val.replace])
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * Helper function for bank connectivity
			 */
			Object.defineProperty(this, '_saveBankStatementFile', {
				set: function (val)
				{
					invoker(val.delegate, 'saveBankStatementFile', [delegate, val.bankStatementFormat])
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns iterator of segments delimited by separator
			 * @param {Object} options
			 * @param {string} options.separator
			 * @return {Iterator}
			 */
			this.getSegments = function getContents(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.getSegments');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject)]);
				var separator = options.separator;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(separator, 'options.separator', util.isString)]);
				if (separator === "")
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SEGMENT_SEPARATOR);
				return Object.freeze({
					iterator: function iterator()
					{
						var fileContents = invoker(delegate, 'createStreamingFileContents', []);
						var fileSegments = new FileSegments(fileContents, separator);
						fileSegmentsObjectsCreated.push(fileSegments);
						return iteratorFactory.create(fileSegments);
					}
				});
			};

			/**
			 * Returns reader object for performing special read operations
			 * @return {Reader}
			 */
			this.getReader = function getReader()
			{
				var fileContents = invoker(delegate, 'createStreamingFileContents', []);
				var reader = new Reader(fileContents);
				fileReaderObjectsCreated.push(reader);
				return reader;
			};

			/**
			 * Return the value (Base64 encoded for binary types) of the file.
			 * Note: Contents are lazy loaded and must be less than 10MB in size in order to access.
			 *
			 * @throws {SuiteScriptError} SSS_FILE_CONTENT_SIZE_EXCEEDED when trying to get contents of a file larger than 10MB
			 *
			 * @return {string}
			 */
			this.getContents = function getContents()
			{
				return invoker(delegate, 'getValue', []);
			};

			/**
			 * Add/update a file in the file cabinet based on the properties of this object.
			 *
			 * @governance 20 units
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when the folder property is not set
			 * @throws {SuiteScriptError} INVALID_KEY_OR_REF if trying to save to a non-existing folder
			 *
			 * @return {number} return internal ID of file in the file cabinet
			 *
			 * @since 2015.2
			 */
			this.save = function save()
			{
				if (delegate.getFolder() == -1)
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT,'file.File.save', 'folder');

				return invoker(fileApi, 'nlapiSubmitFile', [delegate]);
			};

			/**
			 * Append a chunk of text to the file.
			 *
			 * @param {Object} options
			 * @param {string} options.value text to append
			 * @return {file} Returns this file
			 * @throws {SuiteScriptError} YOU_CANNOT_WRITE_TO_A_FILE_AFTER_YOU_BEGAN_READING_FROM_IT If you call it after having called FileLines#each
			 * @since 2017.1
			 */
			this.append = function append(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.append');
				utilityFunctions.checkArgs([options.value], ['options.value'], 'file.append');
				invoker(delegate, 'append', [String(options.value)]);
				return this;
			};

			/**
			 * Append a line of text to the file.
			 *
			 * @param {Object} options
			 * @param {string} options.value text to append
			 * @return {file} Returns this file
			 * @throws {SuiteScriptError} YOU_CANNOT_WRITE_TO_A_FILE_AFTER_YOU_BEGAN_READING_FROM_IT If you call it after having called FileLines#each
			 * @since 2017.1
			 */
			this.appendLine = function appendLine(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.appendLine');
				utilityFunctions.checkArgs([options.value], ['options.value'], 'file.appendLine');
				invoker(delegate, 'appendLine', [String(options.value)]);
				return this;
			};

			/**
			 * Reset the reading and writing streams that may have been opened by appendLine or FileLines#each
			 *
			 * @since 2017.1
			 */
			this.resetStream = function resetStream()
			{
				invoker(delegate, 'resetStream', []);
				for(var i = 0; i < fileLinesObjectsCreated.length; i++)
					fileLinesObjectsCreated[i].reset();

				for(var i = 0; i < fileSegmentsObjectsCreated.length; i++)
					fileSegmentsObjectsCreated[i].reset();

				for(var i = 0; i < fileReaderObjectsCreated.length; i++)
					fileReaderObjectsCreated[i].reset();
			};

			/**
			 * Returns the object type name (file.File)
			 *
			 * @returns {string}
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * JSON.stringify() implementation.
			 *
			 * @returns {{type: string, id: *, name: *, description: *, path: *, url: *, folder: *, fileType: *, isText: *,
                 *     size: *, encoding: *, isInactive: *, isOnline: *, contents: *}}
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: TYPE,
					id: this.id,
					name: this.name,
					description: this.description,
					path: this.path,
					url: this.url,
					folder: this.folder,
					fileType: this.fileType,
					isText: this.isText,
					size: this.size,
					encoding: this.encoding,
					isInactive: this.isInactive,
					isOnline: this.isOnline
				};
			};

			Object.defineProperty(this, '_attachToEmail', {
				set: function (email)
				{
					email._attach = delegate;
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			if (folder != null)
				this.folder = folder;
		}
		File.prototype = nsobject.getNewInstance();

		/**
		 * @protected
		 *
		 * @constructor
		 */
		function FileLines(delegate)
		{

			var nextLine = invoker(delegate, 'nextLine', []);

			this.hasNext = function hasNext()
			{
				return nextLine !== null;
			};

			this.next = function next()
			{
				var _nextLine = nextLine;
				nextLine = invoker(delegate, 'nextLine', []);
				return _nextLine;
			};

			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
				nextLine = invoker(delegate, 'nextLine', []);
			}

		}

		/**
		 * @protected
		 *
		 * @constructor
		 */
		function FileSegments(delegate, separator)
		{

			var nextSegment = invoker(delegate, 'nextSegment', [separator]);

			this.hasNext = function hasNext()
			{
				return nextSegment !== null;
			};

			this.next = function next()
			{
				var _nextSegment = nextSegment;
				nextSegment = invoker(delegate, 'nextSegment', [separator]);
				return _nextSegment;
			};

			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
				nextSegment = invoker(delegate, 'nextSegment', [separator]);
			}
		}

		/**
		 * @protected
		 *
		 * @constructor
		 */
		function Reader(delegate)
		{
			/**
			 * Returns string from current position to the next occurrence of options.tag
			 *
			 * @param {Object} options
			 * @param {string} options.tag
			 * @throws {SuiteScriptError} SSS_TAG_CANNOT_BE_EMPTY if tag to read until is empty
			 * @return {string}
			 */
			this.readUntil = function(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'readUntil');
				var tag = util.isObject(options) && options.hasOwnProperty('tag') ? options.tag : options;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(tag, 'tag', util.isString)]);
				if (tag === "")
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_TAG_CANNOT_BE_EMPTY);
				return invoker(delegate, 'readUntil', [tag]);
			};

			/**
			 * Returns the next options.number characters from the current position
			 *
			 * @param {Object} options
			 * @param {number} options.number
			 * @throws {SuiteScriptError} SSS_INVALID_READ_SIZE if number of characters to read is not greater than zero
			 * @return {string}
			 */
			this.readChars = function(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'readChars');
				var number = util.isObject(options) && options.hasOwnProperty('number') ? options.number : options;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(number, 'number', util.isNumber)]);
				if (number <= 0)
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_READ_SIZE);
				return invoker(delegate, 'readChars', [number]);
			};

			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
			}
		}

		function create(options)
		{
			utilityFunctions.checkArgs([options], ['options object'], 'file.create');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name, options.fileType], ['name', 'fileType'], 'file.create');
			var name = options.name;
			var fileType = options.fileType;
			var contents = options.contents || "";
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(name, 'name', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(fileType, 'fileType', util.isString)]);
			if (utilityFunctions.isSignedXml(contents))
				contents = contents.asString();
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(contents, 'contents', util.isString)]);

			return new File(invoker(fileApi, 'nlapiCreateFile', [name, fileType, contents]), options.folder);
		}

		/** @alias N/file */
		return Object.freeze({
			/**
			 * Instantiate a file object (specifying the name, type, and contents which are base-64 encoded for binary types.)
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {string} options.name file name
			 * @param {string} options.fileType file type i.e. PLAINTEXT, HTMLDOC, PDF, WORD, see file.Type enum
			 * @param {string} options.contents string containing file contents (must be base-64 encoded for binary types)
			 * @param {number} [options.folder] (optional) the internal ID of the folder to be used when the file is saved
			 * @return {File}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options is missing or one of mandatory options
			 *     properties not set
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if options.fileType is an invalid type
			 *
			 * @since 2015.2
			 */
			create: funcWrapper.wrap( create ),
			/**
			 * Load a file from the file cabinet (via its internal ID or path).
			 *
			 * @governance 10 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID or path to file in the file cabinet (i.e. /SuiteScript/foo.js)
			 * @return {File}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if idOrPath parameter is missing
			 * @throws {SuiteScriptError} RCRD_DSNT_EXIST attempt to load a file from non-existing path
			 * @throws {SuiteScriptError} INSUFFICIENT_PERMISSION attempt to load a file with non-existing ID
			 *
			 * @since 2015.2
			 */
			load: function load(options)
			{
				var idOrPath = (options && options.hasOwnProperty('id')) ? options.id : options;

				utilityFunctions.checkArgs([idOrPath], ['id'], 'file.load');
				var stack = Error().stack;
				return new File(invoker(fileApi, 'nlapiLoadRelativeFile', [idOrPath, util.isString(stack) ? stack : ""]));
			},
			/**
			 * Delete a file from the file cabinet.
			 *
			 * @governance 20 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID of file to be deleted
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
			 *
			 * @since 2015.2
			 */
			'delete': function (options)
			{
				var id = (options && options.hasOwnProperty('id')) ? options.id : options;

				utilityFunctions.checkArgs([id], ['id'], 'file.delete');

				invoker(fileApi, 'nlapiDeleteFile', [id]);
			},
			//Undocumented helper function, takes a nlobjFile and wraps it into file.File
			wrap: function wrap(nlobj)
			{
				return new File(nlobj);
			},
			/**
			 * Enum for file types.
			 * @enum {string}
			 * @readonly
			 */
			Type: FILE_TYPES,
			/**
			 * Enum for file encodings.
			 * @enum {string}
			 * @readonly
			 */
			Encoding: ENCODINGS
		});
	});

/**
 * @private
 */
define('N/restricted/httpApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/marshalUtil',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module - common functionality between http and https modules
 *
 * @private
 * @module N/http/httpUtil
 * @suiteScriptVersion 2.x
 *
 */
define('N/http/httpUtil',['N/restricted/scriptArguments', 'N/error', 'N/file', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/restricted/httpApi', 'N/restricted/marshalUtil'],
       function (scriptArguments, error, file, nsobject, invoker, utilityFunctions, httpApi, marshalUtil)
       {
           //enums
           var METHODS = Object.freeze({
                                             GET: 'GET',
                                             POST: 'POST',
                                             PUT: 'PUT',
                                             DELETE: 'DELETE',
                                             HEAD: 'HEAD'
                                         });

           var CACHE_DURATIONS = Object.freeze({
                                                     UNIQUE: 'UNIQUE',
                                                     SHORT: 'SHORT',
                                                     MEDIUM: 'MEDIUM',
                                                     LONG: 'LONG'
                                                 });

           var REDIRECT_TYPES = Object.freeze({
               RECORD: 'RECORD',
               SUITELET: 'SUITELET',
               RESTLET: 'RESTLET',
               MEDIA_ITEM: 'MEDIAITEM',
               TASK_LINK: 'TASKLINK'
           });

           /**
            * Encapsulates the response of an HTTP client request (i.e., the return type for http.delete(options), http.get(options), http.post(options), http.put(options), http.request(options), and corresponding promise methods).
            *
            * @protected
            * @classDescription Encapsulation of the response returned by a web server as a response to our HTTP request.
            * @return {http.ClientResponse}
            * @constructor
            *
            * @since 2015.2
            */
           function ClientResponse(delegate)
           {
               var TYPE = 'http.ClientResponse';
               /**
                * The client response code.
                * @name ClientResponse#code
                * @type number
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'code', {
                   get: function ()
                   {
                       return delegate.getCode ? invoker(delegate, 'getCode', []) : delegate.code;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'code' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * The response headers.
                * @name ClientResponse#headers
                * @type Object
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'headers', {
                   get: function ()
                   {
                       var headers = {};
                       if (delegate.getAllHeaders)
                       {
                           var headerNames = invoker(delegate, 'getAllHeaders', []);
                           var headers = {};
                           for (var i = 0; i < headerNames.length; i++)
                               headers[headerNames[i]] = invoker(delegate, 'getHeader', [headerNames[i]]);
                       }
                       else
                       {
                           headers = delegate.headers;
                       }
                       return headers;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'headers' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * The client response body.
                * @name ClientResponse#body
                * @type string
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'body', {
                   get: function ()
                   {
                       return delegate.getBody ? invoker(delegate, 'getBody', []) : delegate.body;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'body' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });

               /**
                * Returns the object type name (http.ClientResponse)
                * @governance none
                * @returns {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @returns {{type: string, code: *, headers: *, body: *}}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       type: TYPE,
                       code: this.code,
                       headers: this.headers,
                       body: this.body
                   };
               }
           }

           ClientResponse.prototype = nsobject.getNewInstance();

           function checkParams(config, required, optional)
           {
               checkConfig(config);
               for (var i = 0; i < required.length; i++)
               {
                   if (!config[required[i]] && config[required[i]] !== 0)
                       utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "checkParams", "options." + required[i] );

               }
           }

           function checkConfig(config)
           {
               if (!config)
                   utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "checkConfig", 'options object' );
           }

           function runRequest(options, callback)
           {
               var hasBody = options.method === this.Method.POST || options.method === this.Method.PUT;
               this.checkParams(options, hasBody ? ['method', 'url', 'body'] : ['method', 'url'], ['headers']);
               var url = '' + options.url;
               utilityFunctions.assertTrue((url.indexOf("https:") !== 0), error.Type.SSS_INVALID_URL, "HTTP");
               var headers = options.headers || null;
               var isClient = typeof document != 'undefined';
               if (url[0] == '/')
               {
                   utilityFunctions.assertTrue(isClient, error.Type.SSS_INVALID_URL, "HTTP");
                   url = 'http://' + document.location.host + url;
               }
               if (isClient)
               {
                   if (!headers)
                       headers = {};
               }
               headers = invoker(marshalUtil, "nsObjectToMap", [headers]);
               return invoker(httpApi, "nlapiRequestURL", [url, hasBody ? options.body : null, headers, options.method], callback);
           }

           /** @alias N/http */
           return Object.freeze(
                   {
                       /**
                        * Enum for HTTP methods.
                        * @enum {string}
                        * @readonly
                        */
                       Method: METHODS,
                       /**
                        * Enum for caching durations.
                        * @enum {string}
                        * @readonly
                        */
                       CacheDuration: CACHE_DURATIONS,
                       /**
                        * Enum for redirect types.
                        * Holds the string values for supported NetSuite resources that you can redirect to. This enum is used to set the value of the type argument for ServerResponse.sendRedirect.
                        * @enum {string}
                        * @readonly
                        */
                       RedirectType: REDIRECT_TYPES,
                       /**
                        * Send a HTTP GET request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       get: function get(config, headers, httpClient)
                       {
                           checkConfig(config);
                           if (!utilityFunctions.isObject(config))
                           {
                               var url = config;
                               config = {url: url, headers: headers || null};
                           }
                           config.method = this.Method.GET;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP POST request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body POST data
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       post: function post(config, httpClient)
                       {
                           checkConfig(config);
                           config.method = this.Method.POST;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP PUT request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body PUT data
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       put: function put(config, httpClient)
                       {
                           checkConfig(config);
                           config.method = this.Method.PUT;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP DELETE request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       'delete': function (config, headers, httpClient)
                       {
                           checkConfig(config);
                            if (!utilityFunctions.isObject(config))
                           {
                               var url = config;
                               config = {url: url, headers: headers || null};
                           }
                           config.method = this.Method.DELETE;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.method HTTP method of the request
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body POST data; must be present if and only if method is POST
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       request: function request(options, httpClient)
                       {
                           return httpClient.doRequest(options);
                       },
                       setRequester: function setRequester(val)
                       {
                           requester = val;
                       },
                       createClientResponse: function createClientResponse(val)
                       {
                           return new ClientResponse(val);
                       },
                       checkConfig: checkConfig,
                       checkParams: checkParams,
                       runRequest: runRequest
                   });
       });

/**
 * SuiteScript module - defines the Suitelet response and request objects
 *
 * @module N/suiteletContext
 * @NApiVersion 2.x
 *
 */

define('N/suiteletContext',['N/restricted/scriptArguments', 'N/error', 'N/file', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/util'],
        function (scriptArguments, error, file, nsobject, invoker, utilityFunctions, util)
        {
			/**
			 * Return a new instance of ServerRequest object that carries incoming HTTP request info.
			 *
			 * @classDescription Encapsulation of the HTTP request incoming to the suitelet.
			 * @return {http.ServerRequest}
			 * @constructor
			 *
			 * @since 2015.2
			 */
			function ServerRequest(delegate)
			{
				var TYPE = 'http.ServerRequest';
				/**
				 * Server request headers.
				 * @name ServerRequest#headers
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'headers', {
					get: function ()
					{
						return invoker(delegate, 'getAllHeaders', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'headers'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request clientIpAddress.
				 * @name ServerRequest#clientIpAddress
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'clientIpAddress', {
					get: function ()
					{
						return invoker(delegate, 'getClientIpAddress', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'clientIpAddress'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request parameters.
				 * @name ServerRequest#parameters
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'parameters', {
					get: function ()
					{
						return invoker(delegate, 'getAllParameters', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'parameters'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request files.
				 * @name ServerRequest#files
				 * @type Object
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'files', {
					get: function ()
					{
						var fileMap = invoker(delegate, 'getAllFiles', []);
						var files = {};
						util.each(fileMap, function(val, key){
							files[key] = file.wrap(val);
						});
						return files;
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'files'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request body.
				 * @name ServerRequest#body
				 * @type string
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'body', {
					get: function ()
					{
						return invoker(delegate, 'getBody', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'body'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request HTTP method.
				 * @name ServerRequest#method
				 * @type string
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'method', {
					get: function ()
					{
						return invoker(delegate, 'getMethod', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'method'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request URL.
				 * @name ServerRequest#url
				 * @type string
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'url', {
					get: function ()
					{
						return invoker(delegate, 'getURL', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'url'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Returns the number of lines in a sublist.
				 * @param {Object} options
				 * @param {string} options.group sublist internal ID
				 * @returns {integer} the integer value of the number of line items in the sublist
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.getLineCount = function getLineCount(options)
				{
					var group = (options && options.hasOwnProperty('group')) ? options.group : options;
					utilityFunctions.checkArgs([group], ['group'], 'ServerRequest.getLineCount');
					return invoker(delegate, 'getLineItemCount', [group]);
				};
				/**
				 * Returns the value of a sublist line item.
				 * @param {Object} options
				 * @param {string} options.group sublist internal ID
				 * @param {string} options.name the name of the field whose value is returned
				 * @param {string} options.line the line number for this field (1-based)
				 * @returns {string} the string value of the line item
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.getSublistValue = function getSublistValue(options)
				{
					var group = null, name = null, line = null;

					if (options && (options.hasOwnProperty('group') || options.hasOwnProperty('name') || options.hasOwnProperty('line')))
					{
						group = options.group;
						name = options.name;
						line = options.line;
					}
					else
					{
						group = options;
						name = arguments[1];
						line = arguments[2];
					}

					utilityFunctions.checkArgs([group, name, line], ['group', 'name', 'line'], 'ServerRequest.getSublistValue');
					return invoker(delegate, 'getLineItemValue', [group, name, line + 1]);
				};
				/**
				 * Returns the object type name (http.ServerRequest)
				 *
				 * @returns {string}
				 */
				this.toString = function toString()
				{
					return TYPE;
				};
				/**
				 * JSON.stringify() implementation.
				 *
				 * @returns {Object}
				 */
				this.toJSON = function toJSON()
				{
					return {
						type: TYPE,
						method: this.method,
						url: this.url,
						parameters: this.parameters,
						headers: this.headers,
						clientIpAddress: this.clientIpAddress,
						files: this.files,
						body: this.body
					};
				}
			}

			ServerRequest.prototype = nsobject.getNewInstance();

			/**
			 * Return a new instance of ServerResponse object that carries the response to an incoming HTTP request.
			 *
			 * @classDescription Encapsulation of the HTTP response that will be returned to the browser.
			 * @return {http.ServerResponse}
			 * @constructor
			 *
			 * @since 2015.2
			 */
			function ServerResponse(delegate)
			{
				var TYPE = 'http.ServerResponse';
				/**
				 * Server response headers.
				 * @name ServerResponse#headers
				 * @type Object
				 * @returns {Object} key/value pairs with all the headers; if multiple values are assigned to one header name, they are returned as an array
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 */
				Object.defineProperty(this, 'headers', {
					get: function ()
					{
						var headerNames = invoker(delegate, 'getAllHeaders', []);
						var headers = {};
						for (var i = 0; i < headerNames.length; i++)
						{
							var values = delegate.getHeaders(headerNames[i]);
							headers[headerNames[i]] = values.length == 1 ? values[0] : values;
						}
						return headers;
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'headers'});
					},
					enumerable: true,
					configurable: false
				});
				/*
				 * Helper function for ui.Assistant.sendRedirect()
				 */
				Object.defineProperty(this, '_assistantSendRedirect', {
					set: function (val)
					{
						invoker(val.delegate, 'sendRedirect', [delegate]);
					},
					enumerable: false,
					configurable: false
				});

				/*
				 * Helper function for render.TemplateRenderer.renderToResponse()
				 */
				Object.defineProperty(this, '_renderToResponse', {
					set: function (val)
					{
						return invoker(val, 'renderToResponse', [delegate]);
					},
					enumerable: false,
					configurable: false
				});

				/**
				 * Sets the value of a response header.
				 * @param {Object} options
				 * @param {string} options.name the name of the header
				 * @param {string} options.value the value used to set the header
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_HEADER if the header name or value is invalid
				 */
				this.setHeader = function setHeader(options)
				{
					var name = null, value = null;
					if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
					{
						name = options.name;
						value = options.value;
					}
					else
					{
						name = options;
						value = arguments[1];
					}
					utilityFunctions.checkArgs([name, value], ['name', 'value'], 'ServerResponse.setHeader');
					invoker(delegate, 'setHeader', [name, value]);
				};
				/**
				 * Adds a header to the response. If this header has already been set, this will add another line for that header.
				 * @param {Object} options
				 * @param {string} options.name the name of the header
				 * @param {string} options.value the value used to set the header
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_HEADER if the header name or value is invalid
				 */
				this.addHeader = function addHeader(options)
				{
					var name = null, value = null;
					if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
					{
						name = options.name;
						value = options.value;
					}
					else
					{
						name = options;
						value = arguments[1];
					}
					utilityFunctions.checkArgs([name, value], ['name', 'value'], 'ServerResponse.addHeader');
					invoker(delegate, 'addHeader', [name, value]);
				};
				/**
				 * Sets the redirect URL by resolving to a NetSuite resource. Note that all parameters must be prefixed with custparam.
				 * @param {Object} options
				 * @param {string} options.type the base type for this resource - one of RECORD, TASKLINK or SUITELET
				 * @param {string} options.identifier the primary id for this resource
				 * @param {string} options.id (optional) the secondary id for this resource
				 * @param {boolean} options.editMode (optional) for RECORD calls, this determines whether to return a URL for the record in edit mode or view mode
				 * @param {Object} options.parameters (optional) additional URL parameters as name/value pairs
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_URL_CATEGORY if type is none of RECORD, TASKLINK or SUITELET
				 * @throws {error.SuiteScriptError} SSS_INVALID_TASK_ID if type is TASKLINK and an invalid task identifier is passed in the options.identifier parameter
				 * @throws {error.SuiteScriptError} SSS_INVALID_RECORD_TYPE if type is RECORD and an invalid record type is passed in the options.identifier parameter
				 * @throws {error.SuiteScriptError} SSS_INVALID_SCRIPT_ID_1 if type is SUITELET and an invalid script ID and deployment ID are passed in the options.identifier and options.id parameters
				 */
				this.sendRedirect = function sendRedirect(options)
				{
					var type = null, identifier = null, id = null, editMode = false, parameters = null;
					if (options && (options.hasOwnProperty('type') || options.hasOwnProperty('identifier')))
					{
						type = options.type;
						identifier = options.identifier;
						id = options.id ? options.id : null;
						editMode = util.isBoolean(options.editMode) ? options.editMode : false;
						parameters = typeof(options.parameters) === 'object' ? options.parameters : null;
					}
					else
					{
						type = options;
						identifier = arguments[1];
						id = arguments[2] ? arguments[2] : null;
						editMode = util.isBoolean(arguments[3]) ? arguments[3] : false;
						parameters = typeof(arguments[4]) === 'object' ? arguments[4] : null;
					}
					utilityFunctions.checkArgs([type, identifier], ['type', 'identifier'], 'ServerResponse.sendRedirect');
					invoker(delegate, 'sendRedirect', [type, identifier, id, editMode, parameters]);
				};
				/**
				 * Write information (text/xml/html) to the response.
				 * @param {Object} options
				 * @param {string} options.output string or file being written
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a string
				 */
				this.write = function write(options)
				{
					var output = (options && options.hasOwnProperty('output')) ? options.output : options;
					utilityFunctions.checkArgs([output], ['output'], 'ServerResponse.write');
					utilityFunctions.assertTrue(util.isString(output), error.Type.WRONG_PARAMETER_TYPE, 'output');
					invoker(delegate, 'write', [output]);
				};
				/**
				 * Write line information (text/xml/html) to the response.
				 * @param {Object} options
				 * @param {string} options.output string being written
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a string
				 */
				this.writeLine = function writeLine(options)
				{
					var output = (options && options.hasOwnProperty('output')) ? options.output : options;
					utilityFunctions.checkArgs([output], ['output'], 'ServerResponse.writeLine');
					utilityFunctions.assertTrue(util.isString(output), error.Type.WRONG_PARAMETER_TYPE, 'output');
					invoker(delegate, 'writeLine', [output]);
				};
				/**
				 * Generates a page using a page element object.
				 * @param {Object} options
				 * @param {serverWidget.Assistant|serverWidget.Form|serverWidget.List} options.pageObject standalone page object: assistant, form or list
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.writePage = function writePage(options)
				{
					var pageObject = (options && options.hasOwnProperty('pageObject')) ? options.pageObject : options;
					utilityFunctions.checkArgs([pageObject], ['pageObject'], 'ServerResponse.writePage');
					pageObject._writeTo = {'delegate': delegate}
				};
				/**
				 * Write a file to the response.
				 * @param {Object} options
				 * @param {file.File} options.file the file to be written
				 * @param {boolean} options.isInline (optional) true if the file is inline
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a file.File object
				 */
				this.writeFile = function writeFile(options)
				{
					var fileObj = options && options['file'] !== undefined ? options['file'] : options;
					var isInline = options && options['isInline'] !== undefined ? options['isInline'] : arguments[1];
					utilityFunctions.checkArgs([fileObj], ['file'], 'ServerResponse.writeFile');
					if (fileObj.toString() != 'file.File')
					{
						throw error.create({name: error.Type.WRONG_PARAMETER_TYPE, message: 'file'});
					}
					fileObj._writeTo = {'delegate': delegate, 'isInline': isInline};
				};
				/**
				 * Returns the value for a header returned in the response.
				 * @param {Object} options
				 * @param {string} options.name the header name
				 * @returns {string|Array} the value of the header; if multiple values are assigned to the header name, they are returned as an array
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.getHeader = function getHeader(options)
				{
					var name = (options && options.hasOwnProperty('name')) ? options.name : options;
					utilityFunctions.checkArgs([name], ['name'], 'ServerResponse.getHeader');
					var values = invoker(delegate, 'getHeaders', [name]);
					return values != null ? (values.length == 1 ? values[0] : values) : null;
				};
				/**
				 * Generates and renders a PDF directly to the response.
				 * @param {Object} options
				 * @param {string} options.xmlString content of your PDF
				 * @governance 10 units
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.renderPdf = function renderPdf(options)
				{
					var xmlString = (options && options.hasOwnProperty('xmlString')) ? options.xmlString : options;
					utilityFunctions.checkArgs([xmlString], ['xmlString'], 'ServerResponse.renderPdf');
					invoker(delegate, 'renderPDF', [xmlString]);
				};
				/**
				 * Sets CDN caching for a period of time.
				 * @param {Object} options
				 * @param {string} options.type constant value to represent the caching duration, see http.CacheDuration enum
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 */
				this.setCdnCacheable = function setCdnCacheable(options)
				{
					var type = (options && options.hasOwnProperty('type')) ? options.type : options;
					utilityFunctions.checkArgs([type], ['type'], 'ServerResponse.setCdnCacheable');
					invoker(delegate, 'setCDNCacheable', [type]);
				};
				/**
				 * Returns the object type name (http.ServerResponse)
				 * @returns {string}
				 */
				this.toString = function toString()
				{
					return TYPE;
				};
				/**
				 * JSON.stringify() implementation.
				 * @returns {Object}
				 */
				this.toJSON = function toJSON()
				{
					return {
						type: TYPE,
						headers: this.headers
					};
				}
			}

			ServerResponse.prototype = nsobject.getNewInstance();

            return Object.freeze(
                    {
                        createServerRequest: function createServerRequest(delegate)
                        {
                            return new ServerRequest(delegate);
                        },
                        createServerResponse: function createServerResponse(delegate)
                        {
                            return new ServerResponse(delegate);
                        },
	                    getServerRequest: function getServerRequest()
                        {
                            return new ServerRequest(scriptArguments.request);
                        },
                        getServerResponse: function getServerResponse()
                        {
                            return new ServerResponse(scriptArguments.response);
                        },
                        _ServerRequest: Object.freeze(ServerRequest)
                    }
            );
        }
);

/**
 * SuiteScript module
 *
 * @module N/http
 * @suiteScriptVersion 2.x
 *
 */
define('N/http',['N/http/httpUtil', 'N/suiteletContext'],
       function (httpUtil, suiteletContext)
       {

           function requestProcess(options)
           {
               var requestResponse = httpUtil.runRequest(options);
               return httpUtil.createClientResponse(requestResponse);
           }

           function requestProcessPromise(options)
           {
               var myPromise = new Promise(function (resolve, reject)
               {
                   try
                   {
                       httpUtil.runRequest(options, callback)
                   }
                   catch (e)
                   {
                       reject(e);
                   }

                   function callback(result, exception)
                   {
                       if (exception)
                       {
                           reject(exception)
                       }
                       else
                       {
                           try
                           {
                               resolve(httpUtil.createClientResponse(result));
                           }
                           catch (e)
                           {
                               reject(e);
                           }
                       }
                   }
               });
               return myPromise
           };

           var httpClient = Object.freeze({doRequest: requestProcess});
           var httpClientPromise = Object.freeze({doRequest: requestProcessPromise});

           function doGet(options, headers) { return httpUtil.get(options, headers, httpClient)}
           doGet.promise = function doGetPromise(options, headers) { return httpUtil.get(options, headers, httpClientPromise)};

           function doPost(options) { return httpUtil.post(options, httpClient)}
           doPost.promise = function doPostPromise(options) { return httpUtil.post(options, httpClientPromise)};

           function doPut(options) { return httpUtil.put(options, httpClient)}
           doPut.promise = function doPutPromise(options) { return httpUtil.put(options, httpClientPromise)};

           function doDelete(options, headers) { return httpUtil['delete'](options, headers, httpClient)}
           doDelete.promise = function doDeletePromise(options, headers) { return httpUtil['delete'](options, headers, httpClientPromise)};

           function doRequest(options) { return httpUtil.request(options, httpClient)}
           doRequest.promise = function doRequestPromise(options) { return httpUtil.request(options, httpClientPromise)};

           return Object.freeze(
                   {
					   /**
						* Enum describing available HTTP methods. Holds the string value for supported HTTP requests. This enum is used to set the value of http.request and ServerRequest.method.
						* @enum {string}
					    * @readonly
						*/
                       Method: httpUtil.Method,
					   /**
						* Enum describing available Commerce API Cache Durations. Holds the string value for supported cache durations. This enum is used to set the value of the ServerResponse.setCdnCacheable property.
						* @enum {string}
					    * @readonly
						*/
                       CacheDuration: httpUtil.CacheDuration,
					   /**
						* Send a HTTP GET request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {Object} options.headers (optional) The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   get: doGet,
					   /**
						* Send a HTTP POST request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {string|Object} options.body The POST data
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   post: doPost,
					   /**
						* Send a HTTP PUT request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {string|Object} options.body The PUT data
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   put: doPut,
					   /**
						* Send a HTTP DELETE request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   'delete': doDelete,
					   /**
						* Send a HTTP request and return a response from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.method The HTTP request method. Set using the http.Method enum.
						* @param {string} options.url the HTTP URL being requested
						* @param {string|Object} options.body The POST data; must be present if and only if method is POST
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   request: doRequest,
                       getServerRequest: suiteletContext.getServerRequest,
                       getServerResponse: suiteletContext.getServerResponse,
                       /**
                        * @enum {string}
                        * @readonly
                        */
                       RedirectType : httpUtil.RedirectType
                   });

       });

/**
 * SuiteScript portlet module
 *
 * @module N/portlet
 * @NApiVersion 2.x
 *
 */
define('N/portlet',['N/error', 'N/utilityFunctions'],
	function (error, utilityFunctions)
	{
		var SUPPORTED_PORTLET_TYPE = 'form';

		function refresh()
		{
			if (typeof window.nlportlet === 'object' && window.nlportlet.type === SUPPORTED_PORTLET_TYPE)
				window.nlportlet.refreshfn();
			else
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE, window.nlportlet.type, SUPPORTED_PORTLET_TYPE);
		}

		function resize()
		{
			if (typeof window.nlportlet === 'object' && window.nlportlet.type === SUPPORTED_PORTLET_TYPE)
				window.nlportlet.resizefn();
			else
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE, window.nlportlet.type, SUPPORTED_PORTLET_TYPE);
		}

		return Object.freeze({
			/**
			 * Causes a FORM type portlet to immediately refresh.
			 *
			 * @throws {SuiteScriptError} SSS_INVALID_UI_OBJECT_TYPE if portlet is not FORM type
			 *
			 * @since 2016.1
			 */
			refresh: refresh,
			/**
			 * Causes a FORM type portlet to be immediately resized.
			 *
			 * @throws {SuiteScriptError} SSS_INVALID_UI_OBJECT_TYPE if portlet is not FORM type
			 *
			 * @since 2016.1
			 */
			resize: resize
		})
	}
);

/**
 * @private
 */
define('N/restricted/bridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/xmlHelpers
 * @NApiVersion 2.x
 */
define('N/restricted/xmlHelpers',['N/restricted/bridge'],
	function(apiBridge)
	{
		function selectValues(node, expr)
		{
			var selectedValues = [];
			var selections = apiBridge.nlapiSelectNodes(node, expr);
			if (selections != null)
			{
				selectedValues = [];
				for (var i = 0; i < selections.length; i++)
					selectedValues[i] = getXMLValue(selections[i]);
			}
			return selectedValues;
		}

		function selectValue(node, expr)
		{
			var selections = selectValues(node, expr);
			var selection = selections != null ? selections[0] : null;
			return selection;
		}

		function getXMLValue(node)
		{
			if (node.nodeType == 3 || node.nodeType == 4)	/* Text or CDATA Nodes */
				return node.nodeValue;
			if (node.nodeType == 2)
				return node.value;    /* Attr node will deprecate child nodes */
			if (node.nodeType == 9)	/* Document Node (Use root Element instead) */
				node = node.documentElement;

			var value = null;
			var elems = node.childNodes;
			for (var i = 0; i < elems.length; i++)
			{
				var elem = elems[i];
				if (elem.nodeType == 3 || elem.nodeType == 4)	/* Text or CDATA Nodes */
				{
					if (value == null)
						value = elem.nodeValue;
					else
						value += elem.nodeValue;
				}
			}
			return value;
		}

		return Object.freeze({
			nlapiSelectValue: selectValue
		});
	}
)
;
/**
 * SuiteScript module
 *
 * @private
 * @module N/ajaxHelpers
 * @NApiVersion 2.x
 */
define('N/restricted/ajaxHelpers',['N/restricted/bridge', 'N/restricted/xmlHelpers'],
	function(apiBridge, xmlHelpers)
	{
		var trim = String.prototype.trim || function(){
				return this.replace(/^\s+|\s+$/gm,'');
			};

		function isJson(body)
		{
			if(!body)
				return false;
			body = trim.call(body);
			return body && body.indexOf('{') === 0 && body.lastIndexOf('}') === body.length - 1;
		}

		function throwServerCallError(details, code, id)
		{
			var error = Error(details);
			error.name = code;
			error.id = id;
			error.userFacing = false;
			throw error;
		}

		function handleServerCallError(responseCode, responseBody, handleJson)
		{
			if (responseBody && responseBody.toLowerCase().indexOf('error')>=0)
			{
				if (isJson(responseBody))
				{
					if (handleJson && responseBody.indexOf('{"error"') >= 0)
					{
						var errorBody = JSON.parse(responseBody);
						throwServerCallError(errorBody.error.message, errorBody.error.code);
					}
				}
				else if (responseBody.indexOf('<onlineError>') >= 0)
				{
					var errorBody = apiBridge.nlapiStringToXML(responseBody);
					throwServerCallError(xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/detail'), xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/code'), xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/id'));
				}
				else if (responseBody.indexOf('<error>') >= 0)
				{
					var errorBody = apiBridge.nlapiStringToXML(responseBody);
					throwServerCallError(xmlHelpers.nlapiSelectValue(errorBody, '/error/message'), xmlHelpers.nlapiSelectValue(errorBody, '/error/code'));
				}
				else if (responseBody.indexOf('error code:') >= 0 && responseBody.indexOf('error message:') >= 0 && responseCode != 200)
				{
					var errorBody = responseBody.split("\n");
					throwServerCallError(errorBody[1].substring("error message: ".length), errorBody[0].substring("error code: ".length));
				}
			}
			else if (responseCode != 200 && responseCode != 206 && responseCode != 500)
				throwServerCallError(responseBody, 'SERVER_RESPONSE_ERROR');
		}

		return Object.freeze({
			isJson: isJson,
			handleServerCallError: handleServerCallError
		});
	}
)
;
/**
 * SuiteScript https module (Client Side)
 * @private Ignore for JSDoc stub generation
 * @module N/clientHttps
 * @suiteScriptVersion 2.x
 *
 */
define('N/https',['N/http/httpUtil','N/restricted/bridge', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error', 'N/suiteletContext', 'N/restricted/httpApi', 'N/restricted/ajaxHelpers'],
       function (httpUtil, apiBridge, invoker, utilityFunctions, error, suiteletContext, httpApi, ajaxHelpers)
       {
	       function getHost()
	       {
		       return document.location.protocol + '//' + document.location.host;
	       }

           function extractResponse(xhr, async)
           {
	           try
	           {
		           ajaxHelpers.handleServerCallError(xhr.status, xhr.responseText, true);
	           }
	           catch (e)
	           {
		           if (async)
		           	    return e;
		           else
		           	    throw error.create(e);
	           }
               apiBridge.chargeUsage('nlapiRequestURL');
               var responseHeaders = xhr.getAllResponseHeaders();
               var headers = {};
               if (responseHeaders != null)
               {
                   var headerLines = responseHeaders.split("\r\n");
                   var arrayLength = headerLines.length;
                   for (var i = 0; i < arrayLength; i++)
                   {
                       var header = headerLines[i].split(":")[0];
                       if (!!header)
                           headers[header] = xhr.getResponseHeader(header);
                   }
               }
               else
                   headers = null;

               return {code: xhr.status, body: xhr.responseText, headers: headers};
           }

           function runRequest(options, callback)
           {
               utilityFunctions.checkArgs([ options ], ["options"], "request");
               utilityFunctions.checkArgs([ options.url ], ["options.url"], "request");
               var url = '' + options.url;
               utilityFunctions.assertTrue((url.indexOf("http:") !== 0), error.Type.SSS_INVALID_URL, "HTTPS");
               var body = (options.method === httpUtil.Method.POST || options.method === httpUtil.Method.PUT) ? options.body : null;
               var headers = options.headers || {};

	           if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null)
	           {
		           url += url.indexOf("?") > 0 ? "&" : "?";
		           url += "c=" + nsDefaultContextObj.company;
		           url += "&isExternal=T";
	           }

               if (url[0] == '/' || url.indexOf(getHost()) === 0)
               {
                   var async = typeof(callback) === "function";
                   var xhr = new XMLHttpRequest();
                   xhr.open(options.method, url, async);
                   if (async)
                   {
                       xhr.onload = function ()
                       {
                           if (this.readyState === 4)
                           {
	                           var resp = extractResponse(xhr, true);
	                           if (resp instanceof Error)
		                           callback(null, resp);
	                           else
		                           callback(resp);
                           }
                       }
                   }

                   if (url.toLowerCase().indexOf("restlet.nl") >= 0)
                   {
                       if (util.isObject(body))
                       {
                           xhr.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
                           body = JSON.stringify(body);
                       }
                       else
                       {
                       	   if (util.isObject(headers) && util.isString(headers["Content-Type"]))
                       	   	    xhr.setRequestHeader("Content-Type", headers["Content-Type"])
	                       else
	                       	    xhr.setRequestHeader("Content-Type", "text/plain; charset=UTF-8");
                       }
                   }
                   else
                   {
	                   xhr.setRequestHeader("NSXMLHttpRequest", "NSXMLHttpRequest");
                       if (util.isObject(body))
                       {
                           body = Object.keys(body).map(function (v) {return encodeURIComponent(v) + '=' + encodeURIComponent(body[v]);}).join('&');
                           xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                       }
                       else
                       {
	                       if (util.isObject(headers) && util.isString(headers["Content-Type"]))
		                       xhr.setRequestHeader("Content-Type", headers["Content-Type"])
	                       else
		                       xhr.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
                       }
                   }
                   if (util.isObject(headers))
                   {
                   	    delete headers["Content-Type"];
	                    delete headers["NSXMLHttpRequest"];
                   	    Object.getOwnPropertyNames(headers).forEach(function(header){
                   	    	xhr.setRequestHeader(header, headers[header]);
                        });
                   }
                   xhr.send(body);
                   if (!async)
                       return extractResponse(xhr, false);
               }
               else
                   return invoker(httpApi, "nlapiRequestURLWithCredentials", [null, url, body, headers, options.method], callback);
           }

           var requestProcess = function(options)
           {
               var requestResponse = runRequest(options);
               return httpUtil.createClientResponse(requestResponse);
           };

           var requestProcessPromise = function (options)
           {
               var myPromise = new Promise( function(resolve, reject)
                                            {
                                                try
                                                {
                                                    runRequest(options, callback)
                                                }
                                                catch(e)
                                                {
                                                    reject(e);
                                                }

                                                function callback(result, exception)
                                                {
                                                    if (exception)
                                                    {
                                                        reject(exception)
                                                    }
                                                    else
                                                    {
                                                        try
                                                        {
                                                            resolve(httpUtil.createClientResponse(result));
                                                        }
                                                        catch(e)
                                                        {
                                                            reject(e);
                                                        }
                                                    }
                                                }
                                            });
               return myPromise
           };
           var httpClient = Object.freeze({doRequest: requestProcess});
           var httpClientPromise = Object.freeze({doRequest: requestProcessPromise } );

           var doGet = function (options, headers) { return httpUtil.get(options, headers, httpClient)};
           doGet.promise = function(options, headers) { return httpUtil.get(options, headers, httpClientPromise)};

           var doPost = function (options) { return httpUtil.post(options, httpClient)};
           doPost.promise = function (options) { return httpUtil.post(options, httpClientPromise)};

           var doPut = function (options) { return httpUtil.put(options, httpClient)};
           doPut.promise = function (options) { return httpUtil.put(options, httpClientPromise)};

           var doDelete = function (options, headers) { return httpUtil['delete'](options, headers, httpClient)};
           doDelete.promise = function (options, headers) { return httpUtil['delete'](options, headers, httpClientPromise)};

           var doRequest = function (options) { return httpUtil.request(options, httpClient)};
           doRequest.promise = function (options) { return httpUtil.request(options, httpClientPromise)};

           return Object.freeze(
                   {
                       Method: httpUtil.Method,
                       CacheDuration: httpUtil.CacheDuration,
                       get: doGet,
                       post: doPost,
                       put: doPut,
                       'delete': doDelete,
                       request: doRequest,
                       getServerRequest: suiteletContext.getServerRequest,
                       getServerResponse: suiteletContext.getServerResponse
                   });

       });

/**
 * @private
 */
define('N/restricted/searchApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript searchPaging module (Client Side)
 * @private Ignore for JSDoc stub generation
 * @module N/search/searchPaging
 * @NApiVersion 2.x
 *
 */
define('N/search/searchPaging',['N/restricted/invoker', 'N/restricted/bridge', 'N/error', 'N/nsobject', 'N/search/pagingUtil'],
function (invoker, api, error, nsobject, pagingUtil){
    function RemotePageRange(options)
    {
        var index = options.index,
            compoundKey = options.compoundKey,
            compoundLabel = options.compoundLabel;

        this.getIndex = function getIndex(){return index;};
        this.getCompoundKey = function getCompoundKey(){return compoundKey;};
        this.getCompoundLabel = function getCompoundLabel(){return compoundLabel;};
    }
    RemotePageRange.prototype = nsobject.getNewInstance();

    function RemotePage(options)
    {
        var data = options.data,
            pageRange = new RemotePageRange(options.pageRange),
            _isFirst = options.isFirst,
            _isLast = options.isLast;

        this.getData = function getData(){return data;};
        this.getPageRange = function getPageRange(){return pageRange};
        this.isFirst = function isFirst(){return _isFirst;};
        this.isLast = function isLast(){return _isLast;};
    }
    RemotePage.prototype = nsobject.getNewInstance();

    function RemotePagedData(options)
    {
        var recordType = options.recordType,
            searchId = options.searchId,
            filters = options.filters,
            columns = options.columns,
            settings = options.settings,
            totalRows = isNaN(options.totalRows) ? -1 : options.totalRows,
            pageSize = isNaN(options.pageSize) ? -1 : options.pageSize,
            pageRanges = Array.isArray(options.pageRanges) && options.pageRanges.map(function(v,i,a){return new RemotePageRange(v);}) || [];

        this.getPageSize = function getPageSize(){return pageSize;};
        this.getTotalRows = function getTotalRows(){return totalRows;};
        this.getPageRanges = function getTotalRows(){return pageRanges;};
        this.getPage = function getPage(index){
            var pageRange = pageRanges[index],
                pageCount = pageRanges.length;

            return new RemotePage(invoker(api, 'getSearchPage', [recordType, searchId, filters, columns, settings,
                pageRange.getCompoundKey(), pageRange.getCompoundLabel(), pageRange.getIndex(),
                pageSize,
                pageRanges[0].getCompoundKey(), pageRanges[pageCount - 1].getCompoundKey(),
                pageCount, null]));
        };
        this.getPagePromise = function getPagePromise(index)
        {
            return new Promise(function(resolve, reject){
                function callback(result, exception) {
                    if (exception)
                    {
                        reject(exception);
                    }
                    else
                    {
                        resolve(new RemotePage(result));
                    }
                }

                try
                {
                    var pageRange = pageRanges[index],
                        pageCount = pageRanges.length;

                    invoker(
                        api,
                        'getSearchPage',
                        [recordType, searchId, filters, columns, settings,
                            pageRange.getCompoundKey(), pageRange.getCompoundLabel(), pageRange.getIndex(),
                            pageSize,
                            pageRanges[0].getCompoundKey(), pageRanges[pageCount - 1].getCompoundKey(),
                            pageCount, null],
                        callback);
                }
                catch(e)
                {
                    reject(e);
                }
            });
        }
    }
    RemotePagedData.prototype = nsobject.getNewInstance();

    var SearchPaging = {};

    SearchPaging.create = function create(options){
        var recordType = options.searchDefinition.searchType,
            searchId = options.searchDefinition.searchId,
            filters = options.filters,//options.searchDefinition.filters,
            columns = options.columns,//options.searchDefinition.columns,
            settings = options.settings,//options.searchDefinition.settings,
            pageSize = pagingUtil.regulatePageSize(options.pageSize);

        var result = invoker(api, 'getSearchPages', [recordType, searchId, filters, columns, settings, pageSize, null]);
        result.recordType = recordType;
        result.searchId = searchId;
        result.filters = filters;
        result.columns = columns;

        return new RemotePagedData(result);
    };

    SearchPaging.create.promise = function createPromise(options){
        var recordType = options.searchDefinition.searchType,
            searchId = options.searchDefinition.searchId,
            filters = options.filters,//options.searchDefinition.filters,
            columns = options.columns,//options.searchDefinition.columns,
            settings = options.settings,//options.searchDefinition.settings,
            pageSize = pagingUtil.regulatePageSize(options.pageSize);

        return new Promise(function(resolve, reject){
            function callback(result, exception) {
                if (exception)
                {
                    reject(exception);
                }
                else
                {
                    result.recordType = recordType;
                    result.searchId = searchId;
                    result.filters = filters;
                    result.columns = columns;
                    result.settings = settings;
                    resolve(new RemotePagedData(result));
                }
            }

            try
            {
                invoker(api, 'getSearchPages', [recordType, searchId, filters, columns, settings, pageSize, null], callback);
            }
            catch(e)
            {
                reject(e);
            }
        });
    };

    return SearchPaging;
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/pagination/paginationObject
 * @suiteScriptVersion 2.x
 */
define('N/pagination/paginationObject',['N/nsobject', 'N/restricted/invoker', 'N/error', 'N/utilityFunctions'],
       function (nsobject, invoker, error, utilityFunctions)
       {
           var interfaces = {};
           
           /**
            * PagedData interface
            *
            * @classdesc Holds metadata for a paginated query.
            * @protected
            * @param {Object} delegate PagedData implementation
            * @return {PagedData}
            * @constructor
            *
            * @since 2015.2
            */
           function PagedData(delegate)
           {
               var that = this;
               var pageRanges;

               function validateFetchParameter(options)
               {
                   var index;
                   index = options !== undefined && options !== null && !util.isNumber(options) && !util.isString(options) ? options.index : options;
                   utilityFunctions.checkArgs([index],['index'], 'PagedData.fetch');
                   return validateIndex(index);
               }

               function validateIndex(index)
               {
                   var i = parseInt(index, 10);
                   if(isNaN(i))
                       utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);

                   return i;
               }
               
               /**
                * The total number of results when Search.runPaged(options) was executed.
                * @name PagedData#count
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'count', {
                   get: function () {
                       return delegate.count;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'count' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * The collection of PageRange objects that divide the entire result set into smaller groups.
                * @name PagedData#pageRanges
                * @type {PageRange[]}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'pageRanges', {
                   get: function () {
                       if(!pageRanges)
                       {
                           pageRanges = [];
                           delegate.pageRanges.forEach(function (v) { pageRanges.push(new PageRange(v)); });
                       }
                       return pageRanges;
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * Maximum number of entries per page
                * @name PagedData#pageSize
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                * 
                * @since 2015.2
                */
               Object.defineProperty(this, 'pageSize', {
                   get: function () {
                       return delegate.pageSize;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * The search criteria used to execute the result set for this PagedData Object.
                * @name PagedData#searchDefinition
                * @type {Search}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                * 
                * @since 2015.2
                */
               Object.defineProperty(this, 'searchDefinition', {
                   get: function () {
                       return utilityFunctions.freezeObjectIfPossible(delegate.searchDefinition);
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * This method retrieves the data within the specified page range.
                * @governance 5 units
                * @param {Object} options the options object
                * @param {number} options.index the index of the page
                * @return {Page}
                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when index parameter is missing
                * 
                * @since 2015.2
                */
               this.fetch = function(options){
                   var index = validateFetchParameter(options);
                   return delegate.fetch(index);
               };

               if (delegate.fetch.promise)
               {
	               /**
	                * This method asynchronously retrieves the data bounded by the pageRange parameter.
	                * @governance 5 units
	                * @param {Object} options the options object
	                * @param {number} options.index the index of the page
	                * @return {Promise}
	                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
	                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when index parameter is missing
	                *
	                * @since 2015.2
	                */
                   this.fetch.promise = function(options){
                       var index = validateFetchParameter(options);
                       return delegate.fetch.promise(index);
                   }
               }

	           /**
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            * 
	            * @since 2015.2
	            */
               this.toJSON = function toJSON(){
                   return {
                       count: that.count,
                       pageRanges: that.pageRanges,
                       pageSize: that.pageSize,
                       searchDefinition: that.searchDefinition
                   }
               };

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            * 
	            * @since 2015.2
	            */
               this.toString = function toString(){
                   return "search.PagedData";
               };
           }
           PagedData.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(PagedData);
           interfaces.PagedData = PagedData;

	       /*
	        * ReadonlyPagedData interface
	        *
	        * @classdesc Holds read-only metadata for a paginated query.
	        * @protected
	        * @param {Object} pagedData PagedData delegate
	        * @return {PagedData}
	        * @constructor
	        *
	        * @since 2015.2
	        */
           function ReadonlyPagedData(pagedData)
           {
               var pageRanges;

	           /*
	            * The collection of PageRange objects that divide the entire result set into smaller groups.
	            * @name ReadonlyPagedData#pageRanges
	            * @type {PageRange[]}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pageRanges', {
                   get: function () {
                       if(!pageRanges)
                       {
                           pageRanges = [];
                           pagedData.pageRanges.forEach(function (v) { pageRanges.push(new PageRange(v)); });
                       }
                       return pageRanges;
                   },
                   enumerable: true,
                   configurable: false
               });

	           /*
	            * The total number of results when Search.runPaged(options) was executed.
	            * @name ReadonlyPagedData#count
	            * @type {number}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'count', {
                   value : pagedData.count,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });

	           /*
	            * Maximum number of entries per page
	            * @name ReadonlyPagedData#pageSize
	            * @type {number}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pageSize', {
                   value : pagedData.pageSize,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });

	           /*
	            * The search criteria used to execute the result set for this PagedData Object.
	            * @name ReadonlyPagedData#searchDefinition
	            * @type {Search}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'searchDefinition', {
                   value : pagedData.searchDefinition,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });

	           /*
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            *
	            * @since 2015.2
	            */
               this.toJSON = pagedData.toJSON;

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            *
	            * @since 2015.2
	            */
               this.toString = function (){ return "search.PagedData(readonly)"; }
           }
           utilityFunctions.freezeObjectIfPossible(ReadonlyPagedData);

           /**
            * Page interface
            *
            * @classdesc Encapsulates an individual search page containing a result set for a paginated search.
            * @protected
            * @param {Object} delegate Page implementation
            * @return {Page}
            * @constructor
            * 
            * @since 2015.2
            */
           function Page(delegate)
           {
               var that = this;
               var _pageRange, readonlyPagedData;

               function getReadOnlyPagedDataInstance()
               {
                   if (!readonlyPagedData)
                       readonlyPagedData = utilityFunctions.freezeObjectIfPossible(new ReadonlyPagedData(delegate.pagedData));

                   return readonlyPagedData;
               }

               /**
                * The PagedData Object used to fetch this Page Object.
                * @name Page#pageData
                * @type {PagedData}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'pagedData', {
                   get: function () {
                       return getReadOnlyPagedDataInstance(delegate.pagedData);
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedData' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The PageRange Object used to fetch this Page Object.
                * @name Page#pageRange
                * @type {PageRange}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'pageRange', {
                   get: function () {
                       if(!_pageRange)
                       {
                           _pageRange = new PageRange(delegate.pageRange);
                       }
                       return _pageRange;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Indicates whether the page is within the first range of the result set.
                * @name Page#isFirst
                * @type {boolean}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'isFirst', {
                   get: function () {
                       return delegate.isFirst;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Indicates whether a page is within the last range of the result set.
                * @name Page#isLast
                * @type {boolean}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'isLast', {
                   get: function () {
                       return delegate.isLast;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The results from a paginated search.
                * @name Page#data
                * @type {Result[]}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'data', {
                   get: function () {
                       return delegate.data;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Method used to fetch the next segment of data
                * @governance 5 units
                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                *
                * @since 2015.2
                */
               this.next = delegate.next;
               if(delegate.next.promise)
               {
                   /**
                    * Method used to asynchronously fetch the next segment of data.
                    * @governance 5 units
                    * @return {Promise}
                    * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                    *
                    * @since 2015.2
                    */
                   this.next.promise = delegate.next.promise;
               }

               /**
                * Method used to fetch the previous segment of data
                * @governance 5 units
                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                *
                * @since 2015.2
                */
               this.prev = delegate.prev;
               if(delegate.prev.promise)
               {
                   /**
                    * Method used to asynchronously fetch the previous segment of data.
                    * @governance 5 units
                    * @return {Promise}
                    * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                    *
                    * @since 2015.2
                    */
                   this.prev.promise = delegate.prev.promise;
               }

	           /**
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            *
	            * @since 2015.2
	            */
	           this.toJSON = function toJSON(){
                   return{
                       pagedData: that.pagedData,
                       pageRange: that.pageRange,
                       isFirst: that.isFirst,
                       isLast: that.isLast,
                       data: that.data
                   }
               };

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            *
	            * @since 2015.2
	            */
               this.toString = function toString(){
                   return "search.Page";
               };
           }
           Page.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(Page);
           interfaces.Page = Page;

           /**
            * PageRange interface
            *
            * @classDescription Defines the page range to contain the result set
            * @protected
            * @param {Object} delegate PageRange implementation
            * @return {PageRange}
            * @constructor
            *
            * @since 2015.2
            */
           function PageRange(delegate)
           {
               var that = this;

               /**
                * The index of the pageRange
                * @name PageRange#index
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'index', {
                   get: function () {
                       return invoker(delegate,'getIndex', []);
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Human-readable label with beginning and ending range identifiers
                * @name PageRange#compoundLabel
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'compoundLabel', {
                   get: function () {
                       return invoker(delegate,'getCompoundLabel', []);
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'compoundLabel' );
                   },
                   enumerable: true,
                   configurable: false
               });

	           /**
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            *
	            * @since 2015.2
	            */
               this.toJSON = function toJSON(){
                   return {
                       index: that.index,
                       compoundLabel: that.compoundLabel
                   }
               };

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            *
	            * @since 2015.2
	            */
               this.toString = function toString(){
                   return "search.PageRange";
               };
           }
           PageRange.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(PageRange);
           interfaces.PageRange = PageRange;


           return Object.freeze(interfaces);
       });

/**
 * SuiteScript search object constructor
 *
 * @private
 * @module N/search/searchObject
 * @suiteScriptVersion 2.x
 *
 */
define('N/search/searchObject',['N/restricted/searchApi', 'N/restricted/remoteApiBridge', 'N/error', 'N/nsobject', 'N/restricted/invoker', 'N/search/searchPaging', 'N/pagination/paginationObject', 'N/utilityFunctions'],
       function (searchApi, remoteApi, error, nsobject, invoker, searchPaging, paginationObject, utilityFunctions)
       {
           var OPERATORS = Object.freeze({
                                             AFTER: 'after',
                                             ALLOF: 'allof',
                                             ANY: 'any',
                                             ANYOF: 'anyof',
                                             BEFORE: 'before',
                                             BETWEEN: 'between',
                                             CONTAINS: 'contains',
                                             DOESNOTCONTAIN: 'doesnotcontain',
                                             DOESNOTSTARTWITH: 'doesnotstartwith',
                                             EQUALTO: 'equalto',
                                             GREATERTHAN: 'greaterthan',
                                             GREATERTHANOREQUALTO: 'greaterthanorequalto',
                                             HASKEYWORDS: 'haskeywords',
                                             IS: 'is',
                                             ISEMPTY: 'isempty',
                                             ISNOT: 'isnot',
                                             ISNOTEMPTY: 'isnotempty',
                                             LESSTHAN: 'lessthan',
                                             LESSTHANOREQUALTO: 'lessthanorequalto',
                                             NONEOF: 'noneof',
                                             NOTAFTER: 'notafter',
                                             NOTALLOF: 'notallof',
                                             NOTBEFORE: 'notbefore',
                                             NOTBETWEEN: 'notbetween',
                                             NOTEQUALTO: 'notequalto',
                                             NOTGREATERTHAN: 'notgreaterthan',
                                             NOTGREATERTHANOREQUALTO: 'notgreaterthanorequalto',
                                             NOTLESSTHAN: 'notlessthan',
                                             NOTLESSTHANOREQUALTO: 'notlessthanorequalto',
                                             NOTON: 'noton',
                                             NOTONORAFTER: 'notonorafter',
                                             NOTONORBEFORE: 'notonorbefore',
                                             NOTWITHIN: 'notwithin',
                                             ON: 'on',
                                             ONORAFTER: 'onorafter',
                                             ONORBEFORE: 'onorbefore',
                                             STARTSWITH: 'startswith',
                                             WITHIN: 'within'
                                         });
	       var ARRAY_BASED_OPERATORS = [OPERATORS.ANYOF, OPERATORS.NONEOF, OPERATORS.ALLOF, OPERATORS.NOTALLOF];
	       var PERIOD_OPERATORS = Object.freeze({
		       ABS: "ABS",
		       REL: "REL"
	       });
           var SUMMARY_TYPES = Object.freeze({
                                                 GROUP: 'GROUP',
                                                 COUNT: 'COUNT',
                                                 SUM: 'SUM',
                                                 AVG: 'AVG',
                                                 MIN: 'MIN',
                                                 MAX: 'MAX'
                                             });
           var FUNCTIONS = Object.freeze({
                                             absoluteValue: '',
                                             ageInHours: '',
                                             ageInDays: '',
                                             ageInMonths: '',
                                             ageInWeeks: '',
                                             ageInYears: '',
                                             calendarWeek: '',
                                             day: '',
                                             month: '',
                                             negate: '',
                                             numberAsTime: '',
                                             percentOfTotal: '',
                                             quarter: '',
                                             rank: '',
                                             round: '',
                                             roundToHundredths: '',
                                             roundToTenths: '',
                                             weekOfYear: '',
                                             year: ''
                                         });
           var SORT = Object.freeze({
                                        ASC: 'ASC',
                                        DESC: 'DESC',
                                        NONE: 'NONE'
                                    });

           function applyValidationFunctionToArrayElement(array, func)
           {
               if (!util.isArray(array))
                   return false;
               for (var i = 0; i < array.length; ++i)
               {
                   if (!func(array[i]))
                       return false;
               }
               return true;
           }
           function resolveUndefined(obj)
           {
               return obj === undefined ? null : obj;
           }
           function resolveUndefinedForArguments(args)
           {
               return args.map(function (v, i, a){ return resolveUndefined(v); });
           }

	       function convertJsFiltersToJavaFilters(jsFilters)
	       {
		       var javaFilters = [];
		       for (var i = 0; jsFilters && i < jsFilters.length; i++)
		       {
			       var filterState = jsFilters[i].toJSON();

			       var useArray = filterState.operator && ARRAY_BASED_OPERATORS.indexOf(filterState.operator.toLowerCase()) > -1;
			       var firstValue = (util.isArray(filterState.values)) ? useArray ? filterState.values : filterState.values[0] : null;
			       var secondValue = (util.isArray(filterState.values) && !useArray) ? filterState.values[1] : null;
			       javaFilters[i] = invoker(searchApi, 'createSearchFilter', [filterState.name, filterState.join || null, filterState.operator, firstValue, secondValue]);

			       if (util.isString(filterState.formula))
				       javaFilters[i].setFormula(filterState.formula);
			       if (util.isString(filterState.summarytype))
				       javaFilters[i].setSummaryType(filterState.summarytype);
			       if (util.isBoolean(filterState.isor))
				       javaFilters[i].setOr(filterState.isor);
			       if (util.isBoolean(filterState.isnot))
				       javaFilters[i].setNot(filterState.isnot);
			       if (util.isNumber(filterState.leftparens))
				       javaFilters[i].setLeftParens(filterState.leftparens);
			       if (util.isNumber(filterState.rightparens))
				       javaFilters[i].setRightParens(filterState.rightparens);
		       }
		       return javaFilters;
	       }

	       function convertJsColumnsToJavaColumns(jsColumns)
	       {
		       var javaColumns = [];
		       for (var i = 0; jsColumns && i < jsColumns.length; i++)
		       {
			       var columnState = jsColumns[i].toJSON();

			       javaColumns[i] = invoker(searchApi, 'createSearchColumn', [columnState.name, columnState.join || null, columnState.summary || null]);

			       if (util.isString(columnState.label))
				       javaColumns[i].setLabel(columnState.label);
			       if (util.isString(columnState.sortdir) && columnState.sortdir !== SORT.NONE)
				       javaColumns[i].setSort(/*isDescending*/ columnState.sortdir === SORT.DESC);
			       if (util.isString(columnState.formula))
				       javaColumns[i].setFormula(columnState.formula);
			       if (util.isString(columnState['function']))
				       javaColumns[i].setFunction(columnState['function']);
			       if (util.isString(columnState.whenorderedby))
				       javaColumns[i].setWhenOrderedBy(columnState.whenorderedby, columnState.whenorderedbyjoin);
		       }
		       return javaColumns;
	       }

	       function convertJsSettingsToJavaSettings(jsSettings)
	       {
		       var javaSettings = [];
		       for (var i = 0; jsSettings && i < jsSettings.length; i++)
		       {
			       var settingState = jsSettings[i].toJSON();
			       javaSettings[i] = invoker(searchApi, 'createSearchSetting', [settingState.name, settingState.value]);

		       }
		       return javaSettings;
	       }

	       /**
            * Return a new instance of search.Search object.
            *
            * @classDescription Encapsulates a NetSuite search.
            * @constructor
            * @param {string} typeOrJavaSearch (optional)  the record type you are searching
            * @param {number} id  the internal ID of the search
            * @param {Filter[]} [filters] a single filter object or an array of filters used to
            *     filter the search
            * @param {Column[]|string[]} [columns]  columns to be returned from the search
            * @return {Search}
            * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER when provided filters contain a different type than search.Filter
            * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when provided columns contain a different type than search.Column
            *     or string 
	          * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING when provided filters contain a different type than search.Setting
	        *
            * @since 2015.2
            */
           function Search(typeOrJavaSearch, searchId, filters, columns, settings)
           {
               var that = this;
               var TYPE = 'search.Search';

               /* private vars */
               var javaSearch = !util.isString(typeOrJavaSearch) ? typeOrJavaSearch : undefined;
               var jsSearch;
               var _type = util.isString(typeOrJavaSearch) ? typeOrJavaSearch : null;
               var _searchId = searchId;
               var _filters;
               var _columns;
	           var _settings;
               var _title = null;
               var _scriptId = null;
               var _isPublic = false;
               var _package = null;
	           
	           /* helper method for loadSearch() */
               this._load = function load(callback)
               {
                   if(!javaSearch)
                       javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, String(_searchId)], callback ? loadCallback : null);

                   if (!callback)
                       loadCallback(javaSearch);

                   function loadCallback(javaSearch, exception)
                   {
                       if (callback && exception)
                       {
                           callback(undefined, exception);
                           return;
                       }
                       jsSearch = invoker(remoteApi, 'transform', [javaSearch]);

                       _isPublic = jsSearch.ispublic;
                       _searchId = (jsSearch.searchId === undefined || jsSearch.searchId === null) ? null : parseInt(jsSearch.searchId, 10);
                       _scriptId = jsSearch.scriptid;
                       _package = jsSearch.packageId;
                       _type = jsSearch.type;
                       _filters = utilityFunctions.unmarshalArray(jsSearch, 'filter', Filter.unmarshalFilter);
                       _columns = utilityFunctions.unmarshalArray(jsSearch, 'column', Column.unmarshalColumn);
	                   _settings = utilityFunctions.unmarshalArray(jsSearch, 'setting', Setting.unmarshalSetting);
                       if (callback)
                           callback(that);
                   }
               };

               /**
                * Internal ID name of the record type on which a search is based.
                * @name Search#searchType
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'searchType', {
                   get: function ()
                   {
                       return _type;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchType' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Internal ID of the search.
                * @name Search#searchId
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'searchId', {
                   get: function ()
                   {
                       return _searchId;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchId' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Filters for the search as an array of Filter objects.
                * @name Search#filters
                * @type {Filter[]}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER Invalid value for search filter type.
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When any filter to assign is of invalid type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'filters', {
                   get: function ()
                   {
                       return _filters;
                   },
                   set: function (filters)
                   {
                       _filters = filters ? (util.isArray(filters) ? filters : [filters]) : null;
                       if (_filters !== null)
                       {
                           for (i = 0; i < _filters.length; i++)
                           {
                                if (util.isObject(_filters[i]) )
                                    _filters[i] = createFilter( _filters[i] )
                                else if (!(_filters[i] instanceof Filter))
                                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filters['+i+']', 'Filter' );
                           }
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, '_rawFilters', {
                   get: function ()
                   {
                       return Filter.marshalFilters(_filters);
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Use filter expressions as a shortcut to create filters (search.Filter).
                * @name Search#filterExpression
                * @type {Object[]}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR The options.filters parameter is not a valid search filter, filter array, or filter expression.
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER Invalid value for search filter type.
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When filterExpression contains a member with invalid type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'filterExpression', {
                   get: function ()
                   {
                       var rawFilters = Filter.marshalFilters(_filters);
                       var payload = invoker(remoteApi, 'buildSearchFilterExpression', [rawFilters]);
                       payload = invoker(remoteApi, 'transform', [payload]);
                       return Filter.unmarshalFilterExpression(payload);
                   },
                   set: function (filterExpression)
                   {
                       filterExpression = Filter.normalizeFilters(filterExpression);
                       utilityFunctions.assertTrue(!applyValidationFunctionToArrayElement(filterExpression, Filter.isFilterObject), error.Type.WRONG_PARAMETER_TYPE, 'filterExpression', 'Filter');
                       _filters = Filter.parseFilterExpression(filterExpression);
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Columns to return for this search as an array of search.Column objects or a string array of column names.
                * @name Search#columns
                * @type {Column[]|string[]}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when setting value of different type than search.Column or string
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When any column to assign is of invalid type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return _columns;
                   },
                   set: function (columns)
                   {
                       _columns = columns ? (util.isArray(columns) ? columns : [columns]) : null;
                       if (_columns !== null)
                       {
                           for (var i = 0; i < _columns.length; i++)
                           {
                                if (util.isObject(_columns[i]))
                                    _columns[i] = createColumn( _columns[i] )
                                else if (util.isString(_columns[i]))
                                   _columns[i] = new Column(getNameFromColumn(_columns[i]), getJoinFromColumn(_columns[i]), null);
                               else if (!(_columns[i] instanceof Column))
                                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns['+i+']', 'Column' );

                               _columns[i]._setIndex(i + 1);
                           }
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, '_rawColumns', {
                   get: function ()
                   {
                       return Column.marshalColumns(_columns);
                   },
                   enumerable: false,
                   configurable: false
               });

	           /**
	            * Search settings for this search as an array of search.Setting objects or a string array of column names.
	            * @name Search#settings
	            * @type Setting[]|string[] (setter accepts also a single search.Setting or string)
	            * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
	            * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
	            * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When any setting to assign is of invalid type
	            *
	            * @ince 2018.2
	            */
	           Object.defineProperty(this, 'settings', {
		           get: function ()
		           {
			           return _settings;
		           },
		           set: function (settings)
		           {
			           _settings = settings ? (util.isArray(settings) ? settings : [settings]) : null;
			           if (_settings !== null)
			           {
				           for (var i = 0; i < _settings.length; i++)
				           {
					           if (util.isObject(_settings[i]))
						           _settings[i] = createSetting( _settings[i] )
					           else if (util.isArray(_settings[i]) && _settings[i].length==2 && util.isString(_settings[i][0]) && util.isString(_settings[i][1]))
						           _settings[i] = new Setting(_settings[i][0], _settings[i][1]);
					           else if (!(_settings[i] instanceof Setting))
						           utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'settings['+i+']', 'Setting' );

				           }
			           }
		           },
		           enumerable: true,
		           configurable: false
	           });

	           Object.defineProperty(this, '_rawSettings', {
		           get: function ()
		           {
			           return Setting.marshalSettings(_settings);
		           },
		           enumerable: false,
		           configurable: false
	           });

               /**
                * Title for a saved search. Use this property to set the title for a search before you save it for the first time.
                * @name Search#title
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'title', {
                   get: function ()
                   {
                       return _title;
                   },
                   set: function (val)
                   {
                       _title = val;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Script ID for a saved search, starting with customsearch. If you do not set this property and then save the search, NetSuite generates a script ID for you.
                * @name Search#id
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'id', {
                   get: function ()
                   {
                       return _scriptId;
                   },
                   set: function (val)
                   {
                       _scriptId = val;
                   },
                   enumerable: true,
                   configurable: false
               });

	           /**
	            * The application ID for this search.
	            * @name Search#package
	            * @type {string}
	            *
	            * @since 2019.2
	            */
	           Object.defineProperty(this, 'packageId', {
		           get: function ()
		           {
			           return _package;
		           },
		           set: function (val)
		           {
			           _package = val;
		           },
		           enumerable: true,
		           configurable: false
	           });

               /**
                * Value is true if the search is public, or false if it is not. By default, all searches created through search.create(options) are private.
                * @name Search#isPublic
                * @type {boolean}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'isPublic', {
                   get: function ()
                   {
                       return _isPublic;
                   },
                   set: function (val)
                   {
                       _isPublic = val;
                   },
                   enumerable: true,
                   configurable: false
               });

               function doSave(callback)
               {
                   var rawFilters = Filter.marshalFilters(_filters);
                   var rawColumns = Column.marshalColumns(_columns);
	               var rawSettings = Setting.marshalSettings(_settings);
                   return invoker(searchApi, 'nlapiSaveSearch', [_title, _scriptId, _type, String(_searchId), rawFilters, rawColumns, rawSettings, _isPublic, _package], callback);
               }

               /**
                * Saves a search created by search.create(options) or loaded with search.load(options). Returns the internal ID of the saved search.
                * @governance 5 units
                * @return {number} the internal search ID of the saved search
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required Search.title property not set on search.Search.
                * @throws {SuiteScriptError} NAME_ALREADY_IN_USE The Search.title property on search.Search is not unique.
                * @throws {SuiteScriptError} SSS_DUPLICATE_SEARCH_SCRIPT_ID The Search.id property on search.Search is not unique.
                *
                * @since 2015.2
                */
               this.save = function save()
               {
                   return parseInt(doSave(), 10);
               };

	           /**
	            * Asynchronously saves a search created by search.create(options) or loaded with search.load(options). Returns the internal ID of the saved search.
	            * @governance 5 units
	            * @return {Promise}
	            * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required Search.title property not set on search.Search.
	            * @throws {SuiteScriptError} NAME_ALREADY_IN_USE The Search.title property on search.Search is not unique.
	            * @throws {SuiteScriptError} SSS_DUPLICATE_SEARCH_SCRIPT_ID The Search.id property on search.Search is not unique.
	            *
	            * @since 2015.2
	            */
                   this.save.promise = function ()
                   {
                       var myPromise = new Promise(function (resolve, reject)
                       {
                           try
                           {
                               doSave(callback)
                           }
                           catch (e)
                           {
                               reject(e);
                           }

                       function callback(result, exception)
                           {
                           if (exception)
                               {
                               reject(exception)
                               }
                               else
                               {
                                   try
                                   {
                                       resolve(parseInt(result, 10));
                                   }
                                   catch (e)
                                   {
                                       reject(e);
                                   }
                               }
                           }
                       });
                       return myPromise;
                   };

               /**
                * Runs an on-demand search created with search.create(options) or a search loaded with search.load(options), returning the results as a search.ResultSet.
                * @governance none
                * @return {ResultSet} the result set object
                *
                * @since 2015.2
                */
               this.run = function run()
               {
                   return new ResultSet(clone());
               };

               /**
                * Runs the current search and returns summary information about paginated results. Calling this method does not give you the result set or save the search.
                * @governance none
                * @return {SearchPagedData} PagedData object that allows user to page through the search result
                *
                * @since 2016.1
                */
               this.runPaged = function runPaged(options)
               {
                   var pageSize = options && options.pageSize;

                   var pagedData = new SearchPagedData({
                       delegate: searchPaging.create({
                                                         searchDefinition: that,
                                                         filters: Filter.marshalFilters(that.filters),
                                                         columns: Column.marshalColumns(that.columns),
	                                                     settings: Setting.marshalSettings(that.settings),
                                                         pageSize: pageSize
                                                     }),
                       searchDefinition: that
                   });
                   return new paginationObject.PagedData(pagedData);
               };

               /**
                * Runs the current search asynchronously and returns a search.PagedData Object.
                * @governance none
                * @return {Promise} A promise object returning a PagedData object that allows user to page through the search result
                *
                * @since 2016.1
                */
                   this.runPaged.promise = function runPaged(options)
                   {
                       var pageSize = options && options.pageSize;

                       return searchPaging.create.promise({
                                                              searchDefinition: that,
                                                              filters: Filter.marshalFilters(that.filters),
                                                              columns: Column.marshalColumns(that.columns),
															  settings: Setting.marshalSettings(that.settings),
                                                              pageSize: pageSize
                                                          }).then(function(value){
                           var pagedData = new SearchPagedData({
                               delegate: value,
                               searchDefinition: that
                           });
                           return new paginationObject.PagedData(pagedData);
                       });
                   };

               /**
                * Returns the object type name (search.Search)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       type: _type,
                       id: _searchId,
                       filters: _filters,
                       columns: _columns,
	                   settings: _settings,
                       title: _title,
                       scriptId: _scriptId,
                       isPublic: _isPublic,
	                   packageId: _package
                   };
               };

               /* private methods */
               function clone()
               {
                   var i;
                   var filtersCopy = [];
                   for (i = 0; _filters && i < _filters.length; ++i)
                       filtersCopy.push(_filters[i]._clone());

	               var settingsCopy = [];
	               for (i = 0; _settings && i < _settings.length; ++i)
		               settingsCopy.push(_settings[i]._clone());

                   var columnsCopy = [];
                   for (i = 0; _columns && i < _columns.length; ++i)
                       columnsCopy.push(_columns[i]._clone());
                   var clone = new Search(_type, _searchId, filtersCopy, columnsCopy, settingsCopy);
                   clone.title = _title;
                   clone.id = _scriptId;
                   clone.isPublic = _isPublic;
                   return clone;
               }

	           this.redirectToSearch = function redirectToSearch()
	           {
		           var javaFilters = convertJsFiltersToJavaFilters(_filters);
		           var javaColumns = convertJsColumnsToJavaColumns(_columns);
		           var javaSettings = convertJsSettingsToJavaSettings(_settings);

		           if (!javaSearch) {
			           if (_searchId === -1 || searchId === '-1')
				           javaSearch = invoker(searchApi, 'nlapiCreateSearch', [_type, javaFilters, javaColumns, javaSettings]);
			           else
			           {
				           javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, String(_searchId)]);
				           javaSearch.addFilters(javaFilters);
				           javaSearch.addColumns(javaColumns);
			           }
		           }

		           return invoker(javaSearch, 'setRedirectURLToSearch', []);
	           };

	           this.redirectToSearchResults = function redirectToSearchResults()
	           {
		           var javaFilters = convertJsFiltersToJavaFilters(_filters);
		           var javaColumns = convertJsColumnsToJavaColumns(_columns);
		           var javaSettings = convertJsSettingsToJavaSettings(_settings);

		           if (!javaSearch)
		           {
			           if (_searchId === -1 || searchId === '-1')
				           javaSearch = invoker(searchApi, 'nlapiCreateSearch', [_type, javaFilters, javaColumns, javaSettings]);
			           else
			           {
				           javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, String(_searchId)]);
				           javaSearch.addFilters(javaFilters);
				           javaSearch.addColumns(javaColumns);
				           javaSearch.addSettings(javaSettings);
			           }
		           }
		           else
		           {
			           javaSearch.addFilters(javaFilters);
			           javaSearch.addColumns(javaColumns);
		           }

		           return invoker(javaSearch, 'setRedirectURLToSearchResults', []);
	           };

               // this ensures that the checks in filter/column setters are also executed upon construction
               this.filters = filters;
               this.columns = columns;
	           this.settings = settings;
           }
           Search.prototype = nsobject.getNewInstance();

           /**
            * Return a new instance of search.Filter object.
            *
            * @classDescription Encapsulates a search filter used in a search.
            * @protected
            * @constructor
            * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
            * @throws {SuiteScriptError} SSS_INVALID_SRCH_OPERATOR if an unknown operator is provided
            *
            * @since 2015.2
            */
           function Filter(name, join, operator, values)
           {
               var TYPE = 'search.Filter';

               //constructor logic
                utilityFunctions.checkArgs([name, operator], ['name', 'operator'], 'search.Filter');

               /* private instance vars */
               var _name = name;
               var _join = join;
               if (!util.isString(operator) || (!OPERATORS[operator.toUpperCase()] && !PERIOD_OPERATORS[operator.toUpperCase()]))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SRCH_OPERATOR, operator + "", "[" + Object.keys(OPERATORS).join(", ") + "]");

               var _operator = operator;
               var _values = null;
               var formula = null;
               var summarytype = null;
               var isor = false;
               var isnot = false;
               var leftparens = 0;
               var rightparens = 0;

               addValue(values);

               /* private methods */
               function addValue(val)
               {
                   if (!_values)
                       _values = [];
                   if (util.isArray(val))
                   {
                       for (var i = 0; i < val.length; i++)
                       {
                           if (val[i] || val[i] === 0)
                               _values.push(val[i].toString());
                       }
                   }
                   else if (val !== null && val !== undefined)
                       _values.push(val.toString());

                   return _values;
               }

               /* public undocumented methods */
               this._clone = function _clone()
               {
                   var clone = new Filter(_name, _join, _operator, _values);
                   clone._unmarshal(this._marshal());
                   return clone;
               };
               this._unmarshal = function _unmarshal(filterJSON)
               {
                   formula = filterJSON.formula;
                   summarytype = filterJSON.summarytype;
                   isor = filterJSON.isor;
                   isnot = filterJSON.isnot;
                   leftparens = filterJSON.leftparens;
                   rightparens = filterJSON.rightparens;
               };
               this._marshal = function _marshal()
               {
                   var filterObject = {};
                   filterObject.name = _name;
                   filterObject.join = _join;
                   filterObject.operator = _operator;
                   filterObject.values = (!_values || _values.length === 0) ? null : _values;
                   filterObject.formula = formula;
                   filterObject.summarytype = summarytype;
                   filterObject.isor = isor;
                   filterObject.isnot = isnot;
                   filterObject.leftparens = leftparens;
                   filterObject.rightparens = rightparens;
                   return filterObject;
               };

               /**
                * Name or internal ID of the search field as a string.
                * @name Filter#name
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'name', {
                   get: function ()
                   {
                       return _name;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Join ID for the search filter as a string.
                * @name Filter#join
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'join', {
                   get: function ()
                   {
                       return _join;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Operator used for the search filter.
                * @name Filter#operator
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'operator', {
                   get: function ()
                   {
                       return _operator;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Summary type for the search filter.
                * @name Filter#summary
                * @type {string}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_SUM when setting invalid summary type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'summary', {
                   get: function ()
                   {
                       return summarytype;
                   },
                   set: function (type)
                   {
                       if (type !== null)
                       {
                           if (!util.isString(type) || !SUMMARY_TYPES[type.toUpperCase()])
                               utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'summary', JSON.stringify(Object.keys(SUMMARY_TYPES)));

                           summarytype = type.toUpperCase();
                       }
                       else
                       {
                           summarytype = null;
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Formula used by the search filter.
                * @name Filter#formula
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'formula', {
                   get: function ()
                   {
                       return formula;
                   },
                   set: function (sformula)
                   {
                       formula = sformula;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Returns the object type name (search.Filter)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       name: _name,
                       join: _join,
                       operator: _operator,
                       values: _values,
                       formula: formula,
                       summarytype: summarytype,
                       isor: isor,
                       isnot: isnot,
                       leftparens: leftparens,
                       rightparens: rightparens
                   };
               }
           }
           Filter.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*----- Helper function used for parse search filter expression -----*/
           Filter.parseFilterExpression = function (filterExpression, callback)
           {
               if (applyValidationFunctionToArrayElement(filterExpression, Filter.isFilterObject))
               {
                   if (callback)
                   {
                       callback(filterExpression);
                       return;
                   }
                   else
                   {
                       return filterExpression;
                   }
               }
               checkFilterExpression(filterExpression, 'filters');
               var marshaled = Filter.marshalFiltersOrExpression(filterExpression);
               if (!callback)
               {
                   var javaResult = invoker(remoteApi, 'parseSearchFilterExpression', [marshaled]);
                   return filterCallback(javaResult);
               }
               else
               {
                   invoker(remoteApi, 'parseSearchFilterExpression', [marshaled], filterCallback)
               }

               function filterCallback(javaResult)
               {
                   var nativeResult = invoker(remoteApi, 'transform', [javaResult]);
                   var result = [];
                   for (var i = 0; nativeResult && i < nativeResult.length; i++)
                   {
                       result.push(Filter.unmarshalFilter(nativeResult[i]));
                   }
                   if (callback)
                       callback(result);
                   else
                       return result;
               }
           };

           /*----- Helper function used for marshalling js search.Filter for Remote API -----*/
           Filter.marshalFiltersOrExpression = function (filtersOrExpression)
           {
               if (typeof filtersOrExpression === 'undefined' || filtersOrExpression === null)
                   return null;
                utilityFunctions.assertTrue(util.isArray(filtersOrExpression), error.Type.WRONG_PARAMETER_TYPE,filtersOrExpression,'Array');
                return utilityFunctions.arrayToMap(filtersOrExpression, function (elem)
               {
                   if (Filter.isFilterObject(elem))
                       return elem._marshal();
                   var container = {javaClass: "java.util.HashMap"};
                   if (util.isArray(elem))
                       container.arrayValue = Filter.marshalFiltersOrExpression(elem);
                   else
                       container.stringValue = elem;
                   return container;
               });
           };

           Filter.isFilterObject = function (obj)
           {
                return (obj instanceof Filter) || util.isObject(obj);
           };

           Filter.marshalFilters = function (filters)
           {
               filters = utilityFunctions.getAsArray(filters);
                utilityFunctions.assertArrayElementsOfSameType(filters, Filter, 'filters');

               /* add filter. */
               var rawFilters = [];
               for (var i = 0; filters && i < filters.length; i++)
               {
                   rawFilters.push(filters[i]._marshal());
               }
               return rawFilters;
           };

           Filter.unmarshalFilterExpression = function (mapArrayPayload)
           {
                return utilityFunctions.arrayToMap(mapArrayPayload, function (map)
               {
                   if (map.arrayValue != null)
                       return Filter.unmarshalFilterExpression(map.arrayValue);
                   if (map.stringValue != null)
                       return map.stringValue;
                   return Filter.unmarshalFilter(map);
               });
           };

           /*----- Helper function used for unmarshalling search.Filter from server. -----*/
           Filter.unmarshalFilter = function (filterJSON)
           {
               var filter = new Filter(filterJSON.name, filterJSON.join, filterJSON.operator, filterJSON.values);
               filter._unmarshal(filterJSON);
               return filter;
           };

           Filter.normalizeFilters = function (filters)
           {
               return (Filter.isFilterObject(filters) || isFilterExpressionArray(filters)) ? [filters] : (!filters ? null : filters);
           };

           /*----- Helper function to validate search filter expression (advanced search) -----*/
           function checkFilterExpression(array, name)
           {
               utilityFunctions.assertTrue(!array || applyValidationFunctionToArrayElement(array, isFilterExpTerm), error.Type.WRONG_PARAMETER_TYPE, name, 'Array');
           }

           function isFilterExpTerm(obj)
           {
               if (typeof obj === 'undefined' || !obj)
                   return false;
               if (util.isString(obj))
                   return /not|and|or/i.test(obj);
               if (isFilterExpressionArray(obj))
                   return true;
               return applyValidationFunctionToArrayElement(obj, isFilterExpTerm);
           }

           function isFilterExpressionArray(array)
           {
               return util.isArray(array) && array.length >= 3 && util.isString(array[0]) && util.isString(array[1]) && !/^not$/i.test(array[0]);
           }

	       /**
	        * Return a new instance of search.Setting object.
	        *
	        * @class Setting
	        * @classDescription Defines a search setting.
	        * @protected
	        * @constructor
	        *
	        * @since 2018.2
	        */
	       function Setting(name, value)
	       {
		       var TYPE = 'search.Setting';

		       //constructor logic
		       utilityFunctions.checkArgs([name, value], ['name', 'value'], 'search.Setting');

		       /* private instance vars */
		       var _name = name;
		       var _value = value;


		       /* public undocumented methods */
		       this._clone = function _clone()
		       {
			       var clone = new Setting(_name, _value);
			       clone._unmarshal(this._marshal());
			       return clone;
		       };
		       this._marshal = function _marshal()
		       {
			       var settingObject = {};
			       settingObject.name = _name;
			       settingObject.value = _value;
			       return settingObject;
		       };

		       /**
		        * The name of the search parameter.
		        * @name Setting#name
		        * @type {string}
		        * @readonly
		        * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
		        *
		        * @since 2018.2
		        */
		       Object.defineProperty(this, 'name', {
			       get: function ()
			       {
				       return _name;
			       },
			       set: function (val)
			       {
				       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
			       },
			       enumerable: true,
			       configurable: false
		       });

		       /**
		        * The value of the search parameter.
		        * @name Setting#value
		        * @type {string}
		        * @readonly
		        * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
		        *
		        * @since 2018.2
		        */
		       Object.defineProperty(this, 'value', {
			       get: function ()
			       {
				       return _value;
			       },
			       set: function (val)
			       {
				       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value' );
			       },
			       enumerable: true,
			       configurable: false
		       });

		       /**
		        * Returns the object type name (search.Setting)
		        * @governance none
		        * @return {string}
		        *
		        * @since 2018.2
		        */
		       this.toString = function toString()
		       {
			       return TYPE;
		       };

		       /**
		        * get JSON format of the object
		        * @governance none
		        * @return {Object}
		        *
		        * @since 2018.2
		        */
		       this.toJSON = function toJSON()
		       {
			       return {
				       name: _name,
				       value: _value
			       };
		       };

		       this._unmarshal = function _unmarshal(settingJSON)
		       {
			       _value = settingJSON.value;
		       };
	       }
	       Setting.prototype = nsobject.getNewInstance();

	       /* public static methods */
	       /*----- Helper function used for marshalling js search.Setting for Remote API -----*/
	       Setting.marshalSettings = function marshalSettings(settings)
	       {
		       settings = utilityFunctions.getAsArray(settings);
		       utilityFunctions.assertArrayElementsOfSameType(settings, Setting, 'settings');

		       /* add settings. */
		       var rawSettings = [];
		       for (var i = 0; settings && i < settings.length; i++)
		       {
			       rawSettings.push(settings[i]._marshal());
		       }
		       return rawSettings;
	       };
	       Setting.unmarshalSetting = function unmarshalSetting(settingJSON)
	       {
		       var opt = new Setting(settingJSON.name, settingJSON.value);
		       return opt;
	       };


	       /**
            * Return a new instance of search.Column object.
            *
            * @classDescription Encapsulates a single search column in a search.Search. Use the methods and properties available to the Column object to get or set Column properties.
            * @protected
            * @constructor
	        * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN_SUM if an unknown summary type is provided
	        * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name parameter is missing
            *
            * @since 2015.2
            */
           function Column(name, join, summary)
           {
               var TYPE = 'search.Column';

               //constructor logic
                utilityFunctions.checkArgs([name], ['name'], 'search.Column');

               if (summary != null && (!util.isString(summary) || !SUMMARY_TYPES[summary.toUpperCase()]))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'summary', JSON.stringify(Object.keys(SUMMARY_TYPES)));

               /* private vars */
               var that = this;
               var type = null;
               var label = null;
               var functionid = null;
               var formula = null;
               var sortdir = SORT.NONE;
               var index = -1;
               var userindex = -1;
               var whenorderedby = null;
               var whenorderedbyjoin = null;
	           var whenorderedbyalias = null;

               /**
                * The name of the search column.
                * @name Column#name
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'name', {
                   get: function ()
                   {
                       return name;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The join ID for this search column.
                * @name Column#join
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'join', {
                   get: function ()
                   {
                       return join;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join');
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The summary type for this search column.
                * @name Column#summary
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'summary', {
                   get: function ()
                   {
                       return summary != null ? summary.toUpperCase() : null;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'summary');
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The formula used for this search column.
                * @name Column#formula
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'formula', {
                   get: function ()
                   {
                       return formula;
                   },
                   set: function (sformula)
                   {
                       formula = sformula;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The label used for this search column.
                * @name Column#label
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'label', {
                   get: function ()
                   {
                       return label;
                   },
                   set: function (slabel)
                   {
                       label = slabel;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The function used in this search column.
                * @name Column#function
                * @type {string}
                * @throws {SuiteScriptError} INVALID_SRCH_FUNCTN Unknown function is set.
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When assigning unsupported function is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'function', {
                   get: function ()
                   {
                       return functionid == null ? 'none' : functionid;
                   },
                   set: function (sfunctionid)
                   {
                       if (sfunctionid === 'none' || sfunctionid === null)
                           functionid = null;
                       else
                       {
                            utilityFunctions.assertTrue(sfunctionid && FUNCTIONS[sfunctionid] != null, error.Type.WRONG_PARAMETER_TYPE, sfunctionid, JSON.stringify(Object.keys(FUNCTIONS)));
                           functionid = sfunctionid;
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The sort direction for this search column. Use values from the Sort enum.
                * @name Column#sort
                * @type {string}
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When assigning unsupported direction is attempted
                * @since 2015.2
                */
               Object.defineProperty(this, 'sort', {
                   get: function ()
                   {
                       return sortdir;
                   },
                   set: function (direction)
                   {
                        utilityFunctions.assertTrue(direction && SORT[direction], error.Type.WRONG_PARAMETER_TYPE, direction, JSON.stringify(Object.keys(SORT)));
                       sortdir = SORT[direction];
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Returns the search column for which the minimal or maximal value should be found when returning the search.Column
                * value. For example, can be set to find the most recent or earliest date, or the largest or smallest amount for a
                * record, and then the search.Column value for that record is returned. Can only be used when summary type is MIN
                * or MAX.
                * @governance none
                * @param {Object} options  the options object
                * @param {string} options.name The name of the search column for which the minimal or maximal value should be found.
                * @param {string} options.join The join id for the search column.
                * @return {Column} this search column
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name or join parameter is missing
                *
                * @since 2015.2
                */
               this.setWhenOrderedBy = function setWhenOrderedBy(options)
               {
                   var name = null, join = null;

                   if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join')))
                   {
                       name = options.name;
                       join = options.join;
                   }
                   else
                   {
                       name = options;
                       join = arguments[1];
                   }
                    utilityFunctions.checkArgs([name, join], ['name', 'join'], 'Column.setWhenOrderedBy');
                   whenorderedby = name;
                   whenorderedbyjoin = join;
                   return that;
               };

               /**
                * Returns the object type name (search.Column)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       name: name,
                       join: join,
                       summary: summary,
                       label: label,
                       type: type,
                       'function': functionid,
                       formula: formula,
                       sortdir: sortdir,
                       whenorderedby: whenorderedby,
                       whenorderedbyjoin: whenorderedbyjoin,
	                   whenorderedbyalias: whenorderedbyalias
                   };
               };

               /* public undocumented methods */
               this._setType = function _setType(sType) { type = sType; };
               this._getIndex = function _getIndex() { return index };
               this._setIndex = function _setIndex(nIndex)
               {
                   index = nIndex;
                   return that;
               };
               this._setUserIndex = function _setUserIndex(nUserIndex)
               {
                   userindex = nUserIndex;
                   return that;
               };
               this._clone = function _clone()
               {
                   var clone = new Column(name, join, summary);
                   clone._unmarshal(this._marshal());
                   clone._setIndex(index);
                   clone._setUserIndex(userindex);
                   return clone;
               };
               this._unmarshal = function _unmarshal(columnJSON)
               {
                   label = columnJSON.label;
                   type = columnJSON.type;
                   functionid = columnJSON.functionid;
                   formula = columnJSON.formula;
                   sortdir = columnJSON.sortdir ? columnJSON.sortdir : SORT.NONE;
                   whenorderedby = columnJSON.whenorderedby;
                   whenorderedbyjoin = columnJSON.whenorderedbyjoin;
	               whenorderedbyalias = columnJSON.whenorderedbyalias;
                   return that;
               };
               this._marshal = function _marshal()
               {
                   return {
                       name: name,
                       join: join,
                       summary: summary,
                       label: label,
                       type: type,
                       functionid: functionid,
                       formula: formula,
                       sortdir: sortdir === SORT.NONE ? null : sortdir,
                       index: index,
                       userindex: userindex,
                       whenorderedby: whenorderedby,
                       whenorderedbyjoin: whenorderedbyjoin,
	                   whenorderedbyalias: whenorderedbyalias
                   };
               };
           }

           Column.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*----- Helper function used for marshalling js search.Column for Remote API -----*/
           Column.marshalColumns = function marshalColumns(columns)
           {
               columns = utilityFunctions.getAsArray(columns);
                utilityFunctions.assertArrayElementsOfSameType(columns, Column, 'columns');

               /* add columns. */
               var rawColumns = [];
               for (var i = 0; columns && i < columns.length; i++)
               {
                   columns[i]._setUserIndex(i + 1);
                   rawColumns.push(columns[i]._marshal());
               }
               return rawColumns;
           };

           Column.unmarshalColumn = function unmarshalColumn(columnJSON)
           {
               var col = new Column(columnJSON.name, columnJSON.join, columnJSON.summary);
               return col._unmarshal(columnJSON);
           };

           function getNameFromColumn(column)
           {
	           var firstDotPosition = column.indexOf('.');
	           var lastDotPosition = column.lastIndexOf('.');

	           // excluded segment transaction column field using SuperId from parsing as it has a dot in the field name by default
	           if (firstDotPosition == lastDotPosition)
		           return firstDotPosition !== -1 && !isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition) ? column.substring(firstDotPosition + 1) : column;
	           else
		           return isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition)
			           ? column.substring(lastDotPosition + 1)
			           : column.substring(firstDotPosition + 1);
           }

           function getJoinFromColumn(column)
           {
	           var firstDotPosition = column.indexOf('.');
	           var lastDotPosition = column.lastIndexOf('.');

	           if (firstDotPosition == lastDotPosition)
		           return firstDotPosition !== -1 && !isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition) ? column.substring(0, firstDotPosition) : null;
	           else
		           return isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition)
			           ? column.substring(0, lastDotPosition)
			           : column.substring(0, firstDotPosition);
           }

	       function isSegmentTranColumnFieldUsingSuperId(column, dotPosition)
	       {
		       return (column.substring(0, dotPosition).toLowerCase() === 'line') && (column.toLowerCase().indexOf('cseg') == dotPosition + 1);
	       }

           /**
            * Return a new instance of search.ResultSet object.
            *
            * @classDescription Encapsulation of a search result set.
            * @protected
            * @constructor
            *
            * @since 2015.2
            */
           function ResultSet(searchObject)
           {
               var TYPE = 'search.ResultSet';

               var search = searchObject;
               var FOR_EACH_RESULT_MAX_ROWS = 4000;
               var FOR_EACH_RESULT_MAX_ROWS_ERR_MSG = 'No more than ' + FOR_EACH_RESULT_MAX_ROWS + ' search results may be returned at one time from ResultSet.each(). Please revise your search criteria or modify the callback logic so that no more than ' + FOR_EACH_RESULT_MAX_ROWS + ' results are returned.';

               /**
                * List of columns contained in this result set.
                * @name ResultSet#columns
                * @type {Column[]}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return search.columns;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
                   },
                   enumerable: true,
                   configurable: false
               });


               Object.defineProperty(this, '_getResultset', {
                   get: function ()
                   {
                       var start = 0, end = 1000;
                       var rawFilters = Filter.marshalFilters(search.filters);
                       var rawColumns = Column.marshalColumns(search.columns);
	                   var rawSettings = Setting.marshalSettings(search.settings);
                       var javaResults = invoker(searchApi, 'nlapiSearchRange', [search.searchType, String(search.id), rawFilters, rawColumns, rawSettings, start, end]);
                       return javaResults;
                   },
                   enumerable: false,
                   configurable: false
               });

               function getRange_postProcess(javaResults)
               {
                   var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                   return Result.extractResults(rawResults, search.columns, javaResults);
               }

               /**
                * Retrieve a slice of the search result set. Only 1000 results can be returned at a time. If there are fewer results
                * available than requested, then the array will be truncated.
                * @governance 10 units
                * @param {Object} options  the options object
                * @param {number} options.start  the index number of the first result to return, inclusive
                * @param {number} options.end  the index number of the last result to return, exclusive
                * @return {Result[]} the requested slice of the search result set
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when start or end parameters are missing
                *
                * @since 2015.2
                */
               this.getRange = function getRange()
               {
                   var start = null, end = null;
                   if (arguments[0] && (arguments[0].hasOwnProperty('start') || arguments[0].hasOwnProperty('end')))
                   {
                       start = arguments[0].start;
                       end = arguments[0].end;
                   }
                   else
                   {
                       start = arguments[0];
                       end = arguments[1];
                   }
                    utilityFunctions.checkArgs([start, end], ['start', 'end'], 'ResultSet.getRange');

                    utilityFunctions.assertTrue(start >= 0, error.Type.SSS_INVALID_SEARCH_RESULT_INDEX);
                    utilityFunctions.assertTrue((end - start) <= 1000, error.Type.SSS_SEARCH_RESULT_LIMIT_EXCEEDED);
                   if (start >= end)
                       return [];

                   var rawFilters = Filter.marshalFilters(search.filters);
                   var rawColumns = Column.marshalColumns(search.columns);
	               var rawSettings = Setting.marshalSettings(search.settings);
                   var javaResults = invoker(searchApi, 'nlapiSearchRange', [search.searchType, String(search.id), rawFilters, rawColumns, rawSettings, start, end]);
                   return getRange_postProcess(javaResults);
               };
                   this.getRange.promise = function ()
                   {
                       var args = arguments;
                       var myPromise = new Promise(function (resolve, reject)
                       {
                           try
                           {
                               var start = null, end = null;
                               if (args[0] && (args[0].hasOwnProperty('start') || args[0].hasOwnProperty('end')))
                               {
                                   start = args[0].start;
                                   end = args[0].end;
                               }
                               else
                               {
                                   start = args[0];
                                   end = args[1];
                               }
                               utilityFunctions.checkArgs([start, end], ['start', 'end'], 'ResultSet.getRange');

                               utilityFunctions.assertTrue(start >= 0, error.Type.SSS_INVALID_SEARCH_RESULT_INDEX);
                               utilityFunctions.assertTrue((end - start) <= 1000, error.Type.SSS_SEARCH_RESULT_LIMIT_EXCEEDED);
                               if (start >= end)
                                   resolve([]);

                               var rawFilters = Filter.marshalFilters(search.filters);
                               var rawColumns = Column.marshalColumns(search.columns);
                               invoker(searchApi, 'nlapiSearchRange', [search.searchType, String(search.id), rawFilters, rawColumns, start, end], callback);
                           }
                           catch (e)
                           {
                               reject(e);
                           }

                       function callback(result, exception)
                           {
                           if (exception)
                               {
                               reject(exception)
                               }
                               else
                               {
                                   try
                                   {
                                       resolve(getRange_postProcess(result));
                                   }
                                   catch (e)
                                   {
                                       reject(e);
                                   }
                               }
                           }
                       });
                       return myPromise
                   };

               /**
                * Calls the developer-defined callback function for every result in this set. The result set processed by each()
                * may have maximum 4000 rows. The callback function has the following signature: boolean callback(result.Result
                * result); If the return value of the callback is false, the iteration over results is stopped, otherwise it
                * continues. Note that the work done in the context of the callback function counts towards the governance of the
                * script that called it.
                * @governance 10 units
                * @param {Function} callback  the function called for each result in the result set
                * @return {void}
                * @since 2015.2
                */
               this.each = function each(callback)
               {
                   var remoteId = null;
                   var rawFilters = Filter.marshalFilters(search.filters);
                   var rawColumns = Column.marshalColumns(search.columns);
	               var rawSettings = Setting.marshalSettings(search.settings);
                   var returnedRowCount = 0;
                   var PAGE_SIZE = 500;  // number of search results per request
                   var continueIteration = true;
                   var start = 0;
                   try
                   {
                       while (continueIteration)
                       {
                           var javaResults = invoker(searchApi, 'nlapiContinueSearch', [search.searchType, String(search.id), rawFilters, rawColumns, rawSettings, remoteId, start, start + PAGE_SIZE]);
                           var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                           var searchResults = Result.extractResults(rawResults, search.columns, javaResults);
                           if (searchResults == null || searchResults.length == 0)
                               break;

                           for (var i = 0; continueIteration && i < searchResults.length; i++)
                           {
                                utilityFunctions.assertTrue(returnedRowCount < FOR_EACH_RESULT_MAX_ROWS, error.Type.SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED, FOR_EACH_RESULT_MAX_ROWS);
                               continueIteration = callback(searchResults[i]);
                               returnedRowCount++;
                           }

                           var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
                           if (!remoteId && unwrappedResults != null && unwrappedResults.length > 0)
                               remoteId = unwrappedResults[0].remoteid;

                           if (searchResults.length < PAGE_SIZE)
                               break;
                           start += PAGE_SIZE;
                       }
                   }
                   finally
                   {
                       invoker(searchApi, 'nlapiEndSearch', [String(remoteId)]);
                   }
               };

                   this.each.promise = function promise(callback)
                   {
                       var remoteId = null;
                       var rawFilters = Filter.marshalFilters(search.filters);
                       var rawColumns = Column.marshalColumns(search.columns);
	               var rawSettings = Setting.marshalSettings(search.settings);
                       var returnedRowCount = 0;
                       var PAGE_SIZE = 500;  // number of search results per request
                       var continueIteration = true;
                       var start = 0;

                       var myPromise = new Promise(
                               function (resolve, reject)
                               {
                                   var loop = function ()
                                   {
                                       return new Promise(function (resolveInner, rejectInner)
                                       {
                                           invoker(searchApi, 'nlapiContinueSearch', [search.searchType, String(search.id), rawFilters, rawColumns, rawSettings, remoteId, start, start + PAGE_SIZE], resolveInner);
                                       }).then(function (result)
                                               {
                                                   var rawResults = invoker(remoteApi, 'transform', [result]);
                                                   var searchResults = Result.extractResults(rawResults, search.columns);
                                                   if (searchResults == null || searchResults.length == 0)
                                                   {
                                                       return false;
                                                   }

                                                   for (var i = 0; continueIteration && i < searchResults.length; i++)
                                                   {
                                                       utilityFunctions.assertTrue(returnedRowCount < FOR_EACH_RESULT_MAX_ROWS, error.Type.SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED, FOR_EACH_RESULT_MAX_ROWS);
                                                       continueIteration = callback(searchResults[i]);
                                                       returnedRowCount++;
                                                   }

	                                               var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
                                                   if (!remoteId && unwrappedResults != null && unwrappedResults.length > 0)
                                                       remoteId = unwrappedResults[0].remoteid;

                                                   if (searchResults.length < PAGE_SIZE)
                                                   {
                                                       return false;
                                                   }
                                                   start += PAGE_SIZE;
                                                   return true;
                                               })
                                               .then(function (keepGoing) { if (keepGoing) loop() })
                                               .then(undefined, function (reason) { reject(reason) });
                                   };

                                   loop().then(function ()
                                   {
                                   	    invoker(searchApi, 'nlapiEndSearch', [String(remoteId)]);
                                   	    resolve(true);
                                   });
                               }
                       );
                       return myPromise
                   }
               /**
                * Returns the object type name (search.ResultSet)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       columns: search.columns
                   };
               }
           }

           ResultSet.prototype = nsobject.getNewInstance();

           /**
            * Return a new instance of search.Result object.
            *
            * @classDescription Encapsulation of a search result.
            * @protected
            * @constructor
            *
            * @since 2015.2
            */
           function Result(type, id, rawValues, rawColumns, javaResult)
           {
               var TYPE = 'search.Result';

               /* index values by legacy key for performance - lazy loaded */
               var valuesByKey = {};
               var valuesByKeyMapPopulated = false;

               /* private methods */
               function getCellAttribute(nameOrColumn, join, summary, func, attribute)
               {
                   var cell = null;
                   if (util.isString(nameOrColumn))
                   {
	                   var name = nameOrColumn
                       populateValueByKeyMap();
                       cell = valuesByKey[getKey(name, join, summary, undefined, func)];
                   }
                   else if (nameOrColumn instanceof Column)
                   {
	                   var column = nameOrColumn;
                       if (column._getIndex() !== -1)
                           cell = rawValues[column._getIndex() - 1];
                       if (!cell)
                       {
                           populateValueByKeyMap();
                           cell = valuesByKey[getKey(column.name, column.join, column.summary, column.formula)]
                       }
                   }
                   return (cell != null && cell[attribute] != null) ? cell[attribute] : null;
               }

               function getKey(name, join, summary, formula, func)
               {
                   return (join ? join.toLowerCase() + '_' : '')
	                   + name.toLowerCase()
	                   + (summary ? '_' + summary.toLowerCase() : '')
	                   + (formula ? '_' + formula.toLowerCase() : '')
	                   + (func && func !== 'none' ? '_' + func.toLowerCase() : '');
               }

               function populateValueByKeyMap()
               {
                   if (!valuesByKeyMapPopulated)
                   {
                       // populate the map
                       for (var i = 0; rawValues != null && i < rawValues.length; i++)
                       {
	                       var name = rawColumns[i]['name'];
	                       var join = rawColumns[i]['join'];
	                       var summary = rawColumns[i]['summary'];
	                       var formula = rawColumns[i]['formula'];
	                       var func = rawColumns[i]['function'];
	                       var key;

	                       key = getKey(name, join, summary, formula, func);
	                       valuesByKey[key] = rawValues[i];

	                       key = getKey(name, join, summary, formula, null);
	                       if (valuesByKey[key] === undefined)
		                       valuesByKey[key] = rawValues[i];

	                       /*
	                        For backwards compatibility, we continue to support the ability to refer to a formula column via its
	                        non-unique name, for example 'formulatext'. If multiple formula columns of the same type are present,
	                        the last one will overwrite any previous values which is obviously odd. This behavior should not be
	                        ported to future major versions of this API.
	                        */
	                       if (func)
	                       {
		                       key = getKey(name, join, summary, null, func);
		                       valuesByKey[key] = rawValues[i];

		                       key = getKey(name, join, summary, null, null);
		                       if (valuesByKey[key] === undefined)
			                       valuesByKey[key] = rawValues[i];
	                       }
                       }
                       valuesByKeyMapPopulated = true;
                   }
               }

               /**
                * Record type of the result.
                * @name Result#recordType
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'recordType', {
                   get: function ()
                   {
                       return type;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'recordType' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Record internal ID of the result.
                * @name Result#id
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'id', {
                   get: function ()
                   {
                       return id;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * List of columns contained in this result.
                * @name Result#columns
                * @type {Column[]}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return rawColumns;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
                   },
                   enumerable: true,
                   configurable: false
               });


               Object.defineProperty(this, '_saveToTemplateRenderer', {
                   get: function ()
                   {
                       return javaResult;
                   },
                   set: function (val)
                   {
                       return;
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Returns the value of a specified search return column. The column may be specified in two ways:
                * 1) by providing a search.Column object
                * 2) by providing name, join and summary parameters
                * @governance none
                * @param {Column} column  The search result column from which to return a value.
                * - or -
                * @param {Object} options  the options object
                * @param {string} options.name  The search return column name.
                * @param {string} [options.join] optional The join id for this search return column.
                * @param {Summary} [options.summary]  The summary type for this column.
                * @param {string} [options.func] Special function for the search column.
                * @return {string} string value of the search result column
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name parameter is missing
                *
                * @since 2015.2
                */
               this.getValue = function getValue(options)
               {
                   var name, join, summary, func;
                   if(!!options && !util.isString(options))
                   {
                       name = options.name;
                       join = options.join;
                       summary = options.summary;
	                   func = options.func || options['function'];
                   }
                   else
                   {
                       name = options;
                   }

                   if(options instanceof Column)
                   {
                       name = options;
                       join = undefined;
                       summary = undefined;
	                   func = undefined;
                   }

                    utilityFunctions.checkArgs([name], ['name'], 'Result.getValue');

                   return getCellAttribute(name, join != null ? join : null, summary != null ? summary : null, func != null ? func : null, 'value');
               };

               /**
                * Returns the UI display name (i.e. the text value) of a specified search return column.
                * Note that this method is supported on select, image and document fields only.
                * The column may be specified in two ways:
                * 1) by providing a search.Column object
                * 2) by providing name, join and summary parameters
                * @governance none
                * @param {Column} column  The search result column from which to return a value.
                * - or -
                * @param {Object} options  the options object
                * @param {string} options.name  The search return column name.
                * @param {string} [options.join] optional The join id for this search return column.
                * @param {Summary} [options.summary]  The summary type for this column.
                * @param {string} [options.func] Special function for the search column.
                * @return {string} UI display name (text value) of the search result column
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name parameter is missing
                *
                * @since 2015.2
                */
               this.getText = function getText(options)
               {
                   var name, join, summary, func;

                   if(!!options && !util.isString(options))
                   {
                       name = options.name;
                       join = options.join;
                       summary = options.summary;
	                   func = options.func;
                   }
                   else
                   {
                       name = options;
                   }

                   if(options instanceof Column)
                   {
                       name = options;
                       join = undefined;
                       summary = undefined;
	                   func = undefined;
                   }

                    utilityFunctions.checkArgs([name], ['name'], 'Result.getText');

                   return getCellAttribute(name, join != null ? join : null, summary != null ? summary : null, func != null ? func : null, 'text');
               };

               /**
                * Returns the object type name (search.Result)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @gonvernance 0
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       recordType: type,
                       id: id,
                       values: this.getAllValues()
                   };
               };

               /* public undocumented methods */
               /*
                * Return all the result data in a simple object of the following form:
                * {
                *     foo: 'bar',
                *     name.join: 'othervalue',
                *     select: [{
                *         value: '123',
                *         text: 'Some UI text'
                *     }],
                *     multiselect1: [],
                *     multiselect2: [{
                *         value: '3',
                *         text: 'Green'
                *     },{
                *         value: '5',
                *         text: 'Pinkish yellow'
                *     }],
                *     'MAX(name2.join2)': '324'
                * }
                * This is used in the toJSON() method.
                */
               this.getAllValues = function getAllValues()
               {
                   var names = {};
                   function disabiguateName(name)
                   {
                       var retVal = name;
                       if (names[name])
                       {
                       		var postFix = names[name];
                       		names[name]++;
                       		retVal = retVal + "_" + postFix;
                       }
                       else
                       {
                           names[name]=1;
                       }
                       return retVal;
                   }
                   var results = {};
                   var name = null;
                   var join = null;
                   var sum = null;
	               var func = null;

                   for (var i = 0; rawColumns && i < rawColumns.length; i++)
                   {
                       name = rawColumns[i].name;
                       join = rawColumns[i].join;
                       sum = rawColumns[i].summary;
	                   func = rawColumns[i]['function'];
                       var nameJoin = (join ? join + '.' : '') + name;
                       if (sum)
                           nameJoin = sum + '(' + nameJoin + ')';
                       var isrectype = name.toLowerCase() === 'recordtype';
	                   var param = (util.isString(name) && name.length >= 7 && name.substr(0,7) === "formula") ? rawColumns[i] : {name: name, join: join, summary: sum, func: func};
                       var txt = isrectype ? null : this.getText(param);
                       var val = isrectype ? type : this.getValue(param);
                       nameJoin  = disabiguateName ( nameJoin )
                       if (txt !== null && val !== null && txt !== undefined && val !== undefined)
                       {
                           if (txt.length === 0 && val.length === 0) // multiselect with nothing chosen
                           {
                               results[nameJoin] = [];
                           }
                           else
                           {
                               var multival = val.split(',');
                               var multitxt = txt.split(",");
                               if (multival.length === 1)
                               {
                                   val = [];
                                   val.push({value: multival[0], text: txt});
                                   results[nameJoin] = val;
                               }
                               else if (multival.length === multitxt.length) // parallel arrays match
                               {
                                   val = [];
                                   for (j = 0; j < multival.length; j++)
                                   {
                                       val.push({value: multival[j], text: multitxt[j]});
                                   }
                                   results[nameJoin] = val;
                               }
                               else // fallback
                               {
                                   results[nameJoin] = {value: val, text: txt};
                               }
                           }
                       }
                       else
                       {
                           results[nameJoin] = val;
                       }
                   }
                   return results;
               };
           }

           Result.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*------------ Helper function used for unmarshalling search results from server. ------------*/
           Result.extractResults = function extractResults(rawResults, columns, javaResults)
           {
               var rows = [];
               var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
               if (unwrappedResults != null && unwrappedResults.length > 0)
               {
	               var recordTypeColumn = null;
	               var columnArray = utilityFunctions.getAsArray(columns)
	               if (columnArray != null)
		               recordTypeColumn = columnArray.filter(function(el) { return el.name === "recordtype"; })[0];
                   columns = unwrappedResults[0].columns;
                   for (var i = 0; columns != null && i < columns.length; i++)
                   {
                       var obj = null;
                       var col = columns[i];
                       if (col.userindex == -1)
                       {
                           obj = Column.unmarshalColumn(col);
                       }
                       else if (columnArray != null)
                       {
                           obj = columnArray[col.userindex - 1];
                       }
                       obj._setIndex(col.index);
                       obj._setType(col.type);
                       columns[i] = obj;
                   }

                   if (!!recordTypeColumn)
                   {
                       if (util.isArray(columns))
                       {
                           if (columns.filter(function(el) { return el.name === "recordtype"; }).length === 0)
                               columns.push(recordTypeColumn);
                       }
	                   else
	                   	    columns = [recordTypeColumn];
                   }
                   for (i = 0; i < unwrappedResults.length; i++)
                   {
                       rows[rows.length] = new Result(unwrappedResults[i].recordType, unwrappedResults[i].id, unwrappedResults[i].cells, columns, (javaResults && javaResults[i]) ? javaResults[i] : null)
                   }
               }
               return rows;
           };

            /**
             * @class SearchPageRange
             * @classDescription Defines the page range to contain the result set
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
           function SearchPageRange(options)
           {
               var that = this;
               var delegate;

               if (options)
               {
                   delegate = options.delegate;
               }

                utilityFunctions.checkArgs([delegate], ['delegate'], 'PageRange');

               function getIndex()
               {
                   return invoker(delegate, 'getIndex');
               }
               function getCompoundKey()
               {
                   return invoker(delegate, 'getCompoundKey');
               }
               function getCompoundLabel()
               {
                   return invoker(delegate, 'getCompoundLabel');
               }

                /**
                 * @governance none
                 * @return {number}
                 *
                 * @since 2015.2
                 */
               this.getIndex = getIndex;

                /**
                 * @governance none
                 * @return {string}
                 *
                 * @since 2015.2
                 */
               this.getCompoundKey = getCompoundKey;

                /**
                 * @governance none
                 * @return {string}
                 *
                 * @since 2015.2
                 */
               this.getCompoundLabel = getCompoundLabel;
           }
           SearchPageRange.prototype = nsobject.getNewInstance();

	       /**
	        * Return a new instance of search.Page object.
	        *
	        * @class SearchPage
	        * @classDescription Encapsulates an individual search page containing a result set for a paginated search.
	        * @protected
	        * @constructor
	        *
	        * @since 2015.2
	        */
           function SearchPage(options)
           {
               var that = this;
               var delegate;
               var pagedData;
               var pageIndex;
               var data;

               if (options)
               {
                   delegate = options.delegate;
                   pagedData = options.pagedData;
                   pageIndex = options.pageIndex;
               }

                utilityFunctions.checkArgs([delegate, pagedData, pageIndex], ['delegate', 'pagedData', 'pageIndex'], 'Page');

	           /**
	            * The PagedData Object used to fetch this Page Object.
	            * @name Page#pagedData
	            * @type {PagedData}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pagedData', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return pagedData;
                   }
               });

	           /**
	            * The PageRange Object used to fetch this Page Object.
	            * @name SearchPage#pagedRange
	            * @type {SearchPageRange}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pageRange', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return pagedData.pageRanges[pageIndex];
                   }
               });

	           /**
	            * The results from a paginated search.
	            * @name SearchPage#data
	            * @type {Result[]}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'data', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       var javaResults, rawResults;

                       if(!data){
                           javaResults = invoker(delegate, 'getData');
                           rawResults = invoker(remoteApi, 'transform', [javaResults]);

                           data = Result.extractResults(rawResults, pagedData.searchDefinition.columns, javaResults);
                       }

                       return data;
                   }
               });

	           /**
	            * Indicates whether the page is within the first range of the result set. Flags the start of the data collection.
	            * @name SearchPage#isFirst
	            * @type {boolean}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'isFirst', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'isFirst');
                   }
               });

	           /**
	            * Indicates whether a page is within the last range of the result set. Flags the end of the data collection.
	            * @name SearchPage#isLast
	            * @type {boolean}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'isLast', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'isLast');
                   }
               });

	           /**
	            * Method used to fetch the next segment of data (bounded by search.PageRange). Moves the current page to next range.
	            * @governance 5 units
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            * @return {void}
	            *
	            * @since 2015.2
	            */
               this.next = function next(){
                   var result;

                   if(that.isLast)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'next' );
                   }
                   else
                   {
                       result = pagedData.fetch(pagedData.pageRanges[pageIndex + 1].getIndex());
                   }

                   return result;
               };

	           /**
	            * Method used to fetch the previous segment of data (bounded by search.PageRange). Moves the current page to previous range.
	            * @governance 5 units
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            * @return {void}
	            *
	            * @since 2015.2
	            */
               this.prev = function prev(){
                   var result;

                   if(that.isFirst)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'prev' );
                   }
                   else
                   {
                       result = pagedData.fetch(pagedData.pageRanges[pageIndex - 1].getIndex());
                   }

                   return result;
               };

	           /**
	            * Method used to asynchronously fetch the next segment of data (bounded by search.PageRange). Moves the current page to another range. The promise is complete when the data for this range is loaded or rejected.
	            * @governance 5 units
	            * @return {Promise}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            *
	            * @since 2015.2
	            */
                   this.next.promise = function nextPromise()
                   {
                       var result;

                       if (that.isLast)
                       {
                           result = Promise.reject(error.create({
                                                                    name: error.Type.INVALID_PAGE_RANGE,
                                                                    message: 'Invalid page range: next.promise.',
                                                                    notifyOff: false
                                                                }));
                       }
                       else
                       {
                           result = pagedData.fetch.promise(pagedData.pageRanges[pageIndex + 1].getIndex());
                       }

                       return result;
                   };

	           /**
	            * Method used to asynchronously fetch the previous segment of data (bounded by search.PageRange). Moves the current page to another range. The promise is complete when the data for this range is loaded or rejected.
	            * @governance 5 units
	            * @return {Promise}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            * @since 2015.2
	            */
                   this.prev.promise = function prevPromise()
                   {
                       var result;

                       if (that.isFirst)
                       {
                           result = Promise.reject(error.create({
                                                                    name: error.Type.INVALID_PAGE_RANGE,
                                                                    message: 'Invalid page range: prev.promise.',
                                                                    notifyOff: false
                                                                }));
                       }
                       else
                       {
                           result = pagedData.fetch.promise(pagedData.pageRanges[pageIndex - 1].getIndex());
                       }

                       return result;
                   };
               }
           SearchPage.prototype = nsobject.getNewInstance();

           function ReadonlySearch(delegate)
           {
               function cloneArrayOfFiltersOrColumnsOrSettings(o)
               {
                   var toRet = [];
                   if(o && util.isArray(o))
                   {
                       o.forEach(function(obj){
                           if(obj instanceof Filter || obj instanceof Column || obj instanceof Setting)
                                toRet.push(utilityFunctions.freezeObjectIfPossible(obj._clone()));
                       })
                   }
                    return utilityFunctions.freezeObjectIfPossible(toRet)
               }



               Object.defineProperty(this, 'searchType', {
                   get : function(){ return delegate.searchType; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'searchId', {
                   get : function(){ return delegate.searchId; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'title', {
                   get : function(){ return delegate.title },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'id', {
                   get : function(){ return delegate.id; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'isPublic', {
                   get : function(){ return delegate.isPublic; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'columns', {
                   get : function(){ return cloneArrayOfFiltersOrColumnsOrSettings(delegate.columns); },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, 'filters', {
                   get : function(){ return cloneArrayOfFiltersOrColumnsOrSettings(delegate.filters); },
                   enumerable: true,
                   configurable: false
               });

	           Object.defineProperty(this, 'settings', {
		           get : function(){ return cloneArrayOfFiltersOrColumnsOrSettings(delegate.settings); },
		           enumerable: true,
		           configurable: false
	           });
               this.toJSON = delegate.toJSON;
               this.toString = function (){ return delegate.toString() + "(readonly)"; }
           }
           ReadonlySearch.prototype = nsobject.getNewInstance();

			/**
			 * @class SearchPagedData
			 * @classdesc Holds metadata for a paginated query.
			 * @protected
			 * @constructor
			 *
			 * @since 2015.2
			 */
           function SearchPagedData(options)
           {
               var that = this;
               var delegate, searchDefinition;
               var pageRanges = null;

               if (options)
               {
                   delegate = options.delegate;
                   searchDefinition = options.searchDefinition;
               }

                utilityFunctions.checkArgs([delegate, searchDefinition], ['delegate', 'searchDefinition'], 'PagedData');

               function doGetPage(index, callback)
               {
               	    return invoker(delegate, 'getPage', resolveUndefinedForArguments([index]), callback);
               }

	           /**
	            * This method retrieves the data within the specified page range.
	            * @governance 5 units
	            * @param {number} index The index of the page range that bounds the desired data.
	            * @return {Page}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
	            *
	            * @since 2015.2
	            */
               function getPage(index)
               {
                   if(index < 0 || index >= that.pageRanges.length)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch' );
                   }

                   var page = new SearchPage({
                       delegate: doGetPage(index),
                       pagedData: that,
                       pageIndex: index
                   });
                   return new paginationObject.Page(page);
               }

	           /**
	            * This method asynchronously retrieves the data bounded by the pageRange parameter.
	            * @governance 5 units
	            * @param {number} index The index of the page range that bounds the desired data.
	            * @return {Page}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
	            *
	            * @since 2015.2
	            */
               function getPagePromise(index)
               {
                   var result;
                   if(index < 0 || index >= that.pageRanges.length)
                   {
                       result = Promise.reject(error.create({
                                                                name: error.Type.INVALID_PAGE_RANGE,
                                                                message: 'Invalid page range: fetch.promise.',
                                                                notifyOff: false
                                                            }));
                   }
                   else
                   {
	                   result = new Promise(function (resolve, reject)
	                   {
		                   try
		                   {
			                   doGetPage(index, callback);
		                   }
		                   catch (e)
		                   {
			                   reject(e);
		                   }

		                   function callback(result, exception)
		                   {
			                   if (exception)
			                   {
			                   	    reject(exception);
			                   }
			                   else
			                   {
				                   try
				                   {
				                   	    var page = new SearchPage({
					                        delegate: result,
					                        pagedData: that,
					                        pageIndex: index
				                        });
				                   	    resolve(new paginationObject.Page(page));
				                   }
				                   catch (e)
				                   {
					                   reject(e);
				                   }
			                   }
		                   }
	                   });
                   }

                   return result;
               }

                /**
                 * Maximum number of entries per page. Possible values are 5 - 1000 entries per page.
                 * @type {number}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
               Object.defineProperty(this, 'pageSize', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'getPageSize');
                   }
               });

                /**
                 * The total number of results when Search.runPaged(options) was executed.
                 * @type {number}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
               Object.defineProperty(this, 'count', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'getTotalRows');
                   }
               });

                /**
                 * The collection of SearchPageRange objects that divide the entire result set into smaller groups.
                 * @type {SearchPageRange[]}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
               Object.defineProperty(this, 'pageRanges', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       if(!pageRanges){
                           pageRanges = invoker(delegate, 'getPageRanges').map(function(v,i,a){
                               return new SearchPageRange({delegate: v});
                           });
                       }

                       return pageRanges;
                   }
               });

               this.searchDefinition = new ReadonlySearch(searchDefinition);
               this.fetch = getPage;
               this.fetch.promise = getPagePromise;
               }
           SearchPagedData.prototype = nsobject.getNewInstance();


           function createSearch(type, searchId, filters, columns, settings) {
               return new Search(type, searchId, filters, columns, settings);
           }

           function createFilter(options) {
               var name = null, join = null, operator = null, values = null;
               var isOpts = false;

               if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join') || options.hasOwnProperty('operator') || options.hasOwnProperty('values')))
               {
                   name = options.name;
                   join = options.join;
                   operator = options.operator;
                   values = options.values;
                   isOpts = true;
               }
               else
               {
                   name = options;
                   join = arguments[1];
                   operator = arguments[2];
                   values = arguments[3];
               }
               utilityFunctions.checkArgs([name, operator], ['name', 'operator'], 'search.createFilter');

               var filter = new Filter(name, join, operator, values);
               if (isOpts)
               {
                   if (options.formula)
                       filter.formula = options.formula;
                   if (options.summary)
                       filter.summary = options.summary;
               }
               return filter;
           }

	       function createSetting(options) {
		       var name = null, value = null;
		       if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value') ))
		       {
			       name = options.name;
			       value = options.value;
		       }
		       else
		       {
			       name = options;
			       value = arguments[1];
		       }
		       utilityFunctions.checkArgs([name, value], ['name', 'value'], 'search.createSetting');

		       var setting = new Setting(name, value);
		       return setting;
	       }

           function createColumn(options) {
               var name = null, join = null, summary = null;
               var isOpts = false;

               if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join') || options.hasOwnProperty('summary')))
               {
                   name = options.name;
                   join = options.join;
                   summary = options.summary;
                   isOpts = true;
               }
               else
               {
                   name = options;
                   join = arguments[1];
                   summary = arguments[2];
               }
               utilityFunctions.checkArgs([name], ['name'], 'search.createColumn');

               var column = new Column(name, join ? join : null, summary ? summary : null);
               if (isOpts)
               {
                   if (options.formula)
                       column.formula = options.formula;
                   if (options.func)
	                   column['function'] = options.func;
                   else if (options['function'])
                       column['function'] = options['function'];
                   if (options.label)
                       column.label = options.label;
                   if (options.sort !== undefined)
                       column.sort = options.sort;
               }
               return column;
           }

           return {
               createSearch : createSearch,
               createFilter : createFilter,
	           createSetting : createSetting,
	           createColumn : createColumn,
               Filter : Filter,
               Column : Column,
	           Setting : Setting,
               Result : Result,
               /**
                * @enum {string}
                * @readonly
                */
               SUMMARY_TYPES : SUMMARY_TYPES,
               /**
                * @enum {string}
                * @readonly
                */
               OPERATORS: OPERATORS,
               /**
                * @enum {string}
                * @readonly
                */
               SORT: SORT,
               util : {
                   getNameFromColumn : getNameFromColumn,
                   getJoinFromColumn : getJoinFromColumn
               }
           }
       }
);

/**
 * SuiteScript search util module
 *
 * @private
 * @module N/search/searchUtil
 * @NApiVersion 2.x
 *
 */
define('N/search/searchUtil',['N/restricted/searchApi', 'N/restricted/remoteApiBridge', 'N/error', 'N/restricted/invoker', 'N/search/searchObject', 'N/utilityFunctions', 'N/creationFunctionWrapper'],
        function (searchApi, remoteApi, error, invoker, searchObject, utilityFunctions, funcWrapper)
        {
            var Filter = searchObject.Filter;
            var Column = searchObject.Column;
            var Setting = searchObject.Setting;
            var Result = searchObject.Result;
            var searchUtilityFunctions = searchObject.util;

            //========================================================================

            function validateAndParseFilterExpression(options, callback)
            {
                var type = null,
                        filters = null;

                if (options)
                {
                    type = options.type;
                    filters = options.filters;
                }
                utilityFunctions.checkArgs([type], ['type'], 'search.create');
                invoker(searchApi, 'assertValidSearchType', [type]);

                return parseFilterExpression(filters, callback);
            }

            function parseFilterExpression(filters, callback)
            {
                filters = Filter.normalizeFilters(filters);

                return Filter.parseFilterExpression(filters, callback);
            }

            function doCreateSearch(options)
            {
                var columns = options.columns != null ? options.columns : null;
                var settings = options.settings || null;
                var result = searchObject.createSearch(options.type, -1, options.filters, columns, settings);
                if (options.title)
                    result.title = options.title;
                if (options.id)
                    result.id = options.id;
	            if (options.packageId)
		            result.packageId = options.packageId;
                return result;
            }

            // === load
            function doLoad(options, callback)
            {
                var id = (options && options.hasOwnProperty('id')) ? options.id : options;
                utilityFunctions.checkArgs([id], ['id'], 'search.load');
                var type = (options && options.hasOwnProperty('type')) ? options.type : null;
                if (!!type)
                    invoker(searchApi, 'assertValidSearchType', [type]);

                var search = searchObject.createSearch(type, id, null, null);
                search._load(callback);
                return search;
            }

            // === delete

            function doDelete(options, callback)
            {
                var id = (options && options.hasOwnProperty('id')) ? options.id : options;
                utilityFunctions.checkArgs([id], ['id'], 'search.delete');

                invoker(searchApi, 'nlapiDeleteSearch', [String(id)], callback);
            }

            // === searchRecord
            function doSearchRecord(options, callback)
            {
                var search = doCreateSearch(options);
                var filters = Filter.marshalFilters(search.filters);
                var columns = Column.marshalColumns(search.columns);
                var settings = Setting.marshalSettings(search.settings);
                return invoker(searchApi, 'nlapiSearchRecord', [search.searchType, String(search.id), filters, columns, settings], callback);
            }

            function doSearchRecord_postProcess(javaResults)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var columns = null;
                var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
                if (unwrappedResults && unwrappedResults.length > 0 && unwrappedResults[0].columns)
                    columns = unwrappedResults[0].columns.map(Column.unmarshalColumn);
                var results = Result.extractResults(rawResults, columns);
                return results ? results : [];
            }

            // === searchDuplicates

            function doSearchDuplicates(options, callback)
            {
                var type = null, fields = null, id = 0;
                if (options)
                {
                    type = options.type;
                    fields = options.fields || null;
                    id = options.id || 0;
                }

                utilityFunctions.checkArgs([type], ['type'], 'search.duplicates');

                return invoker(searchApi, 'nlapiSearchDuplicate', [type, fields, id], callback);
            }

            function doSearchDuplicates_postProcess(javaResults)
            {
	            var rawResults = invoker(remoteApi, 'transform', [javaResults]);
	            var searchResults = Result.extractResults(rawResults, null);
                return searchResults ? searchResults : [];
            }

            // === searchGlobal
            function doSearchGlobal(options, callback)
            {
                var keywords = (options && options.hasOwnProperty('keywords')) ? options.keywords : options;
                utilityFunctions.checkArgs([keywords], ['keywords'], 'search.global');

                return invoker(searchApi, 'nlapiSearchGlobal', [keywords], callback);
            }

            function doSearchGlobal_postProcess(javaResults)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var searchResults = Result.extractResults(rawResults, null);
                return searchResults ? searchResults : [];
            }

            // === lookupFields

            function getLookupArgs(options)
            {
                var type = null, id = null, columns = null;

                if (options)
                {
                    type = options.type;
                    id = options.id;
                    columns = utilityFunctions.getAsArray(options.columns);
                }

                utilityFunctions.checkArgs([type, id, columns], ['type', 'id', 'columns'], 'search.lookupFields');
                return {type: type, id: id, columns: columns};
            }

            function getLookupSearchColumns(columns)
            {
                var searchColumns = [];
                for (var i = 0; i < columns.length; i++)
                    if (util.isString(columns[i]) && columns[i].toLowerCase() !== 'recordtype')
                        searchColumns[searchColumns.length] = searchObject.createColumn(searchUtilityFunctions.getNameFromColumn(columns[i]), searchUtilityFunctions.getJoinFromColumn(columns[i]), null);
                return searchColumns;
            }

	        function getPostProcessColumns(searchColumns, asksRecordType)
	        {
		        if (asksRecordType)
			        searchColumns[searchColumns.length] = searchObject.createColumn("recordtype", null, null);
		        return searchColumns;
	        }

            function doLookupFields(argObj, searchColumns, callback)
            {
                argObj.columns = Column.marshalColumns(searchColumns);
                return invoker(searchApi, 'nlapiLookupFields', [argObj.type, utilityFunctions.ensureInteger(argObj.id, "id"), argObj.columns], callback);
            }

            function doLookupFields_postProcess(javaResults, searchColumns)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var searchResult = Result.extractResults(rawResults, searchColumns);

                if (searchResult && searchResult.length > 0)
                    return searchResult[0].getAllValues();
                return {};
            }

            //========================================================================

            return {
                validateAndParseFilterExpression: validateAndParseFilterExpression,
                parseFilterExpression: parseFilterExpression,
                doCreateSearch: funcWrapper.wrap ( doCreateSearch ),
                doLoad: doLoad,
                doDelete: doDelete,
                doSearchRecord: doSearchRecord,
                doSearchRecord_postProcess: doSearchRecord_postProcess,
                doSearchDuplicates: doSearchDuplicates,
                doSearchDuplicates_postProcess: doSearchDuplicates_postProcess,
                doSearchGlobal: doSearchGlobal,
                doSearchGlobal_postProcess: doSearchGlobal_postProcess,
                getLookupArgs: getLookupArgs,
                getLookupSearchColumns: getLookupSearchColumns,
	            getPostProcessColumns: getPostProcessColumns,
                doLookupFields: doLookupFields,
                doLookupFields_postProcess: doLookupFields_postProcess,

                /**
                 * @return {Column}
                 */
                createColumn: funcWrapper.wrap ( searchObject.createColumn ),
                /**
                 * @return {Filter}
                 */
                createFilter: funcWrapper.wrap ( searchObject.createFilter ),
	            /**
	             * @return {Setting}
	             */
                createSetting: funcWrapper.wrap ( searchObject.createSetting),
                /**
                 * @enum
                 */
                OPERATORS: searchObject.OPERATORS,
                /**
                 * @enum
                 */
                SUMMARY_TYPES: searchObject.SUMMARY_TYPES,
                /**
                 * @enum
                 */
                SORT: searchObject.SORT
            }
        });

/**
 * SuiteScript search common module
 * Load the search module to create and run on-demand or saved searches and analyze and iterate through the search results.
 *
 * @module N/search
 * @suiteScriptVersion 2.x
 *
 */
define('N/search',['N/search/searchUtil', 'N/restricted/searchApi', 'N/restricted/invoker'],
        function (searchUtil, api, invoker)
        {
            function createSearch(options)
            {
                var parsedFilters = searchUtil.validateAndParseFilterExpression(options)
                options.filters = parsedFilters;

                return searchUtil.doCreateSearch(options);
            }

            /**
             * Creates a new search asynchronously and returns it as a search.Search object.
             * @governance none
             * @param {Object} options  the options object
             * @param {string} options.type  The search type that you want to base the search on. Use the search.Type enum for this argument.
             * @param {Filter[]|Object[]} [options.filters] A single search.Filter object, an array of search.Filter objects, a search filter expression, or an array of search filter expressions.
             * @param {Object[]} [options.filterExpression] Search filter expression for the search as an array of expression objects.
             * @param {Column[]|Object[]} [options.columns] A single search.Column object or array of search.Column objects.
             * @param {string} [options.packageId] The application ID for this search.
             * @param {Setting[]|Object[]} [options.settings] Search settings for this search as a single search.Setting object or an array of search.Setting objects. Search settings let you specify search parameters that are typically available only in the UI. See Search.settings.
             * @param {string} [options.title] The name for a saved search. The title property is required to save a search with Search.save().
             * @param {string} [options.id] Script ID for a saved search. If you do not set the saved search ID, NetSuite generates one for you. See Search.id.
             * @param {boolean} [options.isPublic] Set to true to make the search public. Otherwise, set to false. If you do not set this parameter, it defaults to false.
             * @return {Promise}
             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR The options.filters parameter is not a valid search filter, filter array, or filter expression.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
             *
             * @since 2015.2
             */
            createSearch.promise = function createSearchPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.validateAndParseFilterExpression(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                options.filters = result;
                                resolve(searchUtil.doCreateSearch(options));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function loadSearch(options)
            {
                return searchUtil.doLoad(options);
            }

	        /**
	         * Loads an existing saved search asynchronously and returns it as a search.Search object. The saved search could have been created using the UI or created with search.create(options) and Search.save().
	         * @governance 5 units
	         * @param {Object} options  the options object
	         * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	         * @param {string} options.type The search type of the saved search to load. Use a value from the search.Type enum for this parameter.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	         *
	         * @since 2015.2
	         */
            loadSearch.promise = function loadSearchPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doLoad(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(result);
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function deleteSearch(options)
            {
                return searchUtil.doDelete(options);
            }

	        /**
	         * Deletes an existing saved search asynchronously and returns it as a search.Search object. The saved search can be created using the UI or created with search.create(options) and Search.save().
	         * @governance 5 units
	         * @param {Object} options  the options object
	         * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	         * @since 2015.2
	         */
            deleteSearch.promise = function deleteSearchPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doDelete(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve();
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function searchDuplicates(options)
            {
                var javaResults = searchUtil.doSearchDuplicates(options);
                return searchUtil.doSearchDuplicates_postProcess(javaResults);
            }

	        /**
	         * Performs a search for duplicate records asynchronously based on the Duplicate Detection configuration for the account.
	         * @governance 10 units
	         * @param {Object} options  the options object
	         * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	         * @param {Object} [options.fields] A set of key/value pairs used to detect duplicates. The keys are internal ID names of the fields used to detect duplicates.
	         * @param {number} [options.id] Internal ID of an existing record.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         *
	         * @since 2015.2
	         */
            searchDuplicates.promise = function searchDuplicatesPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doSearchDuplicates(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(searchUtil.doSearchDuplicates_postProcess(result));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function searchGlobal(options)
            {
                var rawResults = searchUtil.doSearchGlobal(options);
                return searchUtil.doSearchGlobal_postProcess(rawResults);
            }

	        /**
	         * Performs a global search asynchronously against a single keyword or multiple keywords.
	         * @governance 10 units
	         * @param {Object} options  the options object
	         * @param {string} options.keywords Global search keywords string or expression.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         *
	         * @since 2015.2
	         */
            searchGlobal.promise = function searchGlobalPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doSearchGlobal(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(searchUtil.doSearchGlobal_postProcess(result));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function lookupFields(options)
            {
                var lookupArgs = searchUtil.getLookupArgs(options);
                var asksRecordType = lookupArgs.columns.indexOf('recordtype') >= 0;
                var searchColumns = searchUtil.getLookupSearchColumns(lookupArgs.columns);
                var javaResults = searchUtil.doLookupFields(lookupArgs, searchColumns);
                if (options.v1call)
                    api.chargeUsage("nlapiLookupFields_v1", options.type);
                return searchUtil.doLookupFields_postProcess(javaResults, searchUtil.getPostProcessColumns(searchColumns, asksRecordType));
            }

	        /**
	         * Performs a search asynchronously for one or more body fields on a record.
	         * @governance 1 unit
	         * @param {Object} options  the options object
	         * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	         * @param {string} options.id Internal ID for the record, for example 777 or 87.
	         * @param {string|string[]} options.columns Array of column/field names to look up, or a single column/field name. The columns parameter can also be set to reference joined fields.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
	         *
	         * @since 2015.2
	         */
            lookupFields.promise = function lookupFieldsPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            var lookupArgs = searchUtil.getLookupArgs(options);
                            var searchColumns = searchUtil.getLookupSearchColumns(lookupArgs.columns);
                            searchUtil.doLookupFields(lookupArgs, searchColumns, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(searchUtil.doLookupFields_postProcess(result, searchColumns));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            return Object.freeze({
	            /**
	             * Creates a new search and returns it as a search.Search object.
	             * The search can be modified and run as an on demand search with Search.run(), without saving it. Alternatively,
	             * calling Search.save() will save the search to the database, so it can be reused later in the UI or loaded with search.load(options).
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.type  The search type that you want to base the search on. Use the search.Type enum for this argument.
	             * @param {Filter|Filter[]|Object[]} [options.filters] A single search.Filter object, an array of search.Filter objects, a search filter expression, or an array of search filter expressions.
	             * @param {Object[]} [options.filterExpression] Search filter expression for the search as an array of expression objects.
	             * @param {Column|Column[]|Object[]} [options.columns] A single search.Column object or array of search.Column objects.
	             * @param {string} [options.packageId] The application ID for this search.
	             * @param {Setting|Setting[]|Object[]} [options.settings] Search settings for this search as a single search.Setting object or an array of search.Setting objects. Search settings let you specify search parameters that are typically available only in the UI. See Search.settings.
	             * @param {string} [options.title] The name for a saved search. The title property is required to save a search with Search.save().
	             * @param {string} [options.id] Script ID for a saved search. If you do not set the saved search ID, NetSuite generates one for you. See Search.id.
	             * @param {boolean} [options.isPublic] Set to true to make the search public. Otherwise, set to false. If you do not set this parameter, it defaults to false.
	             * @return {Search}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR The options.filters parameter is not a valid search filter, filter array, or filter expression.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
	             *
	             * @since 2015.2
	             */
	            create: createSearch,
	            /**
	             * Loads an existing saved search and returns it as a search.Search. The saved search could have been created using the UI or created with search.create(options) and Search.save().
	             * @governance 5 units
	             * @param {Object} options  the options object
	             * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	             * @param {string} [options.type] The search type of the saved search to load. Use a value from the search.Type enum for this parameter. Required if the saved search to load uses a standalone search type, optional otherwise.
	             * @return {Search}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	             *
	             * @since 2015.2
	             */
	            load: loadSearch,
	            /**
	             * Deletes an existing saved search. The saved search could have been created using the UI or created with search.create(options) and Search.save().
	             * @governance 5 units
	             * @param {Object} options the options object
	             * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	             * @return {void}
	             *
	             * @since 2015.2
	             */
	            'delete': deleteSearch,
	            /**
	             * Performs a search for duplicate records based on the account's duplicate detection configuration.
	             * @governance 10 units
	             * @param {Object} options  the options object
	             * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	             * @param {Object} [options.fields] A set of key/value pairs used to detect duplicates. The keys are internal ID names of the fields used to detect duplicates.
	             * @param {number} [options.id] Internal ID of an existing record.
	             * @return {Result[]}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             *
	             * @since 2015.2
	             */
	            duplicates: searchDuplicates,
	            /**
	             * Performs a global search against a single keyword or multiple keywords.
	             * @governance 10 units
	             * @param {Object} options  the options object
	             * @param {string} options.keywords Global search keywords string or expression.
	             * @return {Result[]}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             *
	             * @since 2015.2
	             */
	            global: searchGlobal,
	            /**
	             * Performs a search for one or more body fields on a record.
	             * @governance 1 unit
	             * @param {Object} options  the options object
	             * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	             * @param {string} options.id Internal ID for the record, for example 777 or 87.
	             * @param {string|string[]} options.columns Array of column/field names to look up, or a single column/field name. The columns parameter can also be set to reference joined fields.
	             * @return {Object}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
	             *
	             * @since 2015.2
	             */
	            lookupFields: lookupFields,

	            /**
	             * Creates a new search column as a search.Column object.
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.name  Name of the search column.
	             * @param {string} [options.join]  Join ID for the search column.
	             * @param {string} [options.summary] Summary type for the column.
	             * @param {string} [options.formula] Formula used for the column.
	             * @param {string} [options.function] Special function for the search column.
	             * @param {string} [options.label] Label for the search column.
	             * @param {string} [options.sort] The sort order of the column.
	             * @return {Column} the created column object
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN_SUM The options.summary parameter is not a valid search summary type.
	             * @throws {SuiteScriptError} INVALID_SRCH_FUNCTN An unknown function is provided.
	             *
	             * @since 2015.2
	             */
	            createColumn: searchUtil.createColumn,

	            /**
	             * Creates a new search filter as a search.Filter object.
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.name  Name or internal ID of the search field.
	             * @param {string} [options.join] Join ID for the search filter.
	             * @param {string} options.operator Operator used for the search filter. Use the search.Operator enum.
	             * @param {string|Date|Number|boolean|string[]|Date[]|Number[]} [options.values] Values to be used as filter parameters.
	             * @param {string} [options.formula] Formula used for this filter
	             * @param {Summary} [options.summary] Summary type for the search filter.
	             * @return {Filter} the created filter object
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_OPERATOR Options.summary parameter is not a valid search summary type.
	             * @throws {SuiteScriptError} INVALID_SRCH_SUMMARY_TYP Options.operator parameter is not a valid operator type.
	             *
	             * @since 2015.2
	             */
	            createFilter: searchUtil.createFilter,

	            /**
	             * Creates a new search setting and returns it as a search.Setting object.
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.name The name of the search parameter to set
	             * @param {string} options.value The value of the search parameter.
	             * @return {Setting} the created setting object
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT A required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
	             *
	             * @since 2015.2
	             */
	            createSetting: searchUtil.createSetting,

	            /**
	             * Enumeration that holds the values for search operators to use with the search.Filter.
	             * @enum {string}
	             * @readonly
	             */
	            Operator: searchUtil.OPERATORS,

	            /**
	             * Enumeration that holds the values for summary types used by the Column.summary or Filter.summary properties.
	             * @enum {string}
	             * @readonly
	             */
	            Summary: searchUtil.SUMMARY_TYPES,

	            /**
	             * Enumeration that holds the values for supported sorting directions used with search.createColumn(options).
	             * @enum {string}
	             * @readonly
	             */
	            Sort: searchUtil.SORT,
	            /*
                 * module enums
                 */
	            get Type()
	            {
		            if(!searchUtil.searchTypes)
			            searchUtil.searchTypes = invoker(api, 'getSearchTypeEnumMap', []);
		            return searchUtil.searchTypes;
	            }
            });
        });

/**
 * SuiteScript transaction util module
 *
 * @private
 * @module N/transaction/transactionUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/transaction/transactionUtil',['N/utilityFunctions'],
       function(utilityFunctions)
       {
            function getVoidTransactionArgs(options,id)
            {
                var type = options;
                if ( utilityFunctions.isObject(options))
                {
                    type = options.type;
                    id = options.id;
                }

                utilityFunctions.checkArgs([type, id], ['type', 'id'], 'void');
                return [type, id];
            }

            function doVoidTransaction(voidedId)
            {
                return parseInt(voidedId, 10);
            }

            return {
                getVoidTransactionArgs: getVoidTransactionArgs,
                doVoidTransaction: doVoidTransaction
            }
       });

/**
 * @private
 */
define('N/restricted/transactionApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript transaction common module
 *
 * @module N/transaction
 * @suiteScriptVersion 2.x
 *
 */

define('N/transaction',['N/transaction/transactionUtil', 'N/restricted/transactionApi', 'N/restricted/invoker'],
       function(transactionUtil, transactionApi, invoker)
       {
            function voidTransaction(options, id)
            {
                var voidArgs = transactionUtil.getVoidTransactionArgs(options, id);
                var voidResult = invoker(transactionApi, "nlapiVoidTransaction", voidArgs);

                return transactionUtil.doVoidTransaction(voidResult);
            }

            voidTransaction.promise = function voidTransactionPromise(options, id) {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            var args = transactionUtil.getVoidTransactionArgs(options, id);
                            invoker(transactionApi, "nlapiVoidTransaction", args, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(transactionUtil.doVoidTransaction(result));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            return Object.freeze({
                /**
                 * Void a transaction record object based on provided type, id
                 *
                 * @param {string} type record type to be voided
                 * @param {number|string} id record id to be voided
                 * @return {number} the id is the voided record or new reverse journal entry based on preference
                 *
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
                 * @throws {SuiteScriptError} INVALID_RCRD_TYPE if type is not voidable
                 * @throws {SuiteScriptError} RCRD_DSNT_EXIST if record does not exist
                 *
                 * @since 2015.2
                 */
                "void": voidTransaction,
                /*
                 * module enums
                 */
                get Type()
                {
                    if(!transactionUtil.transactionTypes)
                        transactionUtil.transactionTypes = invoker(transactionApi, 'getTransactionTypeEnumMap', []);
                    return transactionUtil.transactionTypes;
                }
            });
       });

/**
 * @private
 */
define('N/restricted/emailApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript email common module
 *
 * @module N/email
 * @suiteScriptVersion 2.x
 *
 */

define('N/email',['N/restricted/emailApi', 'N/restricted/invoker', 'N/utilityFunctions', 'N/error'],
	function (emailApi, invoker, utilityFunctions, error)
	{
		/*
		 * Object for sending emails
		 *
		 * @classdesc Special object for sending emails is needed, so delegates from attachments can be accessed
		 * @protected
		 * @param {Object} options Email parameters
		 * @return {EmailObject}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function EmailObject(options)
		{
			var files = [];
			this.doSendEmail = function doSendEmail(options, notifySenderOnBounce)
			{
				var relatedRecords = new Object();
				var undef = undefined;
				utilityFunctions.checkArgs([options], ['options'], 'email.send');
				if (!utilityFunctions.isObject(options))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'object' );
				}
				// check required parameters
				var author = options !== undef && options !== null && options.author !== undef ?
					options.author : undef;
				var recipients = options !== undef && options !== null && options.recipients !== undef ?
					options.recipients : undef;
				var body = options !== undef && options !== null && options.body !== undef ?
					options.body : undef;
				var subject = options !== undef && options !== null && options.subject !== undef ?
					options.subject : undef;

				utilityFunctions.checkArgs([author, recipients, body, subject], ['options.author', 'options.recipients', 'options.body', 'options.subject'], 'email.send');

				if (Array.isArray(recipients))
				{
					recipients = recipients.join();
				}

				// check optional parameters
				if (options.cc && !Array.isArray(options.cc))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.cc', 'Array' );
				}
				if (options.bcc && !Array.isArray(options.bcc))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.bcc', 'Array' );
				}
				if (options.isInternalOnly && !util.isBoolean(options.isInternalOnly))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.isInternalOnly', 'boolean' );
				}

				if (options.replyTo && !util.isString(options.replyTo))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.replyTo', 'string' );
				}

				if (options.attachments && !(util.isArray(options.attachments)))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.attachments', 'Array' );
				}
				if (options.attachments)
				{
					for (var index in options.attachments)
					{
						var file = options.attachments[index];
						if (!file.hasOwnProperty('toString') || file.toString() !== 'file.File')
						{
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.attachments', 'file.File[]' );
						}
						file._attachToEmail = this;
					}
				}

				if (options.relatedRecords && !utilityFunctions.isObject(options.relatedRecords))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.relatedRecords', 'object' );
				}

				if (options.relatedRecords)
				{

					if (options.relatedRecords.hasOwnProperty('transactionId'))
					{
						relatedRecords['transaction'] = options.relatedRecords.transactionId;
					}

					if (options.relatedRecords.hasOwnProperty('activityId'))
					{
						relatedRecords['activity'] = options.relatedRecords.activityId;
					}

					if (options.relatedRecords.hasOwnProperty('entityId'))
					{
						relatedRecords['entity'] = options.relatedRecords.entityId;
					}

					if (options.relatedRecords.hasOwnProperty('customRecord') && options.relatedRecords.customRecord)
					{
						if (options.relatedRecords.customRecord.hasOwnProperty('id') && options.relatedRecords.customRecord.hasOwnProperty('recordType'))
						{
							relatedRecords['record'] = options.relatedRecords.customRecord.id;
							relatedRecords['recordtype'] = options.relatedRecords.customRecord.recordType;
						}
					}
				}

				return invoker(emailApi, 'nlapiSendEmail', [author, recipients, subject, body, options.cc || null, options.bcc || null, relatedRecords, files || null, notifySenderOnBounce, options.isInternalOnly || false, options.replyTo || null]);

			};

			this._attach = function (f)
			{
				files.push(f);
			};

			Object.defineProperty(this, '_attach', {
				set: function (f)
				{
					files.push(f);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2015.2
			 */
			this.toJSON = function toJSON(){
				return {};
			};

			/*
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2015.2
			 */
			this.toString = function toString(){
				return "email.EmailObject";
			};
		}

		function doSendEmail(options, isNotBulk)
		{
			var emailObject = new EmailObject(options);
			return emailObject.doSendEmail(options, isNotBulk);
		}

		function doSendCampaignEventEmail(options, recipientId)
		{
			var campaign = options;
			var recipient = recipientId;
			if (util.isObject(options))
			{
				campaign = options.campaignEventId;
				recipient = options.recipientId;
			}
			utilityFunctions.checkArgs([campaign, recipient], ['campaignEventId', 'recipientId'], 'email.sendCampaignEvent');
			return invoker(emailApi, 'nlapiSendCampaignEmail', [campaign, recipient]);
		}

		function craftPromise(resolveThis)
		{
			return new Promise(function (resolve, reject)
			{
				try
				{
					resolve(resolveThis());
				}
				catch (e)
				{
					reject(e);
				}
			});
		}

		function sendEmail(options)
		{
			return doSendEmail(options, true);
		}

		sendEmail.promise = function sendEmailPromise(options)
		{
			var resolveThis = function callback() { return sendEmail(options); };
			return craftPromise(resolveThis);
		};

		function sendBulkEmail(options)
		{
			return doSendEmail(options, false);
		}

		sendBulkEmail.promise = function sendBulkEmailPromise(options)
		{
			var resolveThis = function callback() { return sendBulkEmail(options) };
			return craftPromise(resolveThis);
		};

		function sendCampaignEventEmail(options, recipientId)
		{
			return doSendCampaignEventEmail(options, recipientId);
		}

		sendCampaignEventEmail.promise = function sendCampaignEventEmailPromise(options, recipientId)
		{
			var resolveThis = function callback() { return sendCampaignEventEmail(options, recipientId); };
			return craftPromise(resolveThis);
		};


		return Object.freeze({
			/**
			 * Sends email to an individual or group of recipients and receives bounceback notifications.
			 *
			 * @governance 20 units
			 * @restriction The maximum number of total recipients (recipient + cc + bcc) allowed is 10
			 *
			 * RelatedRecords represents the NetSuite records to which an Email Message record should be attached.
			 * @typedef {Object} RelatedRecords
			 * @property {number} transactionId - Transaction record to attach Message record to.
			 * @property {number} activityId - Activity record to attach Message record to.
			 * @property {number} entityId - Entity record to attach Message record to.
			 * @property {Object} customRecord - Custom record to attach Message record to.
			 * @property {number} customRecord.id - The instance ID for the custom record to attach the Message record to.
			 * @property {string} customRecord.recordType - The integer ID for the custom record type to attach the Message record to.
			 *
			 * @param {Object} options Email options
			 * @param {number} options.author Sender of the email.
			 * @param {number|number[]|string[]} options.recipients Recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number[]|string[]} [options.cc] CC recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number[]|string[]} [options.bcc] BCC recipients of the email as an EmailEntity, Internal ID or Email Address.
			 * @param {string} options.subject Subject of the outgoing message.
			 * @param {string} options.body Contents of the outgoing message.
			 * @param {string} [options.replyTo] The email address that appears in the reply-to header.
			 * @param {file.File[]} [options.attachments] Email file attachments. Not supported in client side.
			 * @param {RelatedRecords} [options.relatedRecords] Object that contains key/value pairs to associate (attach) the Message record with related records (i.e., transaction, activity, entity, and custom records)
			 * @param {boolean} [options.isInternalOnly] If true, the Message record is not visible to an external Entity (for example, a customer or contact). The default value is false.
			 * @return {void}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some required argument is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument's type is incorrect
			 *
			 * @since 2015.2
			 *
			 */
			send: sendEmail,
			/**
			 * Sends bulk email (for use when bounceback notification is not required).
			 *
			 * @governance 10 units
			 * @restriction The maximum number of total recipients (recipient + cc + bcc) allowed is 10
			 *
			 * RelatedRecords represents the NetSuite records to which an Email Message record should be attached.
			 * @typedef {Object} RelatedRecords
			 * @property {number} transactionId - Transaction record to attach Message record to.
			 * @property {number} activityId - Activity record to attach Message record to.
			 * @property {number} entityId - Entity record to attach Message record to.
			 * @property {Object} customRecord - Custom record to attach Message record to.
			 * @property {number} customRecord.id - The instance ID for the custom record to attach the Message record to.
			 * @property {string} customRecord.recordType - The integer ID for the custom record type to attach the Message record to.
			 *
			 * @param {Object} options Email options
			 * @param {number} options.author Internal ID of the email sender.
			 * @param {number|number[]|string[]} options.recipients Recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number[]|string[]} [options.cc] CC recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number[]|string[]} [options.bcc] BCC recipients of the email as an EmailEntity, Internal ID or Email Address.
			 * @param {string} options.subject Subject of the outgoing message.
			 * @param {string} options.body Contents of the outgoing message.
			 * @param {string} [options.replyTo] The email address that appears in the reply-to header.
			 * @param {file.File[]} [options.attachments] Email file attachments.  Not supported in client side.
			 * @param {RelatedRecords} [options.relatedRecords] Object that contains key/value pairs to associate (attach) the Message record with related records (i.e., transaction, activity, entity, and custom records)
			 * @param {boolean} [options.isInternalOnly] If true, the Message record is not visible to an external Entity (for example, a customer or contact). The default value is false.
			 * @return {void}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some required argument is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument's type is incorrect
			 *
			 * @since 2015.2
			 *
			 */
			sendBulk: sendBulkEmail,
			/**
			 * Send a single "on-demand" campaign email to a specified recipient and return a campaign response ID to track the email
			 * @governance 10 units
			 *
			 * @param {number} campaignEventId  The internal ID of the campaign event.
			 * @param {number} recipientId The internal ID of the recipient. Note that the recipient must have an email.
			 * @return {number} A campaign response ID (tracking code) as an integer. If the email fails to send, the value returned is -1.
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some required argument is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument's type is incorrect
			 *
			 * @since 2015.2
			 *
			 */
			sendCampaignEvent: sendCampaignEventEmail
		});
	});

/**
 * SuiteScript module for routing and storing messages/dialogs
 *
 * @private
 * @module N/msgRouter
 * @suiteScriptVersion 2.x
 */
define(
	'N/msgRouter',['N/nsobject', 'N/utilityFunctions', 'N/restricted/remoteApiBridge', 'N/restricted/invoker', 'N/contextSwitch'],
	function (nsobject, utilityFunctions, remoteApi, invoker, contextSwitch)
	{
		function isServerSide() { return typeof document === 'undefined'; }

		/**
		 * Simple object that contains information about the message stored on the record
		 * @param {Object} [options] all information to be stored about the message
		 * @returns {Message}
		 * @constructor
		 */
		function Message (options)
		{
			var TYPE = 'Message';
			var msgInfo = options;

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return msgInfo;
			};
		}
		Object.freeze(Message);

		// container for all message queues ever created
		var allQueuesContainer = {};

		/**
		 * internal message queue implementation
		 * @returns {MessageQueueImpl}
		 * @constructor
		 */
		function MessageQueueImpl(queueId)
		{
			var TYPE = 'msgRouter.MessageQueueImpl';

			/** the actual container where the messages (@see Message) are kept */
			var messageContainer = [];

			// create the public message service instance for this queue implementation
			var messageService = new MessageService(this);

			Object.defineProperty(this, 'id', {get: function () {return queueId}});
			allQueuesContainer[queueId] = this;

			this.getMessageService = function () { return messageService; };

			this.storeMessage = function (options)
			{
				var msgOptions = {};
				if (!options)
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'options');
				if (!options.hasOwnProperty('source'))
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'source');
				if (!options.hasOwnProperty('data'))
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'data');
				msgOptions.source = options.source;
				msgOptions.data = options.data;
				msgOptions.reply = {value: options.reply || null};
				msgOptions.timestamp = (new Date()).getTime();

				if (isServerSide() && options.source === 'message.Message' && options.forClient === true)
				{
					msgOptions.forClient = options.forClient;
					sendMessageToClient(msgOptions.data);
				}
				messageContainer.push(new Message(msgOptions));
			};

			this.getMessages = function ()
			{
				return messageContainer.slice(0, messageContainer.length);
			};

			var DEFAULT_PROMPT_AUTO_RESPONSE = '';
			var DEFAULT_DIALOG_AUTO_RESPONSE = true;
			var DEFAULT_CONFIRM_AUTO_RESPONSE = true;

			/**
			 * provides an auto-reply for a dialog type specified by options parameter
			 * @param {Object} options
			 * @param {string} options.dialogType can be one of 'prompt', 'dialog', 'confirm'
			 * @param {string} options.dialogOptions this is for the dialog to pass in the buttons defined for the message
			 * @returns {?Object|boolean|string} auto response for the selected dialog type or null
			 */
			this.getAutoResponse = function getAutoResponse(options)
			{
				// TODO: allow to set auto response for a record via the MessageService object
				if (!options || !options.dialogType)
				{
					return null;
				}
				if (options.dialogType === 'prompt')
				{
					return DEFAULT_PROMPT_AUTO_RESPONSE;
				}
				else if (options.dialogType === 'confirm')
				{
					return DEFAULT_CONFIRM_AUTO_RESPONSE;
				}
				else if (options.dialogType === 'dialog')
				{
					if (options.dialogOptions &&
						options.dialogOptions.buttons &&
						options.dialogOptions.buttons.length > 0)
					{
						return options.dialogOptions.buttons[0].value;
					}
					else
						return DEFAULT_DIALOG_AUTO_RESPONSE;
				}
				return null;
			};

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return {};
			};
		}
		Object.freeze(MessageQueueImpl);

		/**
		 * a public message queue to be available as a record's property to retrieve all messages stored on the record
		 * @param {MessageQueueImpl} messageQueueImpl a handle to internal implementation of the message queue
		 * @returns {MessageService}
		 * @constructor
		 */
		function MessageService (messageQueueImpl)
		{
			var TYPE = 'Record.MessageService';

			utilityFunctions.checkArgs([messageQueueImpl], ['messageQueueImpl'], TYPE);

			var messageQueue = messageQueueImpl;

			Object.defineProperty(this, 'id', {get: function () {return messageQueue.id;}});

			/**
			 * retrieves all messages from the message queue
			 * @returns {[Message]} a list of all messages in the queue
			 */
			this.getMessages = function ()
			{
				return messageQueue.getMessages();
			};

			//TODO: setAutoResponse() method that would allow user to define an auto-response for the record messages

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return {};
			};
		}
		Object.freeze(MessageService);

		/**
		 * provides the currently active MessageQueueImpl instance to store a message into it
		 * @returns {MessageQueueImpl} the active MessageQueueImpl instance, either related to a specific record, or a default one (i.e. id is 0)
		 */
		var getActiveQueue = function getActiveQueue()
		{
			var record = contextSwitch.getRecord();
			var activeQueue = allQueuesContainer[record ? record.getSystemId() : 'null'];
			return activeQueue || new MessageQueueImpl('null'); // lazy initialization of a default message queue
		};

		/**
		 * provides a new instance of MessageService to be related to a Record instace
		 * @returns {MessageService}
		 */
		var getMessageServiceInstance = function getMessageServiceInstance(record)
		{
			getActiveQueue(); // we want to make sure that the message queue is lazy initialized with a default queue before we start adding instances
			var msgQueueImpl = new MessageQueueImpl(record.getSystemId());
			return msgQueueImpl.getMessageService();
		};

		// this is here to overload all Javascript native messaging methods
		// so we can also relate them to a record
		(function overloadGlobalAlerts() {
			var global = this;

			function getArgs(args) {
				var _args = [];
				for (var i = 0; i < args.length; i++)
					_args.push(args[i]);
				return _args;
			}

			var gAlert = global.alert;
			global.alert = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.alert', data: {args: getArgs(arguments)}, reply: null};
				if (gAlert) gAlert.apply(null, arguments);
				queue.storeMessage(msg);
			};
			var gPrompt = global.prompt;
			global.prompt = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.prompt', data: {args: getArgs(arguments)}, reply: null};
				msg.reply = gPrompt ? gPrompt.apply(null, arguments) : queue.getAutoResponse({dialogType: 'prompt'});
				queue.storeMessage(msg);
				return msg.reply;
			};
			var gConfirm = global.confirm;
			global.confirm = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.confirm', data: {args: getArgs(arguments)}, reply: null};
				msg.reply = gConfirm ? gConfirm.apply(null, arguments) : queue.getAutoResponse({dialogType: 'confirm'});
				queue.storeMessage(msg);
				return msg.reply;
			};
		})();

		function sendMessageToClient(message)
		{
			if (util.isObject(message))
			{
				var msgJson = JSON.stringify(message);
				invoker(remoteApi, 'sendMessageToClient', [msgJson]);
			}
		}

		var MESSAGE_FIELD = 'custpage__ss_messages_for_client';
		/**
		 * Used to display messges sent from Before Load to the client
		 * @param {Object|string} options - either the JSON string of all messages to be shown or an option object
		 * @param {Object} options.currentRecord - the current record to read the messages from
		 */
		var messageModule;

		function showMessagesFromBeforeLoad(options)
		{
			if (!messageModule)
			{
				//lazy require to avoid circular dependency in define
				require(['N/ui/message'], function(mod) { messageModule = mod; showMessagesFromBeforeLoad(options); });
				return;
			}
			var currentRecord = options && options.currentRecord;
			var messages;
			try {
				if (currentRecord)
					messages = JSON.parse(currentRecord.getValue(MESSAGE_FIELD));
			} catch (e)	{
				return;
			}
			if (messages && Array.isArray(messages.messages))
			{
				messages.messages.forEach(function (msg) {
					if (!msg) return;
					var duration = msg.duration ? msg.duration : undefined;
					messageModule.create(msg).show(duration);
				})
			}
		}

		return Object.freeze(
		{
			getActiveQueue : getActiveQueue,
			getMessageServiceInstance : getMessageServiceInstance,
			showMessagesFromBeforeLoad : showMessagesFromBeforeLoad
		});
	}
);

/**
 * SuiteScript Message Module (Client Side)
 * Load the message module to display a message at the top of the screen under the menu bar.
 *
 * @module N/ui/message
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui/message',['N/utilityFunctions', 'N/nsobject', 'N/error', 'N/msgRouter'], function (utilityFunctions, nsobject, error, msgRouter)
{
	var MESSAGE_TYPE = Object.freeze({
		CONFIRMATION: 0,
		INFORMATION: 1,
		WARNING: 2,
		ERROR: 3
	});

    /**
     * Return a new instance of Message, used to show/hide messages
     * @class
     * @classdesc Encapsulates the Message object that gets created when calling the create method.
     * @constructor
     * @protected
     *
     * @since 2016.1
     */
    function Message(initOptions)
    {
        var THIS_TYPE = 'message.Message';
        var msgOptions = initOptions;
        var msgObject = null;
        var messageQueue = msgRouter.getActiveQueue();
        var initialDuration = msgOptions.duration;

        /**
         * Shows the message.
         * @restriction Client SuiteScript only
         * @governance none
         * @param {Object} [options] The options object.
         * @param {number} [options.duration] The amount of time, in milliseconds, to show the message. The default is 0, which shows the message until Message.hide() is called.
         * @return {void}
         * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options.duration is specified with a non-numerical value.
         *
         * @since 2016.1
         */
        this.show = function(options)
        {
            var msecsToShow = initialDuration;
            if (options != null && options.hasOwnProperty('duration'))
                msecsToShow = options.duration;
            else if (util.isNumber(options))
                msecsToShow = options;

            msecsToShow = parseInt(msecsToShow);
            if (isNaN(msecsToShow))
                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE);

            msgOptions.duration = msecsToShow;

            messageQueue.storeMessage({source: THIS_TYPE, data: msgOptions, reply: null, forClient: options && options.sendToClient});

            // NS.UI.Messaging is available only in client
            if (typeof(NS) !== 'undefined' &&
                typeof(NS.UI) !== 'undefined' &&
                typeof(NS.UI.Messaging) !== 'undefined' &&
                typeof(NS.UI.Messaging.Message) === 'function')
            {
                msgObject = new NS.UI.Messaging.Message(msgOptions);
                msgObject.show();
            }
        };

        /**
         * Hides the message
         * @restriction Client SuiteScript only
         * @governance none
         * @return {void}
         *
         * @since 2016.1
         */
        this.hide = function()
        {
            if (msgObject !== null)
                msgObject.hide();
        };

        /**
         * Returns the object type name (message.Message)
         * @restriction Client SuiteScript only
         * @governance none
         * @return {string}
         *
         * @since 2016.1
         */
        this.toString = function()
        {
            return THIS_TYPE;
        };

	    /**
	     * get JSON format of the object
	     * @restriction Client SuiteScript only
	     * @governance none
	     * @return {Object}
	     *
	     * @since 2016.1
	     */
        this.toJSON = function()
        {
            return msgOptions;
        };
    }
    Message.prototype = nsobject.getNewInstance();
    Object.freeze(Message);

    function create(options)
    {
        var type, title, message, duration;

        if (options != null)
        {
            type = options.type;
            title = options.title || "";
            message = options.message || "";
            duration = options.hasOwnProperty('duration') ? options.duration : 0;
        }

        utilityFunctions.checkArgs([type], ['type'], 'Message.create');

        var messageOptions = {
            title: title,
            message: message,
            type: type,
            duration: duration
        };

        return new Message(messageOptions);
    }

    return Object.freeze({
                             /**
                              * Creates a message that can be displayed or hidden near the top of the page.
                              *
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} options.type The type of message, see message.Type
                              * @param {string} [options.title] The title of the message. Defaults to empty string.
                              * @param {string} [options.message] The content of the message. Defaults to empty string.
                              * @param {number} [options.duration] The amount of time, in milliseconds, to show the message. The default is 0, which shows the message until Message.hide() is called.
                              *
                              * @return {Message} A message object which can be shown or hidden.
                              * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or type are undefined
                              *
                              * @since 2016.1
                              */
                             create: create,

                             /**
                              * Enum for message types
                              * @enum {string}
                              * @readonly
                              */
                             Type: MESSAGE_TYPE
                             //Type: NS.UI.Messaging ? NS.UI.Messaging.Type : null
                         });
});

/**
 * SuiteScript Dialog Module (Client Side)
 * Modules within the N/ui namespace allow you to build a custom UI using SuiteScript 2.0. Note that N/ui itself is not a module.
 *
 * @module N/ui/dialog
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui/dialog',['N/utilityFunctions', 'N/error', 'N/msgRouter'], function (utilityFunctions, error, msgRouter)
{
    var DEFAULT_BUTTON_LABEL = "OK";
    var DEFAULT_BUTTON_VALUE = true;

    function prepareOptions(options)
    {
        var title = "", message = "";
        if (options !== undefined)
        {
            title = options.hasOwnProperty("title") ? options.title : "";
            message = options.hasOwnProperty("message") ? options.message : "";
        }

        return {title: title, message: message};
    }

	function prepareButtons(options)
	{
		var rawButtons;
		if ((options === undefined) || (options === null) || !options.hasOwnProperty("buttons"))
			rawButtons = [];
		else
			rawButtons = options.buttons;

		if (!util.isArray(rawButtons))
			utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE);

		if (rawButtons.length === 0)
			rawButtons = [{label: DEFAULT_BUTTON_LABEL, value: DEFAULT_BUTTON_VALUE}];

		return rawButtons;
	}

    function craftButtons(options)
    {
    	var buttons = prepareButtons(options);
        var buttonList = [];

        for (var i = 0; i < buttons.length; i++)
        {
            var thisButton = buttons[i];
            if (!thisButton.hasOwnProperty("label") || !thisButton.hasOwnProperty("value"))
                utilityFunctions.throwSuiteScriptError(error.Type.BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE);

            buttonList.push(new NS.UI.Messaging.Button({
                                                           label: thisButton.label,
                                                           value: thisButton.value,
                                                           onClick: function (event) { event.dialog.close(event); }
                                                       }));
        }
        return buttonList;
    }


    function doDialog(options, dialogType)
    {
	    var msg = {source: 'dialog.' + dialogType, data: options, reply: null};
    	var finalOptions = prepareOptions(options);

    	var messageQueue = msgRouter.getActiveQueue();

    	// server side or remote record
    	if (typeof(NS) === 'undefined' ||
		    typeof(NS.UI) === 'undefined' ||
		    typeof(NS.UI.Messaging) === 'undefined') {

		    if (dialogType === 'dialog') {
			    finalOptions.buttons = prepareButtons(options);
		    }
		    msg.reply = messageQueue.getAutoResponse({dialogType: dialogType, dialogOptions: finalOptions});
		    messageQueue.storeMessage(msg);
		    return msg.reply;
		    // TODO: change ret value to promise once its defined on the server so the return type is same as on client
	    }
	    // client side
    	else {
    		var creatorFunction;
		    if (dialogType === 'dialog') {
			    creatorFunction = NS.UI.Messaging.Dialog;
			    finalOptions.buttons = craftButtons(options);
		    }
		    else if (dialogType === 'confirm') {
			    creatorFunction = NS.UI.Messaging.Confirm;
		    }
		    else if (dialogType === 'alert') {
			    creatorFunction = NS.UI.Messaging.Alert;
		    }

		    return new Promise(function (resolve, reject) {
			    try {
				    finalOptions.onClose = function (event) {
					    var result = event.button.value;
					    msg.reply = result;
					    messageQueue.storeMessage(msg);
					    resolve(result);
				    };
				    var myDialog = new creatorFunction(finalOptions);
				    myDialog.open();
			    }
			    catch (e) {
				    reject(e);
			    }
		    });
	    }
    }

    function doAlert(options)
    {
        return doDialog(options, 'alert');
    }

    function doConfirm(options)
    {
        return doDialog(options, 'confirm');
    }

    function doCreate(options)
    {
        return doDialog(options, 'dialog');
    }

    return Object.freeze({
                             /**
                              * Creates an Alert Dialog with an OK Button.
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} [options.title] The alert dialog title. This value defaults to an empty string.
                              * @param {string} [options.message] The content of the alert dialog. This value defaults to an empty string.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *                   The callback will be passed in a response object which contains the value of the button where:
                              *                   OK returns true.
                              *
                              * @since 2016.1
                              */
                             alert: doAlert,
                             /**
                              * Creates an Confirm Dialog with OK and Cancel Button.
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} [options.title] The confirmation dialog title. This value defaults to an empty string.
                              * @param {string} [options.message] The content of the confirmation dialog. This value defaults to an empty string.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *					 The callback will be passed in a response object which contains the value of the button where:
                              *					 OK returns true and Cancel returns false.
                              *
                              * @since 2016.1
                              */
                             confirm: doConfirm,
                             /**
                              * Creates an Dialog with the specified buttons.
                              * @typedef ButtonOption
                              * @property label The label of the button
                              * @property value The return value of the dialog if the button was clicked
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} [options.title] The dialog title. This value defaults to an empty string.
                              * @param {string} [options.message] The content of the dialog. This value defaults to an empty string.
                              * @param {ButtonOption[]} [options.buttons] A list of buttons to include in the dialog. Each item in the button list must be a Javascript Object that contains a label and a value property.
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *					 The callback will be passed in a response object which contains the value of the button.
                              * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options.buttons is specified and is not an array.
                              * @throws {SuiteScriptError} BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE If options.buttons is specified and one or more items do not have a label and/or value.
                              *
                              * @since 2016.1
                              */
                             create: doCreate
                         });
});

/**
 * SuiteScript UI Module (Client Side)
 *
 * @module N/ui
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui',['N/ui/message', 'N/ui/dialog'], function (message, dialog)
{
    return Object.freeze({
        message: message,
        dialog: dialog
    })
});

/**
 * @private
 */
define('N/restricted/urlApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @module N/url
 * @NApiVersion 2.x
 *
 */
define('N/url',['N/restricted/invoker', 'N/restricted/urlApi'],
	function (invoker, urlApi)
        {

	        var HOST_TYPES = Object.freeze({
		        APPLICATION: 'APPLICATION',
		        CUSTOMER_CENTER: 'CUSTOMERCENTER',
		        RESTLET: 'RESTLETS',
		        SUITETALK: 'SUITETALK',
		        FORM: 'FORMS'
	        });

            function traverseParams(prefix, obj, add)
            {

                var rbracket = /\[\]$/;
                if (util.isArray(obj))
                {
                    // Serialize array item.
                    util.each(obj, function (i, v)
                    {
                        if (rbracket.test(prefix))
                        {
                            // Treat each array item as a scalar.
                            add(prefix, v);

                        }
                        else
                        {
                            // Item is non-scalar (array or object), encode its numeric index.
                            traverseParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, add);
                        }
                    });

                }
                else
                {
                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

            /*
             Inspired by jQuery.param()
             */
            function format(options, params)
            {
                var domain = options;
                if (util.isObject(options))
                {
                    domain = options.domain;
                    params = options.params;
                }
                var prefix;
                var s = [];
                var r20 = /%20/g;
                format = format || '';

                function add(key, value)
                {
                    // If value is a function, invoke it and return its value
                    value = util.isFunction(value) ? value() : (value == null ? "" : value);
                    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                };

                // If an array was passed in, assume that it is an array of form elements.
                if (util.isArray(params))
                {
                    for (var i = 0; i < params.length; i++)
                        add(i, params[i]);
                }
                else
                {
                    // encode params recursively.
                    for (prefix in params)
                    {
                        traverseParams(prefix, params[prefix], add);
                    }
                }

                // Return the resulting serialization
                var queryString = s.join("&").replace(r20, "+");
                var separator = (domain.indexOf('?') === -1) ? '?' : '&';

                return domain + separator + queryString;
            }


            /** @alias N/url */
            return Object.freeze({
                /**
                 * @param {Object} options
                 * @param {string} options.recordType
                 * @param {string} options.recordId
                 * @param {boolean} options.isEditMode
                 * @param {Object} options.params Per url.format({query
                              *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveRecord: function resolveRecord(options)
                {
                    var url = invoker(urlApi, 'nlapiResolveURL', ['RECORD', options.recordType, options.recordId || null, options.isEditMode === true ? 'EDIT' : null]);
                    if (options.params)
                        url = format(url, options.params);
                    return url;
                },
                /**
                 *
                 * @param {Object} options
                 * @param {string} options.id
                 * @param {Map} options.params (optional) url parameters
                 *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveTaskLink: function resolveTaskLink(options, params)
                {
                    var taskId = options;
                    if (util.isObject(options))
                    {
                        taskId = options.id;
                        params = options.params;
                    }
                    var url = invoker(urlApi, 'nlapiResolveURL', ['TASKLINK', taskId, null, null]);
                    if (params)
                        url = format(url, params);
                    return url;
                },
                /**
                 * @param {Object} options
                 * @param {string} options.scriptId
                 * @param {string} options.deploymentId
                 * @param {boolean} options.returnExternalUrl
                 * @param {Object} options.params Per url.format({query
                              *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveScript: function resolveScript(options)
                {
                    var url = invoker(urlApi, 'nlapiResolveURL', ['WEB_SCRIPT', options.scriptId, options.deploymentId, options.returnExternalUrl === true ? 'EXTERNAL' : null]);
                    if (options.params)
                        url = format(url, options.params);
                    return url;
                },
                /**
                 * @param {Object} options
                 * @param {string} options.hostType
                 * @param {string} options.accountId
                 *
                 * @return {String} domain
                 *
                 * @since 2017.1
                 */
                resolveDomain: function resolveDomain(options)
                {
                    return invoker(urlApi, 'nlapiResolveDomain', [options.hostType, options.accountId || null]);
                },
                /**
                 * @param {Object} options
                 * @param {string} options.domain
                 * @param {Object} options.params query string data parameters as an object
                 *
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                format: format,
                HostType: HOST_TYPES
            });
        });

/**
 * @private
 */
define('N/restricted/recordApi',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * @private
 */
define('N/restricted/recordRemoteApiBridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordConstants
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordConstants',[],
	function ()
	{
		var RECORD_MODE = Object.freeze({
			DYNAMIC_RECORD: 'dynamic record',
			DEFERRED_DYNAMIC_RECORD: 'standard record',
			READ_ONLY_RECORD: 'read-only record'
		});

		var SUBRECORD_MODE = Object.freeze({
			DYNAMIC_SUBRECORD: 'dynamic subrecord',
			DEFERRED_DYNAMIC_SUBRECORD: 'standard subrecord',
			READ_ONLY_SUBRECORD: 'read-only subrecord'
		});

		var CURRENT_RECORD_MODE = Object.freeze({
			CURRENT_RECORD: 'current record',
			READ_ONLY_CURRENT_RECORD: 'read-only current record'
		});

		var CURRENT_SUBRECORD_MODE = Object.freeze({
			CURRENT_SUBRECORD: 'current subrecord',
			READ_ONLY_CURRENT_SUBRECORD: 'read-only current subrecord'
		});

		var ALL_RECORD_PROXY_NAMES = Object.freeze([
			RECORD_MODE.DYNAMIC_RECORD,
			RECORD_MODE.DEFERRED_DYNAMIC_RECORD,
			RECORD_MODE.READ_ONLY_RECORD,
			SUBRECORD_MODE.DYNAMIC_SUBRECORD,
			SUBRECORD_MODE.DEFERRED_DYNAMIC_SUBRECORD,
			SUBRECORD_MODE.READ_ONLY_SUBRECORD,
			CURRENT_RECORD_MODE.CURRENT_RECORD,
			CURRENT_RECORD_MODE.READ_ONLY_CURRENT_RECORD,
			CURRENT_SUBRECORD_MODE.CURRENT_SUBRECORD,
			CURRENT_SUBRECORD_MODE.READ_ONLY_CURRENT_SUBRECORD
		]);

		var LINE_MODE = Object.freeze({
			DYNAMIC_LINE: 'dynamic record sublist line',
			DEFERRED_DYNAMIC_LINE: 'standard record sublist line',
			READ_ONLY_LINE: 'read-only record sublist line'
		});

		var RECORD_UNDERLYING_IMPL_NAME = Object.freeze({
			CLIENT_DYNAMIC_RECORD:      'recordDefinition.Record',	        // recordDefinition.js (both record & subrecord)
			DOM_CURRENT_RECORD:         'DomCurrentRecord',			        // domCurrentRecord.js (V1 client record)
			DOM_CURRENT_SUBRECORD:      'DomCurrentSubrecord',		        // currentSubrecord.js (V1 client subrecord)
			SERVER_DYNAMIC_RECORD:      'RecordImpl',				        // serverRecordService.js (java RecordImpl object)
			SERVER_DYNAMIC_SUBRECORD:   'SubrecordImpl'				        // serverRecordService.js (java SubrecordImpl object)
		});

		var ALL_RECORD_UNDERLYING_IMPL_NAMES = Object.freeze([
			RECORD_UNDERLYING_IMPL_NAME.CLIENT_DYNAMIC_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD,
			RECORD_UNDERLYING_IMPL_NAME.SERVER_DYNAMIC_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.SERVER_DYNAMIC_SUBRECORD
		]);

		return Object.freeze({
			RECORD_MODE: RECORD_MODE,
			SUBRECORD_MODE: SUBRECORD_MODE,
			CURRENT_RECORD_MODE: CURRENT_RECORD_MODE,
			CURRENT_SUBRECORD_MODE: CURRENT_SUBRECORD_MODE,
			ALL_RECORD_PROXY_NAMES: ALL_RECORD_PROXY_NAMES,
			LINE_MODE: LINE_MODE,
			RECORD_UNDERLYING_IMPL_NAME: RECORD_UNDERLYING_IMPL_NAME,
			ALL_RECORD_UNDERLYING_IMPL_NAMES: ALL_RECORD_UNDERLYING_IMPL_NAMES
		});
	});

/**
 * SuiteScript field util module
 *
 * @private
 * @module N/fieldUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/fieldUtil',["N/utilityFunctions"],
	function(utilityFunctions)
	{
		var SELECT_FIELD_TYPES = Object.freeze({
			SELECT: 'select',
			MULTI_SELECT: 'multiselect'
		});
		var RADIO_TYPE = 'radio';
		var CUSTPAGE_PREFIX = 'custpage';
		var SELECT_FIELD_TYPE_LIST = [SELECT_FIELD_TYPES.SELECT, SELECT_FIELD_TYPES.MULTI_SELECT];

		function isPrefixedWithCustPage(fieldName)
		{
			return (!utilityFunctions.isValEmpty(fieldName)) && (fieldName.indexOf(CUSTPAGE_PREFIX) === 0)
		}

		function isMultiSelectType(type)
		{
			return type === SELECT_FIELD_TYPES.MULTI_SELECT;
		}

		function isSelectType(type)
		{
			return SELECT_FIELD_TYPE_LIST.indexOf(type) > -1;
		}

		function isSelectTypeOrRadio(type)
		{
			return isSelectType(type) || type === RADIO_TYPE;
		}

		return {
					isPrefixedWithCustPage: isPrefixedWithCustPage,
					isMultiSelectType : isMultiSelectType,
					isSelectType: isSelectType,
					isSelectTypeOrRadio: isSelectTypeOrRadio,
					SELECT_FIELD_TYPES: SELECT_FIELD_TYPES
			   };
	});

/**
 * SuiteScript record event enum module
 *
 * @private
 * @module N/eventEmitter
 * @suiteScriptVersion 2.x
 *
 */
define('N/eventEmitter',['N/utilityFunctions','N/error'],
	function (utilityFunctions, error)
	{

		var currentToken;

		function assertArray(types)
		{
			var isArray = Array.isArray(types);

			if(!isArray)
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_ARRAY');
			}
		}

		function assertEventType(validEventTypes, checkEventTypes)
		{
			var invalidEventTypeFound = !!validEventTypes && checkEventTypes.some(function(v){
				return validEventTypes.indexOf(v) === -1;
			});

			if(invalidEventTypeFound)
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_EVENT_TYPE');
			}
		}

		function assertListener(listener)
		{
			if(typeof listener !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_EVENT_LISTENER');
			}
		}

		function assertAsyncAvailable()
		{
			if(typeof setTimeout !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.ASYNC_EVENTS_UNAVAILABLE');
			}
		}

		function asyncTransform(listener)
		{
			return function(event)
			{
				setTimeout(listener.bind(null, event), 0);
			};
		}

		function insulatedTransform(listener)
		{
			return function(event){
				try
				{
					listener(event);
				}
				catch(e)
				{
					if(!!console && !!console.error)
					{
						console.error(e);
					}
				}
			};
		}

		function assertFunction(func)
		{
			if(typeof func !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.NOT_A_FUNCTION');
			}
		}

		function createListenerCollection()
		{
			var eventsListeners = {};

			function getEventListeners(eventType)
			{
				var result = eventsListeners[eventType];

				if(!result)
				{
					result = [];
					eventsListeners[eventType] = result;
				}

				return result;
			}

			function add(type, listener)
			{
				var listeners = getEventListeners(type);
				listeners.push(listener);
			}

			function get(type)
			{
				return getEventListeners(type).slice(0);
			}

			function remove(type, listener)
			{
				var listeners = getEventListeners(type);
				var index = 0;
				var count = listeners.length;

				if(!!listener)
				{
					index = listeners.indexOf(listener);
					count = 1;
				}

				if (index != -1) {
					listeners.splice(index, count);
				}
			}

			return Object.freeze({
				add: add,
				get: get,
				remove: remove
			});
		}

		function createEmitter(options)
		{
			var async = !!options && !!options.async;
			var isBlocking = !!options && util.isBoolean(options.blocking) ? options.blocking : async;
			var insulated = !!options && !!options.insulated;
			var eventTypes = !!options && options.eventTypes || null;
			var preProcessor = !!options && options.preProcessor || null;
			var heldEvents = [];
			var heldEventsEmittingFunction = null;
			var eventsListeners = createListenerCollection();

			if(async)
			{
				assertAsyncAvailable();
			}

			function on(options){
				var types = !!options && options.types || null;
				var listener = !!options && options.listener || null;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], 'emitter.on');
				assertArray(types);
				assertEventType(eventTypes, types);
				assertListener(listener);

				types.forEach(function(type){
					eventsListeners.add(type, listener);
				});
			}

			function off(options)
			{
				var types = !!options && options.types || null;
				var listener = !!options && options.listener || null;

				utilityFunctions.checkArgs([types], ['types'], 'emitter.off');
				assertArray(types);
				assertEventType(eventTypes, types);

				types.forEach(function(type){
					eventsListeners.remove(type, listener);
				});
			}

			function emitHeldEvents(){
				function emitHeldEventsInternal(){
					if(!!preProcessor)
					{
						heldEvents = preProcessor(heldEvents);
					}

					var errorEvents = [];
					heldEvents.forEach(function (event) {
						if (event.type === "ERROR" && errorEvents.indexOf(event.error) != -1)
							return;
						if (!!event.error)
							errorEvents.push(event.error);
						if (!event.suppressEmit)
							internalEmit(event);
					});
					heldEvents = [];
					heldEventsEmittingFunction = null;
				}

				if (!heldEventsEmittingFunction)
				{
					heldEventsEmittingFunction = emitHeldEventsInternal;
					setTimeout(heldEventsEmittingFunction, 0);
				}
			}

			function internalEmit(event)
			{
				var type = !!event && event.type || null;
				
				eventsListeners.get(type).forEach(function (listener){
					var func = listener;

					func = insulated ? insulatedTransform(func) : func;
					func = async ? asyncTransform(func) : func;

					func(event);
				});
			}

			function emit(event)
			{
				var type = !!event && event.type || null;

				utilityFunctions.checkArgs([event, type], ['event', 'type'], 'emitter.emit');
				assertEventType(eventTypes, [type]);

				if (!!event && event.token == null && currentToken != null)
				{
					event.token = currentToken;
				}

				if(isBlocking)
				{
					heldEvents.push(event);
					emitHeldEvents();
				}
				else
				{
					if(!!preProcessor)
					{
						event = preProcessor([event])[0];
					}

					internalEmit(event);
				}
			}

			return Object.freeze({
				on: on,
				off: off,
				emit: emit
			});
		}

		function callWithToken(token, callback)
		{
			var previousToken = currentToken;

			if (token != null)
			{
				currentToken = token;
			}
			try
			{
				return callback();
			}
			finally
			{
				currentToken = previousToken;
			}
		}

		return Object.freeze({
			create: createEmitter,
			callWithToken: callWithToken
		});
	});

/**
 * SuiteScript metadata module
 *
 * @private
 * @module N/field
 * @NApiVersion 2.x
 *
 */
define('N/field',['N/error', 'N/nsobject', 'N/restricted/invoker', 'N/utilityFunctions', 'N/fieldUtil', 'N/eventEmitter', 'N/runtime'],
        function (error, nsobject, invoker, utilityFunctions, fieldUtil, eventEmitter, runtime)
{

    /**
     * @protected
     * @constructor
     */
    function Field(delegate)
    {
        /**
         * Return label of the field
         * @name Field#label
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return invoker(delegate, 'getLabel');
            },
            set: function (val)
            {
                return invoker(delegate, 'setLabel', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return id of the field
         * @name Field#id
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                        return invoker(delegate, 'getName');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.id');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Disabled state of the field
         * @name Field#isDisabled
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisabled', {
                    get: function ()
                    {
                        return invoker(delegate, 'isDisabled');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setDisabled', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Display state of the field
         * @name Field#isDisplay
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
                    get: function ()
                    {
                        return invoker(delegate, 'isDisplay');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setDisplay', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Mandatory state of the field
         * @name Field#isMandatory
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isMandatory', {
                    get: function ()
                    {
                        return invoker(delegate, 'isMandatory');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setMandatory', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Read Only state of the field
         * @name Field#isReadOnly
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isReadOnly', {
                    get: function ()
                    {
                        return invoker(delegate, 'isReadOnly');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setReadOnly', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Visible state of the field
         * @name Field#isVisible
         * @type boolean
         * @since 2015.2
         */
        Object.defineProperty(this, 'isVisible', {
                    get: function ()
                    {
                        return invoker(delegate, 'isVisible');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setVisible', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return type of the field
         * @name Field#type
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'type', {
            get: function ()
            {
                return invoker(delegate, 'getType');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.type');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return the sublistId of the field
         * @name Field#sublistId
         * @type string
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'sublistId', {
            get: function ()
            {
                return invoker(delegate, 'getSublistName');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.sublistId');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns if the field is a popup
         * @name Field#isPopup
         * @type boolean
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'isPopup', {
            get: function ()
            {
                return invoker(delegate, 'isPopup');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.isPopup');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns a list of available options on a select field. This API can be used on both standard and custom select fields. Only the first 1,000 available options will be returned by this API.
         *
         * @param {Object} options
         * @param {string} options.filter
         * @param {string} options.operator Supported operators are contains | is | startswith. If not specified, defaults to the contains operator.
         * @return {Array}
         *
         */

        function getSelectOptions(options,filteroperator)
        {
            var filter = options;
            if (utilityFunctions.isObject(options))
            {
                filter = options.filter;
                filteroperator = options.operator;
            }
            var sOptions = [];
                    var optionObjects = invoker(delegate, 'getSelectOptions', [filter || null, filteroperator || null]);
                    for (var i in optionObjects)
            {
                        if (!optionObjects.hasOwnProperty(i))
                    continue;
                        sOptions[sOptions.length] = {
                            'value': optionObjects[i].getId(),
                            'text': optionObjects[i].getText()
                        };
            }
            return sOptions;
        };

        if(fieldUtil.isSelectTypeOrRadio(this.type))
            this.getSelectOptions = getSelectOptions;

        function checkUpdateSelectOptions()
        {
	        var scriptId = runtime.getCurrentScript().id;
	        if (scriptId != null && scriptId !== 'internal' && !invoker(delegate, 'canExternalUpdateSelectOptions'))
	        	utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE);
	        if (invoker(delegate, 'isPopup'))
		        utilityFunctions.throwSuiteScriptError(error.Type.SSS_NOT_YET_SUPPORTED, "update popup select options");
        }

        function insertSelectOption(options, text)
        {
            var value,
                selected = false,
                that = this,
                undef = undefined,
                eventToken;

            if (text !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                text = options.text;
                selected = options.isSelected || false;
	            eventToken = options._eventToken;
            }

            return eventEmitter.callWithToken(eventToken, function ()
            {
	            checkUpdateSelectOptions();
	            utilityFunctions.checkArgs([value, text], ['value', 'text'], 'Field.insertSelectOption');
	            invoker(delegate, 'insertSelectOption', [String(value), text, selected]);
            });
        }

        function removeSelectOption(options)
        {
            var undef = undefined,
                that = this,
                value,
                eventToken;

            if (options !== undef && options !== null && options.value !== undef)
            {
            	value = options.value;
            	eventToken = options._eventToken;
            }
            else
            {
            	value = options;
            }

	        return eventEmitter.callWithToken(eventToken, function ()
	        {
		        checkUpdateSelectOptions();
		        utilityFunctions.checkArgs([value], ['value'], 'Field.removeSelectOption');
		        invoker(delegate, 'removeSelectOption', [String(value)]);
	        });
        }

        if(fieldUtil.isSelectType(this.type)) {
            this.insertSelectOption = insertSelectOption;
            this.removeSelectOption = removeSelectOption;
        }
        // Functions for debugger
        /**
         * get JSON format of the object
         * @return {{id: *, label: *, type: *}}
         *
         */
        this.toJSON = function toJSON()
        {
            return {
                        'id': this.id,
                        'label': this.label,
                        'type': this.type
            };
        };

        /**
         * @return {string}
         *
         */
        this.toString = function toString()
        {
            return "Field";
        };
    }

    Field.prototype = nsobject.getNewInstance();

    return Object.freeze({
        create: function create(f)
        {
            try
            {
                return Object.freeze(new Field(f));
            }
            catch (e)
            {
                throw error.create(e);
            }
        }
    });

});

/**
 * Field Definition module
 * Will create the appropriate Field Object given the desired attributes.
 *
 * @private
 * @module N/fieldDefinition
 * @NApiVersion 2.x
 *
 */
define('N/metadata/fieldDefinition',['N/restricted/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'], function(invoker, utilityFunctions, nsobject, error) {



    var FIELD_CATEGORY = {
        CURRENT_BODY: 'currentBody',
        CURRENT_SUBLIST: 'currentSublist',
        DYNAMIC_BODY: 'dynamicBody',
        DYNAMIC_SUBLIST: 'dynamicSublist',
        DEFERRED_DYNAMIC_BODY: 'deferredDynamicBody',
        DEFERRED_DYNAMIC_SUBLIST: 'deferredDynamicSublist',
        DEFERRED_DYNAMIC_CURRENT_BODY: 'deferredDynamicCurrentBody',
        DEFERRED_DYNAMIC_CURRENT_SUBLIST: 'deferredDynamicCurrentSublist',
        READ_ONLY_BODY: 'readOnlyRecordBody',
        READ_ONLY_SUBLIST: 'readOnlyRecordSublist'
    };
    FIELD_CATEGORY.getInstance = function getFieldCategoryInstance(options){
        var category;
        if(!!options.isDynamic)
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.DYNAMIC_SUBLIST : FIELD_CATEGORY.DYNAMIC_BODY;
        }
        else if(!!options.isReadOnly)
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.READ_ONLY_SUBLIST : FIELD_CATEGORY.READ_ONLY_BODY;
        }
        else
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.DEFERRED_DYNAMIC_SUBLIST : FIELD_CATEGORY.DEFERRED_DYNAMIC_BODY;
        }
        return category;
    };
    FIELD_CATEGORY = utilityFunctions.freezeObjectIfPossible(FIELD_CATEGORY);

    var FIELD_PROPERTIES = Object.freeze({
                                            ID: "id",
                                            LABEL: "label",
                                            TYPE: "type",
                                            SUBLIST_ID: "sublistId",
                                            SELECT_OPTION_PROP: "selectOptionProp",
                                            IS_MANDATORY: "isMandatory",
                                            IS_DISABLED: "isDisabled",
                                            IS_POPUP: "isPopup",
                                            IS_DISPLAY: "isDisplay",
                                            IS_VISIBLE: "isVisible",
                                            IS_READ_ONLY: "isReadOnly",
											TO_JSON: "toJSON",
											TO_STRING: "toString"
                                         });

    var ACCESS_LEVEL = Object.freeze({
                NONE: 0,
                READ_ONLY: 1,
                READ_WRITE: 2
                                     });

    function Field(delegate, permissions)
    {
        function authorizeThenWrite(accessLevel, setFunction, errorMsg)
        {
            if (accessLevel === ACCESS_LEVEL.READ_WRITE)
            {
                setFunction();
            }
            else
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, errorMsg );
            }
        }

        function noAction() { }

        if (permissions[FIELD_PROPERTIES.ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the id of the field
             * @name Field#id
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'id', {
                get: function ()
                {
                    return delegate.id;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.ID], noAction, "Field.id");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.LABEL] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the label of the field
             * @name Field#label
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'label', {
                get: function ()
                {
                    return delegate.label;
                },
                set: function (label)
                {
                            var setFunction = function ()
                            {
                                        delegate.label = label;
                                      };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.LABEL], setFunction, "Field.label");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.TYPE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the type of the field
             * @name Field#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'type', {
                get: function ()
                {
                    return delegate.type;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.TYPE], noAction, "Field.type");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.SUBLIST_ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the sublist id of the field
             * @name Field#sublistId
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'sublistId', {
                get: function ()
                {
                    return delegate.sublistId;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.SUBLIST_ID], noAction, "Field.sublistId");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.SELECT_OPTION_PROP] > ACCESS_LEVEL.NONE)
        {
            this.getSelectOptions = delegate.getSelectOptions;
	        this.insertSelectOption = delegate.insertSelectOption;
	        this.removeSelectOption = delegate.removeSelectOption;
        }
        if (permissions[FIELD_PROPERTIES.IS_MANDATORY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is mandatory or not.
             * @name Field#isMandatory
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isMandatory', {
                get: function ()
                {
                    return delegate.isMandatory;
                },
                set: function (required)
                {
                            var setFunction = function ()
                            {
                                            if (!util.isBoolean(required))
                                                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isMandatory",'boolean' );

                                            delegate.isMandatory = required;
                                        };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_MANDATORY], setFunction, "Field.isMandatory");
                },
                enumerable: true,
                configurable: false
            });
        }
        // ==== Current Record (UI) specific properties
        if (permissions[FIELD_PROPERTIES.IS_DISABLED] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is disabled
             * @name Field#isDisabled
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isDisabled', {
                get: function ()
                {
                    return delegate.isDisabled;
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                        if (!util.isBoolean(val))
                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isDisabled",'boolean' );

                        delegate.isDisabled = val;
                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_DISABLED], setFunction, "Field.isDisabled");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_POPUP] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is a popup
             * @name Field#isPopup
             * @type boolean
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'isPopup', {
                get: function ()
                {
                    return delegate.isPopup;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_POPUP], noAction, "Field.isPopup");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is displayed (when false, there is no space reserved on the UI for this field, unlike visible)
             * @name Field#isDisplay
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isDisplay', {
                get: function ()
                {
                    return delegate.isDisplay;
                },
                set: function (show)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(show))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isDisplay",'boolean' );
                                        delegate.isDisplay = show;
                                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_DISPLAY], setFunction, "Field.isDisplay");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_VISIBLE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is visible (when false, the space is still reserved on the UI for this field, unlike display)
             * @name Field#isVisible
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isVisible', {
                get: function ()
                {
                    return delegate.isVisible;
                },
                set: function (show)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(show))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isVisible",'boolean' );
                                        delegate.isVisible = show;
                                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_VISIBLE], setFunction, "Field.isVisible");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_READ_ONLY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is readOnly
             * @name Field#isVisible
             * @type boolean
             * @since 2015.2
             */
            Object.defineProperty(this, 'isReadOnly', {
                get: function ()
                {
                    return delegate.isReadOnly
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(val))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isReadOnly",'boolean' );
                                        delegate.isReadOnly = val;
                                    };

                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_READ_ONLY], setFunction, "Field.isReadOnly");
                },
                enumerable: true,
                configurable: false
            });
        }

		if (permissions[FIELD_PROPERTIES.TO_JSON] > ACCESS_LEVEL.NONE)
		{
			this.toJSON = delegate.toJSON;
		}

		if (permissions[FIELD_PROPERTIES.TO_STRING] > ACCESS_LEVEL.NONE)
		{
			this.toString = delegate.toString;
		}
    }

    Field.prototype = nsobject.getNewInstance();
    Object.freeze(Field);

    return Object.freeze({
                             Category: FIELD_CATEGORY,
                Property: FIELD_PROPERTIES,
                             Access: ACCESS_LEVEL,
                create: function (delegate, permissions)
                             {
                                 return !delegate ? null : Object.freeze(new Field(delegate, permissions));
                             }
                         });
        });

/**
 *
 * @private
 * @module N/fieldPermissions
 * @NApiVersion 2.x
 *
 */
define('N/metadata/fieldPermissions',['N/metadata/fieldDefinition'], function(fieldDef) {

    var dynamicBody = {};
    dynamicBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
	dynamicBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	dynamicBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var dynamicSublist = {};
    dynamicSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
	dynamicSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	dynamicSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicBody = {};
    deferredDynamicBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicSublist = {};
    deferredDynamicSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var currentBody = {};
    currentBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    currentBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
	currentBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	currentBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var currentSublist = {};
    currentSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
	currentSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	currentSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicCurrentBody = {};
    deferredDynamicCurrentBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    deferredDynamicCurrentBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicCurrentSublist = {};
    deferredDynamicCurrentSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var readOnlyRecordBody = {};
    readOnlyRecordBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    readOnlyRecordBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    readOnlyRecordBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var readOnlyRecordSublist = {};
    readOnlyRecordSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    readOnlyRecordSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var masterPermission = {};
    masterPermission[fieldDef.Category.CURRENT_BODY]                     = currentBody;
    masterPermission[fieldDef.Category.CURRENT_SUBLIST]                  = currentSublist;
    masterPermission[fieldDef.Category.DYNAMIC_BODY]                     = dynamicBody;
    masterPermission[fieldDef.Category.DYNAMIC_SUBLIST]                  = dynamicSublist;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_BODY]            = deferredDynamicBody;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_SUBLIST]         = deferredDynamicSublist;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_BODY]    = deferredDynamicCurrentBody;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_SUBLIST] = deferredDynamicCurrentSublist;
    masterPermission[fieldDef.Category.READ_ONLY_BODY] = readOnlyRecordBody;
    masterPermission[fieldDef.Category.READ_ONLY_SUBLIST] = readOnlyRecordSublist;

    var convertToCurrentVersion = {};
    convertToCurrentVersion[fieldDef.Category.CURRENT_BODY] = fieldDef.Category.CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.CURRENT_SUBLIST] = fieldDef.Category.CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.DYNAMIC_BODY] = fieldDef.Category.CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.DYNAMIC_SUBLIST] = fieldDef.Category.CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.DEFERRED_DYNAMIC_BODY] = fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.DEFERRED_DYNAMIC_SUBLIST] = fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.READ_ONLY_BODY] = fieldDef.Category.READ_ONLY_BODY;
    convertToCurrentVersion[fieldDef.Category.READ_ONLY_SUBLIST] = fieldDef.Category.READ_ONLY_SUBLIST;

    function getPermission(type, isCurrent)
    {
        var trueType = isCurrent ? convertToCurrentVersion[type] : type;
        return masterPermission[trueType];
    }

    return Object.freeze({
                            getPermissions: getPermission
                         });
        });

/**
 * Field metadata module
 * Will provide the proper attributes based on the parameters sent in to identify its source.
 *
 * @private
 * @module N/fieldMetadata
 * @suiteScriptVersion 2.x
 */
define('N/metadata/fieldMetadata',['N/utilityFunctions', 'N/metadata/fieldDefinition', 'N/metadata/fieldPermissions'], function(utilityFunctions, fieldDef, fieldPermissions) {

    function wrap(options)
    {
        var fieldCategory = options.category || null,
                 delegate = options.delegate || null,
                isCurrent = options.current  || false;

        utilityFunctions.checkArgs([fieldCategory, delegate], ["fieldCategory", "delegate"], "fieldMetadata");

        return fieldDef.create(delegate, fieldPermissions.getPermissions(fieldCategory, isCurrent));
    }

    return Object.freeze({
                            Category: fieldDef.Category,
                            wrap : wrap
                         });
});

/**
 * SuiteScript module
 * This file is an alias for NLSqlInjectionFilter - NLSqlInjectionFilter.getFirstIllegalMatch(null)
 *
 * @private
 * @module N/util/sqlInjectionFilter
 * @suiteScriptVersion 2.x
 */
define('N/util/sqlInjectionFilter',["N/restricted/invoker", 'N/restricted/remoteApiBridge'],
	function(invoker, apiBridge){
		/* imports */
		/**
		 * @alias SELECT_STRING (NLSqlInjectionFilter.java)
		 */
		var SQL_SELECT_STRING_REGEX = /select[ ].+from[ ]?[^ ,]*[ ,]+((all)?(trandoc|tranline|trancard|entity|custjob|emaillogin|emailpassword|emailpasswordhistory|emailpasswordnewhistory)|([a-zA-Z_0-9]*)?@SIGNUPDB_0|([a-zA-Z_0-9]*)?@SANDBOX_SIGNUPDB_0|pwdresetanswers|v\$|source\$|dbms_|all_|dba_|user_|java\$|nl_)/i;

		/**
		 * utility function that values field value against SQL injection regex. Logs error if match is found
		 * @param fieldId - field name
		 * @param toValidate - value in field
		 */
		function validateSqlInjection(fieldId, toValidate)
		{
			if(isNonEmptyString(toValidate))
			{
				var matches = SQL_SELECT_STRING_REGEX.exec(toValidate.replace(/\s/g,' '));
				if(matches != null && matches.length > 1 && matches[1].trim().length > 0)
					logSQLInjectionError(fieldId, toValidate, matches[1]);
			}
		}

		function logSQLInjectionError(fieldId, toValidate, firstCaptureGroup)
		{
			invoker(apiBridge, 'logSQLInjectionError', [fieldId, toValidate, firstCaptureGroup]);
		}

		function isNonEmptyString(toValidate)
		{
			return (util.isString(toValidate) && toValidate.length > 0);
		}

		/* assign util.sqlInjectionFilter package */
		return Object.freeze({
			validateSqlInjection: validateSqlInjection
		});
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordUtilityFunctions
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordUtilityFunctions',['N/restricted/invoker', 'N/utilityFunctions', 'N/error', 'N/restricted/remoteApiBridge',
		'N/util/sqlInjectionFilter', 'N/util/formatter'],
	function(invoker, utilityFunctions, error, clientScriptHandler,
	         sqlInjectionFilter, formatter)
	{
	    var undef = undefined;
	    var FIELD_TYPE = {
	            SUBRECORD_FIELD_TYPE : 'summary',
	            MULTISELECT : 'multiselect',
	            RADIO : 'radio',
		        SELECT : 'select',
		        CHECKBOX: 'checkbox',
		        TIME: "time",
		        TIMETRACK: "timetrack",
			    RATE: "rate",
			    RATEHIGHPRECISION: "ratehighprecision"
        };

	    var MACHINE_TYPE = {
	            INLINE_EDIT: 'inlineeditor'
        };

		var SELECT_FIELD_TYPE = [FIELD_TYPE.SELECT, FIELD_TYPE.MULTI_SELECT];
	    function isSelectType(type)
	    {
	        return SELECT_FIELD_TYPE.indexOf(type) > -1;
	    }

	    function isRateType(type)
	    {
	    	return type === FIELD_TYPE.RATE || type === FIELD_TYPE.RATEHIGHPRECISION;
	    }

	    var EDIT_MACHINE_TYPE = [MACHINE_TYPE.INLINE_EDIT];
	    function isEditMachine(sublist)
	    {
	        return EDIT_MACHINE_TYPE.indexOf(sublist.type) > -1;
	    }

	    function handleOverloadingMethodsForSingleArgument(options, key, errorMessageFillerValue)
	    {
	        var argument = options !== undef && options !== null && !util.isString(options) ? options[key] : options;
	        utilityFunctions.checkArgs([argument], [key], errorMessageFillerValue);

	        return argument;
	    }

	    function emptyIfNullOrUndefined(value)
	    {
	        if(value === null || value === undefined)
	            return "";
	        else
	            return value;
	    }

	    function assertValidSublistOperation(isValid)
	    {
	        if(!isValid)
	            utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
	    }

	    function formatValueToArrayType(value)
	    {
	        if(!value && value !== 0 && value !== '')
	            return value;
	        else
	        {
	            if(typeof value === 'string' && value.indexOf(String.fromCharCode(5)) !== -1)
	                value = value.split(String.fromCharCode(5));

	            // Empty value represents the value is not set, hence return empty array
	            return util.isArray(value) ? value : (!utilityFunctions.isValEmpty(value)) ? [value] : [];
	        }
	    }
	    function formatArrayToStringType(value)
	    {
	        if(util.isArray(value))
	            return value.join(String.fromCharCode(5));
	        else
	            return String(value);
	    }

	    function validateAgainstSqlInjection(fieldId, value)
	    {
		    sqlInjectionFilter.validateSqlInjection(fieldId, value);
	    }

	    /**
	     * utility function to apply function to each property of the object, the function takes 2 argument one is the key and second one is the value
	     * @param obj
	     * @param {Function} function to process each property of the object, first argument will be property key and second argument will be the entry
	     */
	    function forEachProperty(obj, f)
	    {
	        for(var pKey in obj)
	        {
	            if(obj.hasOwnProperty(pKey))
	            {
	                f(pKey, obj[pKey]);
	            }
	        }
	    }

	    function executeRecordGetterFunctionsForInstance(sublistId, fieldId, lineInstanceId, isCommitted, bodyFieldFunction, sublistFieldFunction)
	    {
	        var toRet = null;
	        if (!!sublistId)
	        {
	            toRet = sublistFieldFunction(sublistId, fieldId, lineInstanceId, isCommitted);
	        }
	        else
	        {
	            toRet = bodyFieldFunction(fieldId);
	        }
	        return toRet;
	    }

	    function executeRecordGetterFunctions(sublistId, fieldId, line, bodyFieldFunction, sublistFieldFunction, currentSublistFieldFunctions)
	    {
	        var toRet = null;
	        if (sublistId)
	        {
	            if (line >= 0)
	                toRet = sublistFieldFunction(sublistId, fieldId, line);
	            else
	                toRet = currentSublistFieldFunctions(sublistId, fieldId);
	        }
	        else
	        {
	            toRet = bodyFieldFunction(fieldId);
	        }
	        return toRet;
	    }

	    function matchRecordFieldValueSchema(obj)
	    {
	        return util.isObject(obj) && obj.hasOwnProperty('value') && obj.hasOwnProperty('legacyStringValue');
	    }

	    function transformRawValueToFieldValueSchema(obj, cacher)
	    {
	        var fieldValue = {};
	    	if (util.isArray(obj))
		    {
		    	obj = obj.map(function (item)
			    {
			    	if (util.isObject(item) && item.hasOwnProperty('id') && item.hasOwnProperty('text'))
				    {
				    	cacher(item.id, utilityFunctions.unescape(item.text));
				    	return item.id;
				    }
				    else
				    {
				    	return utilityFunctions.unescape(item);
				    }
			    });
		    	fieldValue = {value: undefined, legacyStringValue: obj.join(String.fromCharCode(5))};
		    }
	        else if(/* select schema */ util.isObject(obj) && obj.hasOwnProperty('id') && obj.hasOwnProperty('text'))
	        {
	            fieldValue = {value: undefined, legacyStringValue: obj.id };
	            cacher(obj.id, utilityFunctions.unescape(obj.text));
	        }
	        else
	            fieldValue = {value: undefined, legacyStringValue: utilityFunctions.unescape(obj)};
	        return fieldValue;
	    }

	    function validateRecordFieldValueSchema(val)
	    {
	        if (!matchRecordFieldValueSchema(val) && val !== null && val !== undefined)
	        {
	            utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
	        }
	    }

	    function clone(receiver, contributor)
	    {
	        for (var key in contributor)
	            if (contributor.hasOwnProperty(key))
	            {
	                var value = contributor[key];
	                if(util.isDate(contributor[key]))
	                {
	                    value = new Date(value);
	                }
	                else if(util.isArray(value))
	                {
	                    value = value.map(function(v){
	                        return v;
	                    })
	                }

	                receiver[key] = value;
	            }
	        return receiver;
	    }

	    function getZeroBasedIndex(index)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        return index > 0 ? index - 1 : index;
	    }

	    function getOneBasedIndex(index)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        return index >= 0 ? index + 1 : index;
	    }

	    function validateAndGetOneBasedIndex(index, method, indexUpperLimit)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        if (index < 0 || (indexUpperLimit !== undefined && index >= indexUpperLimit))
	        {
	            throw error.create({name: error.Type.INVALID_SUBLIST_OPERATION, message: method});
	        }
	        else
	        {
	            return index + 1;
	        }
	    }

	    function getClientSlavingResultFromMetadata(clientSlavingMetadata, masterValue, getClientSlavingMetadata)
	    {
	        //TODO refactor into client slaving metadata
	        var slaveResults = {fields: []};

	        for(var slaveFieldId in clientSlavingMetadata)
	        {
	            var clientSlavingResult = clientSlavingMetadata[slaveFieldId];
	            var result = { isClientSlaving: true };
	            result.name = clientSlavingResult.name;
	            if(clientSlavingResult.machine)
	                result.machine = clientSlavingResult.machine;
	            if(clientSlavingResult.firechange || getClientSlavingMetadata(result.machine, result.name) !== null)
	                result.firechange = true;
	            if(clientSlavingResult.condition)
	                result.condition = clientSlavingResult.condition;
	            if(clientSlavingResult.nooverride)
	                result.nooverride = clientSlavingResult.nooverride;

	            if(clientSlavingResult.values)
	                result.value = clientSlavingResult.values["_"+masterValue] || "";

	            if(clientSlavingResult.options && util.isArray(clientSlavingResult.options))
	            {
	                result.options = [];
	                var selectOptions = clientSlavingResult.options;

	                for(var i = 0; i < selectOptions.length; i++)
	                {
	                    if(!!selectOptions[i].isSelected)
	                        result.value = selectOptions[i].value;
	                    result.options.push([selectOptions[i].value, selectOptions[i].text]);
	                }
	            }

	            slaveResults.fields.push(result);
	        }

	        return slaveResults;
	    }

		function parseValue(isValidField, fieldLevelMetadata, value, skipPercentage, ignoreUserPrefs)
		{
			var parsedValue;

			if (fieldLevelMetadata && fieldLevelMetadata.type === FIELD_TYPE.CHECKBOX && value === '')
			{
				parsedValue = false;
			}
			else if (!isValidField || (!value && value !== false && value !== 0 && value !== ''))
			{
				parsedValue = value;
			}
			else if (fieldLevelMetadata && fieldLevelMetadata.isTypeMultiSelect)
			{
				parsedValue = formatValueToArrayType(value).map(function (val) { return String(val); });
			}
			else if (fieldLevelMetadata && fieldLevelMetadata.isTypeSelect)
			{
				parsedValue = String(value);
			}
			else if (fieldLevelMetadata)
			{
				parsedValue = formatter.parse(value, fieldLevelMetadata.type, fieldLevelMetadata.isNumeric,
					fieldLevelMetadata.isCurrency, fieldLevelMetadata.fieldTypeForValidation,
					undefined, skipPercentage, ignoreUserPrefs);
			}

			return parsedValue;
		}


	    return {
	        FIELD_TYPE: FIELD_TYPE,
	        clone: clone,
	        no_op_function: function(){},
	        isSelectType: isSelectType,
		    isRateType: isRateType,
	        isEditMachine: isEditMachine,
	        executeRecordGetterFunctions: executeRecordGetterFunctions,
	        executeRecordGetterFunctionsForInstance: executeRecordGetterFunctionsForInstance,
	        forEachProperty: forEachProperty,
	        handleOverloadingMethodsForSingleArgument: handleOverloadingMethodsForSingleArgument,
	        emptyIfNullOrUndefined: emptyIfNullOrUndefined,
	        assertValidSublistOperation: assertValidSublistOperation,
	        formatValueToArrayType: formatValueToArrayType,
	        formatArrayToStringType: formatArrayToStringType,
	        validateAgainstSqlInjection: validateAgainstSqlInjection,
	        validateRecordFieldValueSchema: validateRecordFieldValueSchema,
	        matchRecordFieldValueSchema: matchRecordFieldValueSchema,
	        getZeroBasedIndex: getZeroBasedIndex,
	        getOneBasedIndex: getOneBasedIndex,
	        validateAndGetOneBasedIndex: validateAndGetOneBasedIndex,
	        getClientSlavingResultFromMetadata: getClientSlavingResultFromMetadata,
	        transformRawValueToFieldValueSchema: transformRawValueToFieldValueSchema,
		    parseValue: parseValue
	    };
	});

/**
 * SuiteScript field level metadata event module
 *
 * @private
 * @module N/record/fieldLevelMetadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldLevelMetadataEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			LABEL_CHANGE: 'LABEL_CHANGE'
		});

	function getEvent(type, fieldLevelMetadata)
	{
		return {
			type: type,
			fieldLevelMetadata: fieldLevelMetadata
		};
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function emit(emitter, fieldLevelMetadata, type, oldValue, newValue)
	{
		emitter.emit(addFieldValues(getEvent(type, fieldLevelMetadata), oldValue, newValue));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/fieldLevelMetadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldLevelMetadata',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/record/fieldLevelMetadataEvent', 'N/eventEmitter', 'N/fieldTypeConstants'],
       function(recordUtil, utilityFunctions, fieldLevelMetadataEvent, eventEmitter, fieldTypeConstants){

           /**
            * object hold the field metadata of record
            *
            * @param {{name: string,
               label: string,
               type: string,
               isMachineHeaderField: boolean,
               acceptEmptyValueForSelectField: boolean,
               isPopup: boolean,
               isSortable: boolean,
               maxLength: number,
               isNumeric: boolean,
               isCurrency: boolean,
               hasBlankString: boolean,
               blankString: string,
               minValue: number,
               maxValue: number,
               validationTypeField: string,
               fieldState: *,
               fieldScript: object,
               radioSet: *,
               slavingMetadata: *,
               clientSlavingMetadata: *,
               optionMastersAndAuxFields: *,
               hasStaticOptions: boolean,
               supplementedOptions: array}} metadata
            * @returns {FieldLevelMetadata}
            * @constructor
            */
           function FieldLevelMetadata(metadata)
           {
               var that = this;
               var label = utilityFunctions.unescape(metadata.label);
               var defaultFieldStates = metadata.hasOwnProperty('fieldState') ? metadata.fieldState : {};
               if (defaultFieldStates.hasOwnProperty('label'))
               	    defaultFieldStates.label = utilityFunctions.unescape(defaultFieldStates.label);
               var emitter = eventEmitter.create();
               var sortableFields = [fieldTypeConstants.Type.TEXT,
		           fieldTypeConstants.Type.TEXTAREA,
		           fieldTypeConstants.Type.EMAIL,
		           fieldTypeConstants.Type.DOCUMENT,
		           fieldTypeConstants.Type.INTEGER,
		           fieldTypeConstants.Type.POSINTEGER,
		           fieldTypeConstants.Type.FLOAT,
		           fieldTypeConstants.Type.POSFLOAT,
		           fieldTypeConstants.Type.NONNEGFLOAT,
		           fieldTypeConstants.Type.RATE,
		           fieldTypeConstants.Type.RATEHIGHPRECISION,
		           fieldTypeConstants.Type.PERCENT,
		           fieldTypeConstants.Type.CURRENCY,
		           fieldTypeConstants.Type.CURRENCY2,
		           fieldTypeConstants.Type.PHONE,
		           fieldTypeConstants.Type.SELECT,
		           fieldTypeConstants.Type.CHECKBOX,
		           fieldTypeConstants.Type.TIME,
		           fieldTypeConstants.Type.TIMETRACK,
		           fieldTypeConstants.Type.DATE,
		           fieldTypeConstants.Type.MMYYDATE,
		           fieldTypeConstants.Type.DATETIME,
		           fieldTypeConstants.Type.DATETIMETZ,
		           fieldTypeConstants.Type.TIMEOFDAY];

               Object.defineProperty(this, 'label', {
                   get: function ()
                   {
                       return label;
                   },
                   set: function (val)
                   {
                       var oldValue = label;
                       label = val;
                       var newValue = label;
                       fieldLevelMetadataEvent.emit(emitter, that, fieldLevelMetadataEvent.Type.LABEL_CHANGE, oldValue, newValue);
                   },
                   enumerable: true,
                   configurable: false
               });

               function getName() { return metadata.name; }
               utilityFunctions.addReadOnlyProperty(that, 'name', getName);

               function getType() { return metadata.type; }
	           utilityFunctions.addReadOnlyProperty(that, 'type', getType);

	           function isFieldMultiSelect() { return metadata.type === recordUtil.FIELD_TYPE.MULTISELECT; }
	           /**
	            * Return true if the field is a multi-select field type
	            * @name FieldLevelMetadata#isTypeMultiSelect
	            * @type boolean
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeMultiSelect', isFieldMultiSelect);

	           function isFieldSelectType(){ return recordUtil.isSelectType(metadata.type); }
	           /**
	            * Return true if the field is a select type
	            * @name FieldLevelMetadata#isTypeSelect
	            * @type boolean
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeSelect', isFieldSelectType);


	           function isFieldRadioType(){ return metadata.type === recordUtil.FIELD_TYPE.RADIO; }
	           /**
	            * Return true if the field is a radio type
	            * @name FieldLevelMetadata#isTypeRadio
	            * @type boolean
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeRadio', isFieldRadioType);

	           /**
	            * Returns whether or not the field is sortable via getLines API
	            * @returns {*|boolean}
	            */
	           function isSortable() { return sortableFields.indexOf(metadata.type) > -1; }
	           utilityFunctions.addReadOnlyProperty(that, 'isSortable', isSortable);

	           function getRadioSet() { return metadata.radioSet || null; }
	           utilityFunctions.addReadOnlyProperty(that, 'radioSet', getRadioSet);

               function isPopup() { return metadata.isPopup || false; }
	           utilityFunctions.addReadOnlyProperty(that, 'isPopup', isPopup);

               function hasStaticOptions() { return metadata.hasStaticOptions || false; }
	           utilityFunctions.addReadOnlyProperty(that, 'hasStaticOptions', hasStaticOptions);

	           function getSupplementedOptions() { return metadata.supplementedOptions || null; }
	           utilityFunctions.addReadOnlyProperty(that, 'supplementedOptions', getSupplementedOptions);

               function isMachineHeaderField() { return metadata.isMachineHeaderField || false; }
	           utilityFunctions.addReadOnlyProperty(that, 'isMachineHeaderField', isMachineHeaderField);


               function acceptEmptyValueForSelectField() {return (metadata.acceptEmptyValueForSelectField) ? metadata.acceptEmptyValueForSelectField : true; };
	           utilityFunctions.addReadOnlyProperty(that, 'acceptEmptyValueForSelectField', acceptEmptyValueForSelectField);


               function getMaxLength() { return metadata.maxLength; }
	           utilityFunctions.addReadOnlyProperty(that, 'maxLength', getMaxLength);

               function isNumeric() { return metadata.isNumeric; }
	           utilityFunctions.addReadOnlyProperty(that, 'isNumeric', isNumeric);

               function isCurrency() { return metadata.isCurrency; }
	           utilityFunctions.addReadOnlyProperty(that, 'isCurrency', isCurrency);

               function hasBlankString() { return metadata.hasBlankString; }
	           utilityFunctions.addReadOnlyProperty(that, 'hasBlankString', hasBlankString);

               function getBlankString() {
                   return metadata.blankString
               }
	           utilityFunctions.addReadOnlyProperty(that, 'blankString', getBlankString);


               function hasMinValue() { return metadata.hasOwnProperty("minValue"); }
	           utilityFunctions.addReadOnlyProperty(that, 'hasMinValue', hasMinValue);

               function getMinValue() { return metadata.minValue; }
	           utilityFunctions.addReadOnlyProperty(that, 'minValue', getMinValue);

               function hasMaxValue() { return metadata.hasOwnProperty("maxValue"); }
	           utilityFunctions.addReadOnlyProperty(that, 'hasMaxValue', hasMaxValue);

               function getMaxValue() { return metadata.maxValue; }
	           utilityFunctions.addReadOnlyProperty(that, 'maxValue', getMaxValue);


               function getValidationFieldType() { return metadata.validationTypeField; }
	           /**
	            * field type for validation logic
	            * @name FieldLevelMetadata#fieldTypeForValidation
	            * @type string
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'fieldTypeForValidation', getValidationFieldType);

               function getDefaultFieldState() { return util.extend({}, defaultFieldStates); }
	           utilityFunctions.addReadOnlyProperty(that, 'defaultFieldState', getDefaultFieldState);

               function getSlavingMetadata() { return metadata.hasOwnProperty('slavingMetadata') ? metadata.slavingMetadata : null; }

	           utilityFunctions.addReadOnlyProperty(that, 'slavingMetadata', getSlavingMetadata);

               function getClientSlavingMetadata() { return metadata.clientSlavingMetadata; }
	           utilityFunctions.addReadOnlyProperty(that, 'clientSlavingMetadata', getClientSlavingMetadata);

               function getFieldScripts(){ return metadata.fieldScript; }
	           utilityFunctions.addReadOnlyProperty(that, 'fieldScripts', getFieldScripts);

               function getFieldScript(scriptType)
               {
                   if(metadata.hasOwnProperty('fieldScript') && metadata['fieldScript'].hasOwnProperty(scriptType))
                       return metadata['fieldScript'][scriptType];
                   else
                       return null;
               }
               this.getFieldScript = getFieldScript;

               function getOptionMastersAndAuxFields() { return metadata.optionMastersAndAuxFields; /* array */ }
	           utilityFunctions.addReadOnlyProperty(that, 'optionMastersAndAuxFields', getOptionMastersAndAuxFields);

               function getSubrecordType()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordType')) ? metadata.subrecordType : null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordType', getSubrecordType);


               function getSubrecordIdField()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordIdField')) ? metadata.subrecordIdField : null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordIdField', getSubrecordIdField);


               function getSubrecordCompatibilityMap()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordCompatibilityMap')) ? metadata.subrecordCompatibilityMap : null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordCompatibilityMap', getSubrecordCompatibilityMap);


               function getSubrecordInitialParameters()
               {
                   return (metadata.type === 'summary' && metadata.hasOwnProperty('subrecordInitialParameters')) ? metadata.subrecordInitialParameters: null;
               }
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordInitialParameters', getSubrecordInitialParameters);

               this.on = emitter.on;
               this.off = emitter.off;

               function toJSON()
               {
                   var copy = util.extend({}, metadata);
                   return copy;
               }

               return this;
           }
           Object.freeze(FieldLevelMetadata);


           return {
               /**
                * return a new instance of field level metadata object
                * @param {Object} options
                * @returns {FieldLevelMetadata}
                */
               create: function create(options) {
                   return new FieldLevelMetadata(options);
               }
           };
       });

/**
 * SuiteScript sublist metadata event module
 *
 * @private
 * @module N/record/sublistLevelMetadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLevelMetadataEvent',['N/record/fieldLevelMetadataEvent'], function(fieldLevelMetadataEvent)
{
	var EVENT_TYPE = Object.freeze({
		FIELD_METADATA_LABEL_CHANGE: 'FIELD_METADATA_LABEL_CHANGE'
	});

	var translateFieldLevelMetadataEventTypeToSublistLevelMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldLevelMetadataEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldLevelMetadataEventToSublistLevelMetadataEvent(sublistLevelMetadata, fieldLevelMetadataEvent)
	{
		return addFieldLevelMetadataEventDetails(getEvent(sublistLevelMetadata, translateFieldLevelMetadataEventTypeToSublistLevelMetadataEventType(fieldLevelMetadataEvent.type)), fieldLevelMetadataEvent);
	}

	function addFieldLevelMetadataEventDetails(event, fieldLevelMetadataEvent)
	{
		event.fieldId = fieldLevelMetadataEvent.fieldLevelMetadata.name;
		if(fieldLevelMetadataEvent.oldValue !== undefined){ event.oldValue = fieldLevelMetadataEvent.oldValue; }
		if(fieldLevelMetadataEvent.newValue !== undefined){ event.newValue = fieldLevelMetadataEvent.newValue; }

		return event;
	}

	function getEvent(sublistLevelMetadata, type)
	{
		return {
			type: type,
			sublistLevelMetadata: sublistLevelMetadata
		};
	}

	function emit(emitter, sublistState, type)
	{
		emitter.emit(getEvent(sublistState, type));
	}

	function forwardFieldLevelMetadataEvent(emitter, sublistLevelMetadata, fieldLevelMetadataEvent)
	{
		emitter.emit(translateFieldLevelMetadataEventToSublistLevelMetadataEvent(sublistLevelMetadata, fieldLevelMetadataEvent));
	}

	function forwardFieldLevelMetadataEvents(emitter, sublistLevelMetadata, fieldLevelMetadata)
	{
		var forward = forwardFieldLevelMetadataEvent.bind(null, emitter, sublistLevelMetadata);

		fieldLevelMetadata.on({
			types: [
				fieldLevelMetadataEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldLevelMetadataEvents: forwardFieldLevelMetadataEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistLevelMetadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLevelMetadata',['N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/sublistLevelMetadataEvent', 'N/eventEmitter'],
       function(utilityFunctions, recordUtil, sublistLevelMetadataEvent, eventEmitter){

           /**
            * object hold the sublist metadata of record
            *
            * @param {Object} options
            * @param {{name: string,
               type: string,
               nlobjSublistType: string,
               sortedFields: *,
               backwardCompatibleFields: *,
               sublistScript: string,
               defaultValues: *,
               displayOnly: boolean,
               isRecalcDeferred: boolean,
               isScriptableMachine: boolean}} options.sublistMetadataObj
            * @param {Object} options.fieldMetadatas fieldLevelMetadata collection
            * @returns {SublistLevelMetadata}
            * @constructor
            */
           function SublistLevelMetadata(options)
           {
               var that = this;
               var sublistMetadataObj = options.sublistMetadataObj;
               var fieldMetadata = options.fieldMetadatas;

               var name = sublistMetadataObj.name;
               var type = sublistMetadataObj.type; /* machine type: edit|list|search|subtab */
               var nlobjSublistType = sublistMetadataObj.nlobjSublistType; /* sublist type: inlineeditor|editor|staticlist|list */
               var isScriptableMachine = sublistMetadataObj.isScriptableMachine;
               var isSublistEditable = sublistMetadataObj.isEditable;
               var sortedFields = sublistMetadataObj.sortedFields || [];
               var noCopyFields = sublistMetadataObj.noCopyFields || [];
               var backwardCompatibleFields = sublistMetadataObj.backwardCompatibleFields;
               var scripts = sublistMetadataObj.sublistScript || {};
               var defaultValues = {};
	           recordUtil.forEachProperty(sublistMetadataObj.defaultValues || {}, function(fld, value) {
		           defaultValues[fld] = utilityFunctions.unescape(value);
	           });
	           var isSublistDisplayOnly = sublistMetadataObj.displayOnly || false;
	           var isSublistMultilineEditable = sublistMetadataObj.isMultilineEditable || false;

               var emitter = eventEmitter.create();
	           recordUtil.forEachProperty(fieldMetadata, function(fieldId, metadata) {
                   sublistLevelMetadataEvent.forwardFieldLevelMetadataEvents(emitter, that, metadata);
               });

               function getName() { return name }
	           utilityFunctions.addReadOnlyProperty(this, 'name', getName);

               function getType() { return type }
	           utilityFunctions.addReadOnlyProperty(this, 'type', getType);

               function getSortedFields() { return sortedFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'sortedFields', getSortedFields);

               function getNoCopyFields() { return noCopyFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'noCopyFields', getNoCopyFields);

               function getBackwardCompatibilityFieldNamesForSubrecord() { return backwardCompatibleFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'backwardCompatibilityFieldNamesForSubrecord', getBackwardCompatibilityFieldNamesForSubrecord);

               function getNlobjSublistConstructorType() { return nlobjSublistType; }
	           utilityFunctions.addReadOnlyProperty(this, 'nlobjSublistConstructorType', getNlobjSublistConstructorType);

               function getIsScriptableMachine(){
                   return isScriptableMachine;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'isScriptableMachine', getIsScriptableMachine);

               function getIsSublistEditable(){
                   return isSublistEditable;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'isEditable', getIsSublistEditable);

               function getSublistScripts(scriptingTrigger)
               {
                   /*
                    * list of scriptingTrigger:
                    * validatelines
                    * validateinsert
                    * validatedelete
                    * lineinit
                    * linecommit
                    * postdeleteline
                    * recalc
                    */
                   var result = null;

                   if(scriptingTrigger === undefined)
                   {
                       result = scripts;
                   }
                   else if(scripts.hasOwnProperty(scriptingTrigger))
                   {
                       result = scripts[scriptingTrigger];
                   }

                   return result;
               }
               this.getSublistScripts = getSublistScripts;

               function getSublistDefaultValue()
               {
                   return util.extend({}, defaultValues);
               }
	           utilityFunctions.addReadOnlyProperty(this, 'defaultValue', getSublistDefaultValue);

               function getDefaultSublistState()
               {
                   return util.extend({}, sublistMetadataObj.sublistState);
               }
	           utilityFunctions.addReadOnlyProperty(this, 'defaultState', getDefaultSublistState);

               function getFieldMetadatas()
               {
                   return fieldMetadata
               }
	           utilityFunctions.addReadOnlyProperty(this, 'fieldMetadata', getFieldMetadatas);


               function getFieldMetadata(fieldId)
               {
                   return fieldMetadata.hasOwnProperty(fieldId) ? fieldMetadata[fieldId] : null;
               }
               this.getFieldMetadata = getFieldMetadata;

               function isRecalcDeferred()
               {
                   return sublistMetadataObj.isRecalcDeferred;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'isRecalcDeferred', isRecalcDeferred);

               function isDisplayOnly()
               {
                   return isSublistDisplayOnly;
               }
	           utilityFunctions.addReadOnlyProperty(this, 'displayOnly', isDisplayOnly);

	           function isMultilineEditable()
	           {
		           return isSublistMultilineEditable;
	           }
	           utilityFunctions.addReadOnlyProperty(this, 'isMultilineEditable', isMultilineEditable);

               this.on = emitter.on;
               this.off = emitter.off;

               return this;
           }
           Object.freeze(SublistLevelMetadata);

           return {
               /**
                * return a new instance of sublist level metadata object
                * @param {Object} options
                * @returns {SublistLevelMetadata}
                */
               create: function create(options) {
                   return new SublistLevelMetadata(options);
               }
           };
       });

/**
 * SuiteScript metadata event module
 *
 * @private
 * @module N/record/metadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/metadataEvent',['N/record/fieldLevelMetadataEvent', 'N/record/sublistLevelMetadataEvent'], function(fieldLevelMetadataEvent, sublistLevelMetadataEvent)
{
	var EVENT_TYPE = Object.freeze({
		FIELD_METADATA_LABEL_CHANGE: 'FIELD_METADATA_LABEL_CHANGE'
	});

	function getEvent(metadata, type)
	{
		return {
			type: type,
			metadata: metadata
		};
	}

	var translateFieldLevelMetadataEventTypeToMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldLevelMetadataEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldLevelMetadataEventToMetadataEvent(metadata, fieldLevelMetadataEvent)
	{
		return addFieldLevelMetadataEventDetails(getEvent(metadata, translateFieldLevelMetadataEventTypeToMetadataEventType(fieldLevelMetadataEvent.type)), fieldLevelMetadataEvent);
	}

	function addFieldLevelMetadataEventDetails(event, fieldLevelMetadataEvent)
	{
		event.fieldId = fieldLevelMetadataEvent.fieldLevelMetadata.name;

		return event;
	}

	function forwardFieldLevelMetadataEvent(emitter, metadata, fieldLevelMetadataEvent)
	{
		emitter.emit(translateFieldLevelMetadataEventToMetadataEvent(metadata, fieldLevelMetadataEvent));
	}

	function forwardFieldLevelMetadataEvents(emitter, metadata, fieldLevelMetadata)
	{
		var forward = forwardFieldLevelMetadataEvent.bind(null, emitter, metadata);

		fieldLevelMetadata.on({
			types: [
				fieldLevelMetadataEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateSublistLevelMetadataEventTypeToMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[sublistLevelMetadataEvent.Type.FIELD_METADATA_LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(sublistLevelMetadataEventType){
			return eventTranslations[sublistLevelMetadataEventType];
		}
	}());

	function translateSublistLevelMetadataEventToMetadataEvent(metadata, sublistLevelMetadataEvent)
	{
		return addSublistLevelMetadataEventDetails(getEvent(metadata, translateSublistLevelMetadataEventTypeToMetadataEventType(sublistLevelMetadataEvent.type)), sublistLevelMetadataEvent);
	}

	function addSublistLevelMetadataEventDetails(event, sublistLevelMetadataEvent)
	{
		event.sublistId = sublistLevelMetadataEvent.sublistLevelMetadata.name;
		event.fieldId = sublistLevelMetadataEvent.fieldId;
		if(sublistLevelMetadataEvent.oldValue !== undefined){ event.oldValue = sublistLevelMetadataEvent.oldValue; }
		if(sublistLevelMetadataEvent.newValue !== undefined){ event.newValue = sublistLevelMetadataEvent.newValue; }

		return event;
	}

	function forwardSublistLevelMetadataEvent(emitter, metadata, sublistLevelMetadataEvent)
	{
		emitter.emit(translateSublistLevelMetadataEventToMetadataEvent(metadata, sublistLevelMetadataEvent));
	}

	function forwardSublistLevelMetadataEvents(emitter, metadata, sublistLevelMetadata)
	{
		var forward = forwardSublistLevelMetadataEvent.bind(null, emitter, metadata);

		sublistLevelMetadata.on({
			types: [
				sublistLevelMetadataEvent.Type.FIELD_METADATA_LABEL_CHANGE
			],
			listener: forward
		});
	}

	function emit(emitter, metadata, type)
	{
		emitter.emit(getEvent(metadata, type));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldLevelMetadataEvents: forwardFieldLevelMetadataEvents,
		forwardSublistLevelMetadataEvents: forwardSublistLevelMetadataEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/metadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/metadata',['N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/fieldLevelMetadata','N/record/sublistLevelMetadata', 'N/record/metadataEvent', 'N/eventEmitter'],
       function(utilityFunctions, recordUtil, fieldLevelMetadata, sublistLevelMetadata, metadataEvent, eventEmitter){


           function Metadata(metadataObj)
           {
               var that = this;
               var type, queryUrl, sortedFields, sortedSublists, libraryScript, staticScript, uiFormScript, workflowScript;
               var fieldIds, sublistIds, sublistFieldIds, fieldMetadata, sublistMetadata;

               var emitter = eventEmitter.create();

               (function constructor(metadataObj){
                   type = metadataObj.type;
                   queryUrl = metadataObj.queryUrl;
                   sortedFields = metadataObj.sortedFields;
                   sortedSublists = metadataObj.sortedSublist;
                   /* Record Scripting Variables */
                   libraryScript = metadataObj.libraryScript;
                   staticScript = metadataObj.staticScript;
                   uiFormScript = metadataObj.uiFormScript;
                   workflowScript = metadataObj.workflowScript;

                   fieldIds = [];
                   sublistIds = [];
                   sublistFieldIds = {};
                   fieldMetadata = {};
                   sublistMetadata = {};
                   (function setFieldMetadata(fieldLevelMetadataObjs){
                       recordUtil.forEachProperty(fieldLevelMetadataObjs, function(fieldId, metadataJSON)
                       {
                           fieldIds[fieldIds.length] = fieldId;
                       });

                       utilityFunctions.freezeObjectIfPossible(fieldIds);
                   })(metadataObj.bodyField);

                   (function setSublistFieldMetadata(sublistLevelMetadataObjs){

                       recordUtil.forEachProperty(sublistLevelMetadataObjs, function(sublistId, sublistLevelMetadataObj){
                           sublistIds[sublistIds.length] = sublistId;

                           var fieldmetadataJSON = sublistLevelMetadataObj.fieldMetadata;
                           var fieldLevelMetadatas = {};
                           sublistFieldIds[sublistId] = [];

                           recordUtil.forEachProperty(fieldmetadataJSON, function(fieldId, metadataJSON)
                           {
                               sublistFieldIds[sublistId].push(fieldId);
                               fieldLevelMetadatas[fieldId] = fieldLevelMetadata.create(metadataJSON);
                           });

                           var metadata = sublistLevelMetadata.create({sublistMetadataObj: sublistLevelMetadataObj, fieldMetadatas: fieldLevelMetadatas});
                           metadataEvent.forwardSublistLevelMetadataEvents(emitter, that, metadata);
                           sublistMetadata[sublistId] = metadata;
                       });

                       utilityFunctions.freezeObjectIfPossible(sublistIds);
                   }) (metadataObj.sublist);


               })(metadataObj);

               function getType() { return type; }
	           utilityFunctions.addReadOnlyProperty(this, 'type', getType);

               function getQueryUrl() { return queryUrl; }
	           utilityFunctions.addReadOnlyProperty(this, 'queryUrl', getQueryUrl);

               function getLibraryScript() { return libraryScript; }
	           utilityFunctions.addReadOnlyProperty(this, 'libraryScript', getLibraryScript);

               function getStaticScript() { return staticScript; }
	           utilityFunctions.addReadOnlyProperty(this, 'staticScript', getStaticScript);

               function getUIFormScript() { return uiFormScript; }
	           utilityFunctions.addReadOnlyProperty(this, 'uiFormScript', getUIFormScript);

               function getWorkflowScript() { return workflowScript; }
               utilityFunctions.addReadOnlyProperty(this, 'workflowScript', getWorkflowScript);

               function getNoCopyFields() { return sortedFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'noCopyFields', getNoCopyFields);

               function getSortedFields() { return sortedFields; }
	           utilityFunctions.addReadOnlyProperty(this, 'sortedFields', getSortedFields);

               function getSortedSublists() { return sortedSublists; }
	           utilityFunctions.addReadOnlyProperty(this, 'sortedSublists', getSortedSublists);

               function getAllFieldNames() { return fieldIds; }
	           utilityFunctions.addReadOnlyProperty(this, 'fieldIds', getAllFieldNames);

               function isValidField(fieldId)
               {
                   return getAllFieldNames().indexOf(fieldId) > -1;
               }
               this.isValidField = isValidField;

               function getAllSubrecordFields()
               {
                   return getAllFieldNames().filter(function(v, i, a){
                       var fieldId = v;
                       return getFieldMetadata(null, fieldId) && getFieldMetadata(null, fieldId).type === recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE;
                   });
               }
	           utilityFunctions.addReadOnlyProperty(this, 'subrecordFieldIds', getAllSubrecordFields);

               function getSublistFieldMetadata(sublistId, fieldId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId) ? sublistMetadata[sublistId].getFieldMetadata(fieldId) : null;
               }

               function getFieldMetadata(sublistId, fieldId)
               {
                   if(sublistId)
                       return getSublistFieldMetadata(sublistId, fieldId);

                   var metadata = null;
                   if(fieldMetadata.hasOwnProperty(fieldId))
                       metadata = fieldMetadata[fieldId];
                   else if(metadataObj.bodyField.hasOwnProperty(fieldId))
                   {
                       metadata = fieldLevelMetadata.create(metadataObj.bodyField[fieldId]);
                       metadataEvent.forwardSublistLevelMetadataEvents(emitter, that, metadata);
                       fieldMetadata[fieldId] = metadata;
                   }

                   return metadata;
               }

	           /**
	            *
	            * @param {string} sublistId
	            * @param {string} fieldId
	            * @returns {FieldLevelMetadata}
	            */
               this.getFieldMetadata = getFieldMetadata;

               function isValidSublist(sublistId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId);
               }
               this.isValidSublist = isValidSublist;

               function getSublistMetadata(sublistId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId) ? sublistMetadata[sublistId] : null;
               }
               this.getSublistMetadata = getSublistMetadata;

               function getSublistType(sublistId)
               {
                   var metadata = getSublistMetadata(sublistId);
                   return (metadata) ? metadata.type : null;
               }
               this.getSublistType = getSublistType;

               function getSublists() { return sublistIds; }
	           utilityFunctions.addReadOnlyProperty(this, 'sublistIds', getSublists);

               function isValidSublistField(sublistId, fieldId)
               {
                   var sublistfields = getAllSublistFields(sublistId);
                   return (sublistfields != null && sublistfields.indexOf(fieldId) > -1);
               }
               this.isValidSublistField = isValidSublistField;

               function getAllSublistFields(sublistId)
               {
                   return sublistFieldIds[sublistId] || [];
               }
               this.getAllSublistFields = getAllSublistFields;

               function getAllSublistSubrecordFields(sublistId)
               {
                   var sublistFields = sublistFieldIds[sublistId] || [];

                   sublistFields = sublistFields.filter(function(v, i, a){
                       var fieldId = v;

                       return getSublistFieldMetadata(sublistId, fieldId) &&
                              getSublistFieldMetadata(sublistId, fieldId).type === recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE;
                   });

                   return sublistFields;
               }
               this.getAllSublistSubrecordFields = getAllSublistSubrecordFields;

               function getSublistScripts(sublistName, scriptingTrigger)
               {
                   var metadata = getSublistMetadata(sublistName);
                   return (metadata) ? metadata.getSublistScripts(scriptingTrigger) : null;
               }
               this.getSublistScripts = getSublistScripts;

               function getSublistDefaultValue(sublistId)
               {
                   var metadata = getSublistMetadata(sublistId);
                   return (metadata) ? metadata.defaultValue : {};
               }
               this.getSublistDefaultValue = getSublistDefaultValue;

               function toJSON()
               {
                   return metadataObj;
               }

               function clone()
               {
                   return new Metadata(toJSON());
               }
               this.clone = clone;

               this.on = emitter.on;
               this.off = emitter.off;

               return this;
           }

           return {
               /**
                * return a new instance of Metadata
                * @param {Object} metadataObj
                * @returns {Metadata}
                */
               create: function(metadataObj) { return new Metadata(metadataObj); },
               /**
                * return true if object is an instance of Metadata
                * @param {Object} obj
                * @returns {boolean}
                */
               isInstance: function(obj) { return obj instanceof Metadata; }
           };
       });

/**
 * SuiteScript field state event module
 *
 * @private
 * @module N/record/fieldStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldStateEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			PARENT_STATE_CHANGE: 'PARENT_STATE_CHANGE',
			USE_TEXT_API_CHANGE: 'USE_TEXT_API_CHANGE',
			IS_PARSED_CHANGE: 'IS_PARSED_CHANGE',
			IS_MANDATORY_CHANGE: 'IS_MANDATORY_CHANGE',
			IS_HIDDEN_CHANGE: 'IS_HIDDEN_CHANGE',
			IS_DISABLED_CHANGE: 'IS_DISABLED_CHANGE',
			IS_VISIBLE_CHANGE: 'IS_VISIBLE_CHANGE',
			IS_DISPLAY_CHANGE: 'IS_DISPLAY_CHANGE',
			IS_READ_ONLY_CHANGE: 'IS_READ_ONLY_CHANGE',
			IGNORE_SLAVING_CHANGE: 'IGNORE_SLAVING_CHANGE',
			IS_CHANGED_CHANGE: 'IS_CHANGED_CHANGE',
			LABEL_CHANGE: 'LABEL_CHANGE'
		});

	function getEvent(fieldState, type)
	{
		return {
			type: type,
			fieldState: fieldState
		};
	}

	function addValues(event, oldValue, newValue)
	{
		if(oldValue !== undefined){ event.oldValue = oldValue; }
		if(newValue !== undefined){ event.newValue = newValue; }

		return event;
	}

	function emit(emitter, fieldState, type, oldValue, newValue)
	{
		emitter.emit(addValues(getEvent(fieldState, type), oldValue, newValue));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/fieldState
 * @suiteScriptVersion 2.x
 */
define('N/record/fieldState',['N/record/fieldStateEvent', 'N/eventEmitter'], function (fieldStateEvent, eventEmitter){
    /**
     * field state for record
     *
     * @param {Object} options
     * @param {RecordStateController} options.parentState parent state
     * @param {Object} options.fieldState field state object
     * @param {string} options.fieldState.name name
     * @param {string} options.fieldState.label label
     * @param {boolean} options.fieldState.isMandatory isMandatory
     * @param {boolean} options.fieldState.isDefaultMandatory isDefaultMandatory
     * @param {boolean} options.fieldState.isHidden isHidden
     * @param {boolean} options.fieldState.isDisabled isDisabled
     * @param {boolean} options.fieldState.isReadOnly isReadOnly
     * @param {boolean} options.fieldState.noSlaving noSlaving
     * @param {boolean} options.fieldState.isChanged isChanged
     * @param {boolean} options.fieldState.isVisible isVisible
     * @param {boolean} options.fieldState.isDisplay isDisplay
     * @param {boolean} options.fieldState.isParsed isParsed
     *
     * @return {FieldState}
     * @constructor
     * @private
     *
     */
    function FieldState(options)
    {
        var that = this;
        var parentState = options.parentState;
        var fs = options.fieldState;
        var id = fs.name || '';
        var label = fs.label || '';
        var shouldUseTextApi = false;
        var isParsed = fs && !!(fs.isParsed);

	    var isFieldMandatory = !!fs.isMandatory;               // is this field mandatory (required)
	    var defaultMandatory = !!fs.isDefaultMandatory;        // is this field mandatory by default (required)
	    var isFieldHidden = !!fs.isHidden;                     // is this field hidden (i.e. not visible or editable to user in the UI)
	    var isFieldDisabled = !!fs.isDisabled;                 // is this field disabled (i.e. uneditable by user in UI).
	    var isFieldReadOnly = !!fs.isReadOnly;                 // is a fundamentally read-only field
	    var ignoreSlaving = !!fs.noSlaving;                    // if true then slaving is disabled when during fieldChange execution
	    var isFieldChanged = !!fs.isChanged;                   // if true then this field was set/changed by the user
	    var isFieldVisible = !!fs.isVisible && !isFieldHidden; // if true then this field should be made visible in the user interface
	    var isFieldDisplay = !!fs.isDisplay && !isFieldHidden; // if false then this field should be removed from the user interface

        var emitter = eventEmitter.create();

        /**
         * parentState
         * @name FieldState#parentState
         * @type {SublistState|RecordStateController}
         */
        Object.defineProperty(this, 'parentState', {
            get: function ()
            {
                return parentState;
            },
            set: function (state)
            {
                if(parentState !== state)
                {
                    parentState = state;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.PARENT_STATE_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * useTextApi
         *
         * @name FieldState#useTextApi
         * @type boolean
         */
        Object.defineProperty(this, 'useTextApi', {
            get: function ()
            {
                return shouldUseTextApi;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (shouldUseTextApi !== val))
                {
                    var oldValue = shouldUseTextApi;
                    shouldUseTextApi = val;
                    var newValue = shouldUseTextApi;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.USE_TEXT_API_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isParsed
         *
         * @name FieldState#isParsed
         * @type boolean
         */
        Object.defineProperty(this, 'isParsed', {
            get: function ()
            {
                return isParsed;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isParsed !== val))
                {
                    var oldValue = isParsed;
                    isParsed = val;
                    var newValue = isParsed;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_PARSED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * isMandatory
         *
         * @name FieldState#isMandatory
         * @type boolean
         */
        Object.defineProperty(this, 'isMandatory', {
            get: function ()
            {
                return isFieldMandatory;
            },
            set: function (val) {
                if (util.isBoolean(val) && (isFieldMandatory !== val))
                {
                    var oldValue = isFieldMandatory;
                    isFieldMandatory = val;
                    var newValue = isFieldMandatory;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_MANDATORY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * isDefaultMandatory
         *
         * @name FieldState#isDefaultMandatory
         * @type boolean
         * @readonly
         */
        Object.defineProperty(this, 'isDefaultMandatory', {
            get: function ()
            {
                return defaultMandatory;
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isHidden
         *
         * @name FieldState#isHidden
         * @type boolean
         */
        Object.defineProperty(this, 'isHidden', {
            get: function ()
            {
                return isFieldHidden;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldHidden !== val))
                {
                    var oldValue = isFieldHidden;
                    isFieldHidden = val;
                    var newValue = isFieldHidden;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_HIDDEN_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isDisabled
         *
         * @name FieldState#isDisabled
         * @type boolean
         */
        Object.defineProperty(this, 'isDisabled', {
            get: function ()
            {
                return isFieldDisabled;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldDisabled !== val))
                {
                    var oldValue = isFieldDisabled;
                    isFieldDisabled = val;
                    var newValue = isFieldDisabled;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_DISABLED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isVisible
         *
         * @name FieldState#isVisible
         * @type boolean
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return isFieldVisible;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldVisible !== val))
                {
                    var oldValue = isFieldVisible;
                    isFieldVisible = val;
                    var newValue = isFieldVisible;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_VISIBLE_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isDisplay
         *
         * @name FieldState#isDisplay
         * @type boolean
         */
        Object.defineProperty(this, 'isDisplay', {
            get: function ()
            {
                return isFieldDisplay;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldDisplay !== val))
                {
                    var oldValue = isFieldDisplay;
                    isFieldDisplay = val;
                    var newValue = isFieldDisplay;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_DISPLAY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isReadOnly
         *
         * @name FieldState#isReadOnly
         * @type boolean
         */
        Object.defineProperty(this, 'isReadOnly', {
            get: function ()
            {
                return isFieldReadOnly;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldReadOnly !== val))
                {
                    var oldValue = isFieldReadOnly;
                    isFieldReadOnly = val;
                    var newValue = isFieldReadOnly;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_READ_ONLY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * ignoreSlaving
         *
         * @name FieldState#ignoreSlaving
         * @type boolean
         */
        Object.defineProperty(this, 'ignoreSlaving', {
            get: function ()
            {
                return ignoreSlaving;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (ignoreSlaving !== val))
                {
                    var oldValue = ignoreSlaving;
                    ignoreSlaving = val;
                    var newValue = ignoreSlaving;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IGNORE_SLAVING_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isChanged
         *
         * @name FieldState#isChanged
         * @type boolean
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                return isFieldChanged;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldChanged !== val))
                {
                    var oldValue = isFieldChanged;
                    isFieldChanged = val;
                    var newValue = isFieldChanged;
                    if(val === true && parentState)
                    {
                        parentState.isChanged = val;
                    }
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_CHANGED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * label
         *
         * @name FieldState#label
         * @type string
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return label;
            },
            set: function (val)
            {
                if(label !== val)
                {
                    var oldValue = label;
                    label = val;
                    var newValue = label;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.LABEL_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * name
         * @name FieldState#name
         * @type string
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                return id;
            },
            set: function (val)
            {
                // TODO: remove ???
                id = val;
            },
            enumerable: true,
            configurable: false
        });
        
        this.on = emitter.on;
        this.off = emitter.off;
        
        return this;
    }
    Object.freeze(FieldState);


    return Object.freeze({
                             /**
                              * create a new instance of fieldState
                              *
                              * @param {Object} options
                              * @param {RecordStateController} [options.parentState]
                              * @param {Object} options.fieldState
                              *
                              * @returns {FieldState}
                              */
                             create: function (options) {
                                 return new FieldState(options);
                             },
                             /**
                              * clone the fieldState object
                              *
                              * @param {FieldState} fieldState
                              * @returns {FieldState}
                              */
                             clone: function (fieldState)
                             {
                                 return new FieldState({
                                     parentState: fieldState.parentState,
                                     fieldState: {
                                             name: fieldState.id,
                                             label: fieldState.label,
                                             isMandatory: fieldState.isMandatory,
                                             isDefaultMandatory: fieldState.isDefaultMandatory,
                                             isHidden: fieldState.isHidden,
                                             isDisabled: fieldState.isDisabled,
                                             isReadOnly: fieldState.isReadOnly,
                                             noSlaving: fieldState.ignoreSlaving,
                                             isChanged: fieldState.isChanged,
                                             isVisible: fieldState.isVisible,
                                             isDisplay: fieldState.isDisplay,
                                             isParsed: fieldState.isParsed
                                         }
                                 });
                             },
                             /**
                              * create a new instance of fieldState
                              *
                              * @param {Object} options
                              * @param {RecordStateController} [options.parentState]
                              * @param {FieldLevelMetadata} options.metadata
                              *
                              * @returns {FieldState}
                              */
                             createBasedOnFieldLevelMetadata: function(options){
                                 var parentState = options.parentState;
                                 var metadata = options.metadata;
                                 return new FieldState({
                                     parentState: parentState,
                                     fieldState: metadata.defaultFieldState
                                 });
                             }
                         })
});

/**
 * SuiteScript sublist line state event module
 *
 * @private
 * @module N/record/sublistLineStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineStateEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			LINE_NUM_CHANGE: 'LINE_NUM_CHANGE',
			IS_INSERTED_CHANGE: 'IS_INSERTED_CHANGE',
			FIELD_STATE_ADDED: 'FIELD_STATE_ADDED',
			FIELD_STATE_REMOVED: 'FIELD_STATE_REMOVED'
		});

	function getEvent(sublistLineState, type)
	{
		return {
			type: type,
			sublistLineState: sublistLineState
		};
	}

	function emit(emitter, sublistLineState, type)
	{
		emitter.emit(getEvent(sublistLineState, type));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});

/**
 * SuiteScript recordstate module
 *
 * @private
 * @module N/record/sublistLineState
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineState',['N/utilityFunctions', 'N/record/fieldState', 'N/record/sublistLineStateEvent', 'N/eventEmitter'], function(utilityFunctions, fieldState, sublistLineStateEvent, eventEmitter)
{
    function addFieldId(obj, fieldId)
    {
        obj.fieldId = fieldId;
        return obj;
    }

    /**
     * line state for record sublist
     *
     * @param {Object} options
     * @param {Object} options.fieldStates field states for the line
     * @param {Number} [options.line=-1]
     *
     * @return {SublistLineState}
     * @constructor
     */
    function SublistLineState(options)
    {
        var that = this;
        var fieldStates = options.fieldStates;
        var originalLine = options.line || options.line === 0 ? options.line : -1;
        var isInsertedLine = false;
        var emitter = eventEmitter.create();

        /**
         * lineNum line number from db
         *
         * @name SublistLineState#lineNum
         * @type number
         */
        Object.defineProperty(this, 'lineNum', {
            get: function ()
            {
                return originalLine;
            },
            set: function (line)
            {
                if(originalLine !== line)
                {
                    originalLine = line;
                    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.LINE_NUM_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isInserted
         *
         * @name SublistLineState#isInserted
         * @type boolean
         */
        Object.defineProperty(this, 'isInserted', {
            get: function ()
            {
                return isInsertedLine;
            },
            set: function (val)
            {
                if(isInsertedLine !== val)
                {
                    isInsertedLine = val;
                    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.IS_INSERTED_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isChanged
         *
         * @name SublistLineState#isChanged
         * @type boolean
         * @readonly
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                for(var fieldId in fieldStates)
                {
                    if(fieldStates.hasOwnProperty(fieldId) && fieldStates[fieldId].isChanged)
                        return true;
                }
                return false;
            },
            enumerable: true,
            configurable: false
        });
        //
        ///**
        // * return all the field names based on field states
        // * @returns {Array}
        // */
        //this.getAllFields = getAllFields;
        //function getAllFields()
        //{
        //    var arr = [];
        //    for(var f in fieldStates)
        //        if(fieldStates.hasOwnProperty(f))
        //            arr.push(f);
        //    return arr;
        //}

        /**
         * has the fieldState for field
         *
         * @param {string} fieldId
         * @returns {boolean}
         */
        function hasFieldState(fieldId)
        {
            return fieldStates.hasOwnProperty(fieldId);
        }
        this.hasFieldState = hasFieldState;

        /**
         * remove field state
         * @param {string} fieldId
         */
        function removeFieldState(fieldId)
        {
            if(fieldStates.hasOwnProperty(fieldId))
            {
                delete fieldStates[fieldId];
                sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.FIELD_STATE_REMOVED);
            }
        }
        this.removeFieldState = removeFieldState;

        /**
         * return the fieldState object for fieldId in the current line
         *
         * @param {string} fieldId
         * @returns {FieldState}
         */
        function getFieldState(fieldId)
        {
            return fieldStates[fieldId];
        }
        this.getFieldState = getFieldState;

        /**
         * add new fieldState object for fieldId in the current line
         *
         * @param {string} fieldId
         * @param {FieldState} state
         * @returns {FieldState}
         */
        function addFieldState(fieldId, state)
        {
            fieldStates[fieldId] = state;
            sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.FIELD_STATE_ADDED);
        }
        this.addFieldState = addFieldState;

        /**
         * clone the fieldState object in the current line
         *
         * @returns {object} collection of cloned fieldState from current line
         */
        function getClonedFieldStates()
        {
            var returnFieldStates = {};
            for(var fieldId in fieldStates)
            {
                if(fieldStates.hasOwnProperty(fieldId))
	                returnFieldStates[fieldId] = fieldState.clone(fieldStates[fieldId]);
            }
            return returnFieldStates;
        }
        this.getClonedFieldStates = getClonedFieldStates;

        this.on = emitter.on;
        this.off = emitter.off;

        return this;
    }
    utilityFunctions.freezeObjectIfPossible(SublistLineState);

    return Object.freeze({
                             /**
                              * create a new instance of sublist line state
                              *
                              * @param {Object} options
                              * @param {Object} options.fieldStates
                              * @param {Number} options.line
                              *
                              * @return {SublistLineState}
                              */
                             create: function (options)
                             {
                                 return new SublistLineState(options);
                             }
                         });
});

/**
 * SuiteScript sublist state event module
 *
 * @private
 * @module N/record/sublistStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistStateEvent',['N/record/fieldStateEvent'], function(fieldStateEvent)
{
	var EVENT_TYPE = Object.freeze({
			IS_DISPLAY_CHANGE: 'IS_DISPLAY_CHANGE',
			IS_CHANGED_CHANGE: 'IS_CHANGED_CHANGE',
			IS_HIDDEN_CHANGE: 'IS_HIDDEN_CHANGE',
			FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
			FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
			FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
			FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
			FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
			FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
			FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE'
		});

	var translateFieldStateEventTypeToSublistStateEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldStateEvent.Type.IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[fieldStateEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldStateEventToSublistStateEvent(sublistState, fieldStateEvent)
	{
		return addFieldStateEventDetails(getEvent(sublistState, translateFieldStateEventTypeToSublistStateEventType(fieldStateEvent.type)), fieldStateEvent);
	}

	function addFieldStateEventDetails(event, fieldStateEvent)
	{
		var lineFieldStateLocation = event.sublistState.findLineForFieldState(fieldStateEvent.fieldState);
		event.fieldId = fieldStateEvent.fieldState.id;
		if(fieldStateEvent.oldValue !== undefined){ event.oldValue = fieldStateEvent.oldValue; }
		if(fieldStateEvent.newValue !== undefined){ event.newValue = fieldStateEvent.newValue; }
		event.line = lineFieldStateLocation.line;
		event.currentLine = lineFieldStateLocation.current;

		return event;
	}

	function getEvent(sublistState, type)
	{
		return {
			type: type,
			sublistState: sublistState
		};
	}

	function addValues(event, oldValue, newValue)
	{
		if(oldValue !== undefined){ event.oldValue = oldValue; }
		if(newValue !== undefined){ event.newValue = newValue; }

		return event;
	}

	function emit(emitter, sublistState, type, oldValue, newValue)
	{
		emitter.emit(addValues(getEvent(sublistState, type), oldValue, newValue));
	}

	function forwardFieldStateEvent(emitter, sublistState, fieldStateEvent)
	{
		emitter.emit(translateFieldStateEventToSublistStateEvent(sublistState, fieldStateEvent));
	}

	function forwardFieldStateEvents(emitter, sublistState, fieldState)
	{
		var forward = forwardFieldStateEvent.bind(null, emitter, sublistState);

		fieldState.on({
			types: [
				fieldStateEvent.Type.IS_MANDATORY_CHANGE,
				fieldStateEvent.Type.IS_HIDDEN_CHANGE,
				fieldStateEvent.Type.IS_DISABLED_CHANGE,
				fieldStateEvent.Type.IS_VISIBLE_CHANGE,
				fieldStateEvent.Type.IS_DISPLAY_CHANGE,
				fieldStateEvent.Type.IS_READ_ONLY_CHANGE,
				fieldStateEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldStateEvents: forwardFieldStateEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistState
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistState',['N/utilityFunctions', 'N/error', 'N/record/fieldState', 'N/record/sublistLineState', 'N/record/sublistStateEvent', 'N/eventEmitter'],
       function(utilityFunctions, error, fieldState, sublistLineState, sublistStateEvent, eventEmitter){

           function SublistController()
           {
               var that = this;
               var sublist = {};

               function lineInstanceIdExists(lineInstanceId)
               {
                   return sublist.hasOwnProperty(lineInstanceId);
               }

               function getLineInstanceIds()
               {
                   return Object.keys(sublist);
               }
               this.getLineInstanceIds = getLineInstanceIds;

               function has(lineInstanceId)
               {
                   var result = false;
                   var hasLineInstanceId = lineInstanceIdExists(lineInstanceId);

                   if(hasLineInstanceId)
                   {
                       result = !!sublist[lineInstanceId];
                   }

                   return result;
               }
               this.has = has;

               function get(lineInstanceId)
               {
                   var result = null;
                   var hasLineInstanceId = lineInstanceIdExists(lineInstanceId);

                   if(hasLineInstanceId)
                   {
                       result = sublist[lineInstanceId];
                   }

                   return result;
               }
               this.get = get;

               function put(lineInstanceId, value)
               {
                   var previousValue = get(lineInstanceId);
                   sublist[lineInstanceId] = value;
                   return previousValue;
               }
               this.put = put;

               function remove(lineInstanceId)
               {
                   var removedValue = get(lineInstanceId);
                   delete sublist[lineInstanceId];
                   return removedValue;
               }
               this.remove = remove;
           }

        /**
         * sublist state for record sublist
         *
         * @param {Object} options
         * @param {string} options.id sublist name
         * @param {RecordStateController} options.parentState
         * @param {Object} options.sublistStateObj
         * @param {boolean} options.sublistStateObj.allowAddlines
         * @param {boolean} options.sublistStateObj.isDisplay
         * @param {Object} options.fieldMetadata group of field metadata with field id as key
         *
         * @return {SublistState}
         * @constructor
         */
        function SublistState(options)
        {
            var that = this;
            var id = options.id;
            var parentState = options.parentState;
            var sublistStateObj = options.sublistStateObj;
            var fieldMetadata = options.fieldMetadata;
            var getModelController = options.getModelController;
            var lineStatePrototype = {};

            var lines = new SublistController();
            var lineBuffers = new SublistController();

            var allowsNewLine = sublistStateObj.allowAddlines || false;
            var isSublistChanged = false;
            var isSublistDisplay = sublistStateObj.isDisplay || true;
            var isSublistHidden = false;
            var isSublistMultilineEditable = options.isMultilineEditable || false;

            var emitter = eventEmitter.create();

            function checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId)
            {
            	var isCommitted = true;
            	return !allowsNewLine && !getModelController().isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted);
            }

            function getSublistlines(isCommitted)
            {
                return isCommitted ? lines : lineBuffers;
            }

            function findLineForFieldState(fieldstate)
            {
                var result = {
                        current: false,
                        line: null
                    };
                var fieldId = fieldstate.id;
                var modelController = getModelController();

                var lineInstanceId = null;
                var lineInstanceIds = null;
                var sublistLineState = null;
                var found = false;

                if(!found)
                {
                    lineInstanceIds = lineBuffers.getLineInstanceIds();
                    for (var i = 0; i < lineInstanceIds.length; i++)
                    {
                        lineInstanceId = lineInstanceIds[i];
                        sublistLineState = lineBuffers.get(lineInstanceId);
                        if (!!sublistLineState && sublistLineState.hasFieldState(fieldId) && sublistLineState.getFieldState(fieldId) === fieldstate)
                        {
                            found = true;
                            result.current = true;
                            result.line = modelController.getSublistLineValueForInstance(id, '_sequence', lineInstanceId, !result.current);
                            break;
                        }
                    }
                }

                if(!found)
                {
                    lineInstanceIds = lines.getLineInstanceIds();
                    for (var i = 0; i < lineInstanceIds.length; i++)
                    {
                        lineInstanceId = lineInstanceIds[i];
                        sublistLineState = lines.get(lineInstanceId);
                        if (sublistLineState.hasFieldState(fieldId) && sublistLineState.getFieldState(fieldId) === fieldstate)
                        {
                            found = true;
                            result.current = false;
                            result.line = modelController.getSublistLineValueForInstance(id, '_sequence', lineInstanceId, !result.current);
                            break;
                        }
                    }
                }

                return result;
            }
            this.findLineForFieldState = findLineForFieldState;

            (function constructor(fieldMetadata){
                lineStatePrototype = {};
                for(var fieldId in fieldMetadata)
                {
                    if(fieldMetadata.hasOwnProperty(fieldId))
                        lineStatePrototype[fieldId] = fieldMetadata[fieldId].defaultFieldState;
                }
            }(fieldMetadata));


            /**
             * name of sublist
             * @name SublistState#name
             * @type string
             */
            Object.defineProperty(this, 'id', {
                get: function ()
                {
                    return id;
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is allowed to add line
             * @name SublistState#allowsNewLine
             * @type boolean
             * @readonly
             */
            Object.defineProperty(this, 'allowsNewLine', {
                get: function ()
                {
                    return allowsNewLine;
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is on display
             * @name SublistState#isDisplay
             * @type boolean
             */
            Object.defineProperty(this, 'isDisplay', {
                get: function ()
                {
                    return isSublistDisplay;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistDisplay !== val))
                    {
                        var oldValue = isSublistDisplay;
                        isSublistDisplay = val;
                        var newValue = isSublistDisplay;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_DISPLAY_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is changed
             * @name SublistState#isChanged
             * @type boolean
             */
            Object.defineProperty(this, 'isChanged', {
                get: function ()
                {
                    return isSublistChanged;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistChanged !== val))
                    {
                        var oldValue = isSublistChanged;
                        isSublistChanged = val;
                        var newValue = isSublistChanged;
                        if(val === true && parentState)
                            parentState.isChanged = true;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_CHANGED_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is hidden
             * @name SublistState#isHidden
             * @type boolean
             */
            Object.defineProperty(this, 'isHidden', {
                get: function ()
                {
                    return isSublistHidden;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistHidden !== val))
                    {
                        var oldValue = isSublistHidden;
                        isSublistHidden = val;
                        var newValue = isSublistHidden;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_HIDDEN_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });

	        /**
	         * Return true if sublist has multi-line buffer feature enabled.
	         * @name SublistState#isMultilineEditable
	         * @type boolean
	         */
	        utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isMultilineEditable', function () { return isSublistMultilineEditable; });

            function getFieldLevelMetadata(fieldId)
            {
                return fieldMetadata.hasOwnProperty(fieldId) ? fieldMetadata[fieldId] : null;
            }

            function createNewFieldState(lineState, fieldId)
            {
                var fieldstate;
                var fieldLevelMetadata = getFieldLevelMetadata(fieldId);
                if(fieldLevelMetadata)
                {
                    fieldstate = fieldState.createBasedOnFieldLevelMetadata({metadata: fieldLevelMetadata});
                }
                else
                {
                    var fsObj = {name: fieldId, label: fieldId};
                    addField(fieldId, fsObj);
                    fieldstate = fieldState.create({fieldState: fsObj});
                }
                sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);

                return fieldstate;
            }


            /**
             * add field state for virtual field and apply to all rows
             * @param {String} fieldId
             * @param {Object} state
             */
            function addField(fieldId, state)
            {
                var fieldstate;

                lineBuffers.getLineInstanceIds().forEach(function(lineInstanceId){
                    var fieldstate = fieldState.create({fieldState: {name: fieldId, label: fieldId}});
                    sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);
                    var thisLine = lineBuffers.get(lineInstanceId);
                    if (thisLine != null)
                        thisLine.addFieldState[fieldId] = fieldstate;
                });

                lines.getLineInstanceIds().forEach(function(lineInstanceId){
                    var fieldstate = fieldState.create({fieldState: {name: fieldId, label: fieldId}});
                    sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);
                    lines.get(lineInstanceId).addFieldState[fieldId] = fieldstate;
                });

                lineStatePrototype[fieldId] = state;
            }


            /**
             * remove field state from sublist line state
             * @param fieldId
             *
             */
            function removeFieldState(fieldId, line_0)
            {
                var isCommitted = true;
                var lineInstanceId = getModelController().getSublistLineInstanceIdForLine(id, line_0, isCommitted);
                removeFieldStateForInstance(fieldId, lineInstanceId, isCommitted);
            }
            this.removeFieldState = removeFieldState;

            function removeFieldStateForInstance(fieldId, lineInstanceId, isCommitted)
            {
                var sublistlineState = getSublistlines(isCommitted).get(lineInstanceId);
                if(!!sublistlineState)
                {
                    sublistlineState.removeFieldState(fieldId);
                }
            }
            this.removeFieldStateForInstance = removeFieldStateForInstance;

            /**
             * return the field state in a line
             * @param {string} fieldId field of the return field state
             * @param {number} line_0 the line number of the field (0 index based)
             * @returns {FieldState}
             */
            function getFieldState(fieldId, line_0)
            {
                var modelController = getModelController();
                var isCommitted = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                if(lineInstanceId === null)
                {
	                isCommitted = true;
                    lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);
                }

                return getFieldStateForInstance(fieldId, lineInstanceId, isCommitted);
            }
            this.getFieldState = getFieldState;

            function getFieldStateForInstance(fieldId, lineInstanceId, isCommitted)
            {
                var fieldState = null;
                var modelController = getModelController();

	            var isLineInstanceValid = modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted);
	            if (!isLineInstanceValid && !isCommitted)
	            {
		            isCommitted = true;
		            isLineInstanceValid = modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted);
	            }

                if(isLineInstanceValid)
                {
                    var sublistLines = getSublistlines(isCommitted);
                    if(!sublistLines.has(lineInstanceId))
                    {
                        insertLineForInstance(lineInstanceId, isCommitted, true);
                    }

                    var sublistlineState = sublistLines.get(lineInstanceId);
                    if(!sublistlineState.hasFieldState(fieldId))
                    {
                        sublistlineState.addFieldState(fieldId, createNewFieldState(sublistlineState, fieldId));
                    }

                    fieldState = sublistlineState.getFieldState(fieldId);
                }
                else
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
                }

                return fieldState;
            }
            this.getFieldStateForInstance = getFieldStateForInstance;

            function getLineStatePropotype(overwrittenDefaults)
            {
                var prototype = {};
                for(var fieldId in lineStatePrototype)
                {
                    if(lineStatePrototype.hasOwnProperty(fieldId))
                        prototype[fieldId] = util.extend({}, lineStatePrototype[fieldId]);

                    if(overwrittenDefaults)
                    {
                        var fs = overwrittenDefaults[fieldId];
                        for (var key in fs)
                        {
                            if (fs.hasOwnProperty(key))
                                prototype[fieldId][key] = fs[key];
                        }
                    }
                }

                return prototype;
            }

            function createClonedLineState(line_0)
            {
                var modelController = getModelController();
                var isCommitted = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                return createClonedLineStateForInstance(lineInstanceId, isCommitted);
            }

            function createClonedLineStateForInstance(lineInstanceId, isCommitted)
            {
                var sublistlineStateClone = null;
                var modelController = getModelController();

                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted))
                {
                    var sublistlines = getSublistlines(isCommitted);

                    if(sublistlines.has(lineInstanceId))
                    {
                        var sublistlineState = getSublistlines(isCommitted).get(lineInstanceId);

                        sublistlineStateClone = sublistLineState.create({
                            fieldStates: forwardFieldStateEventsOnClonedFieldStates(sublistlineState.getClonedFieldStates()),
                            line: sublistlineState.lineNum
                        });

                        sublistlineStateClone.isInserted = sublistlineState.isInserted;
                        sublistlineStateClone.isChanged = sublistlineState.isChanged;
                    }
                    else
                    {
                    	var isCommitted = false;
                        sublistlineStateClone = sublistLineState.create({
                            fieldStates: transformFieldPrototypesToFieldStates(getLineStatePropotype()),
                            line: modelController.getSublistLineValueForInstance(id, '_sequence', lineInstanceId, isCommitted)
                        });
                    }
                }

                return sublistlineStateClone;
            }

            function doForwardFieldStateEvents(fieldStates, needToCreateFirst)
            {
	            return Object.keys(fieldStates).reduce(function(p, c){
		            var fieldstate = needToCreateFirst ? fieldState.create({fieldState: fieldStates[c]}) : fieldStates[c];
		            sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldstate);
		            p[c] = fieldstate;
		            return p;
	            }, {});
            }

            function forwardFieldStateEventsOnClonedFieldStates(fieldStates)
            {
	            return doForwardFieldStateEvents(fieldStates, false)
            }

            function transformFieldPrototypesToFieldStates(fieldPrototypes)
            {
	            return doForwardFieldStateEvents(fieldPrototypes, true)
            }

            /**
             * initiate the line states by record data
             */
            function init()
            {
                var modelController = getModelController();
                lines.getLineInstanceIds().forEach(function(lineInstanceId){
                    lines.remove(lineInstanceId);
                });
                lineBuffers.getLineInstanceIds().forEach(function(lineInstanceId){
                    lineBuffers.remove(lineInstanceId);
                });

                for(var i = 0; i < modelController.getSublistLineCount(id); i++)
                {
                    var sublistFieldStates = modelController.getSublistFieldStates(id, i);
                    var overwrittenDefaults = !!sublistFieldStates ? sublistFieldStates : {};
                    var fieldStates = transformFieldPrototypesToFieldStates(getLineStatePropotype(overwrittenDefaults));
                    var linestate = sublistLineState.create({fieldStates: fieldStates, line: i});

                    var isCommitted = true;
                    var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, i, isCommitted);
                    lines.put(lineInstanceId, linestate);
                }
            }
            this.init = init;

            /**
             * return all the field names
             * @returns {String[]} fieldnames
             */
            function getAllFields()
            {
                var fields = [];
                for(var fieldId in lineStatePrototype)
                    if(lineStatePrototype.hasOwnProperty(fieldId))
                        fields.push(fieldId);

                return fields;
            }
            this.getAllFields = getAllFields;
            /**
             * return all the field names
             * @param {number} line_0 the sublist line index
             * @returns {String[]} fieldnames
             */
            function getAllLineFields(line_0)
            {
                var modelController = getModelController();
                var isCommitted = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                return getAllLineFieldsForInstance(lineInstanceId, isCommitted);
            }
            this.getAllLineFields = getAllLineFields;

            function getAllLineFieldsForInstance(lineInstanceId, isCommitted)
            {
                var result = null,
                    sublistlineState = getSublistlines(isCommitted).get(lineInstanceId);

                if(!!sublistlineState && !!sublistlineState.getAllFields)
                {
                    result = sublistlineState.getAllFields();
                }

                return result;
            }
            this.getAllLineFieldsForInstance = getAllLineFieldsForInstance;

            /**
             * return the field state from the current line state
             * @param {string} fieldId
             * @returns {FieldState}
             */
            function getCurrentLineFieldState(fieldId)
            {
                var currentLineFieldState = null;
                var isCommitted = false;
                var modelController = getModelController();
                var lineInstanceId = modelController.getSublistSelectedLineInstanceId(id);

                if(lineInstanceId !== null)
                {
                    currentLineFieldState = getBufferLineFieldStateForInstance(fieldId, lineInstanceId, isCommitted);
                }
                return currentLineFieldState;
            }
            this.getCurrentLineFieldState = getCurrentLineFieldState;

            function getBufferLineFieldStateForInstance(fieldId, lineInstanceId, isCommitted)
            {
                var fieldState = null;
                var modelController = getModelController();
                var isLineInstanceSelected = modelController.isSublistLineInstanceIdSelected(id, lineInstanceId);
                var isLineInstanceValid = modelController.isSublistLineInstanceIdSelected(id, lineInstanceId, isCommitted);

                if(isLineInstanceSelected || isLineInstanceValid)
                {
                    var sublistLines = getSublistlines(isCommitted);
                    if(!sublistLines.has(lineInstanceId))
                    {
                        resetBufferLineStateForInstance(lineInstanceId, isCommitted);
                    }

                    var sublistlineState = sublistLines.get(lineInstanceId);
                    if(!sublistlineState.hasFieldState(fieldId))
                    {
                        sublistlineState.addFieldState(fieldId, createNewFieldState(sublistlineState, fieldId));
                    }

                    fieldState = sublistlineState.getFieldState(fieldId);
                }
                else
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
                }

                return fieldState;
            }
            this.getBufferLineFieldStateForInstance = getBufferLineFieldStateForInstance;

            /**
             * remove the current line buffer
             */
            function removeCurrentLineState()
            {
                var modelController = getModelController();
                var isCommitted = false;
                var lineInstanceId = modelController.getSublistSelectedLineInstanceId(id);

                removeSublistLineState(lineInstanceId, isCommitted);
            }
            this.removeCurrentLineState = removeCurrentLineState;

            function removeSublistLineState(lineInstanceId, isCommitted)
            {
                getSublistlines(isCommitted).remove(lineInstanceId);
            }
            this.removeSublistLineState = removeSublistLineState;

            /**
             * reload the current line state buffer by current line index
             * @param {number} currentLineIndex
             */
            function resetCurrentLineState(currentLineIndex)
            {
                var modelController = getModelController();
                var isCommitted = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, currentLineIndex, isCommitted);

                resetBufferLineStateForInstance(lineInstanceId, isCommitted)
            }
            this.resetCurrentLineState = resetCurrentLineState;

            function resetBufferLineStateForInstance(lineInstanceId, isCommitted)
            {
                var sublistlineState = null;

                removeBufferLineForInstance(lineInstanceId);
                if(!isCommitted)
                {
                    sublistlineState = createClonedLineStateForInstance(lineInstanceId, true);
                }
                if(!sublistlineState)
                {
                    sublistlineState = createClonedLineStateForInstance(lineInstanceId, isCommitted);
                }

                getSublistlines(isCommitted).put(lineInstanceId, sublistlineState);
            }
            this.resetBufferLineStateForInstance = resetBufferLineStateForInstance;

            function cloneLineStateToLineCopy(sourceLineInstanceId, isSourceCommitted, targetLineInstanceId)
            {
	            var line = getModelController().getSublistLineValueForInstance(id, '_sequence', targetLineInstanceId, false);
	            var sublistlineState = createClonedLineStateForInstance(sourceLineInstanceId, isSourceCommitted);
	            sublistlineState.lineNum = line;

	            getSublistlines(false).put(targetLineInstanceId, sublistlineState);
            }
            this.cloneLineStateToLineCopy = cloneLineStateToLineCopy;

            /**
             * commit the current line state buffer to actual line state
             * @param {number} currentLineIndex
             */
            function commitCurrentLine(currentLineIndex)
            {
                var modelController = getModelController();
                var isCommitted = false;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, currentLineIndex, isCommitted);

                commitLineForInstance(lineInstanceId);
            }
            this.commitCurrentLine = commitCurrentLine;

            function commitLineForInstance(lineInstanceId)
            {
                if(lineBuffers.has(lineInstanceId))
                {
                    var sublistlineState = lineBuffers.remove(lineInstanceId);
                    sublistlineState.isInserted = false;
                    lines.put(lineInstanceId, sublistlineState);
                    that.isChanged = true;
                }
            }
            this.commitLineForInstance = commitLineForInstance;

            /**
             * insert a new LineState
             * @param {number} line_0 line number of inserted line
             * @param {boolean} isInsert if the line is inserted
             */
            function insertLine(line_0, isInsert)
            {
                var modelController = getModelController();
                var isCommitted = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                insertLineForInstance(lineInstanceId, isCommitted, isInsert);
            }
            this.insertLine = insertLine;

            function insertLineForInstance(lineInstanceId, isCommitted, isInsert)
            {
                if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

                var modelController = getModelController();
                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted))
                {
                    var sublistlineState = sublistLineState.create({fieldStates: transformFieldPrototypesToFieldStates(getLineStatePropotype())});
                    sublistlineState.isInserted = !!isInsert;
                    getSublistlines(isCommitted).put(lineInstanceId, sublistlineState);
                }
            }
            this.insertLineForInstance = insertLineForInstance;


            /**
             * return true if line is inserted
             * @param line_0
             * @returns {boolean}
             */
            function isLineInserted(line_0)
            {
                var modelController = getModelController();
                var isCommitted = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                return isLineInsertedForInstance(lineInstanceId, isCommitted);
            }
            this.isLineInserted = isLineInserted;

            function isLineInsertedForInstance(lineInstanceId, isCommitted)
            {
                var result = false;
                var sublistlines = getSublistlines(isCommitted);

                if(sublistlines.has(lineInstanceId))
                {
                    var sublistlineState = sublistlines.get(lineInstanceId);
                    result = sublistlineState.isInserted;
                }

                return result;
            }
            this.isLineInsertedForInstance = isLineInsertedForInstance;

            /**
             * remove line state
             * @param {number} line_0
             */
            function removeLine(line_0)
            {
                var modelController = getModelController();
                var isCommitted = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                removeLineForInstance(lineInstanceId);
            }
            this.removeLine = removeLine;

	        function removeBufferLineForInstance(lineInstanceId)
	        {
	        	var isCommitted = false;
		        if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
			        utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

		        getSublistlines(isCommitted).remove(lineInstanceId);
	        }

            function removeLineForInstance(lineInstanceId)
            {
	            var isCommitted = false;
                if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

                getSublistlines(isCommitted).remove(lineInstanceId);
	            getSublistlines(!isCommitted).remove(lineInstanceId);
            }
            this.removeLineForInstance = removeLineForInstance;

            /**
             * return true if line is removed
             * @param line_0
             * @returns {boolean}
             */
            function isLineRemoved(line_0)
            {
                var isNotRemoved = false;
                var lineInstanceIds = lines.getLineInstanceIds();
                var lineNum = parseInt(line_0, 10);

                if(!isNaN(lineNum))
                {
                    var index = 0;
                    while(!isNotRemoved && index < lineInstanceIds.length)
                    {
                        var lineInstanceId = lineInstanceIds[index];
                        isNotRemoved = lines.get(lineInstanceId).lineNum === lineNum;
                        index += 1;
                    }
                }

                return !isNotRemoved;
            }
            this.isLineRemoved = isLineRemoved;

            /**
             * return true if line is changed
             * @param {number} line_0
             * @return {boolean}
             */
            function isLineChanged(line_0)
            {
                var modelController = getModelController();
                var isCommitted = true;
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(id, line_0, isCommitted);

                return isLineChangedForInstance(lineInstanceId, isCommitted);
            }
            this.isLineChanged = isLineChanged;

            function isLineChangedForInstance(lineInstanceId, isCommitted)
            {
                var result = false;
                var sublistlines = getSublistlines(isCommitted);

                if(sublistlines.has(lineInstanceId))
                {
                    var sublistlineState = sublistlines.get(lineInstanceId);
                    result = sublistlineState.isChanged;
                }

                return result;
            }
            this.isLineChangedForInstance = isLineChangedForInstance;

            /**
             * return the number of lines
             * @return {number}
             */
            function getLineCount()
            {
                return lines.getLineInstanceIds().length;
            }
            this.getLineCount = getLineCount;

            this.on = emitter.on;
            this.off = emitter.off;

            return this;
        }
        Object.freeze(SublistState);

        return Object.freeze({
                                /**
                                 * create a new instance of sublist state
                                 *
                                 * @param {Object} options
                                 * @param {String} options.id
                                 * @param {Object} options.sublistStateObj
                                 * @param {RecordStateController} options.parentState
                                 * @param {Object} options.fieldMetadata
                                 *
                                 * @return {SublistState}
                                 */
                                create: function (options) { return new SublistState(options); }
                            });
});

/**
 * SuiteScript record state controller event module
 *
 * @private
 * @module N/record/recordStateControllerEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordStateControllerEvent',['N/record/fieldStateEvent', 'N/record/sublistStateEvent'], function(fieldStateEvent, sublistStateEvent) {
	var EVENT_TYPE = Object.freeze({
			FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
			FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
			FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
			FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
			FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
			FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
			FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',
			SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
			SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE'
		});

	function getEvent(type)
	{
		return {
			type: type
		}
	}

	var translateFieldStateEventTypeToRecordControllerEventType = (function () {
		var eventTranslations = {};

		eventTranslations[fieldStateEvent.Type.IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[fieldStateEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addFieldStateEventDetails(event, fieldStateEvent)
	{
		event.fieldId = fieldStateEvent.fieldState.id;
		if(fieldStateEvent.oldValue !== undefined){ event.oldValue = fieldStateEvent.oldValue; }
		if(fieldStateEvent.newValue !== undefined){ event.newValue = fieldStateEvent.newValue; }
		return event;
	}

	function translateFieldStateEventToRecordControllerStateEvent(fieldStateEvent)
	{
		return addFieldStateEventDetails(getEvent(translateFieldStateEventTypeToRecordControllerEventType(fieldStateEvent.type)), fieldStateEvent);
	}

	function forwardFieldStateEvent(emitter, fieldStateEvent)
	{
		emitter.emit(translateFieldStateEventToRecordControllerStateEvent(fieldStateEvent));
	}

	function forwardFieldStateEvents(emitter, fieldState)
	{
		var forward = forwardFieldStateEvent.bind(null, emitter);

		fieldState.on({
			types: [
				fieldStateEvent.Type.IS_MANDATORY_CHANGE,
				fieldStateEvent.Type.IS_HIDDEN_CHANGE,
				fieldStateEvent.Type.IS_DISABLED_CHANGE,
				fieldStateEvent.Type.IS_VISIBLE_CHANGE,
				fieldStateEvent.Type.IS_DISPLAY_CHANGE,
				fieldStateEvent.Type.IS_READ_ONLY_CHANGE,
				fieldStateEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateSublistStateEventTypeToRecordControllerEventType = (function () {
		var eventTranslations = {};

		eventTranslations[sublistStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.SUBLIST_IS_HIDDEN_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function (sublistStateEventType) {
			return eventTranslations[sublistStateEventType];
		}
	}());

	function addSublistStateEventDetails(event, sublistStateEvent)
	{
		event.sublistId = sublistStateEvent.sublistState.id;
		if(sublistStateEvent.hasOwnProperty('fieldId'))
		{
			event.line = sublistStateEvent.line;
			event.currentLine = sublistStateEvent.currentLine;
			event.fieldId = sublistStateEvent.fieldId;
		}
		if(sublistStateEvent.oldValue !== undefined){ event.oldValue = sublistStateEvent.oldValue; }
		if(sublistStateEvent.newValue !== undefined){ event.newValue = sublistStateEvent.newValue; }

		return event;
	}

	function translateSublistStateEventToRecordControllerStateEvent(sublistStateEvent)
	{
		return addSublistStateEventDetails(getEvent(translateSublistStateEventTypeToRecordControllerEventType(sublistStateEvent.type)), sublistStateEvent);
	}

	function forwardSublistStateEvent(emitter, sublistStateEvent)
	{
		emitter.emit(translateSublistStateEventToRecordControllerStateEvent(sublistStateEvent));
	}

	function forwardSublistStateEvents(emitter, sublistState)
	{
		var forward = forwardSublistStateEvent.bind(null, emitter);

		sublistState.on({
			types: [
				sublistStateEvent.Type.IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				sublistStateEvent.Type.FIELD_LABEL_CHANGE
			],
			listener: forward
		});
	}

	function unforwardSublistStateEvents(sublistState)
	{
		sublistState.off({
			types: [
				sublistStateEvent.Type.IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				sublistStateEvent.Type.FIELD_LABEL_CHANGE
			]
		})
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		forwardFieldStateEvents: forwardFieldStateEvents,
		forwardSublistStateEvents: forwardSublistStateEvents,
		unforwardSublistStateEvents: unforwardSublistStateEvents
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordStateController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordStateController',['N/record/fieldState', 'N/record/sublistState', 'N/record/recordStateControllerEvent', 'N/eventEmitter'], function(fieldState, sublistState, recordStateControllerEvent, eventEmitter){

   function createSublistState(sublistId, parentState, sublistMetadata, getModelController)
   {
      var state = sublistState.create({
            id: sublistId,
            parentState: parentState,
            sublistStateObj: sublistMetadata.defaultState,
            fieldMetadata: sublistMetadata.fieldMetadata,
            getModelController: getModelController,
	        isMultilineEditable: sublistMetadata.isMultilineEditable
         });
      state.init();

      return state;
   }

    /**
     * record state controller
     * @param {Object} options
     * @param {Metadata} options.metadata
     * @param {ModelController} options.data
     * @constructor
     */
    function RecordStateController(options)
    {
        var that = this;
        var metadata = options.metadata;
        var modelController = options.data;
      var getModelController = options.getModelController;
        var isChanged = false;
       var emitter = eventEmitter.create();

        var fieldStates = {};
        var sublistStates = {};

        (function constructor(metadata, getModelController){
            var sublists = metadata.sublistIds;
            sublists.forEach(function(sublistId){
                var sublistMetadata = metadata.getSublistMetadata(sublistId);
                if(sublistMetadata)
                {
                   var sublist = createSublistState(sublistId, that, sublistMetadata, getModelController);
                   recordStateControllerEvent.forwardSublistStateEvents(emitter, sublist);
                    sublistStates[sublistId] = sublist;
                }
            });
        })(metadata, getModelController);


        /**
         * is record changed by any operations
         * @name RecordStateController#isChanged
         * @type {boolean}
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                return isChanged;
            },
            set: function (val)
            {
                if(util.isBoolean(val))
                    isChanged = val;
            },
            enumerable: true,
            configurable: false
        });

        function createNewFieldState(fieldId)
        {
            var state;
            var fieldLevelMetadata = metadata.getFieldMetadata(undefined, fieldId);
            if(fieldLevelMetadata)
            {
                state = fieldState.createBasedOnFieldLevelMetadata({metadata: fieldLevelMetadata, parentState: that});
            }
            else
            {
               state = fieldState.create({parentState: that, fieldState: {name: fieldId, label: fieldId}});
            }
           recordStateControllerEvent.forwardFieldStateEvents(emitter, state);

            return state;
        }

        /**
         * remove field state
         * @param {string} fieldId
         */
        function removeFieldState(fieldId)
        {
            if(fieldStates.hasOwnProperty(fieldId))
                delete fieldStates[fieldId];
        }
        this.removeFieldState = removeFieldState;

        /**
         * return field state for record field
         * @param {string} fieldId
         * @return {FieldState}
         */
        function getFieldState(fieldId)
        {
            var state;
            if(fieldStates.hasOwnProperty(fieldId))
                state = fieldStates[fieldId];
            else
            {
                state = createNewFieldState(fieldId);
                fieldStates[fieldId] = state;
            }

            return state;
        }
        this.getFieldState = getFieldState;

        /**
         * return the sublist state of record sublist
         * @param {string} sublistId
         * @returns {SublistState}
         */
        function getSublistState(sublistId)
        {
            var state = null;
            if(sublistStates.hasOwnProperty(sublistId))
                state = sublistStates[sublistId];

            return state;
        }
        this.getSublistState = getSublistState;

        function addSublist(sublistId, getModelController)
        {
            removeSublist(sublistId);
            var sublistMetadata = metadata.getSublistMetadata(sublistId);
           var sublist = createSublistState(sublistId, that, sublistMetadata, getModelController);
           recordStateControllerEvent.forwardSublistStateEvents(emitter, sublist);
            sublistStates[sublistId] = sublist;
        }
        this.addSublist = addSublist;

        function removeSublist(sublistId)
        {
            var sublist = sublistStates[sublistId];
            if(!!sublist)
            {
                delete sublistStates[sublistId];
                recordStateControllerEvent.unforwardSublistStateEvents(emitter, sublist);
            }
        }

        function removeSublistFieldState(sublistId, fieldId, line)
        {
            getSublistState(sublistId).removeFieldState(fieldId, line);
            getSublistState(sublistId).isChanged = true;
        }
        this.removeSublistFieldState = removeSublistFieldState;


        function getAllFields()
        {
            var arr = [];
            for(var f in fieldStates)
                if(fieldStates.hasOwnProperty(f))
                    arr.push(f);
            return arr;
        }
        this.getAllFields = getAllFields;
        function getAllSublists()
        {
            var arr = [];
            for(var sublistId in sublistStates)
                if(sublistStates.hasOwnProperty(sublistId))
                    arr.push(sublistId);
            return arr;
        }
        this.getAllSublists = getAllSublists;

      this.on = emitter.on;
      this.off = emitter.off;
    }

    return {
        /**
         * return a new instance of RecordStateController
         * @param {Object} options
         * @returns {RecordStateController}
         */
        create: function(options) { return new RecordStateController(options); },
        /**
         * return true if object is an instance of FieldStates
         * @param {Object} obj
         * @returns {boolean}
         */
        isInstance: function(obj) { return obj instanceof RecordStateController; }
    };
});

/**
 * @private
 */
define('N/restricted/fieldClientScriptHandler',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/validator
 * @suiteScriptVersion 2.x
 */
define(
	'N/util/validator',['N/util/date','N/error','N/format','N/fieldTypeConstants','N/utilityFunctions'],
	function (DateUtil, error, format, fieldTypeConstants, utilityFunctions){

		// For Email Validation  
		var TLD_PATTERN = "zw|zuerich|zone|zm|zippo|zip|zero|zara|zappos|za|yun|yt|youtube|you|yokohama|yoga|yodobashi|ye|yandex|yamaxun|yahoo|yachts|xyz|xxx|xperia|xn--zfr164b|xn--ygbi2ammx|xn--yfro4i67o|xn--y9a3aq|xn--xkc2dl3a5ee0h|xn--xkc2al3hye2a|xn--xhq521b|xn--wgbl6a|xn--wgbh1c|xn--w4rs40l|xn--w4r85el8fhu5dnra|xn--vuq861b|xn--vhquv|xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--unup4y|xn--tiq49xqyj|xn--tckwe|xn--t60b56a|xn--ses554g|xn--s9brj9c|xn--rovu88b|xn--rhqv96g|xn--qxam|xn--qcka1pmc|xn--q9jyb4c|xn--pssy2u|xn--pgbs0dh|xn--pbt977c|xn--p1ai|xn--p1acf|xn--ogbpf8fl|xn--o3cw4h|xn--nyqy26a|xn--nqv7fs00ema|xn--nqv7f|xn--node|xn--ngbe9e0a|xn--ngbc5azd|xn--mxtq1m|xn--mk1bu44c|xn--mix891f|xn--mgbx4cd0ab|xn--mgbtx2b|xn--mgbt3dhd|xn--mgbpl2fh|xn--mgbi4ecexp|xn--mgberp4a5d4ar|xn--mgbca7dzdo|xn--mgbc0a9azcg|xn--mgbbh1a71e|xn--mgbb9fbpob|xn--mgbayh7gpa|xn--mgbab2bd|xn--mgbaam7a8h|xn--mgba7c0bbn0a|xn--mgba3a4f16a|xn--mgba3a3ejt|xn--mgb9awbf|xn--lgbbat1ad8j|xn--l1acc|xn--kput3i|xn--kpu716f|xn--kpry57d|xn--kprw13d|xn--kcrx77d1x4a|xn--jvr189m|xn--jlq61u9w7b|xn--j6w193g|xn--j1amh|xn--j1aef|xn--io0a7i|xn--imr513n|xn--i1b6b1a6a2e|xn--hxt814e|xn--h2brj9c|xn--gk3at1e|xn--gecrj9c|xn--gckr3f0f|xn--g2xx48c|xn--fzys8d69uvgm|xn--fzc2c9e2c|xn--fpcrj9c3d|xn--flw351e|xn--fjq720a|xn--fiqz9s|xn--fiqs8s|xn--fiq64b|xn--fiq228c5hs|xn--fhbei|xn--fct429k|xn--estv75g|xn--efvy88h|xn--eckvdtc9d|xn--e1a4c|xn--d1alf|xn--d1acj3b|xn--czru2d|xn--czrs0t|xn--czr694b|xn--co-pka|xn--clchc0ea0b2g2a9gcd|xn--cg4bki|xn--cck2b3b|xn--c2br7g|xn--c1avg|xn--bck1b9a5dre4c|xn--b4w605ferd|xn--9krt00a|xn--9et52u|xn--9dbq2a|xn--90ais|xn--90ae|xn--90a3ac|xn--8y0a063a|xn--80aswg|xn--80asehdb|xn--80aqecdr1a|xn--80ao21a|xn--80adxhks|xn--6qq986b3xl|xn--6frz82g|xn--5tzm5g|xn--5su34j936bgsg|xn--55qx5d|xn--55qw42g|xn--54b7fta0cc|xn--4gbrim|xn--45q11c|xn--45brj9c|xn--42c2d9a|xn--3pxu8k|xn--3oq18vl8pn36a|xn--3e0b707e|xn--3ds443g|xn--3bst00m|xn--30rr7y|xn--1qqw23a|xn--1ck2e1b|xn--11b4c3d|xin|xihuan|xfinity|xerox|xbox|wtf|wtc|ws|wow|world|works|work|woodside|wolterskluwer|wme|winners|wine|windows|win|williamhill|wiki|wien|whoswho|wf|weir|weibo|wedding|wed|website|weber|webcam|weatherchannel|weather|watches|watch|warman|wanggou|wang|walter|walmart|wales|vuelos|vu|voyage|voto|voting|vote|volvo|volkswagen|vodka|vn|vlaanderen|vivo|viva|vistaprint|vista|vision|visa|virgin|vip|vin|villas|viking|vig|video|viajes|vi|vg|vet|versicherung|verisign|ventures|vegas|ve|vc|vanguard|vana|vacations|va|uz|uy|us|ups|uol|uno|university|unicom|uk|ug|uconnect|ubs|ubank|ua|tz|tw|tvs|tv|tushu|tunes|tui|tube|tt|trv|trust|travelersinsurance|travelers|travelchannel|travel|training|trading|trade|tr|toys|toyota|town|tours|total|toshiba|toray|top|tools|tokyo|today|to|tn|tmall|tm|tl|tkmaxx|tk|tjx|tjmaxx|tj|tirol|tires|tips|tiffany|tienda|tickets|tiaa|theatre|theater|thd|th|tg|tf|teva|tennis|temasek|telefonica|telecity|tel|technology|tech|team|tdk|td|tci|tc|taxi|tax|tattoo|tatar|tatamotors|target|taobao|talk|taipei|tab|sz|systems|symantec|sydney|sy|sx|swiss|swiftcover|swatch|sv|suzuki|surgery|surf|support|supply|supplies|sucks|su|style|study|studio|stream|store|storage|stockholm|stcgroup|stc|statoil|statefarm|statebank|starhub|star|staples|stada|st|srt|srl|sr|spreadbetting|spot|spiegel|space|soy|sony|song|solutions|solar|sohu|software|softbank|social|soccer|so|sncf|sn|smile|smart|sm|sling|sl|skype|sky|skin|ski|sk|sj|site|singles|sina|silk|si|shriram|showtime|show|shouji|shopping|shop|shoes|shiksha|shia|shell|shaw|sharp|shangrila|sh|sg|sfr|sexy|sex|sew|seven|ses|services|sener|select|seek|security|secure|seat|se|sd|scot|scor|scjohnson|science|schwarz|schule|school|scholarships|schmidt|schaeffler|scb|sca|sc|sbs|sbi|sb|saxo|save|sas|sarl|sapo|sap|sanofi|sandvikcoromant|sandvik|samsung|samsclub|salon|sale|sakura|safety|safe|saarland|sa|ryukyu|rwe|rw|run|ruhr|ru|rsvp|rs|room|rogers|rodeo|rocks|rocher|ro|rmit|rip|rio|ril|rightathome|ricoh|richardli|rich|rexroth|reviews|review|restaurant|rest|republican|report|repair|rentals|rent|ren|reliance|reit|reisen|reise|rehab|redumbrella|redstone|red|recipes|realty|realtor|realestate|read|re|raid|radio|racing|qvc|quest|quebec|qpon|qa|py|pwc|pw|pub|pt|ps|prudential|pru|protection|property|properties|promo|progressive|prof|productions|prod|pro|prime|press|praxi|pramerica|pr|post|porn|politie|poker|pohl|pnc|pn|pm|plus|plumbing|playstation|play|place|pl|pk|pizza|pioneer|pink|ping|pin|pid|pictures|pictet|pics|piaget|physio|photos|photography|photo|philips|pharmacy|ph|pg|pfizer|pf|pet|pe|pccw|pay|passagens|party|parts|partners|pars|paris|panerai|panasonic|pamperedchef|page|pa|ovh|ott|otsuka|osaka|origins|orientexpress|organic|org|orange|oracle|open|ooo|onyourside|online|onl|ong|one|omega|om|ollo|oldnavy|olayangroup|olayan|okinawa|office|off|observer|obi|nz|nyc|nu|ntt|nrw|nra|nr|np|nowtv|nowruz|now|norton|northwesternmutual|nokia|no|nl|nissay|nissan|ninja|nikon|nike|nico|ni|nhk|ngo|ng|nfl|nf|nexus|nextdirect|next|news|newholland|new|neustar|network|netflix|netbank|net|nec|ne|nc|nba|navy|natura|nationwide|name|nagoya|nadex|nab|na|mz|my|mx|mw|mv|mutuelle|mutual|museum|mu|mtr|mtpc|mtn|mt|msd|ms|mr|mq|mp|movistar|movie|mov|motorcycles|moto|moscow|mortgage|mormon|mopar|montblanc|monster|money|monash|mom|moi|moe|moda|mobily|mobi|mo|mn|mma|mm|mls|mlb|ml|mk|mitsubishi|mit|mint|mini|mil|microsoft|miami|mh|mg|metlife|meo|menu|men|memorial|meme|melbourne|meet|media|med|me|md|mckinsey|mcdonalds|mcd|mc|mba|mattel|maserati|marshalls|marriott|markets|marketing|market|mango|management|man|makeup|maison|maif|madrid|macys|ma|ly|lv|luxury|luxe|lupin|lundbeck|lu|ltda|ltd|lt|ls|lr|lplfinancial|lpl|love|lotto|lotte|london|lol|loft|locus|locker|loans|loan|lk|lixil|living|live|lipsy|link|linde|lincoln|limo|limited|lilly|like|lighting|lifestyle|lifeinsurance|life|lidl|liaison|li|lgbt|lexus|lego|legal|lefrak|leclerc|lease|lds|lc|lb|lawyer|law|latrobe|latino|lat|lasalle|lanxess|landrover|land|lancome|lancia|lancaster|lamer|lamborghini|ladbrokes|lacaixa|la|kz|kyoto|ky|kw|kuokgroup|kred|krd|kr|kpn|kpmg|kp|kosher|komatsu|koeln|kn|km|kiwi|kitchen|kindle|kinder|kim|kia|ki|kh|kg|kfh|kerryproperties|kerrylogistics|kerryhotels|ke|kddi|kaufen|juniper|juegos|jprs|jpmorgan|jp|joy|jot|joburg|jobs|jo|jnj|jmp|jm|jll|jlc|jio|jewelry|jetzt|jeep|je|jcp|jcb|java|jaguar|iwc|iveco|itv|itau|it|istanbul|ist|ismaili|iselect|is|irish|ir|iq|ipiranga|io|investments|intuit|international|intel|int|insure|insurance|institute|ink|ing|info|infiniti|industries|in|immobilien|immo|imdb|imamat|im|il|ikano|iinet|ifm|ieee|ie|id|icu|ice|icbc|ibm|hyundai|hyatt|hughes|hu|htc|ht|hsbc|hr|how|house|hotmail|hoteles|hot|hosting|host|hospital|horse|honeywell|honda|homesense|homes|homegoods|homedepot|holiday|holdings|hockey|hn|hm|hkt|hk|hiv|hitachi|hisamitsu|hiphop|hgtv|hermes|here|helsinki|help|healthcare|health|hdfcbank|hdfc|hbo|haus|hangout|hamburg|hair|gy|gw|guru|guitars|guide|guge|gucci|guardian|gu|gt|gs|group|gripe|green|gratis|graphics|grainger|gr|gq|gp|gov|got|gop|google|goog|goodyear|goodhands|goo|golf|goldpoint|gold|godaddy|gn|gmx|gmo|gmbh|gmail|gm|globo|global|gle|glass|glade|gl|giving|gives|gifts|gift|gi|gh|ggee|gg|gf|george|genting|gent|gea|ge|gdn|gd|gbiz|gb|garden|gap|games|game|gallup|gallo|gallery|gal|ga|fyi|futbol|furniture|fund|fujixerox|fujitsu|ftr|frontier|frontdoor|frogans|frl|fresenius|free|fr|fox|foundation|forum|forsale|forex|ford|football|foodnetwork|food|foo|fo|fm|fly|flowers|florist|flir|flights|flickr|fk|fj|fitness|fit|fishing|fish|firmdale|firestone|fire|financial|finance|final|film|fido|fidelity|fiat|fi|ferrero|ferrari|feedback|fedex|fast|fashion|farmers|farm|fans|fan|family|faith|fairwinds|fail|fage|extraspace|express|exposed|expert|exchange|everbank|events|eus|eurovision|eu|et|esurance|estate|esq|es|erni|ericsson|er|equipment|epson|epost|enterprises|engineering|engineer|energy|emerck|email|eg|ee|education|edu|edeka|eco|ec|eat|earth|dz|dvr|dvag|durban|dupont|duns|dunlop|duck|dubai|dtv|drive|download|dot|domains|doha|dog|dodge|doctor|docs|do|dnp|dm|dk|dj|diy|dish|discover|discount|directory|direct|digital|diet|diamonds|dhl|dev|design|desi|dentist|dental|democrat|delta|deloitte|dell|delivery|degree|deals|dealer|deal|de|dds|dclk|day|datsun|dating|date|dance|dad|dabur|cz|cyou|cymru|cy|cx|cw|cv|cuisinella|cu|csc|cruises|cruise|crs|crown|cricket|creditunion|creditcard|credit|cr|courses|coupons|coupon|country|corsica|corp|coop|cool|cookingchannel|cooking|contractors|contact|consulting|construction|condos|comsec|computer|compare|company|community|commbank|comcast|com|cologne|college|coffee|codes|coach|co|cn|cm|clubmed|club|cloud|clothing|clinique|clinic|click|cleaning|claims|cl|ck|cityeats|city|citic|citi|citadel|cisco|circle|cipriani|ci|church|chrysler|chrome|christmas|chloe|chintai|cheap|chat|chase|channel|chanel|ch|cg|cfd|cfa|cf|cern|ceo|center|ceb|cd|cc|cbs|cbre|cbn|cba|catholic|catering|cat|casino|cash|caseih|case|casa|cartier|cars|careers|career|care|cards|caravan|car|capitalone|capital|capetown|canon|cancerresearch|camp|camera|cam|calvinklein|call|cal|cafe|cab|ca|bzh|bz|by|bw|bv|buzz|buy|business|builders|build|bugatti|budapest|bt|bs|brussels|brother|broker|broadway|bridgestone|bradesco|br|box|boutique|bot|boston|bostik|bosch|boots|booking|book|boo|bond|bom|bofa|boehringer|boats|bo|bnpparibas|bnl|bn|bmw|bms|bm|blue|bloomberg|blog|blockbuster|blanco|blackfriday|black|bj|biz|bio|bingo|bing|bike|bid|bible|bi|bharti|bh|bg|bf|bet|bestbuy|best|berlin|bentley|beer|beauty|beats|be|bd|bcn|bcg|bbva|bbt|bbc|bb|bayern|bauhaus|basketball|baseball|bargains|barefoot|barclays|barclaycard|barcelona|bar|bank|band|bananarepublic|banamex|baidu|baby|ba|azure|az|axa|ax|aws|aw|avianca|autos|auto|author|auspost|audio|audible|audi|au|attorney|athleta|at|associates|asia|asda|as|arte|art|arpa|army|archi|aramco|ar|aquarelle|aq|apple|app|apartments|aol|ao|anz|anquan|android|analytics|amsterdam|amica|amfam|amex|americanfamily|americanexpress|am|alstom|alsace|ally|allstate|allfinanz|alipay|alibaba|alfaromeo|al|akdn|airtel|airforce|airbus|aigo|aig|ai|agency|agakhan|ag|afl|afamilycompany|af|aetna|aero|aeg|ae|adult|ads|adac|ad|actor|active|aco|accountants|accountant|accenture|academy|ac|abudhabi|abogado|able|abc|abbvie|abbott|abb|abarth|aarp|aaa";
		var DOMAIN_PART_PATTERN = "(?:[a-z0-9]+(?:-+[a-z0-9]+)*\\.)+(?:" + TLD_PATTERN + ")";
		var SIMPLE_EMAIL_PATTERN_LOCAL_PART = "[-a-z0-9!#$%&'*+/=?^_`{|}~]+(?:\\.[-a-z0-9!#$%&'*+/=?^_`{|}~]+)*";
		var SIMPLE_EMAIL_PATTERN = "^" + SIMPLE_EMAIL_PATTERN_LOCAL_PART + '@' + DOMAIN_PART_PATTERN + "$";
		var DISPLAY_NAME_PATTERN = "(?:\\\\[^\\x00-\\x1f]|[^\"\\x00-\\x1f])*";
		var COMPOUND_EMAIL_PATTERN = "\""+ DISPLAY_NAME_PATTERN +"\"[ \\t]*<" + SIMPLE_EMAIL_PATTERN + ">";
	
		var DIGIT_ONLY_REGEX = /^[0-9]+$/;
		var LOWERALPHANUMERIC_UNDERSCORE_REGEX = /^[0-9a-z_]+$/;
		var ALPHANUMERIC_UNDERSCORE_REGEX = /^[0-9A-Za-z_]+$/;
		var T_OR_F_REGEX = /(T|F)/;
		var COLOR_HEX_REGEX = /^#[0-9a-fA-F]{6}$/;
		var ASCII_CHARS_REGEX = /^[\x20-\x7E]+$/;
		var PACKAGE_REGEX = /^[a-z0-9]+(\.[a-z0-9]+){2}$/;
		var FURIGANA_REGEX = /^[\u0020\u3000\u30A0-\u30FF\uFF61-\uFF9F]+$/;
		var FUNCTION_REGEX = /^[0-9A-Za-z_$]+(\.[0-9A-Za-z_$]+)*$/;
	
		var NON_EMAIL_DELIMITER_REGEX_G = /("[^"\u0000-\u001f]*"|[^,;\n\r])+/g;
		var NON_ALPHANUMERIC_REGEX_G = /[^a-zA-Z0-9]/g;
	
		/**
		 *  validate[type] or validateAndFormat[type] summary
		 *  [type] is determined based on the fieldType
		 *
		 *  @param toValidate - the value to validate
		 *
		 *  @returns object with the following:
		 *  isValid				 - whether the inputted value was valid or not
		 *  formattedValue		  - the value reformatted appropriately (if just a validateXXXX function, it will equal toValidate)
		 *							if isValid = F, should return an empty string.
		 *
		 *  You can optionally return a code and message (key) from error module ERROR_TYPES to throw specific errors
		 *  errorCode (optional)	- the error code to send back, default: INVALID_FLD_VALUE
		 *  errorMsgKey (optional)  - *just* the message key which will retrieve the desired message later, default: INVALID_FIELD_VALUE
		 *							Will fill in {1} as fieldValue and {2} as fieldName.
		 *  errorFullMsg (optional) - the *entire* message in which to use when throwing error. Use if errorMsgKey does not satisfy your reqs
		 *							You will need to call util.getErrorMessage(yourMessageKey, param1, param2, ...) on your own
		 *							If present, will ignore errorMsgKey.
		 */
	
		// General case where only a test on a specific regex is necessary, and no specific error message is required
		function validateByRegexTest(toValidate, regexPattern, msgKeyOnFail)
		{
			if (!regexPattern.test(toValidate))
			{
				if (!!msgKeyOnFail)
					return {isValid: false, formattedValue: toValidate, errorMsgKey: msgKeyOnFail};
				else
					return {isValid: false, formattedValue: ""};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validateDateObject(toValidate, fieldType)
		{
			var isDate = Object.prototype.toString.call(toValidate) === '[object Date]';
			if ( !(toValidate instanceof Date || isDate) || (isDate && isNaN(toValidate.getDay())))
			{
				var errorMsg = "";
				if (fieldType === fieldTypeConstants.Type.DATE)
					errorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_DATE_VALUE_MUST_BE_1, window.userfacing_dateformat);
				return {isValid: false, formattedValue: "", errorFullMsg: errorMsg};
			}
			else if (DateUtil.isDateTooOld(toValidate))
			{
				var errorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE, DateUtil.getOldestDateString());
				return {isValid: false, formattedValue: toValidate, errorFullMsg: errorMsg}
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validateMMYYDateObject(toValidate)
		{
			if ( !(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]') || toValidate.getFullYear() < 1900 || toValidate.getFullYear() > 2100 )
			{
				return {isValid: false, formattedValue: ""};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function isWithinMinMax(toValidate, minVal, maxVal, exclusive)
		{
			var numVal = parseFloat(toValidate);
			var minimum = isNaN(parseFloat(minVal)) ? -Number.MAX_VALUE : minVal;
			var maximum = isNaN(parseFloat(maxVal)) ?  Number.MAX_VALUE : maxVal;

			var isBelow = !!exclusive ? numVal <= minimum : numVal < minimum;
			var isAbove = !!exclusive ? numVal >= maximum : numVal > maximum;

			var fullErrorMsg;
			if (maxVal == null && isBelow)
			{
				fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_GREATER_THAN_1, String(minimum));
			}
			else if (minVal == null && isAbove)
			{
				fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_LOWER_THAN_1, String(maximum));
			}
			else if (isBelow || isAbove)
			{
				fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2, String(minimum), String(maximum));
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
			return {isValid: false, formattedValue: "", errorFullMsg: fullErrorMsg};
		}

		function validateBoolean(toValidate)
		{
			if(toValidate === true || toValidate === false || toString.call(toValidate) === '[object Boolean]')
				return {isValid: true, formattedValue: toValidate} ;
			else
				return {isValid: false, formattedValue: ""};
		}
	
		function validateInteger(toValidate, posOnly, minVal, maxVal)
		{
			var numVal = parseInt(toValidate, 10);
			if (isNaN(toValidate) || (parseFloat(toValidate) !== numVal))
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_NUMBER_OR_PERCENTAGE};
			}
			return isWithinMinMax(toValidate, posOnly ? 0 : minVal, maxVal, posOnly);
		}
	
		function validateNumericValue(toValidate, minVal, maxVal, fieldType)
		{
			if ( isNaN(toValidate) || isNaN(parseFloat(toValidate)))
			{
				return { isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_NUMBER_OR_PERCENTAGE};
			}
	
			var numVal = parseFloat(toValidate);
			var exclusive = false;

			if(fieldType !== null && fieldType !== undefined)
			{
				if ((fieldType === fieldTypeConstants.Type.POSFLOAT) || (fieldType === fieldTypeConstants.Type.POSCURRENCY))
				{
					exclusive = true;
					minVal = 0;
				}
				else if ((fieldType === fieldTypeConstants.Type.NONNEGFLOAT) || (fieldType === fieldTypeConstants.Type.NONNEGCURRENCY))
				{
					minVal = 0;
				}
			}

			return isWithinMinMax(numVal, minVal, maxVal, exclusive);
		}
	
		function validateEmail(toValidate)
		{
			var simpleEmailRegex = new RegExp(SIMPLE_EMAIL_PATTERN, "i");
			var compoundEmailRegex = new RegExp(COMPOUND_EMAIL_PATTERN, "i");
	
			var testResult = simpleEmailRegex.test(toValidate) || compoundEmailRegex.test(toValidate);
	
			return {isValid: testResult, formattedValue: toValidate};
		}
	
		function validateEmails(toValidate)
		{
			var emailList = toValidate.split(/[,;\n\r]/);
			var bademails = [];
	
			for (var i = 0; i < emailList.length; i++)
			{
				var anEmail = util.trim(emailList[i]);
				if (anEmail === "")
					continue;
				if (!validateEmail(anEmail).isValid)
					bademails.push(anEmail);
			}
			if (bademails.length > 0)
			{
				var badEmailString = bademails.join(" ");
				var fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_EMAILS_FOUND) + badEmailString;
				return {isValid: false, formattedValue: "", errorFullMsg: fullErrorMsg};
			}
			return {isValid: true, formattedValue: toValidate};
		}
	
		function validateUrl(toValidate)
		{
			var val = toValidate.toLowerCase();
	
			if ( !(val.indexOf('/') === 0 || val.indexOf('http://') === 0 || val.indexOf('https://') === 0 || val.indexOf('ftp://') === 0 || val.indexOf('file://') === 0) )
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE};
			}
	
			if (val.indexOf(' ') > 0 || val.indexOf('\t') > 0)
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL};
			}
	
			return {isValid: true, formattedValue: toValidate};
		}
	
		function validateCCNumber(toValidate)
		{
			var cardnum = toValidate;
			// This is for credit card numbers. Do not validate if it is masked (i.e. all but last 4 numbers are masked)
			if ((cardnum.length > 4) &&
				(cardnum.slice(0, -4).replace(new RegExp( "\\*", "g" ), '').length === 0) &&
				(cardnum.slice(-4).replace(new RegExp( "\\*", "g" ), '').length === 4))
			{
				isValid = true;
				return cardnum;
			}
			else //adapted from checkccnumber (NLRecordUtil.js)
			{
				if (cardnum.length < 13 || cardnum.length > 20)
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS};
				}
				if (!DIGIT_ONLY_REGEX.test(cardnum))
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS};
				}
	
				// Perform Luhn check
				// http://www.ling.nwu.edu/~sburke/pub/luhn_lib.pl
				var no_digit = cardnum.length;
				var oddoeven = no_digit & 1;
				var sum = 0;
	
				for (var count = 0; count < no_digit; count++)
				{
					var digit = parseInt(cardnum.charAt(count),10);
					if (!((count & 1) ^ oddoeven))
					{
						digit *= 2;
						if (digit > 9)
							digit -= 9;
					}
					sum += digit;
				}
				if (sum % 10 !== 0)
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY};
				}
	
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validatePhoneNumber(toValidate, isFullPhoneType)
		{
			// Fail immediately if any non-ascii characters are found [0x20 (space) - 0x7E (~)]
			if ( !(ASCII_CHARS_REGEX.test(toValidate)) )
			{
				return {isValid: false, formattedValue: ""};
			}
			// Remove all non-alphanumeric characters to check if valid.
			var validPhoneDigits = toValidate.replace(NON_ALPHANUMERIC_REGEX_G, '');
			if (validPhoneDigits.length < 7)
			{
				return {isValid: false, formattedValue: "",  errorMsgKey: error.Type.PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE};
			}
	
			if (isFullPhoneType && (validPhoneDigits.length < 10) )
			{
				return {isValid: false, formattedValue: "",  errorMsgKey: error.Type.PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER};
			}
	
			return {isValid: true, formattedValue: toValidate}
		}
	
		function validateIdentifier(toValidate, lowercaseOnly)
		{
			var re = lowercaseOnly ? LOWERALPHANUMERIC_UNDERSCORE_REGEX : ALPHANUMERIC_UNDERSCORE_REGEX;
			if (!re.test(toValidate))
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES};
			}
			else
				return {isValid: true, formattedValue: toValidate};
		}
	
		function validateCCDate(toValidate, checkNotBeforeToday)
		{
			var toValidateDate = toValidate.split("/");
			// must be in MM/YYYY form
			if (toValidate.length !== 7 || toValidateDate.length !== 2 || toValidateDate[0].length !== 2 || toValidateDate[1].length !== 4)
			{
				errorKey = checkNotBeforeToday ? error.Type.PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT
											   : error.Type.PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT;
				return {isValid: false, formattedValue: "", errorMsgKey: errorKey};
			}
			else
			{
				var toValidateMonth = DIGIT_ONLY_REGEX.test(toValidateDate[0]) ? parseInt(toValidateDate[0], 10) : NaN;
				var toValidateYear = DIGIT_ONLY_REGEX.test(toValidateDate[1]) ? parseInt(toValidateDate[1], 10) : NaN;
				if (isNaN(toValidateMonth) || toValidateMonth < 1 || toValidateMonth > 12 ||
					isNaN(toValidateYear) || toValidateYear < 1000)
				{
					return {isValid: false, formattedValue: "", errorMsgKey:  error.Type.NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT};
				}
				else
				{
					var today = new Date();
					if (	checkNotBeforeToday && (toValidateYear < today.getFullYear() || ( (toValidateYear === today.getFullYear()) && toValidateMonth < (today.getMonth() + 1) ))
						|| !checkNotBeforeToday && (toValidateYear > today.getFullYear() || ( (toValidateYear === today.getFullYear()) && toValidateMonth > (today.getMonth() + 1) )) )
					{
						return {isValid: false, formattedValue: "", errorMsgKey:  error.Type.NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT};
					}
					else
					{
						return {isValid: true, formattedValue: toValidate};
					}
				}
			}
		}

		function validateRate(toValidate, minVal, maxVal, allowPercentage)
		{
			if (allowPercentage)
			{
				var strToValidate = "" + toValidate;
				if (strToValidate.indexOf('%') !== -1)
				{
					var numericResult = validateNumericValue(strToValidate.replace('%', ''));
					if (numericResult.isValid)
					{
						return {isValid: true, formattedValue: toValidate};
					}
					else
					{
						return {isValid: false, formattedValue: "", errorMsgKey: numericResult.errorMsgKey};
					}
				}
			}

			return validateNumericValue(toValidate, minVal, maxVal);
		}

		function validateDynamicPrecision(toValidate, minVal, maxVal, scale)
		{
			if (scale)
			{
				var numericResult = validateNumericValue(toValidate);
				if (numericResult.isValid)
				{
					return {isValid: true, formattedValue:  round_float_to_n_places(toValidate, scale)};
				}
				else
				{
					return {isValid: false, formattedValue: "", errorMsgKey: numericResult.errorMsgKey};
				}

			}

			return validateNumericValue(toValidate, minVal, maxVal);
		}
	
		/**
		 * validateValueLength
		 * Checks whether fieldValue is no greater than maxLen (given it is a positive value).
		 * Throws error if fieldValue is longer than maxLen.
		 * If strictValidation is true, then ensures its value is checked even if fieldValue is numeric.
		 * @param fieldName - name of given field
		 * @param fieldValue - value of given field
		 * @param maxLen - cross reference getFieldLength() in NLRecordFieldUtil.java for the value used
		 * @param useStrict - strictly apply to all value types
		 */
		function validateValueLength(fieldName, fieldValue, maxLen, useStrict)
		{
			var validateMe = (useStrict && !isNaN(parseFloat(fieldValue)) && isFinite(fieldValue)) ? ("" + fieldValue) : fieldValue;
			if ( !isNaN(maxLen) && (maxLen > 0) && (validateMe.length > maxLen) )
			{
				throwError({name: error.Type.INVALID_FLD_VALUE,
					           message: utilityFunctions.getErrorMessage(error.Type.THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED, fieldName, maxLen)});
			}
		}

		/**
		 * validateField
		 * validates the fieldValue from fieldName based on its fieldType, and possibly formats appropriately.
		 * Does nothing if fieldValue is empty UNLESS it is a checkbox
		 *
		 * @param fieldName, fieldType, fieldValue - self explanatory
		 * @param fieldType
		 * @param fieldValue
		 * @param isNum
		 * @param isCurr
		 * @param validationType - gives a specific type for validation ('function' uses this)
		 * @param minVal - minimum valid value
		 * @param maxVal - maximum valid value
		 * @param maxLength - maximum valid length for fieldValue (cross-check NLRecordFieldType.java:getFieldLength )
		 * @param useStrict - record is in a mode that requires stricter validation
		 *
		 * Throws error if fieldValue is invalid or null/undefined
		 * @returns {object} fieldValue
		 * @param mandatory
		 */
		function validateField(fieldName, fieldType, fieldValue, isNum, isCurr, validationType, minVal, maxVal, maxLength, mandatory, useStrict, allowPercentage,scale)
		{
			if ((fieldValue === undefined) || (fieldValue === null) || (fieldValue.length === 0))
			{
				if (mandatory)
				{
					throwError({name: error.Type.INVALID_FLD_VALUE,
							message: utilityFunctions.getErrorMessage(error.Type.FIELD_MUST_CONTAIN_A_VALUE)});
				}
				else if(fieldType !== fieldTypeConstants.Type.CHECKBOX)
				{
					return fieldValue;
				}
			}
	
	
			var isNumeric =   isNum || fieldTypeConstants.isNumeric(fieldType);
			var isCurrency = isCurr || fieldTypeConstants.isCurrency(fieldType);

			// TIME internally converts string time to numeric which can cause unnecessary length error.
			useStrict = useStrict && (fieldType !== fieldTypeConstants.Type.TIME);
			validateValueLength(fieldName, fieldValue, maxLength, useStrict);
	
			switch(true)
			{
				case (fieldType === fieldTypeConstants.Type.DATE) ||
					 (fieldType === fieldTypeConstants.Type.TIMEOFDAY) ||
                     (fieldType === fieldTypeConstants.Type.DATETIME) ||
					 (fieldType === fieldTypeConstants.Type.DATETIMETZ):
					validationPackage = validateDateObject(fieldValue, fieldType);
					break;
	
				case (fieldType === fieldTypeConstants.Type.MMYYDATE):
					validationPackage = validateMMYYDateObject(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.INTEGER):
					validationPackage = validateInteger(fieldValue, false, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.POSINTEGER):
					validationPackage = validateInteger(fieldValue, true, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.TIMETRACK):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.TIME):
					minVal = (!minVal || (minVal < 0)) ? 0 : minVal;
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PERCENT):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;

				case (fieldType === fieldTypeConstants.Type.RATE) ||
					 (fieldType === fieldTypeConstants.Type.RATEHIGHPRECISION):
					validationPackage = validateRate(fieldValue, minVal, maxVal, allowPercentage);
					break;
				case (fieldType === fieldTypeConstants.Type.DYNAMICPRECISION):
					validationPackage = validateDynamicPrecision(fieldValue, minVal, maxVal, scale);
					break;
				case ( !!isNumeric || !!isCurrency ):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal, fieldType);
					break;
	
				case (fieldType === fieldTypeConstants.Type.EMAIL):
					validationPackage = validateEmail(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.EMAILS):
					validationPackage = validateEmails(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.URL):
					validationPackage = validateUrl(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CHECKBOX):
					validationPackage = validateBoolean(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCNUMBER):
					validationPackage = validateCCNumber(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PHONE):
					validationPackage = validatePhoneNumber(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.FULLPHONE):
					validationPackage = validatePhoneNumber(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.IDENTIFIER):
					validationPackage = validateIdentifier(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.IDENTIFIERANYCASE):
					validationPackage = validateIdentifier(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCEXPDATE):
					validationPackage = validateCCDate(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCVALIDFROM):
					validationPackage = validateCCDate(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.COLOR):
					validationPackage = validateByRegexTest(fieldValue, COLOR_HEX_REGEX, error.Type.COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PACKAGE):
					validationPackage = validateByRegexTest(fieldValue, PACKAGE_REGEX, error.Type.INVALID_SUITEAPP_APPLICATION_ID);
					break;
	
				case (fieldType === fieldTypeConstants.Type.FURIGANA):
					validationPackage = validateByRegexTest(fieldValue, FURIGANA_REGEX, error.Type.NON_KATAKANA_DATA_FOUND);
					break;

                case (fieldType === fieldTypeConstants.Type.FUNCTION):
				case (validationType !== null) && (typeof validationType !== "undefined") &&
					 (validationType.toLowerCase() === fieldTypeConstants.Type.QUOTEDFUNCTION):
					validationPackage = validateByRegexTest(fieldValue, FUNCTION_REGEX);
					break;
	
				default:
					return fieldValue;
			}
	
			if (!validationPackage.isValid || validationPackage.formattedValue.length === 0)
			{
				// If there is a specific error message, use it. Else use the cookie-cutter version.
				var errorCode = validationPackage.errorCode ? validationPackage.errorCode : error.Type.INVALID_FLD_VALUE;
	
				if (!!validationPackage.errorFullMsg)
				{
					throwError({name: errorCode, message: validationPackage.errorFullMsg});
				}
				else
				{
					if ( !!isNumeric || !!isCurrency )
					{
						fieldName = fieldName.replace("_formattedValue", "");
					}
					var errorMsgKey = validationPackage.errorMsgKey ? validationPackage.errorMsgKey : error.Type.INVALID_FIELD_VALUE;
					var errorMessage = utilityFunctions.getErrorMessage(errorMsgKey, String(fieldValue), fieldName);

					throwError({name: errorCode, message: errorMessage.replace(/\\\"/g, "\"")});
				}
			}
	
			return validationPackage.formattedValue;
		}

		function throwError(e)
		{
			throw error.create(e);
		}
	
		/**
		 * validateRadioField
		 * specific method to validate radio fields.
		 * Unlike most other fields, a radio field will NOT accept an empty string (unless it is a radio value)
		 *
		 * @param fieldName, fieldValue - self explanatory
		 * @param radioSet - a set of possible values for the radio buttons with the given fieldname
		 *
		 * Throws error if fieldValue is not found in radioSet
		 * @returns fieldValue
		 */
		function validateRadioField(fieldName, fieldValue, radioSet)
		{
			if ( (radioSet === null) || (typeof radioSet === "undefined") || !radioSet.hasOwnProperty(fieldValue) )
			{
				throw error.create({name: error.Type.INVALID_FLD_VALUE,
									message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(fieldValue), fieldName)});
			}
			return fieldValue;
		}

		/**
		 * validateRadioField
		 * specific method to validate radio fields.
		 * Unlike most other fields, a radio field will NOT accept an empty string (unless it is a radio value)
		 *
		 * @param {string} fieldId
		 * @param {string} text
		 * @param {Object} radioSet
		 *
		 * Throws error if fieldValue is not found in radioSet
		 * @returns key
		 */
		function validateRadioFieldByText(fieldId, text, radioSet)
		{
			if(radioSet !== null && radioSet !== undefined)
			{
				for (var key in radioSet)
				{
					if (radioSet.hasOwnProperty(key) && radioSet[key] === text)
						return key;
				}
			}

			throw error.create({name: error.Type.INVALID_FLD_VALUE,
								   message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(text), fieldId)});
		}

		/**
		 * validateCheckBoxField
		 * specific method to validate check box fields.
		 * Unlike most other fields, a check box field will NOT accept an empty string
		 *
		 * @param {string} fieldId
		 * @param {string} text
		 * Throws error if fieldValue is empty
		 * @returns text
		 */
		function validateCheckBoxField(fieldId, text)
		{
			if (utilityFunctions.isValEmpty(text))
			{
				throw error.create({
					name: error.Type.INVALID_FLD_VALUE,
					message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(text), fieldId)
				});
			}
		}

		/* assign util.validator package */
		return Object.freeze({
				validateField: validateField,
				validateRadioField: validateRadioField,
				validateRadioFieldByText: validateRadioFieldByText,
				validateCheckBoxField: validateCheckBoxField
			});
	}
);

/**
 * SuiteScript record field event module
 *
 * @private
 * @module N/record/recordFieldEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordFieldEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE'
		});

	function getEvent(type, recordField)
	{
		return {
			type: type,
			recordField: recordField
		};
	}

	function addErrorDetails(event, error)
	{
		event.error = error;

		return event;
	}

	function wrapValueValidation(options)
	{
		var func = options.func;
		var emitter = options.emitter;
		var recordField = options.recordField;

		return function(){
			var result = undefined;

			try
			{
				result = func.apply(null, arguments);
			}
			catch(error)
			{
				emitter.emit(addErrorDetails(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE, recordField), error));
				throw error;
			}
			return result;
		}
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		wrapValueValidation: wrapValueValidation
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordField
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/recordField',['N/restricted/fieldClientScriptHandler', 'N/restricted/invoker', 'N/fieldUtil', 'N/utilityFunctions', 'N/error','N/nsobject', 'N/util/formatter', 'N/util/validator', 'N/record/recordFieldEvent', 'N/eventEmitter', 'N/runtime'],
	function (remoteApi, invoker, fieldUtil, utilityFunctions, error, nsobject, formatter, validator, recordFieldEvent, eventEmitter, runtime){

		var INVALID_KEY_OR_REF = 'INVALID_KEY_OR_REF';

		var UPDATE_FIELD_ATTRIBUTE = "updateFieldAttribute",
			UPDATE_FIELD_ATTRIBUTE_EXCEPTION = "updateFieldAttributeException",
			UPDATE_LINEITEM_FIELD_ATTRIBUTE = "updateLineItemFieldAttribute",
			UPDATE_LINEITEM_FIELD_ATTRIBUTE_EXCEPTION = "updateLineItemFieldAttributeException";

		/* private object constructor */
		function SelectOption(text, id, isDynamicOption)
		{
			var optionText = utilityFunctions.unescape(text);
			function getText() { return optionText; }
			function getId() { return id; }
			function toJSON() { return {id:id, text:optionText}; }
			function toString() { return "SelectOption"; }
			function isDynamic() { return !!isDynamicOption; } // added dynamically on client, allowed only for current record in NEW UI

			this.getText = getText;
			this.getId = getId;
			this.toJSON = toJSON;
			this.toString = toString();
			this.isDynamic = isDynamic();
		}
		SelectOption.prototype = nsobject.getNewInstance();
		Object.freeze(SelectOption);

		//TODO JSDoc these methods, this is exported by Record
		/*
		* Field - Primary object used to encapsulate a record field object.
		*
		* @protected
		* @constructor
		*/
		function Field(params)
		{
			/* private vars */

			var that = this;
			var field = params;
			var recordFunctions = params.recordFunctions;
			var metadata = params.metadata;
			var fieldState = params.fieldState;
			var label = fieldState.label;
			var emitter = eventEmitter.create();

			/* private method */
			function getFieldInfo()
			{
				return {sublistId: getSublistName(), fieldId: String(metadata.name), lineNum: parseInt(getLine(),10) };
			}
			function isRecordDynamic()
			{
				return field.isRecordDynamic;
			}
			function isCurrentRecord()
			{
				return field.isCurrentRecord;
			}
			function getRecordForm() {
				return field.form;
			}
			function getFieldOptions() {
				return recordFunctions.getFieldOptions();
			}
			function constructSelectOptions(options, isDynamic)
			{
				var selectOptions = [];
				for(var i = 0; i < options.length; i++)
				{
					if(options[i] instanceof SelectOption)
					{
						selectOptions.push(options[i]);
						continue;
					}
					/* remove empty option */
					if(!utilityFunctions.isValEmpty(options[i].id))
						selectOptions.push(new SelectOption(options[i].text, options[i].id, !!isDynamic));
				}

				if (metadata && metadata.hasBlankString &&
					selectOptions.filter(function(opt) {return opt.getText() === metadata.blankString}).length === 0)
					selectOptions.splice(0,0, new SelectOption(metadata.blankString, '', false));

				return selectOptions;
			}
			function getValidFilterOperation(op)
			{
				if(typeof op === 'undefined')
					return 'contains';

				var validOperations = ['contains', 'is', 'startswith'];
				if( validOperations.indexOf(op.toLowerCase()) > -1)
					return op.toLowerCase();
				else
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_GETSELECTOPTION_FILTER_OPERATOR, op, validOperations.join(','));
			}
			function filterOptions(options, filter, filterOperation)
			{
				var toRet = [];
				for(var i = 0; i < options.length; i++)
				{
					var isValid = isOptionValid(options[i], filter, filterOperation);
					if(isValid)
						toRet.push(options[i]);
				}
				return toRet;
			}
			function isOptionValid(option, filter, filterOperation)
			{
				var isValid = false;
				if((filterOperation === 'contains') || (filterOperation === 'startswith'))
				{
					var pos = option.getText().toLowerCase().search(filter.toLowerCase());
					if(filterOperation === 'startswith')
						isValid = (pos === 0);
					else
						isValid = (pos > -1);
				}
				else if(filterOperation === 'is')
				{
					isValid = option.getText().toLowerCase() === filter.toLowerCase();
				}

				return isValid;
			}
			function cacheFieldOption(options, action, data)
			{
				if(getRecord().isDynamic)
				{
					getFieldOptions().put(getSublistName(), getName(), getLine(), options, action, data);
					cacheSelectOptionTexts(getSublistName(), getName(), options);
				}
			}
			function cacheFieldColumnOption(options, action, data)
			{
				if(getRecord().isDynamic && getSublistName())
				{
					getFieldOptions().put(getSublistName(), getName(), -1, options, action, data);
					cacheSelectOptionTexts(getSublistName(), getName(), options);
				}
			}
			function cacheSelectOptionTexts(sublistName, fieldName, options)
			{
				var modelController = getRecord().getModelController();
				(options || []).forEach(function(option) {
					modelController.cacheSelectOptionText(sublistName, fieldName, option.getId(), option.getText());
				});
			}

			function getOptionsFromRecordFieldCache()
			{
				if(getRecord().isDynamic)
					return getFieldOptions().get(getSublistName(), getName(), getLine());
				else
					return undefined;
			}
			function getOptionsFromRecordFieldColumnCache()
			{
				if(getRecord().isDynamic && getSublistName())
					return getFieldOptions().get(getSublistName(), getName(), -1);
				else
					return undefined;
			}

			function getRecord() { return field.record; }
			function getSubrecordType() { return metadata.subrecordType; }
			function getSubrecordIdField() { return metadata.subrecordIdField; }
			function isSublistField() { return (field.sublistId) ? true : false; }
			function isMachineHeaderField() { return metadata.isMachineHeaderField; }
			function acceptEmptyValueForSelectField() { return metadata.acceptEmptyValueForSelectField; }
			function isRadioField() { return getType() === 'radio'; }
			function isPopup() { return metadata.isPopup; }
			function getType() { return  metadata.type; }
			function getName() { return metadata.name; }
			function getFieldState() { return fieldState; }
			function getSublistName() { return field.sublistId ? String(field.sublistId) : null; }
			function getLine() { return field.lineNum || field.lineNum === 0 ? field.lineNum : -1; }
			function setLine(ln)
			{
				field.lineNum = ln;
				// TODO: does this need an event? what data object is responsible for this value?
			}
			function getMaxLength() { return metadata.maxLength; }
			function isNumeric() { return metadata.isNumeric; }
			function isCurrency() { return metadata.isCurrency; }
			function getMinValue() { return (metadata.hasMinValue) ? metadata.minValue : undefined; }
			function getMaxValue() { return (metadata.hasMaxValue) ? metadata.maxValue : undefined; }
			function getValidationFieldType() { return metadata.fieldTypeForValidation; }
			function noSlaving() { return getFieldState().ignoreSlaving; }
			function setNoSlaving(noSlaving) { 
				getFieldState().ignoreSlaving = noSlaving;
				return that;
			}
			function isDisabled() { return getFieldState().isDisabled; }
			function setDisabled(disable)
			{
				disable = !!disable;
				var oldDisabled = getFieldState().isDisabled;

				if(disable !== oldDisabled){
					getFieldState().isDisabled = disable;
				}

				return that;
			}
			function isDefaultMandatory() { return getFieldState().isDefaultMandatory; }
			function isMandatory() { return getFieldState().isMandatory; }
			function setMandatory(mandatory)
			{
				mandatory = !!mandatory;
				var oldMandatory = getFieldState().isMandatory;

				if(mandatory !== oldMandatory){
					getFieldState().isMandatory = mandatory;
				}

				return that;
			}
			function isDisplay() { return getFieldState().isDisplay; }
			function setDisplay(display)
			{
				display = !!display;
				var oldDisplay = getFieldState().isDisplay;

				if(display !== oldDisplay){
					getFieldState().isDisplay = display;
				}

				return that;
			}
			function isVisible() { return getFieldState().isVisible; }
			function setVisible(visible)
			{
				visible = !!visible;
				var oldVisible = getFieldState().isVisible;

				if(visible !== oldVisible){
					getFieldState().isVisible = visible;
				}

				return that;
			}
			function isReadOnly() { return getFieldState().isReadOnly; }
			function setReadOnly(readonly)
			{
				readonly = !!readonly;
				var oldReadonly = getFieldState().isReadOnly;

				if(readonly !== oldReadonly){
					getFieldState().isReadOnly = readonly;
				}

				return that;
			}
			function getLabel()
			{
				if(getFieldState().label !== label)
					label = getFieldState().label;
				return label;
			}
			function setLabel(newLabel)
			{
				newLabel = '' + newLabel;
				var oldLabel = label;

				if(newLabel !== oldLabel){
					label = newLabel;
					getFieldState().label = newLabel;
				}

				return that;
			}

			function getRecordFieldValue(sublistId, fieldId, lineNum)
			{
				if(sublistId)
				{
					if(isRecordDynamic() && (lineNum === -1 || lineNum === getRecord().doGetCurrentSublistIndex(sublistId)))
						return getRecord().getCurrentSublistLineValueAsLegacyString(sublistId, fieldId);
					else
						return getRecord().getSublistLineValueAsLegacyString(sublistId, fieldId, lineNum);
				}
				else
					return getRecord().getValueAsLegacyString(fieldId);
			}
			function getRecordQueryRequest()
			{
				return recordFunctions.getQueryRequest.call();
			}
			function getRequestParam()
			{
				var queryRequest = getRecordQueryRequest();
				markQueryRequest(queryRequest.payload,getName());
				return [getRecord().type, queryRequest.url, queryRequest.payload , getFieldInfo()];
			}
			function getSelectOptionForPopup(idsOrTexts, byIds)
			{
				var lookupBind = utilityFunctions.normalizeArrayOrSingularObjectArg(idsOrTexts) || [];
				var requestParam = getRequestParam();
				requestParam.push(getOptionMastersAndAuxFieldsValue(), lookupBind, byIds);
				return invoker(remoteApi, 'getSelectOptionForPopup', requestParam);
			}
			function getSelectOptions(filter, filterOperator, lookupBind, returnNullIfOverflow)
			{
				var selectOptions = [];
				if(fieldUtil.isSelectType(getType()))
				{
					if (isPopup() && lookupBind)
					{
						selectOptions = constructSelectOptions(getSelectOptionForPopup(lookupBind, true));
					}
					else
					{
						var cachedOpts = getOptionsFromRecordFieldCache();
						if (cachedOpts === undefined)
						{
							if (Array.isArray(metadata.supplementedOptions))
							{
								cachedOpts = constructSelectOptions(metadata.supplementedOptions, true);
							}
							else
							{
								var serverOpts = getSelectOptionsFromServer();
								cachedOpts = serverOpts.overflow ? null : constructSelectOptions(serverOpts.options);
							}
							cacheFieldOption(cachedOpts); // overflow (too many options) is cached as null
						}
						else if (cachedOpts !== null)
						{
							cachedOpts = constructSelectOptions(cachedOpts);
						}
						selectOptions = cachedOpts ? extendWithColumnOptions(cachedOpts) : (returnNullIfOverflow ? null : []);
					}
				}
				else if(isRadioField())
				{
					selectOptions = getRadioSelectOption();
				}

				if(filter && selectOptions)
					selectOptions = filterOptions(selectOptions, filter, getValidFilterOperation(filterOperator));

				return selectOptions;
			}

			function getColumnSelectOptions(filter, filterOperator)
			{
				var columnSelectOptions = [];
				if(getSublistName() && fieldUtil.isSelectType(getType()) && !isPopup())
				{
					var options = getOptionsFromRecordFieldColumnCache() || [];
					columnSelectOptions = constructSelectOptions(options);
				}

				if(filter)
					columnSelectOptions = filterOptions(columnSelectOptions, filter, getValidFilterOperation(filterOperator));

				return columnSelectOptions;
			}
			function extendWithColumnOptions(lineOptions)
			{
				lineOptions = lineOptions || [];
				var columnOptions = getColumnSelectOptions();
				columnOptions.forEach(function(columnOption) { if (!lineOptions.some(function(lineOption) {return lineOption.getId() === columnOption.getId();})) lineOptions.push(columnOption); });
				return lineOptions;
			}

			function canExternalUpdateSelectOptions()
			{
				return fieldUtil.isPrefixedWithCustPage(getName());
			}

			function isInternal()
			{
				var scriptId = runtime.getCurrentScript().id;
				return scriptId == null || scriptId === 'internal';
			}

			function insertSelectOption(value, text, selected, isColumnOption)
			{
				var addedOpt = new SelectOption(text, value, true);

				var myOptions = (isColumnOption ? getColumnSelectOptions : getSelectOptions)();
				if (myOptions.some(function(v) { return v.getId() === value; }))
					utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_ALREADY_PRESENT, value);

				myOptions.push(addedOpt);
				(isColumnOption ? cacheFieldColumnOption : cacheFieldOption)(myOptions, 'add', addedOpt);

				recordFunctions.updateSelectOptions(getSublistName(), getName(), getLine(), myOptions, value, text, selected);
			}

			function removeSelectOption(value, isColumnOption)
			{
				var internal = isInternal();
				var myOptions = (isColumnOption ? getColumnSelectOptions : getSelectOptions)();

				var removedOpt = null;
				var postRemovalOptionList = myOptions.filter(function(v) {
					if ((v.getId() === value) && (v.isDynamic || internal)) {
						removedOpt = v;
						return false;
					}
					return true;
				});
				if (removedOpt === null)
					utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_NOT_FOUND, value);
				(isColumnOption ? cacheFieldColumnOption : cacheFieldOption)(postRemovalOptionList, 'remove', removedOpt);
			}

			function getOptionMastersAndAuxFieldsValue()
			{
				var fields = metadata.optionMastersAndAuxFields;
				var toRet = [];
				fields.forEach(function(field) {
					toRet.push({
						           fieldId: field.fieldName,
						           sublistId: field.sublistName,
						           value: getRecordFieldValue(field.sublistName, field.fieldName, getLine())
					           });
				});
				return toRet;
			}
			function getRadioSet(fieldId)
			{
				return recordFunctions.getRadioSet.call(getRecord(), fieldId);
			}
			function getRadioSelectOption()
			{
				var selectOptions = [];
				if(isSublistField() && !isMachineHeaderField())
				{
					for (var i = 1; i <= getRecord().getLineItemCount(getSublistName()); i++)
						selectOptions.push(new SelectOption(getLabel(), String(i)));
				}
				else
				{
					var radioValues = getRadioSet(getName());
					for(var radioValue in radioValues)
					{
						selectOptions.push(new SelectOption(radioValues[radioValue], radioValue));
					}
				}
				return selectOptions;
			}
			function getSelectOptionsFromServer()
			{
				var queryRequest = getRecordQueryRequest();
				markQueryRequest(queryRequest.payload, getName());
				var requestParam = [ getRecord().type, queryRequest.url, queryRequest.payload , getFieldInfo(), getOptionMastersAndAuxFieldsValue() ];
				return invoker(remoteApi, 'getFieldSelectOptions', requestParam);
			}
			function removeEmptyValueForPopUpSelect(value)
			{
				var newArray = [];
				for(var idx = 0; idx < value.length; idx++)
				{
					if(!utilityFunctions.isValEmpty(value[idx]) && !considerAsEmptyForPopup(value[idx]))
						newArray.push(value[idx]);
				}

				return newArray;
			}
			function validateEmptyValue(value)
			{
				var valArray = util.isArray(value) ? value : [value];
				validateEmptyValueInArray(valArray);
			}
			function validateSelectFieldByText(text)
			{
				var result = text;

				validateEmptyValue(text);

				if(!utilityFunctions.isValEmpty(text) && !considerAsEmptyForPopup(text))
				{
					var options;
					if(isPopup())
					{
						if(util.isArray(text))
							text = removeEmptyValueForPopUpSelect(text);
						options = getSelectOptionForPopup(text, false);
						options = constructSelectOptions(options);
						result = findIdInFieldOptions(options, text);
					}
					else if(isRadioField())
					{
						var thisRadioSet = getRadioSet(getName());
						result = validator.validateRadioFieldByText(getName(), text, thisRadioSet);
					}
					else
					{
						options = getSelectOptions();
						result = findIdInFieldOptions(options, text);
					}
				}

				return result;
			}
			function considerAsEmptyForPopup(value)
			{
				if(isPopup())
				{
					//TODO translation
					return ["<Type then tab>", "<Type & tab for single value>"].indexOf(value) > -1;
				}
				else
					return false;
			}
			function validateSelectField(value, option)
			{
				validateEmptyValue(value);

				if(!utilityFunctions.isValEmpty(value) && !considerAsEmptyForPopup(value))
				{
					if (util.isArray(value) && !areIdsInFieldOptions(option, value))
					{
						throw error.create({name:INVALID_KEY_OR_REF, message: utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), JSON.stringify(value))});
					}
					else if (!util.isArray(value) && !isIdInFieldOptions(option, value))
					{
						throw error.create({name:INVALID_KEY_OR_REF,message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), value)});
					}
				}
			}
			function validateEmptyValueInArray(valueArray)
			{
				// validate if there are empty value in values
				if (!acceptEmptyValueForSelectField() &&
					(utilityFunctions.arrayContains(valueArray, '') || utilityFunctions.arrayContains(valueArray, null) || utilityFunctions.arrayContains(valueArray, undefined) ))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.EMPTY_KEY_NOT_ALLOWED, getName());
				}
			}
			function areIdsInFieldOptions(options, ids)
			{
				var keyList = [];
				for(var i = 0; i < options.length; i++)
					keyList.push(options[i].getId());

				for(var j = 0; i < ids.length; j++)
				{
					if(keyList.indexOf(ids[j]) === -1)
						return false;
				}

				return true;
			}
			function isIdInFieldOptions(options, id)
			{
				for (var i = 0; i < options.length; i++)
				{
					if (options[i].getId() == id)
						return true;
				}
				return false;
			}
			function findIdInFieldOptions(options, text)
			{
				if(util.isArray(text))
					return findIdsInFieldOptions(options, text);

				for(var i = 0; i < options.length; i++)
				{
					if(options[i].getText() === text)
						return options[i].getId();
				}

				throw error.create({name:INVALID_KEY_OR_REF,
									message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), String(text))});
			}
			function findIdsInFieldOptions(options, texts)
			{
				var internalIds = [];
				var validTexts = [];
				for(var i = 0; i < options.length; i++)
				{
					if(texts.indexOf(options[i].getText()) > -1)
					{
						internalIds.push(options[i].getId());
						validTexts.push(options[i].getText());
					}
				}

				if(validTexts.length !== texts.length)
				{
					var invalidTexts = [];
					for(var j=0; j < texts.length; j++)
						if(validTexts.indexOf(texts[j]) == -1)
							invalidTexts.push(texts[j]);

					throw error.create({name:INVALID_KEY_OR_REF,
										message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), JSON.stringify(invalidTexts))});
				}

				return internalIds;
			}
			function validateAndFormatFieldValue(value, useStrict, allowPercentage)
			{
				var returnedValue = value;
				if(fieldUtil.isSelectType(getType()) && isRecordDynamic())
				{
					var options = getSelectOptions(null, null, value, true);
					if(options) {
						validateSelectField(value, options);
					}
					else {
						validateSelectFieldData(value);
					}

					if(util.isArray(value))
						returnedValue = value.map(function(val){ return String(val);});
					else
						returnedValue = String(value);
				}
				else if (isRadioField())
				{
					var thisRadioSet = getRadioSet(getName());
					returnedValue = validator.validateRadioField(getName(), value, thisRadioSet);
				}
				else
				{
					var validateMe = value;
					returnedValue = validator.validateField(getName(), getType(), validateMe, isNumeric(), isCurrency(),
					                                        getValidationFieldType(), getMinValue(), getMaxValue(), getMaxLength(),
					                                        isMandatory(), !!useStrict, allowPercentage);
				}

				return returnedValue;
			}
			function validateSelectFieldData(idsOrTexts)
			{
				var idsOrTexts = utilityFunctions.normalizeArrayOrSingularObjectArg(idsOrTexts);

				var fieldValue = String(idsOrTexts);
				if (fieldUtil.isMultiSelectType(getType()) && idsOrTexts.length > 1)
				{
					fieldValue = idsOrTexts.join(String.fromCharCode(5));
				}

				var isValid = false;
				if (fieldUtil.isSelectType(getType()) && fieldUtil.isPrefixedWithCustPage(getName()) && (idsOrTexts !== null))
				{
					var myOptions = getSelectOptions();
					cacheFieldOption(myOptions);
					var matchedOptions = myOptions.filter(function(v) { return idsOrTexts.indexOf(v.getId()) > -1; });
					isValid = matchedOptions.length > 0;
				}
				else
				{
					var requestParam = getRequestParam();
					requestParam.push(getOptionMastersAndAuxFieldsValue(), fieldValue);
					isValid = invoker(remoteApi, 'validateSelectField', requestParam);
				}
				return isValid;
			}
			function markQueryRequest(request, fieldId)
			{
				request.q = String(fieldId);
			}
			function toString() { return "Field" }
			function toJSON()
			{
				return {
					name: getName(),
					type: getType(),
					label: getLabel()
				};
			}

			/* public undocumented methods */
			this.validateAndFormatFieldValue = recordFieldEvent.wrapValueValidation({
				emitter: emitter,
				recordField: that,
				func: validateAndFormatFieldValue
			});
			this.validateSelectFieldByText = recordFieldEvent.wrapValueValidation({
				emitter: emitter,
				recordField: that,
				func: validateSelectFieldByText
			});
			this.setLine = setLine;
			this.getLine = getLine;
			this.on = emitter.on;
			this.off = emitter.off;

			/* public methods */
			this.getType = getType;
			this.getSubrecordType = getSubrecordType;
			this.getSubrecordIdField = getSubrecordIdField;
			this.getName = getName;
			this.getSublistName = getSublistName;
			this.isPopup = isPopup;
			this.getMaxLength = getMaxLength;
			this.isNumeric = isNumeric;
			this.isCurrency = isCurrency;
			this.getMinValue = getMinValue;
			this.getMaxValue = getMaxValue;
			this.getValidationFieldType = getValidationFieldType;
			this.noSlaving = noSlaving;
			this.setNoSlaving = setNoSlaving;
			this.isDisabled = isDisabled;
			this.setDisabled = setDisabled;
			this.isDefaultMandatory = isDefaultMandatory;
			this.isMandatory = isMandatory;
			this.setMandatory = setMandatory;
			this.isDisplay = isDisplay;
			this.setDisplay = setDisplay;
			this.isVisible = isVisible;
			this.setVisible = setVisible;
			this.isReadOnly = isReadOnly;
			this.setReadOnly = setReadOnly;
			this.getLabel = getLabel;
			this.setLabel = setLabel;
			this.getSelectOptions = getSelectOptions;
			this.canExternalUpdateSelectOptions = canExternalUpdateSelectOptions;
			this.insertSelectOption = insertSelectOption;
			this.removeSelectOption = removeSelectOption;
			this.getRequestParam = getRequestParam;
			this.isCurrentRecord = isCurrentRecord;

			/* Debugger support */
			this.toJSON = toJSON;
			this.toString = toString;
		}
		Field.prototype = nsobject.getNewInstance();
		Object.freeze(Field);

		return Object.freeze({
				create: function(params) { return new Field(params); },
				isSelectType: fieldUtil.isSelectType,
				Type: fieldUtil.SELECT_FIELD_TYPES
			})
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/matrix
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/matrix',['N/utilityFunctions','N/error', 'N/record/recordUtilityFunctions'],
	function(utilityFunctions, error, recordUtil){

		function doGetMatrixHeaderCount(record, sublistId)
		{
			return parseInt(record.getValue(sublistId + 'headercount'), 10) || 0;
		}

		function getMatrixHeaderFieldName(record, sublistId, column)
		{
			var prefix = record.getValue(sublistId + 'header');

			return prefix + column;
		}

		function getMatrixFields(record, sublistId)
		{
			var matrixfieldsvalue = record.getValue(sublistId + 'matrixfields');

			return !!matrixfieldsvalue && matrixfieldsvalue.split(',') || [];
		}

		function isMatrixField(record, options, fieldId)
		{
			var sublistId,
				undef = undefined;
			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			return utilityFunctions.arrayIndexOf(getMatrixFields(record, sublistId), fieldId) !== -1;
		}

		function getMatrixLineFieldName(record, options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
		    {
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			return isMatrixField(record, sublistId, fieldId) ? fieldId + "_" + column + "_" : null;
		}

		function getMatrixHeaderCount(record, options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
                fieldId = options.fieldId;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderCount'));
			return isMatrixField(record, sublistId, fieldId) ? doGetMatrixHeaderCount(record, sublistId) : -1;
		}

		function getMatrixHeaderValue(record, options, fieldId, column)
		{
            var matrixHeaderFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderValue'));
			validateMatrixField(record, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixHeaderValue", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixHeaderFieldName = getMatrixHeaderFieldName(record, sublistId, column);
			return record.getValue(matrixHeaderFieldName);
		}

		function setMatrixHeaderValue(record, options, fieldId, column, value, ignoreFieldChange)
		{
			var sublistId,
				noSlaving = false,
				fireFieldChanged= true,
				matrixHeaderFieldName,
				forceSyncSourcing = false,
				fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				fireFieldChanged = util.isBoolean(ignoreFieldChange) ? !ignoreFieldChange : fireFieldChanged;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('setMatrixHeaderValue'));
			validateMatrixField(record, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "setMatrixHeaderValue", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixHeaderFieldName = getMatrixHeaderFieldName(record, sublistId, column);
			var sourcingMetadata = record.getSlavingMetadata(sublistId, matrixHeaderFieldName);
			var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !record.getIsCurrentRecord();
			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
			}
			record.setValue(matrixHeaderFieldName, value, fireFieldChanged, noSlaving);
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = metadataForceSync;
			}
			return this;
		}

		function getCurrentMatrixSublistValue(record, options, fieldId, column)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('getCurrentMatrixSublistValue'));
			validateMatrixField(record, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getCurrentMatrixSublistValue", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			return record.getCurrentSublistValue(sublistId, matrixLineFieldName, column);
		}

		function setCurrentMatrixSublistValue(record, options, fieldId, column, value, ignoreFieldChange)
		{
            var matrixLineFieldName,
                noSlaving = false,
				sublistId,
				fireFieldChanged = true,
	                        forceSyncSourcing = false,
	                        fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				fireFieldChanged = util.isBoolean(ignoreFieldChange) ? !ignoreFieldChange : fireFieldChanged;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('setCurrentMatrixSublistValue'));
			validateMatrixField(record, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "setCurrentMatrixSublistValue", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			var sourcingMetadata = record.getSlavingMetadata(sublistId, matrixLineFieldName);
			var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !record.getIsCurrentRecord();
			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
			}
			record.setCurrentSublistValue(sublistId, matrixLineFieldName, value, fireFieldChanged, noSlaving);
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = metadataForceSync;
			}
            return this;
		}

		function getMatrixSublistValue(record, options, fieldId, linenum, column)
		{

            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixSublistValue'));
			validateMatrixFieldAndLine(record, sublistId, fieldId, linenum);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixSublistValue", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			return record.getSublistValue(sublistId, matrixLineFieldName, linenum);
		}

		function setMatrixSublistValue(record, options, fieldId, linenum, column, value)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				linenum = options.line;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
			validateMatrixFieldAndLine(record, sublistId, fieldId, linenum);
			column = recordUtil.validateAndGetOneBasedIndex(column, "setMatrixSublistValue", getMatrixHeaderCount(record, sublistId, fieldId));

			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			record.setSublistValue(sublistId, matrixLineFieldName, linenum, value);

            return this;
		}

		function findMatrixSublistLineWithValue(record, options, fieldId, column, value)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('findMatrixSublistLineWithValue'));
			validateMatrixField(record, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "findMatrixSublistLineWithValue", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);
			return record.doFindSublistLineWithValue(sublistId, matrixLineFieldName, value);
		}

		function getMatrixHeaderField(record, options, fieldId, column)
		{
            var matrixHeaderFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderField'));
			validateMatrixField(record, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixHeaderField", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixHeaderFieldName = getMatrixHeaderFieldName(record, sublistId, column);
			return record.getField(matrixHeaderFieldName);
		}

		function getMatrixSublistField(record, options, fieldId, linenum, column)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('getMatrixSublistField'));
			validateMatrixFieldAndLine(record, sublistId, fieldId, linenum);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixSublistField", getMatrixHeaderCount(record, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName(record, sublistId, fieldId, column);

			return record.getSublistField(sublistId, matrixLineFieldName, linenum);
		}

		function parseMatrixLineField(record, fieldId, sublistId)
		{
			var result = null,
				fields, field, count, matrixLineFieldName,
				i;

			fields = getMatrixFields(record, sublistId);
			count = doGetMatrixHeaderCount(record, sublistId);
			for(i = 0; i < fields.length; i++)
			{
				field = fields[i];
				while(count-- > 0)
				{
					matrixLineFieldName = getMatrixLineFieldName(record, sublistId, field, count);
					if(fieldId === matrixLineFieldName)
					{
						result = {
							sublistname: sublistId,
							fieldname: field,
							column: count
						};
						break;
					}
				}
				if(!!result){break;}
			}

			return result;
		}

		function validateMatrixField(record, sublistId, fieldName)
		{
			if(!isMatrixField(record, sublistId, fieldName))
				utilityFunctions.throwSuiteScriptError(error.Type.METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD);
		}

		function validateMatrixFieldAndLine(record, sublistId, fieldName, lineNum)
		{
			validateMatrixField(record, sublistId, fieldName);
			if (isNaN(lineNum) || (parseInt(lineNum, 10) >= record.doGetLineCount(sublistId)) )
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
		}

		return Object.freeze({
			getMatrixHeaderFieldName : getMatrixHeaderFieldName,
			getMatrixFields : getMatrixFields,
			isMatrixField : isMatrixField,
			getMatrixLineFieldName : getMatrixLineFieldName,
            getMatrixHeaderCount : getMatrixHeaderCount,
			getMatrixHeaderValue : getMatrixHeaderValue,
			setMatrixHeaderValue : setMatrixHeaderValue,
            getCurrentMatrixSublistValue : getCurrentMatrixSublistValue,
            setCurrentMatrixSublistValue : setCurrentMatrixSublistValue,
            getMatrixSublistValue : getMatrixSublistValue,
            setMatrixSublistValue : setMatrixSublistValue,
            findMatrixSublistLineWithValue : findMatrixSublistLineWithValue,
            getMatrixHeaderField : getMatrixHeaderField,
            getMatrixSublistField : getMatrixSublistField,
			parseMatrixLineField : parseMatrixLineField
		})
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublist
 * @suiteScriptVersion 2.x
 *
 */
define(
	'N/record/sublist',['N/nsobject'],
	function (nsobject){

		var SUBLIST_TYPE = Object.freeze({
											INLINE_EDITOR : 'inlineeditor',
											EDITOR : 'editor',
											STATIC_LIST : 'staticlist',
											LIST: 'list'
										});

		/**
		 * Return a new instance of sublist object
		 *
		 * @param {Object} sublist
		 * @param {string} sublist.type type of sublist
		 * @param {SublistState} sublist.sublistState SublistState

		 * @return {Sublist}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function Sublist(sublist)
		{
			var that = this;
			var sublistType = sublist.type;
			var sublistState = sublist.sublistState;
			var sublistFieldsMetadata = sublist.sublistFields;

			/* private method */
			/**
			 * The name of the sublist.
			 * @name Sublist#name
			 * @type string
			 * @readonly
			 */
            this.getName = function() {
                return sublistState.id;
            };

			/**
			 * The type of the sublist.
			 * @name Sublist#type
			 * @type string
			 * @readonly
			 */
            this.getType = function() {
                return sublistType;
            };
			/**
			 * The sublist is changed
			 * @name Sublist#isChanged
			 * @type boolean
			 * @readonly
			 */
            this.isChanged = function() {
                return sublistState.isChanged;
            };

			/**
			 * The sublist is hidden
			 * @name Sublist#isHidden
			 * @type boolean
			 * @readonly
			 */
			this.isHidden = function() {
                return sublistState.isHidden
			};

			/**
			 * The sublist is display
			 * @name Sublist#isDisplay
			 * @type boolean
			 * @readonly
			 */
            this.isDisplay = function() {
                return sublistState.isDisplay;
            };

			/**
			 * A flag to indicate whether or not the sublist supports multi-line buffer feature.
			 * @name Sublist#isMultilineEditable
			 * @type boolean
			 * @readonly
			 */
			this.isMultilineEditable = function() {
				return sublistState.isMultilineEditable;
			};

            this.getColumn = function(fieldId)
            {
                var columnMetadata = null;
                if (sublistFieldsMetadata.hasOwnProperty(fieldId))
                {
                    var fieldLevelMetadata = sublistFieldsMetadata[fieldId];
                    columnMetadata = {
                                        getName: function() { return fieldLevelMetadata.name },
                                        getType: function() { return fieldLevelMetadata.type },
                                        getLabel: function() { return fieldLevelMetadata.label },
                                        setLabel: function(newLabel) {
											fieldLevelMetadata.label = newLabel;
										},
                                        getSublistId: function() { return sublistState.id },
                                        isSortable: function() { return fieldLevelMetadata.isSortable}
                                     };
                }
                return columnMetadata;
            };

			/**
			 * Returns the object type name (sublist.Sublist)
			 * @returns {string}
			 */
			this.toString = function() {
				return "record.Sublist"
			};

			/**
			 * JSON.stringify() implementation.
             * @returns {{id: string, type: string, isChanged: boolean, isDisplay: boolean}}
			 */
			this.toJSON  = function () {
				return {
					id: this.id,
					type: this.type,
					isChanged: this.isChanged,
                    isDisplay: this.isDisplay,
					isMultilineEditable: this.isMultilineEditable
				}
			};

			return this;
		}
		Sublist.prototype = nsobject.getNewInstance();
		Object.freeze(Sublist);

		/*
		 * Return a new instance of sublist v1 object
		 *
		 * @param {Sublist} sublist
		 * @return {SublistV1}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function SublistV1(sublist)
		{
            this.getName = function() { return sublist.getName(); };
			this.isChanged = function() { return sublist.isChanged(); };
			this.getSublistType = function() { return sublist.getType(); };
			this.getType = function() { return sublist.getType(); };
			this.isDisplay = function() { return sublist.isDisplay(); };
			this.setDisplay = function(val) {
				// TODO: figure out what it this mess about, but this is not supported in 1.0
				//sublist.isDisplay = val;
			};
			this.isHidden = function() { return sublist.isHidden(); };
			this.setHidden = function(val) {
				//sublist.isHidden = val;
			};
			return this;
		}
		SublistV1.prototype = nsobject.getNewInstance();
		Object.freeze(SublistV1);

		return Object.freeze({
			/**
			 * return a new instance of sublist object
			 * @param {Object} sublist
			 * @returns {Sublist}
			 */
			create: function(sublist) { return new Sublist(sublist); },
			/**
			 * return a new instance of sublist object
			 * @param {Object} sublistJson
			 * @returns {SublistV1}
			 */
			newInstanceOfV1Sublist: function(sublistJson) {
                var sublist = new Sublist(sublistJson);
                return new SublistV1(sublist);
            },
			/**
			 * @enum
			 */
			Type: SUBLIST_TYPE
		})
	}
);

/**
 * Sublist Definition module
 * Will create the appropriate Sublist Object given the desired attributes.
 *
 * @private
 * @module N/sublistDefinition
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistDefinition',['N/restricted/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'],
	function(invoker, utilityFunctions, nsobject, error) {

    var SUBLIST_CATEGORY = Object.freeze({
                                             REMOTE: "remoteRecord",
                                             CURRENT: "currentRecord",
                                             READ_ONLY: "readOnlyRecord"
                                       });

    var SUBLIST_PROPERTIES = Object.freeze({
                                            ID: "id",
                                            TYPE: "type",
                                            IS_CHANGED: "isChanged",
                                            IS_DISPLAY: "isDisplay",
	                                        IS_MULTILINE_EDITABLE : "isMultilineEditable",
                                            GET_COLUMN: "getColumn",
                                            GET_COLUMNS: "getColumns"
                                         });

    var COLUMN_PROPERTIES = Object.freeze({
                                               COLUMN_METADATA: "columnMetadata",
                                               ID: "id",
                                               TYPE: "type",
                                               LABEL: "label",
                                               SUBLIST_ID: "sublistId",
                                               IS_SORTABLE: "isSortable"
                                           });

    var ACCESS_LEVEL = Object.freeze({
                NONE: 0,
                READ_ONLY: 1,
                READ_WRITE: 2
                                     });

    function Sublist(sublistDelegate, permissions)
    {
        function authorizeThenWrite(accessLevel, setFunction, propertyName)
        {
            if (accessLevel === ACCESS_LEVEL.READ_WRITE)
            {
                setFunction();
            }
            else
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName );
            }
        }

        function noAction() { }

        if (permissions[SUBLIST_PROPERTIES.ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the ID of the Sublist
             * @name Sublist#id
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.ID, {
                get: function ()
                {
                    return sublistDelegate.getName();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.ID], noAction, "Sublist." + SUBLIST_PROPERTIES.ID);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.TYPE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the type of the Sublist
             * @name Sublist#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.TYPE, {
                get: function ()
                {
                    return sublistDelegate.getType();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.TYPE], noAction, "Sublist." + SUBLIST_PROPERTIES.TYPE);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_CHANGED] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist has changed
             * @name Sublist#isChanged
             * @type boolean
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_CHANGED, {
                get: function ()
                {
                    return sublistDelegate.isChanged();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_CHANGED], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_CHANGED);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist is displayed
             * @name Sublist#isDisplay
             * @type boolean
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_DISPLAY, {
                get: function ()
                {
                    return sublistDelegate.isDisplay();
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_DISPLAY], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_DISPLAY);
                },
                enumerable: true,
                configurable: false
            });
        }
	    if (permissions[SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE] > ACCESS_LEVEL.NONE)
	    {
		    /**
		     * Return whether this sublist has Multiline Buffer feature enabled.
		     * @name Sublist#isMultilineEditable
		     * @type boolean
		     * @readonly
		     * @since 2018.2
		     */
		    Object.defineProperty(this, SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE, {
			    get: function ()
			    {
				    return sublistDelegate.isMultilineEditable();
			    },
			    set: function (val)
			    {
				    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE);
			    },
			    enumerable: true,
			    configurable: false
		    });
	    }
	    if (permissions[SUBLIST_PROPERTIES.GET_COLUMN] > ACCESS_LEVEL.NONE)
        {
            /**
             * Returns a Column object given the specified fieldId
             * @name Sublist#getColumn
             * @param fieldId
             * @return {Column}
             * @since 2015.2
             */
                    this.getColumn = function (options)
            {
                var undef = undefined,
                                fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;
                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'sublist.getColumn');
                var columnInfo = sublistDelegate.getColumn(fieldId);
                return !columnInfo ? null : Object.freeze(new Column(columnInfo));
            }
        }
        if (permissions[SUBLIST_PROPERTIES.GET_COLUMNS] > ACCESS_LEVEL.NONE)
        {
            /**
             * Returns an array containing the fieldIds of all columns in the sublist
             * @name Sublist#getColumns
             * @param sublistId
             * @return {Array}
             * @since 2015.2
             */
            this.getColumns = sublistDelegate.getColumns;
        }

        /**
         * Returns the object type name (sublist.Sublist)
         * @returns {string}
         */
                this.toString = function ()
                {
            return "sublist.Sublist"
        };

        /**
         * JSON.stringify() implementation.
         * @returns {{id: string, type: string, isChanged: boolean, isDisplay: boolean}}
         */
                this.toJSON = function ()
                {
            return {
                id: this.id,
                type: this.type,
                isChanged: this.isChanged,
                isDisplay: this.isDisplay
            }
        };

        function Column(columnDelegate)
        {
            var columnPermissions = permissions[COLUMN_PROPERTIES.COLUMN_METADATA];
            /**
             * Return the ID of the Column
             * @name Column#id
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.ID, {
                get: function ()
                {
                    return columnDelegate.getName();
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.ID], noAction, "Column." + COLUMN_PROPERTIES.ID);
                },
                enumerable: true,
                configurable: false
            });

	        /**
	         * Returns if column is sortable
	         * @name Column#isSortable
	         * @type boolean
	         * @readonly
	         */
	        Object.defineProperty(this, COLUMN_PROPERTIES.IS_SORTABLE, {
		        get: function ()
		        {
			        return columnDelegate.isSortable();
		        },
		        set: function (val)
		        {
			        authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.IS_SORTABLE], noAction, "Column." + COLUMN_PROPERTIES.IS_SORTABLE);
		        },
		        enumerable: true,
		        configurable: false
	        });

            /**
             * Return the type of the Column
             * @name Sublist#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.TYPE, {
                get: function ()
                {
                    return columnDelegate.getType();
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.TYPE], noAction, "Column." + COLUMN_PROPERTIES.TYPE);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Return the label of the Column
             * @name Sublist#label
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.LABEL, {
                get: function ()
                {
                    return columnDelegate.getLabel();
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                        columnDelegate.setLabel(val);
                    };
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.LABEL], setFunction, "Column." + COLUMN_PROPERTIES.LABEL);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Return the sublistId of the Column
             * @name Sublist#type
             * @type string
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.SUBLIST_ID, {
                get: function ()
                {
                    return columnDelegate.getSublistId();
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.SUBLIST_ID], noAction, "Column." + COLUMN_PROPERTIES.SUBLIST_ID);
                },
                enumerable: true,
                configurable: false
            });

            /**
             * Returns the object type name (sublist.Column)
             * @returns {string}
             */
                    this.toString = function ()
                    {
                return "sublist.Column"
            };

            /**
             * JSON.stringify() implementation.
             * @returns {{id: string, type: string, label: string, sublistId: string}}
             */
                    this.toJSON = function ()
                    {
                return {
                    id: this.id,
                    type: this.type,
                    label: this.label,
                    sublistId: this.sublistId
                }
            };


        }

        Column.prototype = nsobject.getNewInstance();
        Object.freeze(Column);
    }

    Sublist.prototype = nsobject.getNewInstance();
    Object.freeze(Sublist);


    return Object.freeze({
                             Category: SUBLIST_CATEGORY,
                Property: SUBLIST_PROPERTIES,
                             Column: COLUMN_PROPERTIES,
                             Access: ACCESS_LEVEL,
                create: function (delegate, permissions)
                             {
                                 return !delegate ? null : Object.freeze(new Sublist(delegate, permissions));
                             }
                         });
        });

/**
 *
 * @private
 * @module N/sublistPermissions
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistPermissions',['N/metadata/sublistDefinition'], 
	function(sublistDef) {

    var sublistRemoteRecord = {};
    sublistRemoteRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
	sublistRemoteRecord[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA]                              = {};
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_WRITE;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;

    var readOnlySublist = {};
    readOnlySublist[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA]                              = {};
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_SORTABLE] = sublistDef.Access.READ_ONLY;

    var sublistCurrentRecord = {};
    sublistCurrentRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.NONE;
    sublistCurrentRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;

    var masterPermission = {};
    masterPermission[sublistDef.Category.REMOTE] = sublistRemoteRecord;
    masterPermission[sublistDef.Category.CURRENT] = sublistCurrentRecord;
    masterPermission[sublistDef.Category.READ_ONLY] = readOnlySublist;

    return Object.freeze(masterPermission);
        });

/**
 * Sublist metadata module
 * Will provide the proper attributes based on the parameters sent in to identify its source.
 *
 * @private
 * @module N/sublistMetadata
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistMetadata',['N/utilityFunctions', 'N/metadata/sublistDefinition', 'N/metadata/sublistPermissions'],
	function(utilityFunctions, sublistDef, sublistPermissions) {

    function wrap(options)
    {
        var sublistCategory = options.category || null,
                   delegate = options.delegate || null;

        utilityFunctions.checkArgs([sublistCategory, delegate], ["sublistCategory", "delegate"], "sublistMetadata");

        return sublistDef.create(delegate, sublistPermissions[sublistCategory]);
    }

    return Object.freeze({
                             Category: sublistDef.Category,
                wrap: wrap
                         });
        });

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/dynamicLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/dynamicLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		var proxyOptions = Object.freeze({isInteractive: true});

		/**
		 * 
		 * Interface to subrecord line of dynamic record
		 * @param {Line} line
		 * @return {Line}
		 * @constructor
		 * @since 2017.1
		 */
		function DynamicLine(line)
		{
			/**
			 * The instance id of the line
			 * @property {string} instanceId
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', line.getLineInstanceId);
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', line.getSublistId);
			utilityFunctions.addReadOnlyProperty(this, 'sequence', line.getSequence);
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);
			
			function getRecord()
			{
				return line.getRecord().proxy(proxyOptions);
			}

			this.cancel = line.cancel;
			this.commit = line.commit;
			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.setValue = line.setValue;
			this.getText = line.getText;
			this.setText = line.setText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = line.getSubrecord.apply(line, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};
			this.removeSubrecord = line.removeSubrecord;
			this.makeCopy = line.makeCopy;
			this.on = line.on;
			this.off = line.off;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.DYNAMIC_LINE;};

			return this;
		}

		DynamicLine.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicLine);

		return DynamicLine;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/deferredDynamicLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/deferredDynamicLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		var proxyOptions = Object.freeze({isInteractive: true});

		/**
		 * Interface to sublist line of deferred dynamic record
		 * @param {Line} line
		 * @return {Line}
		 * @constructor
		 * @since 2017.1
		 */
		function DeferredDynamicLine(line)
		{
			/**
			 * The instance id of the line
			 * @property {string} instanceId
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', line.getLineInstanceId);
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', line.getSublistId);
			utilityFunctions.addReadOnlyProperty(this, 'sequence', line.getSequence);
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getRecord()
			{
				return line.getRecord().proxy(proxyOptions);
			}

			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.setValue = line.setValue;
			this.getText = line.getText;
			this.setText = line.setText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = line.getSubrecord.apply(line, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};
			this.removeSubrecord = line.removeSubrecord;
			this.makeCopy = line.makeCopy;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.DEFERRED_DYNAMIC_LINE;};

			return this;
		}

		DeferredDynamicLine.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicLine);

		return DeferredDynamicLine;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/readOnlyLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/readOnlyLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		var proxyOptions = Object.freeze({isInteractive: true});

		/**
		 * ReadOnly Line interface
		 * @param {Line} line
		 * @return {Line}
		 * @constructor
		 * @since 2016.2
		 */
		function ReadOnlyLine(line)
		{
			/**
			 * The instance id of the line
			 * @property {string} instanceId
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', line.getLineInstanceId);
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', line.getSublistId);
			utilityFunctions.addReadOnlyProperty(this, 'sequence', line.getSequence);
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getRecord()
			{
				return line.getRecord().proxy(proxyOptions);
			}

			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.getText = line.getText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = line.getSubrecord.apply(line, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};
			this.makeCopy = line.makeCopy;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.READ_ONLY_LINE;};

			return this;
		}

		ReadOnlyLine.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlyLine);

		return ReadOnlyLine;
	});

/**
 * SuiteScript record sublist line proxy module
 *
 * Creates a wrapper around the record sublist line that selectively exposes the line interface.
 *
 * @private
 * @module N/record/line/lineProxy
 * @NApiVersion 2.x
 */
define('N/record/line/lineProxy',['N/record/recordConstants',
		'N/record/line/dynamicLine', 'N/record/line/deferredDynamicLine', 'N/record/line/readOnlyLine'],
	function(constants,
	         DynamicLine, DeferredDynamicLine, ReadOnlyLine)
	{
		/**
		 * returns a record sublist line proxy based on the input configuration
		 *
		 * @param options
		 * @param {Line} options.delegate the actual underlying line instance (from lineDefinition).
		 * @param {boolean} options.isDynamic true if the line's record instance is a dynamic record
		 * @param {boolean} options.isReadOnly true if the line is read only instance
		 */
		function wrap(options)
		{
			var wrappedLine;
			var line = options.delegate;
			var isReadOnly = !!options.isReadOnly;
			var isDynamic = !!options.isDynamic;

			if(isReadOnly)
			{
				wrappedLine = new ReadOnlyLine(line);
			}
			else if (!isDynamic)
			{
				wrappedLine = new DeferredDynamicLine(line);
			}
			else if (isDynamic)
			{
				wrappedLine = new DynamicLine(line);
			}

			return wrappedLine;
		}

		return {
			wrap : wrap
		};
	}
);

// RecordBehaviorDelegate

/**
 * Performs the actions desired by the record or line objects with respect to the record.
 *
 * @private
 * @module N/common/record/recordActualWork
 * @NApiVersion 2.x
 *
 */
define('N/common/record/recordActualWork',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/util/formatter', 'N/util/validator'],
	function(recordUtil, utilityFunctions, formatter, validator)
{
	var undef = undefined;
	var IS_CHANGED = true;
	var FIELD_ID = "fieldId";
	var SUBLIST_ID = "sublistId";
	var METHOD_GET_FIELD = "getField";
	var METHOD_GET_FIELDS = "getFields";
	var METHOD_GET_VALUE = "getValue";
	var METHOD_SET_VALUE = "setValue";
	var METHOD_GET_TEXT = "getText";
	var METHOD_SET_TEXT = "setText";
	var METHOD_HAS_SUBRECORD = "hasSubrecord";
	var METHOD_GET_SUBRECORD = "getSubrecord";
	var METHOD_REMOVE_SUBRECORD = "removeSubrecord";


	/**
	 * Delegation Service for record-like object
	 * @param {Object} options
	 * @param {Record|Line} options.delegate
	 * @constructor
	 */
	function RecordBehaviorDelegate(options)
	{
		var delegate = options.delegate;


		function getFieldState(fieldId)
		{
			return delegate.getFieldState(fieldId);
		}

		function getFieldLevelMetadata(fieldId)
		{
			return delegate.getFieldLevelMetadataForBodyField(fieldId);
		}

		function isValidField(fieldId)
		{
			return delegate.isValidBodyField(fieldId);
		}

		function getField(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_FIELD));
			return delegate.doGetField(fieldId, this);
		}
		this.getField = getField;

		function getFields()
		{
			return delegate.doGetFields();
		}
		this.getFields = getFields;

		function getValue(options)
		{
			var isTextApi = false;
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_VALUE));
			delegate.validateTextApi(isTextApi, getFieldState(fieldId), METHOD_SET_TEXT, METHOD_GET_TEXT);
			return delegate.getParsedValueForBodyField(fieldId, this);
		}
		this.getValue = getValue;

		function setValue(options, value)
		{
			var fieldId, fireFieldChange = true, forceSyncSourcing = false, fireSlavingSync = false;
			if (value !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([fieldId], [FIELD_ID], delegate.getMissingArgumentErrorMessageFillerValue(METHOD_SET_VALUE));
			recordUtil.validateAgainstSqlInjection(fieldId, value);

			var sourcingMetadata = delegate.getSourcingMetadata(fieldId);
			var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !delegate.getIsCurrentRecord();
			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
			}
			delegate.doSetValue(fieldId, value, fireFieldChange, this);
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = metadataForceSync;
			}
		}
		this.setValue = setValue;

		function getText(options)
		{
			var isTextApi = true;
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_TEXT));
			delegate.validateTextApi(isTextApi, getFieldState(fieldId), METHOD_SET_VALUE, METHOD_GET_VALUE);
			return delegate.doGetText(fieldId, this);
		}
		this.getText = getText;

		function setText(options, text)
		{
			var fieldId, fireFieldChange = true, forceSyncSourcing = false, fireSlavingSync = false;
			if (text !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_TEXT);
			utilityFunctions.checkArgs([fieldId], [FIELD_ID], delegate.getMissingArgumentErrorMessageFillerValue(METHOD_SET_TEXT));

			text = recordUtil.emptyIfNullOrUndefined(text);
			recordUtil.validateAgainstSqlInjection(fieldId, text);

			var sourcingMetadata = delegate.getSourcingMetadata(fieldId);
			var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !delegate.getIsCurrentRecord();
			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
			}
			delegate.doSetText(fieldId, text, fireFieldChange, this);
			if (sourcingMetadata && forceSyncSourcing)
			{
				sourcingMetadata.forceSyncSlaving = metadataForceSync;
			}
		}
		this.setText = setText;

		function getParsedValue(fieldId, skipPercentage)
		{
			var returnValue = delegate.doGetValue(fieldId);
			var fs = getFieldState(fieldId);
			var fieldLevelMetadata = getFieldLevelMetadata(fieldId);
			var isCheckbox = fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX;
			var isRate = fieldLevelMetadata && recordUtil.isRateType(fieldLevelMetadata.type);

			if ((fs && !fs.isParsed) || (isCheckbox && returnValue === "") || (isRate && ("" + returnValue).indexOf("%") !== -1))
			{
				var isFieldValid = isValidField(fieldId);
				var parsedValue = recordUtil.parseValue(isFieldValid, fieldLevelMetadata, returnValue, undefined, !fs.isChanged);
				if (isFieldValid || parsedValue !== undefined)
					delegate.setParsedValueAndUpdateFieldState(fieldId, parsedValue, fs);
				returnValue = (isRate && skipPercentage) ? recordUtil.parseValue(isFieldValid, fieldLevelMetadata, returnValue, true, !fs.isChanged) : parsedValue;
			}
			return returnValue;
		}
		this.getParsedValue = getParsedValue;

		function getTextValue(fieldId)
		{
			var isCommitted = true;
			var lineInstanceId = null;
			return getTextValueForInstance(undef, fieldId, lineInstanceId, isCommitted)
		}
		this.getTextValue = getTextValue;

		function getTextValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
		{
			var setFieldMetadata = delegate.getSetFieldMetadata(sublistId, fieldId);
			var fieldLevelMetadata = delegate.extractInforFromFieldLevelMetadata(sublistId, fieldId);
			var value = getParsedValue(fieldId);
			return doGetTextValueForInstance(delegate.getHack(), value, lineInstanceId, isCommitted, setFieldMetadata, fieldLevelMetadata);
		}
		this.getTextValueForInstance = getTextValueForInstance;

		function commit()
		{
			return delegate.doCommit();
		}
		this.commit = commit;

		function cancel()
		{
			return delegate.doCancel();
		}
		this.cancel = cancel;

		function hasSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_HAS_SUBRECORD));
			return delegate.doHasSubrecord(fieldId);
		}
		this.hasSubrecord = hasSubrecord;

		function getSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_SUBRECORD));
			return delegate.doGetSubrecord(fieldId);
		}
		this.getSubrecord = getSubrecord;

		function removeSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_REMOVE_SUBRECORD));
			return delegate.doRemoveSubrecord(fieldId);
		}
		this.removeSubrecord = removeSubrecord;

		function makeCopy()
		{
			return delegate.doMakeCopy();
		}
		this.makeCopy = makeCopy;
	}

	function create(options)
	{
		return new RecordBehaviorDelegate(options);
	}


	function updateSubrecordStates(record)
	{
		var subrecordSublistState = record.getSubrecordSublistState();
		var subrecordFieldState = record.getSubrecordFieldState();
		if (subrecordSublistState != null)
			subrecordSublistState.isChanged = IS_CHANGED;
		if (subrecordFieldState != null)
			subrecordFieldState.isChanged = IS_CHANGED;
	}

	function formatValueAsText(value, metadata)
	{
		var returnMe;
		if (util.isArray(value))
		{
			returnMe = value.map(function (val)
			{
				return recordUtil.formatArrayToStringType(val);
			});
		}
		else
		{
			returnMe = formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata);
			if (returnMe === null)
			{
				returnMe = doFormatValue(value, metadata);
			}
		}
		return returnMe;
	}

	function formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata)
	{
		var fieldType = metadata.type || null;
		var formattedValue = null;

		if (!value && value !== "" && value !== 0 && !util.isBoolean(value))
			formattedValue = "";
		else if (metadata.isMultiSelect && util.isArray(value))
			formattedValue = value.join(String.fromCharCode(5));
		else if (metadata.isSelect || fieldType === null)
			formattedValue = String(value);

		return formattedValue;
	}

	function needsToBeFormattedForLegacySave(metadata, value)
	{
		return util.isDate(value) || util.isBoolean(value) ||
			   metadata.type === recordUtil.FIELD_TYPE.TIME || metadata.type === recordUtil.FIELD_TYPE.TIMETRACK;
	}

	function doFormatValue(value, metadata)
	{
		var fieldType = metadata.type || null;
		var isNumeric = metadata.isNumeric || false;
		var isCurrency = metadata.isCurrency || false;
		var formattedValue = formatter.format(value, fieldType, isNumeric, isCurrency);
		return formattedValue ? String(formattedValue) : formattedValue;
	}

	function formatValueForLegacySyntheticRequest(value, metadata)
	{
		var formattedValue = formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata);
		if (formattedValue === null || formattedValue === undef)
		{
			if (needsToBeFormattedForLegacySave(metadata, value))
				formattedValue = doFormatValue(value, metadata);
			else
				formattedValue = String(value)
		}

		return formattedValue;
	}

	function postDoSetSublistValueForInstance(record, sublistId, fieldId, lineInstanceId, isCommitted)
	{
		record.invalidateSubrecordClones();
		record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted).isChanged = IS_CHANGED;
		record.getSublistState(sublistId).isChanged = IS_CHANGED;
		updateSubrecordStates(record);
	}

	function postDoSetValueForInstance(record, postSetObject, lineInstanceId, isCommitted)
	{
		record.invalidateSubrecordClones();
		record.postSetFieldValueForInstance(postSetObject.sublistId, postSetObject.fieldId,
			lineInstanceId, isCommitted, postSetObject.dbValue,
			postSetObject.fireFieldChange, postSetObject.noSlaving, postSetObject.noValidation);
		updateSubrecordStates(record);
	}

	function createObjectToDoSetSublistValue(val, metadata)
	{
		var value = recordUtil.emptyIfNullOrUndefined(val);
		var dbValue = formatValueForLegacySyntheticRequest(value, metadata);
		return {value: value, legacyStringValue: dbValue};
	}

	function createObjectToDoSetValue(val, metadata)
	{
		var dbValue;
		if (metadata.valueIsFormattedAsString)
			dbValue = (val !== null) ? String(val) : null;
		else
			dbValue = formatValueForLegacySyntheticRequest(val, metadata);
		return {value: val, legacyStringValue: dbValue};
	}

	function getTextValueForRadioField(value, fieldLevelMetadata)
	{
		var returnText = "";
		if (fieldLevelMetadata.radioSet)
			returnText = fieldLevelMetadata.radioSet[value];
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;
		return returnText;
	}

	function getTextValueForSelectField(record, value, lineInstanceId, isCommitted, fieldLevelMetadata)
	{
		var returnText = "";
		var isMulti = false;
		if (util.trim(value) || value === 0 || value === false)
		{
			if (Array.isArray(fieldLevelMetadata.supplementedOptions))
				returnText = record.doGetTextValueForSupplementedSelectFieldForInstance(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, isCommitted, isMulti);
			else
				returnText = record.doGetTextValueForSelectFieldForInstance(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, isCommitted, isMulti);
		}
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;

		return returnText;
	}

	function getTextValueForMultiSelectFieldForInstance(record, value, lineInstanceId, isCommitted, fieldLevelMetadata)
	{
		var returnText = "";
		var isMulti = true;
		if (value || value === 0 || value === false)
			returnText = record.doGetTextValueForSelectFieldForInstance(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, isCommitted, isMulti);
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;

		return returnText ? String(returnText).split(String.fromCharCode(5)) : [];
	}

	function doGetTextValueForInstance(record, value, lineInstanceId, isCommitted, metadata, fieldLevelMetadata)
	{
		var formattedValue;
		if (!metadata.isValidField || value === undef || value === null)
			formattedValue = value;
		else if (metadata.isMultiSelect)
			formattedValue = getTextValueForMultiSelectFieldForInstance(record, value, lineInstanceId, isCommitted, fieldLevelMetadata);
		else if (metadata.isSelect)
			formattedValue = getTextValueForSelectField(record, value, lineInstanceId, isCommitted, fieldLevelMetadata);
		else if (metadata.isRadio)
			formattedValue = getTextValueForRadioField(value, fieldLevelMetadata);
		else
			formattedValue = formatValueAsText(value, metadata);
		return formattedValue;
	}


	function handleMultiSelectAndVirtualFieldForReturnValue(value, metadata)
	{
		var returnMe;
		if (metadata.hasFieldExisted)
			returnMe = (metadata.isMultiSelect && !value && value !== 0) ? [] : value;
		else
			returnMe = undef;
		return returnMe;
	}

	function getValueOrValuesForSelect(record, sublistId, fieldId, text, lineInstanceId, isMultiSelect, isCommitted)
	{
		var returnMe = "";
		var rf;
		record.validateIfSublistIdEditableAndInstanceIdValid(sublistId, lineInstanceId, isCommitted);
		if (isMultiSelect)
		{
			returnMe = recordUtil.formatValueToArrayType(text);
			rf = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			returnMe = rf.validateSelectFieldByText(returnMe);
		}
		else
		{
			var unwrappedText = recordUtil.formatArrayToStringType(text);
			if (unwrappedText || unwrappedText === "")
			{
				rf = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				returnMe = rf.validateSelectFieldByText(unwrappedText);
			}
		}
		return returnMe;
	}

	function convertTextToValueForSetText(record, sublistId, fieldId, lineInstanceId, text, metadata, isCommitted)
	{
		var value;
		if (metadata.isMultiSelect || metadata.isSelect)
			value = getValueOrValuesForSelect(record, sublistId, fieldId, text, lineInstanceId, metadata.isMultiSelect, isCommitted);
		else if (metadata.isRadio)
			value = validator.validateRadioFieldByText(fieldId, text, metadata.radioSet);
		else
		{
			var fieldLevelMetadata = record.getMetadata().getFieldMetadata(sublistId, fieldId);
			if (fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.TIME)
				validator.validateField(fieldId, "text", text, false, false, undefined, undefined, undefined, fieldLevelMetadata.maxLength, false, true);
			if (record.isFieldCheckbox(sublistId, fieldId)) {
				text = "" + text; // to keep legacy behavior where only "T" is accepted as true by parser
			}
			value = recordUtil.parseValue(metadata.isValidField, fieldLevelMetadata, text);
		}
		return value;
	}

	return {
		create: create,
		createObjectToDoSetSublistValue : createObjectToDoSetSublistValue,
		createObjectToDoSetValue: createObjectToDoSetValue,
		postDoSetSublistValueForInstance: postDoSetSublistValueForInstance,
		postDoSetValueForInstance: postDoSetValueForInstance,
		handleMultiSelectAndVirtualFieldForReturnValue: handleMultiSelectAndVirtualFieldForReturnValue,
		convertTextToValueForSetText: convertTextToValueForSetText
	}
});

/**
 * SuiteScript persisted sublist line impl
 *
 * @private
 * @module N/record/line/sublistLineImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineImpl',[],
	function() {

	/**
	 * Line implementation for sublist line instance
	 * @param {Line} line
	 * @constructor
	 */
	function SublistLineImpl(line) {
		var isCommitted = true;

		function getSublistId()
		{
			return line.getSublistId();
		}

		function getLineInstanceId()
		{
			return line.getLineInstanceId();
		}

		function getParentRecord(){
			return line.getUnproxiedRecord();
		}

		function getFieldState(fieldId)
		{
			return getParentRecord().getSublistFieldStateForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.getFieldState = getFieldState;

		function getParsedValueForBodyField(fieldId, delegator)
		{
			return getParentRecord().doGetParsedSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.getParsedValueForBodyField = getParsedValueForBodyField;

		function setParsedValueForBodyField(fieldId, value)
		{
			getParentRecord().setParsedValueForSublistFieldForInstance(getSublistId(), getLineInstanceId(), fieldId, value, isCommitted);
		}
		this.setParsedValueForBodyField = setParsedValueForBodyField;

		function doGetValue(fieldId)
		{
			return getParentRecord().doGetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.doGetValue = doGetValue;

		function doGetText(fieldId, delegator)
		{
			return getParentRecord().doGetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.doGetText = doGetText;

		function doSetValue(fieldId, value, fireFieldChange)
		{
			return getParentRecord().doSetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), value, fireFieldChange, isCommitted);
		}
		this.doSetValue = doSetValue;

		function doSetText(fieldId, text, fireFieldChange)
		{
			var noSlaving = false;
			var noValidationAndFormatting = false;
			return getParentRecord().doSetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), text, fireFieldChange, noSlaving, noValidationAndFormatting, isCommitted);
		}
		this.doSetText = doSetText;

		function doGetField(fieldId, delegator)
		{
			return getParentRecord().doGetFieldForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.doGetField = doGetField;

		function doGetFields()
		{
			return getParentRecord().getSublistFields(getSublistId());
		}
		this.doGetFields = doGetFields;

		function doCommit()
		{
			return getParentRecord().commitLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCommit = doCommit;

		function doCancel()
		{
			return getParentRecord().cancelLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCancel = doCancel;

		function hasSubrecord(fieldId)
		{
			return getParentRecord().doHasSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.hasSubrecord = hasSubrecord;

		function getSubrecord(fieldId)
		{
			return getParentRecord().doGetSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.getSubrecord = getSubrecord;

		function removeSubrecord(fieldId)
		{
			return getParentRecord().doRemoveSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.removeSubrecord = removeSubrecord;

		function makeCopy()
		{
			return getParentRecord().makeCopyForInstance(getSublistId(), getLineInstanceId(), isCommitted);
		}
		this.makeCopy = makeCopy;
	}

	function create(line)
	{
		return new SublistLineImpl(line);
	}

	return {
		/**
		 * create a regular sublistline implementation that will supplement line behavior
		 * @param {Line} line
		 */
		create : create
	};
});

/**
 * SuiteScript sublist buffer line impl
 *
 * @private
 * @module N/record/line/sublistLineBufferImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineBufferImpl',[], function() {

	/**
	 * Line implementation for sublist buffer line instance
	 * @param {Line} line
	 * @constructor
	 */
	function SublistLineBufferImpl(line) {
		var isCommitted = false;

		function getSublistId()
		{
			return line.getSublistId();
		}

		function getLineInstanceId()
		{
			return line.getLineInstanceId();
		}

		function getParentRecord(){
			return line.getUnproxiedRecord();
		}

		function getFieldState(fieldId)
		{
			return getParentRecord().getSublistFieldStateForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.getFieldState = getFieldState;
		
		function getParsedValueForBodyField(fieldId, delegator)
		{
			return getParentRecord().doGetParsedSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.getParsedValueForBodyField = getParsedValueForBodyField;

		function setParsedValueForBodyField(fieldId, value)
		{
			getParentRecord().setParsedValueForSublistFieldForInstance(getSublistId(), getLineInstanceId(), fieldId, value, isCommitted);
		}
		this.setParsedValueForBodyField = setParsedValueForBodyField;

		function doGetValue(fieldId)
		{
			return getParentRecord().doGetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.doGetValue = doGetValue;

		function doGetText(fieldId, delegator)
		{
			return getParentRecord().doGetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.doGetText = doGetText;

		function doSetValue(fieldId, value, fireFieldChange)
		{
			return getParentRecord().doSetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), value, fireFieldChange, isCommitted);
		}
		this.doSetValue = doSetValue;

		function doSetText(fieldId, text, fireFieldChange)
		{
			var noSlaving = false;
			var noValidationAndFormatting = false;
			return getParentRecord().doSetSublistTextForInstance(getSublistId(), fieldId, getLineInstanceId(), text, fireFieldChange, noSlaving, noValidationAndFormatting, isCommitted);
		}
		this.doSetText = doSetText;

		function doGetField(fieldId, delegator)
		{
			return getParentRecord().doGetFieldForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.doGetField = doGetField;

		function doGetFields()
		{
			return getParentRecord().getSublistFields(getSublistId());
		}
		this.doGetFields = doGetFields;

		function doCommit()
		{
			return getParentRecord().commitLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCommit = doCommit;

		function doCancel()
		{
			return getParentRecord().cancelLineForInstance(getSublistId(), getLineInstanceId());
		}
		this.doCancel = doCancel;

		function hasSubrecord(fieldId)
		{
			return getParentRecord().doHasSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.hasSubrecord = hasSubrecord;

		function getSubrecord(fieldId)
		{
			return getParentRecord().doGetSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.getSubrecord = getSubrecord;
		
		function removeSubrecord(fieldId)
		{
			return getParentRecord().doRemoveSublistSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.removeSubrecord = removeSubrecord;

		function makeCopy()
		{
			return getParentRecord().makeCopyForInstance(getSublistId(), getLineInstanceId(), isCommitted);
		}
		this.makeCopy = makeCopy;
	}

	function create(line)
	{
		return new SublistLineBufferImpl(line);
	}

	return {
		/**
		 * create a buffered sublistline implementation that will supplement line behavior
		 * @param {Line} line
		 */
		create : create
	};
});

/**
 * SuiteScript record impl factory
 *
 * @private
 * @module N/record/line/sublistLineImplementation
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineImplementation',['N/record/line/sublistLineImpl', 'N/record/line/sublistLineBufferImpl'], function(sublistLineImpl, sublistLineBufferImpl){

	function create(options)
	{
		var isCommitted = options.isCommitted;
		var line = options.line;
		return isCommitted ? sublistLineImpl.create(line) : sublistLineBufferImpl.create(line);
	}

	return {
		/**
		 * create the corresponding implementation for line object based on the isCommitted mode
		 * @param {Object} options
		 * @param {boolean} options.isCommitted is not buffer instance
		 * @param {Line} options.line line definition object
		 */
		create : create
	};
});

/**
 * SuiteScript record event enum module
 *
 * @private
 * @module N/record/recordEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordEvent',[],function () {
    var EVENT_TYPE = Object.freeze({
            ERROR: 'ERROR',

            UPDATE_ALL: 'UPDATE_ALL',
            RECORD_INITIALIZED: 'RECORD_INITIALIZED',
	        RECORD_SAVABLE: 'RECORD_SAVABLE',
	        RECORD_NOT_SAVABLE: 'RECORD_NOT_SAVABLE',

            UPDATE_FIELD_VALUE: 'UPDATE_FIELD_VALUE',
            UPDATE_FIELD_OPTIONS: 'UPDATE_FIELD_OPTIONS',
            UPDATE_SUBLIST: 'UPDATE_SUBLIST',
            CREATE_LINE: 'CREATE_LINE',
            UPDATE_LINE: 'UPDATE_LINE',
            INSERT_LINE: 'INSERT_LINE',
            REMOVE_LINE: 'REMOVE_LINE',
            SELECT_LINE: 'SELECT_LINE',
	        LINE_COMMITTABLE: 'LINE_COMMITTABLE',
	        LINE_NOT_COMMITTABLE: 'LINE_NOT_COMMITTABLE',
            UPDATE_RELATED_RECORD_VIEW: 'UPDATE_RELATED_RECORD_VIEW',

            FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
            FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
            FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
            FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
            FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
            FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
            FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',

            SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
            SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
            SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE',

            VALIDATION_FAILED: 'VALIDATION_FAILED'
        });

    return Object.freeze({
        Type : EVENT_TYPE
    });
});

/**
 * SuiteScript sublist line event module
 *
 * @private
 * @module N/record/sublistLineEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE'
		});

	function getEvent(sublistLine, fieldId, type)
	{
		return {
			type: type,
			sublistLine: sublistLine,
			fieldId: fieldId
		};
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function addInternalFlag(event, isInternalChange)
	{
		if (isInternalChange === true)
			event.internal = true;

		return event;
	}

	function emit(emitter, sublistLine, fieldId, type)
	{
		emitter.emit(getEvent(sublistLine, fieldId, type));
	}

	function updateField(emitter, sublistLine, fieldId, oldValue, newValue, isInternalChange)
	{
		emitter.emit(addInternalFlag(addFieldValues(getEvent(sublistLine, fieldId, EVENT_TYPE.FIELD_VALUE_CHANGE), oldValue, newValue), isInternalChange));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		updateField: updateField
	});
});

/**
 * SuiteScript model event module
 *
 * @private
 * @module N/record/modelEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/modelEvent',['N/record/sublistLineEvent'], function(sublistLineEvent)
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE',
			LINE_SELECT: 'LINE_SELECT',
			LINE_CREATE: 'LINE_CREATE',
			LINE_INSERT: 'LINE_INSERT',
			LINE_UPDATE: 'LINE_UPDATE',
			LINE_DELETE: 'LINE_DELETE',
			LINE_COMMITTABLE: 'LINE_COMMITTABLE',
			LINE_NOT_COMMITTABLE: 'LINE_NOT_COMMITTABLE',
			RECORD_SAVABLE: 'RECORD_SAVABLE',
			RECORD_NOT_SAVABLE: 'RECORD_NOT_SAVABLE'
		});

	var EVENT_ORIGIN = Object.freeze({
			CANCEL: "CANCEL",
			COPY: "COPY"
		});

	function getEvent(type, origin)
	{
		var returnMe = { type: type };
		if (origin !== undefined)
		{
			returnMe.origin = origin;
		}
		return returnMe;
	}

	function addFieldId(event, fieldId)
	{
		event.fieldId = fieldId;

		return event;
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function addSublistInfo(event, sublistLine, isBuffer, suppressEmit)
	{
		event.sublistId = sublistLine.id;
		event.lineId = sublistLine.getFieldValue('_id');
		event.line = sublistLine.index;
		event.useLineBuffer = !!isBuffer;
		if (!!suppressEmit)
			event.suppressEmit = true;

		return event;
	}

	function addInternalFlag(event, isInternalChange)
	{
		if (isInternalChange === true)
			event.internal = true;

		return event;
	}

	function emit(emitter, fieldId, type)
	{
		emitter.emit(addFieldId(getEvent(type), fieldId));
	}

	function updateField(emitter, fieldId, oldValue, newValue, isInternalChange)
	{
		emitter.emit(addInternalFlag(addFieldValues(addFieldId(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE), fieldId), oldValue, newValue), isInternalChange));
	}

	function selectLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_SELECT), sublistLine, isBuffer));
	}

	function createLine(emitter, sublistLine, isBuffer, origin, suppressEmit)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_CREATE, origin), sublistLine, isBuffer, suppressEmit));
	}

	function insertLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_INSERT), sublistLine, isBuffer));
	}

	function updateLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_UPDATE), sublistLine, isBuffer));
	}

	function deleteLine(emitter, sublistLine, isBuffer, origin, suppressEmit)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_DELETE, origin), sublistLine, isBuffer, suppressEmit));
	}

	function committableLine(emitter, sublistLine)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_COMMITTABLE), sublistLine, false, false));
	}

	function notCommittableLine(emitter, sublistLine)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_NOT_COMMITTABLE), sublistLine, false, false));
	}

	function savableRecord(emitter)
	{
		emitter.emit(getEvent(EVENT_TYPE.RECORD_SAVABLE));
	}

	function notSavableRecord(emitter)
	{
		emitter.emit(getEvent(EVENT_TYPE.RECORD_NOT_SAVABLE));
	}

	var translateSublistLineEventTypeToModelEventType = (function () {
		var eventTranslations = {};

		eventTranslations[sublistLineEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.FIELD_VALUE_CHANGE;

		return function (sublistStateEventType) {
			return eventTranslations[sublistStateEventType];
		}
	}());

	function addSublistLineEventDetails(event, sublistLineEvent, isBuffer)
	{
		event.sublistId = sublistLineEvent.sublistLine.id;
		event.lineId = sublistLineEvent.sublistLine.getFieldValue('_id');
		event.line = sublistLineEvent.sublistLine.index;
		event.fieldId = sublistLineEvent.fieldId;
		if(sublistLineEvent.oldValue !== undefined){ event.oldValue = sublistLineEvent.oldValue; }
		if(sublistLineEvent.newValue !== undefined){ event.newValue = sublistLineEvent.newValue; }
		event.useLineBuffer = isBuffer;
		if (sublistLineEvent.internal) { event.internal = true; }
		return event;
	}

	function translateSublistLineEventToModelEvent(sublistLineEvent, isBuffer)
	{
		return addSublistLineEventDetails(getEvent(translateSublistLineEventTypeToModelEventType(sublistLineEvent.type)), sublistLineEvent, isBuffer);
	}

	function forwardSublistLineEvent(emitter, isBuffer, sublistStateEvent)
	{
		emitter.emit(translateSublistLineEventToModelEvent(sublistStateEvent, isBuffer));
	}

	function forwardSublistLineEvents(emitter, sublistLine, isBuffer)
	{
		var forward = forwardSublistLineEvent.bind(null, emitter, isBuffer);

		sublistLine.on({
			types: [
				sublistLineEvent.Type.FIELD_VALUE_CHANGE
			],
			listener: forward
		});
	}

	function unforwardSublistLineEvents(sublistLine)
	{
		sublistLine.off({
			types: [
				sublistLineEvent.Type.FIELD_VALUE_CHANGE
			]
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		Origin: EVENT_ORIGIN,
		emit: emit,
		updateField: updateField,
		selectLine: selectLine,
		createLine: createLine,
		insertLine: insertLine,
		updateLine: updateLine,
		deleteLine: deleteLine,
		committableLine: committableLine,
		notCommittableLine: notCommittableLine,
		forwardSublistLineEvents: forwardSublistLineEvents,
		unforwardSublistLineEvents: unforwardSublistLineEvents,
		savableRecord: savableRecord,
		notSavableRecord: notSavableRecord
	});
});

/**
 * SuiteScript record definition event filter module
 *
 * @private
 * @module N/common/record/recordDefinitionEventCompressor
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record/recordDefinitionEventCompressor',['N/record/recordEvent'], function (recordEvent) {
	/*
	 UPDATE_FIELD_VALUE: 'UPDATE_FIELD_VALUE',
	 UPDATE_FIELD_OPTIONS: 'UPDATE_FIELD_OPTIONS',
	 UPDATE_SUBLIST: 'UPDATE_SUBLIST',
	 CREATE_LINE: 'CREATE_LINE',
	 UPDATE_LINE: 'UPDATE_LINE',
	 INSERT_LINE: 'INSERT_LINE',
	 REMOVE_LINE: 'REMOVE_LINE',
	 SELECT_LINE: 'SELECT_LINE',
	 UPDATE_RELATED_RECORD_VIEW: 'UPDATE_RELATED_RECORD_VIEW',

	 FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
	 FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
	 FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
	 FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
	 FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
	 FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
	 FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',

	 SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
	 SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
	 SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE'
	 */

	function isErrorEvent(event)
	{
		return event.error !== undefined;
	}

	function getSingletonEvent(eventType, eventData)
	{
		var event = eventData.singleton[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSaveRecordEvent(eventType, eventData)
	{
		var event = eventData.saveRecord[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getBodyFieldEvent(fieldId, eventData, eventType)
	{
		var event = eventData.body[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.last;

		return event || null;
	}

	function getBodyFieldErrorEvent(fieldId, eventData, eventType)
	{
		var event = eventData.body[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistFieldEvent(sublistId, fieldId, lineId, buffer, eventData, eventType)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';
		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistFieldErrorEvent(sublistId, fieldId, lineId, buffer, eventData, eventType)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';
		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistEvent(eventType, sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistErrorEvent(eventType, sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[eventType];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistLineEvent(eventType, sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistLineErrorEvent(eventType, sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event.error;

		return event || null;
	}

	function getUpdateAllEvent(eventData)
	{
		return getSingletonEvent(recordEvent.Type.UPDATE_ALL, eventData);
	}

	function getCreateLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.CREATE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getUpdateLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.UPDATE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getInsertLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.INSERT_LINE, sublistId, lineId, buffer, eventData);
	}

	function getRemoveLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.REMOVE_LINE, sublistId, lineId, buffer, eventData);
	}

	function hasErrorEvent(event, eventData)
	{
		var hasEvent = false;

		for(var i = 0; i < eventData.errors.length; i+= 1)
		{
			if(event.error !== undefined && event.error === eventData.errors[i].error)
			{
				hasEvent = true;
				break;
			}
		}

		return hasEvent;
	}

	function hasSingletonEvent(event, eventData)
	{
		return event === getSingletonEvent(event.type, eventData);
	}

	function hasSaveRecordEvent(event, eventData)
	{
		return event === getSaveRecordEvent(event.type, eventData);
	}

	function hasFieldEvent(event, eventData)
	{
		var result = false;

		if(!!event.sublistId)
		{
			var func = isErrorEvent(event) ? getSublistFieldErrorEvent : getSublistFieldEvent;
			result = event === func(event.sublistId, event.fieldId, event.lineId, event.useLineBuffer, eventData, event.type);
		}
		else
		{
			var func = isErrorEvent(event) ? getBodyFieldErrorEvent : getBodyFieldEvent;
			result = event === func(event.fieldId, eventData, event.type);
		}

		return result;
	}

	function hasSublistEvent(event, eventData)
	{
		var func = isErrorEvent(event) ? getSublistErrorEvent : getSublistEvent;
		return event === func(event.type, event.sublistId, event.useLineBuffer, eventData);
	}

	function hasSublistLineEvent(event, eventData)
	{
		var func = isErrorEvent(event) ? getSublistLineErrorEvent : getSublistLineEvent;
		return event === func(event.type, event.sublistId, event.lineId, event.useLineBuffer, eventData);
	}

	function getSublistEventDataSafe(sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var data = eventData.sublist[bufferOrActual];
		data[sublistId] = data[sublistId] || {};

		return data[sublistId];
	}

	function getSublistLineEventDataSafe(sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var data = eventData.sublist[bufferOrActual];
		data[sublistId] = data[sublistId] || {};

		data = data[sublistId];
		data[lineId] = data[lineId] || {};

		return data[lineId];
	}

	function processErrorEvent(event, eventData)
	{
		if(!hasErrorEvent(event, eventData))
		{
			eventData.errors.push(event);
		}
	}

	function processSingletonEvent(event, eventData)
	{
		var data = eventData.singleton;
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSaveRecordEvent(event, eventData)
	{
		var data = eventData.saveRecord;
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processUpdateAllEvent(event, eventData)
	{
		eventData.body = {};
		eventData.sublist = {actual:{}, buffer:{}};
		eventData.singleton = {};
		eventData.errors = [];
		eventData.saveRecord = {};

		processSingletonEvent(event, eventData);
	}

	function updateSublistEvent(event, data)
	{
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSublistEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistEventDataSafe(event.sublistId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll)
		{
			updateSublistEvent(event, data);
		}
	}

	function updateSublistLineEvent(event, data)
	{
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSublistLineEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll && !getRemoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) || isErrorEvent(event))
		{
			updateSublistLineEvent(event, data);
		}
	}

	function processSublistRemoveLineEvent(event, eventData)
	{
		var isError = isErrorEvent(event);
		if(isError)
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);
		var lineCreatedOrInserted = (getCreateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getInsertLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData));

		if(!isError)
		{
			Object.keys(data).forEach(function (v) {
				delete data[v];
			});
		}

		if(!updateAll && !lineCreatedOrInserted || isError)
		{
			updateSublistLineEvent(event, data);
		}
	}

	function updateFirstLastEvent(event, data)
	{
		var isError = isErrorEvent(event);
		var firstEvent = data.first == null;
		var eventGoesToOriginalState = !firstEvent &&
				data.first.oldValue !== undefined &&
				event.newValue !== undefined &&
				data.first.oldValue === event.newValue;

		if(isError)
		{
			data.error = event;
		}
		else if(firstEvent)
		{
			data.first = event;
			data.last = event;
		}
		else if(eventGoesToOriginalState)
		{
			data.first = null;
			data.last = event;
		}
		else
		{
			data.last = event;
			if(data.first.hasOwnProperty('oldValue'))
			{
				data.last.oldValue = data.first.oldValue;
			}
		}
	}

	function updateFieldEvent(event, data)
	{
		data[event.type] = data[event.type] || {};
		data = data[event.type];
		data[event.fieldId] = data[event.fieldId] || {first: null, last: null, error:null};
		data = data[event.fieldId];

		updateFirstLastEvent(event, data);
	}

	function processFieldBodyEvent(event, eventData)
	{
		var data = eventData.body;
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll)
		{
			updateFieldEvent(event, data);
		}
	}

	function processFieldSublistEvent(event, eventData)
	{
		var updateAll = !!getUpdateAllEvent(eventData);
		var ignore = !isErrorEvent(event) && (
				getCreateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getUpdateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getInsertLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getRemoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) );
		
		if (ignore && ignore.type !== recordEvent.Type.REMOVE_LINE && isFieldStatus(event)) {
			ignore = false;
		}
		if(!updateAll && !ignore || isErrorEvent(event))
		{
			var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
			updateFieldEvent(event, data);
		}
	}

	function isFieldStatus(event) {
		return (event.type == recordEvent.Type.FIELD_IS_MANDATORY_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_HIDDEN_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_DISABLED_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_VISIBLE_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_DISPLAY_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE ||
			event.type == recordEvent.Type.FIELD_LABEL_CHANGE);
	}

	function processFieldEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		if(!!event.sublistId)
		{
			processFieldSublistEvent(event, eventData)
		}
		else
		{
			processFieldBodyEvent(event, eventData);
		}
	}

	var processEvent = (function(){
		var process = {};

		process[recordEvent.Type.ERROR] = processErrorEvent;

		process[recordEvent.Type.UPDATE_ALL] = processUpdateAllEvent;
		process[recordEvent.Type.RECORD_INITIALIZED] = processSingletonEvent;
		process[recordEvent.Type.RECORD_SAVABLE] = processSaveRecordEvent;
		process[recordEvent.Type.RECORD_NOT_SAVABLE] = processSaveRecordEvent;

		process[recordEvent.Type.UPDATE_FIELD_OPTIONS] = processFieldEvent;
		process[recordEvent.Type.UPDATE_FIELD_VALUE] = processFieldEvent;
		process[recordEvent.Type.CREATE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.UPDATE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.INSERT_LINE] = processSublistLineEvent;
		process[recordEvent.Type.REMOVE_LINE] = processSublistRemoveLineEvent;
		process[recordEvent.Type.SELECT_LINE] = processSublistEvent;
		process[recordEvent.Type.LINE_COMMITTABLE] = processSublistLineEvent;
		process[recordEvent.Type.LINE_NOT_COMMITTABLE] = processSublistLineEvent;

		process[recordEvent.Type.FIELD_IS_MANDATORY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_HIDDEN_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_DISABLED_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_VISIBLE_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_DISPLAY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_LABEL_CHANGE] = processFieldEvent;

		process[recordEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = processSublistEvent;

		process[recordEvent.Type.VALIDATION_FAILED] = processSublistLineEvent;

		return function processEvent(event, eventData){
			var func = process[event.type] || function(){};
			func(event, eventData);
		};
	}());

	var hasEvent = (function(){
		var has = {};
		has[recordEvent.Type.ERROR] = hasErrorEvent;

		has[recordEvent.Type.UPDATE_ALL] = hasSingletonEvent;
		has[recordEvent.Type.RECORD_INITIALIZED] = hasSingletonEvent;
		has[recordEvent.Type.RECORD_SAVABLE] = hasSaveRecordEvent;
		has[recordEvent.Type.RECORD_NOT_SAVABLE] = hasSaveRecordEvent;

		has[recordEvent.Type.UPDATE_FIELD_OPTIONS] = hasFieldEvent;
		has[recordEvent.Type.UPDATE_FIELD_VALUE] = hasFieldEvent;
		has[recordEvent.Type.CREATE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.UPDATE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.INSERT_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.REMOVE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.SELECT_LINE] = hasSublistEvent;
		has[recordEvent.Type.LINE_COMMITTABLE] = hasSublistLineEvent;
		has[recordEvent.Type.LINE_NOT_COMMITTABLE] = hasSublistLineEvent;

		has[recordEvent.Type.FIELD_IS_MANDATORY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_HIDDEN_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_DISABLED_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_VISIBLE_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_DISPLAY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_LABEL_CHANGE] = hasFieldEvent;

		has[recordEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = hasSublistEvent;

		has[recordEvent.Type.VALIDATION_FAILED] = hasSublistLineEvent;

		return function hasEvent(event, eventData){
			var func = has[event.type] || function(){return false;};
			return func(event, eventData);
		};
	}());

	function createEventData(events)
	{
		var eventData = {body:{}, sublist:{actual:{}, buffer:{}}, singleton: {}, errors:[], saveRecord:{}};

		events.forEach(function(event){
			processEvent(event, eventData);
		});

		return {
			hasEvent: function (event){ return hasEvent(event, eventData); }
		}
	}

	function cleanEvent(event)
	{
		delete event.oldValue;
		delete event.newValue;

		return event;
	}

	// Fixes Issue 467543: If while filtering the eventData, we encounter multiple inserts in a row, we must ensure
	// all intermediate "creates" are suppressed from being emitted, such that the UI does not accidentally wipe out
	// the previously "inserted" line's values. The only surviving "create" should be the last one which indicates
	// the new line buffer being created. 
	function BatchInsertModeHandler(events)
	{
		var isBatchInserting = getEventsByType(events || [], recordEvent.Type.INSERT_LINE).length > 1;
		var lastCreateEvent = getLastEvent(getEventsByType(events || [], recordEvent.Type.CREATE_LINE));

		function isEventThisType(thisEvent, thisType)
		{
			return !!thisEvent && (thisEvent.type === thisType);
		}

		function getLastEvent(eventList)
		{
			return eventList.slice(eventList.length - 1)[0];
		}

		function getEventsByType(eventList, eventType)
		{
			return eventList.filter(function(event) { return event.type === eventType; });
		}

		function shouldIgnoreEvent(thisEvent, filteredEventList)
		{
			if (!isBatchInserting || filteredEventList.length === 0)
				return false;

			var lastEvent = getLastEvent(filteredEventList);
			var isCreateEvent = isEventThisType(thisEvent, recordEvent.Type.CREATE_LINE);
			var isLastCreateEvent = isCreateEvent && thisEvent === lastCreateEvent;
			var doLineIdsMatch = thisEvent.lineId === lastEvent.lineId;

			return isBatchInserting && isCreateEvent && !isLastCreateEvent && doLineIdsMatch;
		}
		this.shouldIgnore = shouldIgnoreEvent;
	}

	function compress(events)
	{
		var eventData = createEventData(events);
		var batchInsertModeChecker = new BatchInsertModeHandler(events);
		var filteredEvents = events.reduce(function(p, c, i, a){
				if(eventData.hasEvent(c) && !batchInsertModeChecker.shouldIgnore(c, p))
				{
					p.push(cleanEvent(c));
				}
				return p;
			}, []);

		return filteredEvents;
	}

	function noCompress(events)
	{
		return events.map(function(v, i, a){
			return cleanEvent(v);
		});
	}

	return Object.freeze({
		compress: compress,
		noCompress: noCompress
	});
});

/**
 * SuiteScript record definition event module
 *
 * @private
 * @module N/common/record/recordDefinitionEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record/recordDefinitionEvent',['N/record/recordEvent', 'N/record/modelEvent', 'N/record/recordStateControllerEvent', 'N/record/metadataEvent', 'N/record/recordFieldEvent',
		'N/common/record/recordDefinitionEventCompressor', 'N/eventEmitter'],
function (recordEvent, modelEvent, recordStateControllerEvent, metadataEvent, recordFieldEvent,
		recordDefinitionEventCompressor, eventEmitter
){
	var EVENT_TYPE = recordEvent.Type;

	function getEvent(type, record, useInteractiveMode)
	{
		var useInteractive = useInteractiveMode || false;
		return {
			type: type,
			record: record.proxy({isInteractive: useInteractive})
		}
	}

	function addErrorAttribute(obj, error)
	{
		obj.error = error;

		return obj;
	}

	function wrapEmitError(options)
	{
		var record = options.record;    /* This will always be an unproxied recordDefinition instance */
		var func = options.func;
		var emitter = options.emitter;

		return function(){
			var args = arguments;
			var eventToken = null;
			var useCachedSourcing = null;
			if (args.length === 1 && util.isObject(args[0]))
			{
				eventToken = args[0]._eventToken || null;
				useCachedSourcing = util.isBoolean(args[0]._useCachedSourcing) ? args[0]._useCachedSourcing : null;
			}

			return eventEmitter.callWithToken(eventToken, function () {
				var result = undefined;

				if (useCachedSourcing != null) {
					var wasCS = record.useCachedSourcing();
					record.useCachedSourcing(useCachedSourcing);
				}

				try
				{
					result = func.apply(record, args);
				}
				catch(error)
				{
					emitError(emitter, record, error);
					throw error;
				}
				finally
				{
					if (useCachedSourcing != null)
						record.useCachedSourcing(wasCS);
				}
				return result;
			});
		}
	}
	function addSublistLineAttributes_MLB(event, sublistId, line, lineInstanceId)
	{
		if (!!sublistId)
		{
			var isCommitted = false;
			event.sublistId = sublistId;
			event.lineId = lineInstanceId;
			event.line = line;
			event.useLineBuffer = !isCommitted;
		}
		return event;
	}

	function addSublistLineAttributes(event, sublistId, line)
	{
		if (!sublistId)
			return event;

		var onCurrentLine = line === -1 || line === event.record.getCurrentSublistIndex(sublistId);

		event.sublistId = sublistId;
		event.line = line;

		if(onCurrentLine)
		{
			event.lineId = event.record.getCurrentSublistValue({
				sublistId: sublistId,
				fieldId: '_id'
			});
		}
		else
		{
			if (event.record.getCurrentSublistIndex(sublistId) === -1)
				return event;
			event.lineId = event.record.getSublistValue({
				sublistId: sublistId,
				fieldId: '_id',
				line: line
			});
		}
		event.useLineBuffer = onCurrentLine;

		return event;
	}

	function getLineValidationEvent(record, sublistId, line, fields)
	{
		var event = addFieldAttributes(getEvent(EVENT_TYPE.VALIDATION_FAILED, record), fields, sublistId, line);
		return event;
	}


	function wrapEmitValidationError(options)
	{
		var record = options.record;    /* This will always be an unproxied recordDefinition instance */
		var func = options.func;
		var emitter = options.emitter;
		var sublistId = options.sublistId;
		var line = sublistId != null ? record.getCurrentSublistIndex(sublistId) : undefined; // TODO: SCOTTNAK - ahhhh. current
		var fields = options.fieldId ? [{id: options.fieldId}] : [];

		return function(){
			var result = undefined;

			try
			{
				result = func.apply(record, arguments);
			}
			catch(error)
			{
				var messages;
				if (error.hasOwnProperty('validationDetail'))
				{
					if (error.validationDetail.hasOwnProperty('fields'))
						fields = error.validationDetail.fields;
					messages = error.validationDetail.messages;
				}
				var event = addErrorAttribute(getLineValidationEvent(record, sublistId, line, fields), error);
				emitter.emit(event);

				// this object copy is on purpose, so the event compressor does not throw away the alert message with the actual error text
				var errorCopy = Object.create(error);
				if (error.userFacing !==undefined && error.userFacing !== null) {
					errorCopy.userFacing = error.userFacing;
				}
				errorCopy.validationDetail = {};
				var inputs = [['messages', messages], ['fields', fields], ['sublistId', sublistId], ['line', line], ['lineId', event.lineId]];
				inputs.forEach(function(v) { if (v[1] != null) errorCopy.validationDetail[v[0]] = v[1]; });
				throw errorCopy;
			}
			return result;
		}
	}

	function emitError(emitter, record, error)
	{
		emitter.emit(addErrorAttribute(getEvent(EVENT_TYPE.ERROR, record), error));
	}

	function emitUpdateAll(emitter, record)
	{
		emitter.emit(getEvent(EVENT_TYPE.UPDATE_ALL, record));
	}

	//TODO: [MLB] Followup 2E: Re-done without current line, utilizing lineInstanceId instead. Hopefully a good copy. Worth re-factoring after.
	function addFieldAttributes_MLB(event, fieldId, sublistId, line, lineInstanceId)
	{
		var onSublist = !!sublistId;
		var singleMode = !Array.isArray(fieldId);

		if (onSublist)
			event = addSublistLineAttributes_MLB(event, sublistId, line, lineInstanceId);

		event.fieldId = singleMode ? fieldId : fieldId[0] && fieldId[0].id;
		if (singleMode)
			event.field = getField_MLB(fieldId, lineInstanceId);
		else
			event.fields = fieldId.map(function(v) { var res = util.extend({}, v); res.field = getField_MLB(v.id, lineInstanceId); return res; });

		function getField_MLB(fieldId, lineInstanceId)
		{
			if (!onSublist)
				return event.record.getField({fieldId: fieldId});
			else
				return event.record.getLine({sublistId: sublistId, lineInstanceId: lineInstanceId, isCommitted:false}).getField({fieldId: fieldId});
		}

		return event;
	}

	function addFieldAttributes(event, fieldId, sublistId, line)
	{
		var onSublist = !!sublistId;
		var onCurrentLine = onSublist && (line === -1 || line === event.record.getCurrentSublistIndex(sublistId));
		var singleMode = !Array.isArray(fieldId);
		var canGetField = !onSublist || onCurrentLine || event.record.getCurrentSublistIndex(sublistId) !== -1;

		if (onSublist)
			event = addSublistLineAttributes(event, sublistId, line);

		// TODO fieldId can be removed for non-single mode after the UI team starts to fully use event.fields
		event.fieldId = singleMode ? fieldId : fieldId[0] && fieldId[0].id;
		if (singleMode && canGetField)
			event.field = getField(fieldId);
		if (!singleMode)
			event.fields = fieldId.map(function(v) { var res = util.extend({}, v); if (canGetField) res.field = getField(v.id); return res; });

		function getField(fieldId)
		{
			if (!onSublist)
				return event.record.getField({fieldId: fieldId});
			else if (onCurrentLine)
				return event.record.getCurrentSublistField({sublistId: sublistId, fieldId: fieldId});
			else
				return event.record.getSublistField({sublistId: sublistId, fieldId: fieldId, line: line});
		}

		return event;
	}

	function addActionAttributes(event, action, data)
	{
		if (action)
		{
			event.action = action;
			event.data = data;
		}
		return event;
	}

	function emitUpdateFieldOptions(emitter, record, sublistId, fieldId, line, action, data, isMultilineEditable, lineInstanceId)
	{
		var event = getEvent(EVENT_TYPE.UPDATE_FIELD_OPTIONS, record, isMultilineEditable);
		if(!!isMultilineEditable)
		{
			event = addFieldAttributes_MLB(event, fieldId, sublistId, line, lineInstanceId);
		}
		else
		{
			event = addFieldAttributes(event, fieldId, sublistId, line);
		}
		event = addActionAttributes(event, action, data);
		emitter.emit(event);
	}

	var translateModelEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[modelEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.UPDATE_FIELD_VALUE;
		eventTranslations[modelEvent.Type.LINE_SELECT] = EVENT_TYPE.SELECT_LINE;
		eventTranslations[modelEvent.Type.LINE_CREATE] = EVENT_TYPE.CREATE_LINE;
		eventTranslations[modelEvent.Type.LINE_INSERT] = EVENT_TYPE.INSERT_LINE;
		eventTranslations[modelEvent.Type.LINE_UPDATE] = EVENT_TYPE.UPDATE_LINE;
		eventTranslations[modelEvent.Type.LINE_DELETE] = EVENT_TYPE.REMOVE_LINE;
		eventTranslations[modelEvent.Type.LINE_COMMITTABLE] = EVENT_TYPE.LINE_COMMITTABLE;
		eventTranslations[modelEvent.Type.LINE_NOT_COMMITTABLE] = EVENT_TYPE.LINE_NOT_COMMITTABLE;
		eventTranslations[modelEvent.Type.RECORD_SAVABLE] = EVENT_TYPE.RECORD_SAVABLE;
		eventTranslations[modelEvent.Type.RECORD_NOT_SAVABLE] = EVENT_TYPE.RECORD_NOT_SAVABLE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addModelEventDetails(event, modelEvent)
	{
		var onSublist = modelEvent.hasOwnProperty('sublistId');
		var onField = modelEvent.hasOwnProperty('fieldId');

		if(onSublist)
		{
			event.sublistId = modelEvent.sublistId;
			event.lineId = modelEvent.lineId;
			event.line = modelEvent.line;
			event.useLineBuffer = modelEvent.useLineBuffer;
			if (modelEvent.hasOwnProperty("suppressEmit"))
				event.suppressEmit = modelEvent.suppressEmit;
			if (modelEvent.hasOwnProperty("origin"))
				event.origin = modelEvent.origin;
		}

		if(onField) {
			event.fieldId = modelEvent.fieldId;
			if(modelEvent.oldValue !== undefined){ event.oldValue = modelEvent.oldValue; }
			if(modelEvent.newValue !== undefined){ event.newValue = modelEvent.newValue; }
		}

		if (modelEvent.internal)
			event.internal = true;

		return event;
	}

	function translateModelEventToRecordEvent(modelEvent, record)
	{
		return addModelEventDetails(getEvent(translateModelEventTypeToRecordEventType(modelEvent.type), record), modelEvent);
	}

	function forwardModelControllerEvent(record, emitter, modelEvent)
	{
		emitter.emit(translateModelEventToRecordEvent(modelEvent, record));
	}

	function forwardModelControllerEvents(options)
	{
		var record = options.record;
		var emitter = options.emitter;
		var forward = forwardModelControllerEvent.bind(null, record, emitter);

		record.getModelController().on({
			types: [
				modelEvent.Type.FIELD_VALUE_CHANGE,
				modelEvent.Type.LINE_SELECT,
				modelEvent.Type.LINE_CREATE,
				modelEvent.Type.LINE_INSERT,
				modelEvent.Type.LINE_UPDATE,
				modelEvent.Type.LINE_DELETE,
				modelEvent.Type.LINE_COMMITTABLE,
				modelEvent.Type.LINE_NOT_COMMITTABLE,
				modelEvent.Type.RECORD_SAVABLE,
				modelEvent.Type.RECORD_NOT_SAVABLE
			],
			listener: forward
		});
	}

	var translateRecordStateEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = EVENT_TYPE.SUBLIST_IS_HIDDEN_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());


	//TODO: [MLB] Followup 5A: Explicit Use of currentLine / current value to check things. May cause issues. None yet found.
	function addRecordStateEventFieldDetails(event, recordStateEvent)
	{
		var onSublist = recordStateEvent.hasOwnProperty('sublistId');
		var onCurrentLine = onSublist && !!recordStateEvent.currentLine;

		if(onSublist)
		{
			event.sublistId = recordStateEvent.sublistId;
			if(onCurrentLine)
			{
				event.lineId = event.record.getCurrentSublistValue({
					sublistId: recordStateEvent.sublistId,
					fieldId: '_id'
				});
				event.line = recordStateEvent.line;
				event.field = event.record.getCurrentSublistField({
					sublistId: recordStateEvent.sublistId,
					fieldId: recordStateEvent.fieldId
				});
			}
			else
			{
				event.lineId = event.record.getSublistValue({
					sublistId: recordStateEvent.sublistId,
					fieldId: '_id',
					line: recordStateEvent.line
				});
				event.line = recordStateEvent.line;
				event.field = event.record.getSublistField({
					sublistId: recordStateEvent.sublistId,
					fieldId: recordStateEvent.fieldId,
					line: recordStateEvent.line
				});
			}
			event.useLineBuffer = onCurrentLine;
		}
		else
		{
			event.field = event.record.getField({
				fieldId: recordStateEvent.fieldId
			});
		}

		event.fieldId = recordStateEvent.fieldId;
		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventSublistDetails(event, recordStateEvent)
	{
		event.sublistId = recordStateEvent.sublistId;
		event.sublist = event.record.getSublist({
			sublistId: recordStateEvent.sublistId
		});
		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventDetails(event, recordStateEvent)
	{
		function isRecordStateFieldEvent(type)
		{
			return [recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
					recordStateControllerEvent.Type.FIELD_LABEL_CHANGE].indexOf(type) !== -1;
		}

		function isRecordStateSublistEvent(type)
		{
			return [recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE,
					recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE].indexOf(type) !== -1;
		}

		if(isRecordStateFieldEvent(recordStateEvent.type))
		{
			addRecordStateEventFieldDetails(event, recordStateEvent);
		}
		else if(isRecordStateSublistEvent(recordStateEvent.type))
		{
			addRecordStateEventSublistDetails(event, recordStateEvent);
		}

		return event;
	}

	//TODO: [MLB] Followup 5A: Explicit Use of currentLine from event. May cause issues. None yet found.
	function translateRecordStateEventToRecordEvent(recordStateEvent, record)
	{
		record.flushBufferCacheForFieldStateUpdate(recordStateEvent.sublistId, recordStateEvent.fieldId, recordStateEvent.line, recordStateEvent.currentLine);
		return addRecordStateEventDetails(getEvent(translateRecordStateEventTypeToRecordEventType(recordStateEvent.type), record), recordStateEvent);
	}

	function forwardRecordStateEvent(emitter, record, recordStateEvent)
	{
		emitter.emit(translateRecordStateEventToRecordEvent(recordStateEvent, record));
	}

	function forwardRecordStateEvents(emitter, record)
	{
		var recordStateController = record.getRecordStateController();
		var forward = forwardRecordStateEvent.bind(null, emitter, record);

		recordStateController.on({
			types: [
				recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				recordStateControllerEvent.Type.FIELD_LABEL_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE
			],
			listener: forward
		});
	}

	var translateMetadataEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[metadataEvent.Type.FIELD_METADATA_LABEL_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addMetadataEventDetails(event, metadataEvent)
	{
		event.sublistId = metadataEvent.sublistId;
		event.fieldId = metadataEvent.fieldId;
		if(metadataEvent.oldValue !== undefined){ event.oldValue = metadataEvent.oldValue; }
		if(metadataEvent.newValue !== undefined){ event.newValue = metadataEvent.newValue; }

		return event;
	}

	function translateMetadataEventToRecordEvent(metadataEvent, record)
	{
		return addMetadataEventDetails(getEvent(translateMetadataEventTypeToRecordEventType(metadataEvent.type), record), metadataEvent);
	}

	function forwardMetadataEvent(emitter, record, metadataEvent)
	{
		emitter.emit(translateMetadataEventToRecordEvent(metadataEvent, record));
	}

	function forwardMetadataEvents(emitter, record)
	{
		var metadata = record.getMetadata();
		var forward = forwardMetadataEvent.bind(null, emitter, record);

		metadata.on({
			types: [
				metadataEvent.Type.FIELD_METADATA_LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateRecordFieldEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[recordFieldEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.UPDATE_FIELD_VALUE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	//todo: scottnak - currentline status being utilized :/
	function addRecordFieldEventDetails(event, recordFieldEvent, onCurrentLine)
	{
		var onSublist = recordFieldEvent.recordField.getSublistName() !== null;

		if(onSublist)
		{
			var sublistId = recordFieldEvent.recordField.getSublistName();
			var lineNum = recordFieldEvent.recordField.getLine();

			event.sublistId = sublistId;
			if(onCurrentLine)
			{
				event.lineId = event.record.getCurrentSublistValue({
					sublistId: sublistId,
					fieldId: '_id'
				});
				event.line = lineNum;
			}
			else
			{
				event.lineId = event.record.getSublistValue({
					sublistId: sublistId,
					fieldId: '_id',
					line: lineNum
				});
				event.line = lineNum;
			}
			event.useLineBuffer = onCurrentLine;
		}

		event.fieldId = recordFieldEvent.recordField.getName();

		if(recordFieldEvent.hasOwnProperty('error'))
		{
			event.error = recordFieldEvent.error;
		}

		return event;
	}

	function onCurrentLine(recordFieldEvent, record)
	{
		var result = false;
		var sublistId = recordFieldEvent.recordField.getSublistName();
		var fieldId = recordFieldEvent.recordField.getName();
		var onSublist = sublistId !== null;

		if(onSublist)
		{
			result = record.getCurrentCachedRecordField(sublistId, fieldId) === recordFieldEvent.recordField;
		}

		return result;
	}

	//TODO: [MLB] Followup 5A: Explicit Use of currentLine to check things. May cause issues. None yet found.
	function translateRecordFieldEventToRecordEvent(recordFieldEvent, record)
	{
		return addRecordFieldEventDetails(getEvent(translateRecordFieldEventTypeToRecordEventType(recordFieldEvent.type), record), recordFieldEvent, onCurrentLine(recordFieldEvent, record));
	}

	function forwardRecordFieldEvent(emitter, record, recordFieldEvent)
	{
		emitter.emit(translateRecordFieldEventToRecordEvent(recordFieldEvent, record));
	}

	function forwardRecordFieldEvents(emitter, record, recordField)
	{
		var forward = forwardRecordFieldEvent.bind(null, emitter, record);

		recordField.on({
			types: [
				recordFieldEvent.Type.FIELD_VALUE_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type : EVENT_TYPE,
		emitError: emitError,
		emitUpdateAll: emitUpdateAll,
		emitUpdateFieldOptions: emitUpdateFieldOptions,
		forwardModelControllerEvents: forwardModelControllerEvents,
		forwardRecordStateEvents: forwardRecordStateEvents,
		forwardMetadataEvents: forwardMetadataEvents,
		forwardRecordFieldEvents: forwardRecordFieldEvents,
		wrapEmitError: wrapEmitError,
		wrapEmitValidationError: wrapEmitValidationError,
		eventCompress: recordDefinitionEventCompressor.compress,
		eventNoCompress: recordDefinitionEventCompressor.noCompress
	});
});

/**
 * SuiteScript record sublist line definition common module
 *
 * @private
 * @module N/common/record/line/lineDefinition
 * @NApiVersion 2.x
 *
 */
define(
	'N/common/record/line/lineDefinition',['N/record/line/lineProxy', 'N/utilityFunctions', 'N/error',
	 'N/common/record/recordActualWork', 'N/record/line/sublistLineImplementation', 'N/eventEmitter', 'N/common/record/recordDefinitionEvent'],
	function (lineProxy, utilityFunctions, error,
	          recordBehaviorDelegateService, sublistLineImplementation, eventEmitter, recordDefinitionEvent)
	{
		/**
		 * Primary object used to encapsulate a record sublist line object.
		 *
		 * @protected
		 * @param {Object} options
		 * @param {Record} options.unproxiedRecord - Instance of recordDefinition that owns the Line object.
		 * @param {string} options.sublistId
		 * @param {string} options.lineInstanceId
		 * @param {boolean} options.fromBuffer
		 * @param {boolean} options.isReadOnly
		 * @return {Line}
		 * @constructor
		 */
		function Line(options)
		{
			var that = this;
			var exposedLineProxy;
			var lineConstructorOptions = options;
			var lineInstanceId, sublistId, isCommitted, isReadOnly;
			var unproxiedRecord;
			var isInited = false;
			var recordBehaviorDelegate = recordBehaviorDelegateService.create({ delegate: this });
			var implementation;

			lineInstanceId = options.lineInstanceId;
			sublistId = options.sublistId;
			isCommitted = !options.fromBuffer;
			unproxiedRecord = options.unproxiedRecord;
			isReadOnly = !!options.isReadOnly;
			implementation = sublistLineImplementation.create({ isCommitted: isCommitted, line: this});

			(function processOptions(options)
			{
				var isRecordDynamic = !!unproxiedRecord.isDynamic || false;
				var isLineReadOnly = options.isReadOnly || false;

				exposedLineProxy = (function ()
				{
					var proxyCache = null;

					return function ()
					{
						if (!proxyCache)
						{
							var wrappedLine = lineProxy.wrap({
								delegate: that,
								isDynamic: isRecordDynamic,
								isReadOnly: isLineReadOnly
							});
							proxyCache = wrappedLine;
						}
						return proxyCache;
					}.bind(null, that);
				}());

			}(lineConstructorOptions));

			// Disable re-emitting the Record events via the line object if there's no MLB.
			// Enabling with MLB is also questionable as UI listens only to Record events anyway.
			if (unproxiedRecord.isMultilineEditable(sublistId))
			{
				unproxiedRecord.on({
					types: [
						recordDefinitionEvent.Type.ERROR,
						recordDefinitionEvent.Type.UPDATE_FIELD_VALUE,
						recordDefinitionEvent.Type.UPDATE_FIELD_OPTIONS,
						recordDefinitionEvent.Type.CREATE_LINE,
						recordDefinitionEvent.Type.UPDATE_LINE,
						recordDefinitionEvent.Type.INSERT_LINE,
						recordDefinitionEvent.Type.REMOVE_LINE,
						recordDefinitionEvent.Type.SELECT_LINE,
						recordDefinitionEvent.Type.LINE_COMMITTABLE,
						recordDefinitionEvent.Type.LINE_NOT_COMMITTABLE,
						recordDefinitionEvent.Type.FIELD_IS_MANDATORY_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_HIDDEN_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_DISABLED_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_VISIBLE_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_DISPLAY_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
						recordDefinitionEvent.Type.FIELD_LABEL_CHANGE,
						recordDefinitionEvent.Type.VALIDATION_FAILED
					],
					listener: function(event)
					{
						if (event.sublistId === sublistId && event.lineId === lineInstanceId && event.useLineBuffer === !isCommitted)
						{
							emitter.emit(event);
						}
					}
				});
			}

			var emitter = eventEmitter.create({
				eventTypes: Object.keys(recordDefinitionEvent.Type).map(function(v){ return recordDefinitionEvent.Type[v]; }),
				async: typeof setTimeout === 'function',
				blocking: false,
				insulated: true
			});

			function getHack()
			{
				return getUnproxiedRecord();
			}
			this.getHack = getHack;

			function getExposedLineProxy() { return exposedLineProxy; }
			this.getExposedLineProxy = getExposedLineProxy;
			utilityFunctions.addReadOnlyProperty(this, 'proxy', getExposedLineProxy);

			function getLineInstanceId() { return lineInstanceId; }
			this.getLineInstanceId = getLineInstanceId;
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', getLineInstanceId);

			function getSublistId() { return sublistId; }
			this.getSublistId = getSublistId;
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', getSublistId);

			function getSequence() { return unproxiedRecord.getModelController().getSublistLineValueForInstance(sublistId, '_sequence', lineInstanceId, isCommitted); }
			this.getSequence = getSequence;
			utilityFunctions.addReadOnlyProperty(this, 'sequence', getSequence);

			function getRecord() { return unproxiedRecord; }
			this.getRecord = getRecord;
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getUnproxiedRecord() { return unproxiedRecord; }
			this.getUnproxiedRecord = getUnproxiedRecord;

			function getSourcingMetadata(fieldId) {
				return getUnproxiedRecord().getSlavingMetadata(getSublistId(), fieldId);
			}
			this.getSourcingMetadata = getSourcingMetadata;

			function getIsCurrentRecord() {
				return getUnproxiedRecord().getIsCurrentRecord();
			}
			this.getIsCurrentRecord = getIsCurrentRecord;

			function validateTextApi(isTextApi, fieldState, methodName, suggestedMethod)
			{
				getUnproxiedRecord().validateTextApi(isTextApi, fieldState, methodName, suggestedMethod);
			}
			this.validateTextApi = validateTextApi;

			function getFieldLevelMetadataForBodyField(fieldId)
			{
				return getUnproxiedRecord().getFieldLevelMetadataForSublistField(getSublistId(), fieldId);
			}
			this.getFieldLevelMetadataForBodyField = getFieldLevelMetadataForBodyField;

			function isValidBodyField(fieldId)
			{
				return getUnproxiedRecord().isValidSublistField(getSublistId(), fieldId);
			}
			this.isValidBodyField = isValidBodyField;
			
			function getFieldState(fieldId)
			{
				return implementation.getFieldState(fieldId)
			}
			this.getFieldState = getFieldState;

			function setParsedValueAndUpdateFieldState(fieldId, value, fieldState)
			{
				implementation.setParsedValueForBodyField(fieldId, value, fieldState);
				fieldState.isParsed = true;
			}
			this.setParsedValueAndUpdateFieldState = setParsedValueAndUpdateFieldState;


			//TODO remove sublistId once refactor getSetFieldMetadata
			function getSetFieldMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
				return {
					isValidField : isValidBodyField(fieldId),
					isMultiSelect: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeMultiSelect : false,
					isSelect: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeSelect : false,
					isRadio: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeRadio : false,
					isNumeric: !!fieldLevelMetadata ? fieldLevelMetadata.isNumeric : false,
					isCurrency: !!fieldLevelMetadata ? fieldLevelMetadata.isCurrency : false,
					type: !!fieldLevelMetadata ? fieldLevelMetadata.type : null
				};
			}
			this.getSetFieldMetadata = getSetFieldMetadata;

			function extractInforFromFieldLevelMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
				return {
					fieldId: fieldId,
					sublistId: getSublistId(),
					radioSet: !!fieldLevelMetadata ? fieldLevelMetadata.radioSet : false,
					hasBlankString: !!fieldLevelMetadata ? fieldLevelMetadata.hasBlankString : false,
					blankString: !!fieldLevelMetadata ? fieldLevelMetadata.blankString : undefined,
					supplementedOptions: !!fieldLevelMetadata ? fieldLevelMetadata.supplementedOptions : undefined
				}
			}
			this.extractInforFromFieldLevelMetadata = extractInforFromFieldLevelMetadata;


			function cancel()
			{
				recordBehaviorDelegate.cancel();
				return exposedLineProxy();
			}
			this.cancel = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: cancel,
				emitter: emitter
			});

			function commit()
			{
				commitPromise();
				return exposedLineProxy();
			}
			this.commit = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: commit,
				emitter: emitter
			});

			function commitPromise()
			{
				var modelController = unproxiedRecord.getModelController();
				var commitPromise = modelController.getPendingCommitPromise({
					delegateFunction: function() {
						recordBehaviorDelegate.commit();
						return exposedLineProxy();
					},
					unproxiedRecord: unproxiedRecord,
					lineInstanceId: lineInstanceId,
					sublistId: sublistId
				});
				return commitPromise;
			}
			this.commit.promise = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: commitPromise,
				emitter: emitter
			});

			function getFields()
			{
				return recordBehaviorDelegate.getFields();
			}
			this.getFields = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getFields,
				emitter: emitter
			});

			function getField(options)
			{
				return recordBehaviorDelegate.getField(options);
			}
			this.getField = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getField,
				emitter: emitter
			});

			function hasSubrecord(options)
			{
				return recordBehaviorDelegate.hasSubrecord(options);
			}
			this.hasSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: hasSubrecord,
				emitter: emitter
			});

			function getSubrecord(options)
			{
				var subrecord = recordBehaviorDelegate.getSubrecord(options);
				return subrecord;
			}
			this.getSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getSubrecord,
				emitter: emitter
			});

			function removeSubrecord(options)
			{
				recordBehaviorDelegate.removeSubrecord(options);
				return exposedLineProxy();
			}
			this.removeSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: removeSubrecord,
				emitter: emitter
			});

			function getValue(options)
			{
				return recordBehaviorDelegate.getValue(options);
			}
			/**
			 * return value of the field on the line instance
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getValue,
				emitter: emitter
			});

			function doGetValue(fieldId)
			{
				return implementation.doGetValue(fieldId);
			}
			this.doGetValue = doGetValue;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				var delegator = delegator || recordBehaviorDelegate;
				return implementation.getParsedValueForBodyField(fieldId, delegator);
			}
			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function setValue(options)
			{
				recordBehaviorDelegate.setValue(options);
				return exposedLineProxy();
			}
			this.setValue = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: setValue,
				emitter: emitter
			});

			function doSetValue(fieldId, value, fireFieldChange, delegator)
			{
				return implementation.doSetValue(fieldId, value, fireFieldChange, delegator);
			}
			this.doSetValue = doSetValue;

			function getText(options)
			{
				return recordBehaviorDelegate.getText(options);
			}
			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getText,
				emitter: emitter
			});

			function doGetText(fieldId, delegator)
			{
				delegator = delegator || recordBehaviorDelegate;
				return implementation.doGetText(fieldId, delegator);
			}
			this.doGetText = doGetText;

			function setText(options)
			{
				recordBehaviorDelegate.setText(options);
				return exposedLineProxy();
			}
			this.setText = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: setText,
				emitter: emitter
			});

			function doSetText(fieldId, text, fireFieldChange, delegator)
			{
				return implementation.doSetText(fieldId, text, fireFieldChange, delegator);
			}
			this.doSetText = doSetText;

			function doGetField(fieldId, delegator)
			{
				delegator = delegator || recordBehaviorDelegate;
				return implementation.doGetField(fieldId, delegator);
			}
			this.doGetField = doGetField;

			function doGetFields()
			{
				return implementation.doGetFields();
			}
			this.doGetFields = doGetFields;

			function doCommit()
			{
				return implementation.doCommit();
			}
			this.doCommit = doCommit;

			function doCancel()
			{
				return implementation.doCancel();
			}
			this.doCancel = doCancel;

			function doHasSubrecord(fieldId)
			{
				return implementation.hasSubrecord(fieldId);
			}
			this.doHasSubrecord = doHasSubrecord;

			function doGetSubrecord(fieldId)
			{
				return implementation.getSubrecord(fieldId);
			}
			this.doGetSubrecord = doGetSubrecord;

			function doRemoveSubrecord(fieldId)
			{
				return implementation.removeSubrecord(fieldId)
			}
			this.doRemoveSubrecord = doRemoveSubrecord;

			/*
		         * Makes a copy of the line and adds it as a new line.
			 * @returns {Line} reference to new line.
			 */
			function makeCopy()
			{
				return recordBehaviorDelegate.makeCopy()
			}
			this.makeCopy = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: makeCopy,
				emitter: emitter
			});

			function doMakeCopy()
			{
				return implementation.makeCopy()
			}
			this.doMakeCopy = doMakeCopy;

			function on(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('on'));
				emitter.on({
					types: types,
					listener: listener
				});

				return exposedLineProxy();
			}
			this.on = on;

			function off(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('off'));
				emitter.off({
					types: types,
					listener: listener
				});

				return exposedLineProxy();
			}
			this.off = off;

			function toJSON()
			{
				return {
					lineInstanceId : that.instanceId,
					sublistId : that.sublistId,
					fields: unproxiedRecord.getModelController().getSublistLineJSON(that.sublistId, that.instanceId, isCommitted)
				}
			}
			this.toJSON = toJSON;

			function toString()
			{
				return "line.Line";
			}
			this.toString = toString;

			function setIsInited() { isInited = true; }

			function getIsInited() { return isInited; }

			function getMissingArgumentErrorMessageFillerValue(methodName)
			{
				return exposedLineProxy().toString() + '.' + methodName;
			}
			this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

			utilityFunctions.checkArgs([lineInstanceId, sublistId, unproxiedRecord], ['lineInstanceId', 'sublistId', 'unproxiedRecord'], getMissingArgumentErrorMessageFillerValue("Line() constructor"));

			setIsInited();
			return that;
		}

		return Line;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/slaving
 * @suiteScriptVersion 2.x
 */
define('N/util/slaving',['N/utilityFunctions', 'N/record/recordUtilityFunctions'], function(utilityFunctions, recordUtilityFunctions){

slavingUtil =
	function ()
	{
		//noinspection JSUnresolvedVariable
		var MULTISELECT = "multiselect";

		var SlavingMetadataKey = {
			QUERY_URL: "queryurl",
			EDIT:"edit",
			DISPLAY_ONLY:"displayonly",
			AUX_FIELDS:"auxfields",
			MULTILINE:"ln",
			MASTER:"master",
			FIELD_OBJECT: {
				NAME:"name",
				MACHINE:"machine",
				HTML_REF:"htmlReference",
				REQUIRED:"required",
				REQUIRED_SCRIPT:"requiredScript",
				IS_REQUIRED:"isRequired"
			}
		};

		var QueryRequst = {
			URL: "url",
			PAYLOAD: "payload"
		};

		var SlaveResultKey ={
			NAME : 'name',
			MACHINE_NAME : 'machine',
			FIRE_FIELDCHANGE : 'firechange',
			IS_CLIENT_SLAVING: 'isClientSlaving',
			OPTIONS : 'options',
			VALUE : 'value',
			TEXT : 'text',
			NO_OVERRIDE : 'nooverride',
			CONDITION : 'condition'
		};

		function RemoteRecordDelegate(recordDelegate)
		{
			var record = recordDelegate.currentRecord;
			var utilFunctionsFromRecordInstance = recordDelegate.util;
			/* Helper Function for finding option index */
			function getFieldOptionIndexById(options, id)
			{
				for(var i = 0; i < options.length; i++)
				{
					if(options[i].id == id)
						return i;
				}
				return -1;
			}

			function getFieldOptions() { return utilFunctionsFromRecordInstance.getFieldOptions(); }
			function setFieldNoSlaving(fieldInfo, noslaving)
			{
				utilFunctionsFromRecordInstance.setFieldNoSlaving(fieldInfo.machineName, fieldInfo.fieldName, fieldInfo.lineNum, noslaving);
			}
			function isMultilineEditable(machineName)
			{
				return utilFunctionsFromRecordInstance.isMultilineEditable(machineName);
			}
			function getValue(params)
			{
				var value = "";
				if(params.isMachineField === true)
				{
					if(!!params.lineInstanceId)
					{
						var isCommitted = false;
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, params.lineInstanceId, isCommitted);
					}
					else if(params.ln && params.ln !== -1)
					{
						value = record.getSublistLineValueAsLegacyString(params.machineName, params.fieldName, params.ln);
						value = value === null || value === undefined ? "" : value;
					}
					else
					{
						value = record.getCurrentSublistLineValueAsLegacyString(params.machineName, params.fieldName);
					}
				}
				else if(params.isMultiSelectField)
					value = record.getValueAsLegacyStringArray(params.fieldName);
				else
					value = record.getValueAsLegacyString(params.fieldName);

				return recordUtilityFunctions.emptyIfNullOrUndefined(value);
			}
			function setValue(params, value, fireFieldChange, isClientSlaving)
			{
				var noslaving = isClientSlaving ? false : true;
				if(params.isMachineField === true)
					record.doSetCurrentSublistFieldValue(params.machineName, params.fieldName, value, fireFieldChange, noslaving, true, true);
				else if(params.isMultiSelectField)
					record.doSetFieldValue(params.fieldName, value, fireFieldChange, noslaving, true, true);
				else
					record.doSetFieldValue(params.fieldName, value, fireFieldChange, noslaving, true, true);
			}
			function setSelectValue(params, value, text, fireFieldChange)
			{
				if(!value && value !== '')
				{
					if(params.isMachineField === true)
						record.doSetCurrentSublistText(params.machineName, params.fieldName, text, fireFieldChange, true, true);
					else
						record.doSetText(params.fieldName, value, fireFieldChange, true, true);
				}
				else
					setValue(params, value, fireFieldChange);
			}
			function getFieldOptionFromCache(params)
			{
				if(getFieldOptions() !== null && !(getFieldOptions().get(params.machineName, params.fieldName, params.lineNum)))
					putFieldOptionInCache(params, []);

				return getFieldOptions().get(params.machineName, params.fieldName, params.lineNum);
			}
			function putFieldOptionInCache(params, obj)
			{
				getFieldOptions().put(params.machineName, params.fieldName, params.lineNum, obj);
			}
			function removeOption(params, value)
			{
				var options = getFieldOptionFromCache(params);
				if(options.length > 0)
				{
					if(value || value === 0)
					{
						var idx = getFieldOptionIndexById(options, value);
						options.splice(idx,1);
					}
					else
					{
						options.splice(0, options.length);
					}
					putFieldOptionInCache(params, options);
				}
			}
			function insertOption(params, value, text)
			{
				var options = getFieldOptionFromCache(params);
				if(options && options instanceof Array)
				{
					options.push({ text:text, id:value });
					putFieldOptionInCache(params, options);
				}
			}

			this.setFieldNoSlaving = setFieldNoSlaving;
			this.isMultilineEditable = isMultilineEditable;
			this.getValue = getValue;
			this.setValue = setValue;
			this.setSelectValue = setSelectValue;
			this.removeOption = removeOption;
			this.insertOption = insertOption;
			this.isEditableSublist = utilFunctionsFromRecordInstance.isEditableSublist;
			this.isFieldMultiSelect = utilFunctionsFromRecordInstance.isFieldMultiSelect;
			this.returnEmptyIfNull = utilityFunctions.returnEmptyIfNull;
			this.isValEmpty = utilityFunctions.isValEmpty;

			this.getCurrentLineItemIndex = function(sublist){ return record.getCurrentSublistIndex({sublistId: sublist});};
			this.triggerPostSourcing = utilFunctionsFromRecordInstance.postSourcing;
			this.eval = record.runLegacyScript;
		}

		function BrowserRecordDelegate()
		{
			function setFieldNoSlaving(fieldInfo, noslaving)
			{
				var field = getFieldObject(fieldInfo);
				if(field)
					field.noslaving = noslaving;
			}
			function getFieldObject(params)
			{
				if(params.isMachineField === true)
					return nlapiGetLineItemField(params.machineName, params.fieldName, params.lineNum);
				else
					return nlapiGetField(params.fieldName);
			}
			function getValue(params)
			{
				var value = "";
				if(params.isMachineField === true)
				{
					if(!!params.lineInstanceId)
					{
						var isCommitted = false;
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, params.lineInstanceId, isCommitted);
					}
					else if(params.ln)
						value = utilityFunctions.returnEmptyIfNull(nlapiGetLineItemValue(params.machineName, params.fieldName, params.ln));
					else
						value = nlapiGetCurrentLineItemValue(params.machineName, params.fieldName);
				}
				else if(params.isMultiSelectField)
					value = nlapiGetFieldValues(params.fieldName);
				else
					value = nlapiGetFieldValue(params.fieldName);

				return value;
			}
			function setValue(params, value, fireFieldChange)
			{
				if(params.isMachineField === true)
					nlapiSetCurrentLineItemValue(params.machineName, params.fieldName, value, fireFieldChange, true);
				else if(params.isMultiSelectField)
					nlapiSetFieldValues(params.fieldName, value, fireFieldChange, true);
				else
					nlapiSetFieldValue(params.fieldName, value, fireFieldChange, true);
			}
			function setSelectValue(params, value, text, fireFieldChange)
			{
				if(params.isMachineField === true)
					nlapiSetCurrentLineItemSelectValue(params.machineName, params.fieldName, value, text, fireFieldChange, getSlavingAsync());
				else
					nlapiSetSelectValue(params.fieldName, text, fireFieldChange, getSlavingAsync());
			}
			function insertSelectOption(fieldName, value, text)
			{
				var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fieldName)] != null ? document.forms[ftabs[getFieldName(fieldName)]+'_form'] : document.forms[0];
				doInsertSelectOption(form, fieldName, text, value);
			}
			function insertLineItemOption(machineName, fieldName, value, text)
			{
				var form = document.forms[machineName+'_form'];
				doInsertSelectOption(form, fieldName, text, value);
			}
			function doInsertSelectOption(form, fieldName, text, value)
			{
				var fld = getFormElement( form, getFieldName(fieldName) );
				if (fld != null)
					addSelectOption( document, fld, text, value );
			}
			function removeSelectOption(fieldName, value)
			{
				var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fieldName)] != null ? document.forms[ftabs[getFieldName(fieldName)]+'_form'] : document.forms[0];
				doRemoveSelectOption(form, fieldName, value);
			}

			function removeLineItemOption(machineName, fieldName, value)
			{
				var form = document.forms[machineName+'_form'];
				doRemoveSelectOption(form, fieldName, value);
			}
			function doRemoveSelectOption(form, fieldName, value)
			{
				var fld = getFormElement( form, getFieldName(fieldName) );
				if (fld != null)
				{
					if(value != null)
						deleteOneSelectOption( fld, value );
					else
						deleteAllSelectOptions( fld, window );
				}
			}
			function removeOption(params, value)
			{
				if(params.isMachineField === true)
					removeLineItemOption(params.machineName, params.fieldName, value);
				else
					removeSelectOption(params.fieldName, value)
			}
			function insertOption(params, value, text)
			{
				if(params.isMachineField === true)
					insertLineItemOption(params.machineName, params.fieldName, value, text);
				else
					insertSelectOption(params.fieldName, value, text)
			}
			function isFieldMultiSelect(sublistId, fieldId, line)
			{
				var field = getFieldObject({isMachineField: !!sublistId, machineName: sublistId, fieldName: fieldId, lineNum: line});
				return field ? field.getType() === MULTISELECT : false;
			}

			this.setFieldNoSlaving = setFieldNoSlaving;
			this.getValue = getValue;
			this.setValue = setValue;
			this.setSelectValue = setSelectValue;
			this.removeOption = removeOption;
			this.insertOption = insertOption;
			this.isEditableSublist = isEditMachine;
			this.isFieldMultiSelect = isFieldMultiSelect;
			this.serverCall = nsServerCall;
			this.returnEmptyIfNull = emptyIfNull;
			this.isValEmpty = isValEmpty;

			this.getCurrentLineItemIndex = nlapiGetCurrentLineItemIndex;
			this.eval = eval;
		}

		/**
		 * getQueryRequest - static util function which transform metadata and dynamic recordDelegate context to query request
		 * object
		 *
		 * @param metadata - slaving metadata for current field
		 * @param masterInfo - a js object with 'queryFieldName', 'queryFieldValue', 'lineNum', 'fieldspec'
		 * @param recordDelegate - recordDelegate scope for client object. It should be null for Browser
		 * @returns {*}
		 */
		function getQueryRequest(metadata, masterInfo, recordDelegate)
		{
			var IS_EDIT = 'e';
			var RECORD_ID = 'id';
			var QUERY_PARAMETER_NAME = 'q';
			var QUERY_PARAMETER_VALUE = 'si';
			var MACHINE_NAME = 'machine';
			var QUERYREQUEST_SLAVING_FIELD = 'f';
			var LIST_MACHINE_LINE_NUMBER = 'ln';

			var RecordDelegate = (recordDelegate) ? new RemoteRecordDelegate(recordDelegate) : new BrowserRecordDelegate();
			var isBrowserRequest = (recordDelegate) ? false : true;
			var lineNum = masterInfo.hasOwnProperty('lineNum') && masterInfo.lineNum != null ? masterInfo.lineNum : null;
			var lineInstanceId = masterInfo.hasOwnProperty('lineInstanceId') && masterInfo.lineInstanceId != null ? masterInfo.lineInstanceId : null;
			var sublistName = masterInfo.sublistId || masterInfo.sublistName;
			var result = cleanupQueryURL(metadata[SlavingMetadataKey.QUERY_URL]);
			var url = result[QueryRequst.URL];
			var payload = result[QueryRequst.PAYLOAD];

			// adding id and edit flag
			if (metadata[SlavingMetadataKey.EDIT] === 'T')
			{
				var id = (recordDelegate ? recordDelegate.currentRecord.id : RecordDelegate.getValue({fieldName: 'id'}));
				if(id || id === 0)
					payload[RECORD_ID] = String(id);
				if (metadata[SlavingMetadataKey.DISPLAY_ONLY] !== 'T')
					payload[IS_EDIT] = 'T';
			}
			// adding q and si
			payload[QUERY_PARAMETER_NAME] = masterInfo['queryFieldName'];
			payload[QUERY_PARAMETER_VALUE] = masterInfo['queryFieldValue'];
			if(sublistName)
				payload[MACHINE_NAME] = sublistName;
			if(masterInfo['fieldspec'].length != 0)
				payload[QUERYREQUEST_SLAVING_FIELD] = masterInfo['fieldspec'];
			// adding ln -- list machine field only
			if (metadata[SlavingMetadataKey.MULTILINE] === 'T' && lineNum > 0 )
				payload[LIST_MACHINE_LINE_NUMBER] = String(lineNum);

			// adding aux fields params
			var valid = addAuxFieldValueToPayloadAndReturnFalseWhenInvalid(isBrowserRequest, metadata, lineNum, lineInstanceId, payload, RecordDelegate);
			if(!valid)
				return null;
			// adding master of query field
			addMasterValueToPayload(metadata, lineNum, payload, RecordDelegate);

			return { url : url, payload : payload /* all value should be String */};
		}
		/*
		 * Description: helper function to add aux field value to payload for field query request
		 */
		function addAuxFieldValueToPayloadAndReturnFalseWhenInvalid(isBrowserRequest, metadata, lineNum, lineInstanceId, payload, RecordDelegate)
		{
			var auxfields = metadata[SlavingMetadataKey.AUX_FIELDS];
			for (var idx = 0; auxfields && idx < auxfields.length; idx++)
			{
				var auxfld = auxfields[idx];
				var fieldName = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.NAME) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.NAME] : "";
				var machineName = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.MACHINE) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.MACHINE] : null;
				var htmlReference = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.HTML_REF) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.HTML_REF] : null;
				var fieldValue = RecordDelegate.getValue({isMachineField: machineName !== null, machineName: machineName, fieldName: fieldName, ln: lineNum, lineInstanceId: lineInstanceId});

				if(isBrowserRequest && !fieldValue && fieldValue !== 0 && fieldValue !== "")
					fieldValue = eval(htmlReference);

				if(auxfld[SlavingMetadataKey.FIELD_OBJECT.REQUIRED] === 'T' && isInvalidRequiredAuxField(isBrowserRequest, auxfld, fieldValue))
					return false;

				payload['si_'+fieldName] = fieldValue;
			}

			return true;
		}
		/*
		 * Description: helper function to add master value of the query field to payload for field query request
		 */
		function addMasterValueToPayload(metadata, lineNum, payload, RecordDelegate)
		{
			if (metadata[SlavingMetadataKey.MASTER] && metadata[SlavingMetadataKey.MASTER] !== '')
			{
				var fld = metadata[SlavingMetadataKey.MASTER];
				var masterFieldName = fld[SlavingMetadataKey.FIELD_OBJECT.NAME];
				var machineName = fld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.MACHINE) ? fld[SlavingMetadataKey.FIELD_OBJECT.MACHINE] : null;
				// adding master value
				payload['si_' + masterFieldName] = RecordDelegate.getValue({isMachineField: machineName !== null, machineName: machineName, fieldName: masterFieldName, ln: lineNum});
			}
		}

		/*
		 * Description: helper function to separate the base url into url and payload
		 */
		function cleanupQueryURL(url)
		{
			var payload = {};
			if(url.indexOf("?") !== -1)
			{
				var list = url.split("?");
				url = list[0];
				if(list[1].length >0)
				{
					var params = list[1].split("&");

					for(var i=0; i < params.length; i++)
					{
						//noinspection JSUnfilteredForInLoop
						if(params[i].length >0)
						{
							//noinspection JSUnfilteredForInLoop
							var pair = params[i].split("=");
							payload[pair[0]] = String(pair[1]);
						}
					}
				}
			}
			return { url : url, payload : payload };
		}

		function isInvalidRequiredAuxField(isBrowserRequest, field, value)
		{
			var requiredScriptCondition = true;
			if (isBrowserRequest && field.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.REQUIRED_SCRIPT))
				requiredScriptCondition = ( eval(field[SlavingMetadataKey.FIELD_OBJECT.REQUIRED_SCRIPT]) ) ? true : false;
			else if(field.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.IS_REQUIRED) && field.isRequired)
				requiredScriptCondition = true;

			var isValidValue = (value && value.length != 0) ? true : false;

			return requiredScriptCondition && !isValidValue;
		}

		function getURL(metadata, masterInfo)
		{
			var requestObj = getQueryRequest(metadata, masterInfo, undefined /* no remote record context required */);
			var fullUrl = requestObj['url'];
			var payload = requestObj['payload'];
			if(fullUrl.indexOf('?') == -1)
			{
				fullUrl+='?';
			}
			var first = true;
			for(var key in payload)
			{
				if(!first)
					fullUrl+='&';
				else
					first = false;

				if(key.indexOf('si_')===0 || key==='q' || key==='si' || key==='id')
					fullUrl = fullUrl+key+'='+encodeURIComponent(emptyIfNull(payload[key])) ;
				else
					fullUrl = fullUrl+key+'='+emptyIfNull(payload[key]) ;
			}

			return fullUrl;
		}

		function addEscaping(value)
		{
			value= value.replace(/\\/g, "\\\\");
			value= value.replace(/'/g, "\\\'");
			value= value.replace(/"/g, "\\\"");
			return value;
		}

		/**
		 * static function that verifies that slaving data sent from server using new format are the same that were set by legacy
		 * code. fields parameter is needed so we call verify before slaving script execution as fields can be modified by slave
		 * script.
		 * @param fields  fields that need to be checked on the current level
		 * @param slavingValues array of all slaving values
		 */
		function verifySlavingValues(fields,slavingValues)
		{
			try{
				for(var j = 0; fields && j < fields.length; j++)
				{
					for (var idx = 0; slavingValues && idx < slavingValues.length; idx++)
					{
						var slaveInfo = slavingValues[idx];
						if(isFunction(slaveInfo))
						{
							continue;
						}
						if(slaveInfo['name'] != fields[j][0] || (slaveInfo['machine']!= null && slaveInfo['machine']!= fields[j][1] || slaveInfo['machine'] == null && fields[j][1] != ""))
							continue;
						var options = slaveInfo["options"];
						var fld = nlapiGetLineItemField(slaveInfo["machine"],slaveInfo["name"]);
						if(slaveInfo["machine"] != null)
						{
							if(options != null)
							{
								var legacyValues = getLineItemOptionValues(slaveInfo["machine"],slaveInfo["name"],fld.type);
								var legacyTexts = getLineItemOptionTexts(slaveInfo["machine"],slaveInfo["name"],fld.type);
								if(legacyValues.length != options.length)
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Length mismatch',
										'Options length do not match. Field name:' + slaveInfo['name'] +' ,path = '+  window.location.pathname]);
								else
								{
									for( var i= 0; options && i <options.length; i++)
									{
										var option = options[i];
										// need to take care of escape character difference
										var legacyValue= addEscaping(legacyValues[i]);
										var legacyText= addEscaping(legacyTexts[i]);
										// some options have extra CR in legacy ignoring it
										legacyText = legacyText.replace('\n','');


										if(option[0] != legacyValue)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving value do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[0] +' legacyValue = ' + legacyValues[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
										if(option[1] != legacyText)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving text do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[1] +' legacyValue = ' + legacyTexts[i]  +' ,path = '+  window.location.pathname]);
										   break;
										}
									}
								}

							}

							// don't know the old value (before slaving)
							// so can not check values for this case.
							if(slaveInfo["nooverride"] != null)
							{
								continue;
							}
							if(slaveInfo["condition"] != null)
								if(!eval(slaveInfo["condition"]))
									continue;
							// need to take care of escape character difference
							var oldvalue = nlapiGetCurrentLineItemValue(slaveInfo["machine"],slaveInfo["name"]);
							oldvalue= addEscaping(oldvalue);

							if(slaveInfo["value"] != null && slaveInfo["value"] != oldvalue  )
							{
								nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
									'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo["value"]+', actualValue  = ' + oldvalue +' ,path = '+  window.location.pathname]);

							}
							if(slaveInfo["text"] != null)
							{
								// need to take care of escape character difference
								var oldtext = nlapiGetCurrentLineItemText(slaveInfo["machine"],slaveInfo["name"]);
								oldtext= addEscaping(oldtext);

								if(slaveInfo["text"] != oldtext)
								{
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl',
											'logSlavingError',['Json Value mismatch',
												'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['text'] +', actualValue  = ' + oldtext +' ,path = '+ window.location.pathname]);

								}
							}
						}
						else
						{
							// need to take care of escape character difference

							var oldvalue = nlapiGetFieldValue(slaveInfo["name"]);
							oldvalue=  addEscaping(oldvalue);

							var options = slaveInfo["options"];
							var fld = nlapiGetField(slaveInfo["name"]);
							if(options != null)
							{
								var legacyValues = getOptionValues(slaveInfo["name"], fld.type);
								var legacyTexts = getOptionTexts(slaveInfo["name"],fld.type);

								if(legacyValues.length != options.length)
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Length mismatch',
										'Options length do not match. Field name:' + slaveInfo['name']  +' ,path = '+  window.location.pathname]);
								else
								{
									for( var i= 0; options && i <options.length; i++)

									{
										var option = options[i];
										var legacyValue=  addEscaping(legacyValues[i]);
										var legacyText= addEscaping(legacyTexts[i]);
										// some options have extra CR in legacy ignoring it
										legacyText = legacyText.replace('\n','');

										if(option[0] != legacyValue)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving value do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[0] +' legacyValue = ' + legacyValues[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
										if(option[1] != legacyText)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving text do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[1] +' legacyValue = ' + legacyText[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
									}
								}
							}
							// don't know the old value (before slaving)
							// so can not check values for this case.
							if(slaveInfo["nooverride"] != null)
							{
								continue;
							}
							if(slaveInfo["condition"] != null)
								if(!eval(slaveInfo["condition"]))
									continue;

							if(slaveInfo["value"] != null && slaveInfo["value"] != oldvalue  )
							{
								nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
									'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['value'] +', actualValue  = ' + oldvalue +' ,path = '+
																																	window.location.pathname]);

							}
							if(slaveInfo["text"] != null)
							{
								// need to take care of escape character difference
								var oldtext = nlapiGetFieldText(slaveInfo["name"]);
								oldtext= addEscaping(oldtext);;

								if(slaveInfo["text"] != oldtext)
								{
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
										'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['text'] +', actualValue  = ' + oldtext +' ,path = '+
										window.location.pathname]);
								}
							}
						}
					}
				}
			}
			catch(err)
			{
				nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Excepion in verifying values', err.msg +' ,path = '+	  window.location.pathname]);
			}
		}

		function isFunction(obj)
		{
			return Object.prototype.toString.call(obj) === '[object Function]';
		}

		/**
		 * static utility function that process the slavingResponse data in the json format and sets the data in the DOM using
		 * Nlapi when possible.
		 * @param slavingValues
		 * @param record
		 */
		function processSlavingValues(slavingValues, record)
		{
			var RecordDelegate = (record) ? new RemoteRecordDelegate(record) : new BrowserRecordDelegate();
			for (var idx = 0; slavingValues && idx < slavingValues.length; idx++)
			{
				var slaveResult = slavingValues[idx];
				var fieldName = slaveResult[SlaveResultKey.NAME];
				var isMachineField = slaveResult.hasOwnProperty(SlaveResultKey.MACHINE_NAME);
				var machineName = (isMachineField) ? slaveResult[SlaveResultKey.MACHINE_NAME] : null;
				var lineNum = (isMachineField) ? RecordDelegate.getCurrentLineItemIndex(machineName) : -1;
				var fieldInfo = {isMachineField: isMachineField, machineName: machineName, fieldName: fieldName, lineNum: lineNum};
				fieldInfo.isMultiSelectField = RecordDelegate.isFieldMultiSelect(machineName, fieldName, lineNum);

				if(isFunction(slaveResult))
				{
					slaveResult(RecordDelegate);
					continue;
				}

				if(isMachineField && lineNum === -1 && RecordDelegate.isMultilineEditable(machineName))
				{
					if (!!console && !!console.warn)
						console.warn("Slaving was called on a Multiline Editable Sublist, but there is no current index available! Slaving IGNORED");
					continue;
				}

				try
				{
					applySlaveValueToRecord(RecordDelegate, slaveResult, fieldInfo);
				}
				catch(err)
				{
					if(RecordDelegate instanceof BrowserRecordDelegate)
						RecordDelegate.serverCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Excepion in processing values', err.msg +',path =  '+  ((record)? "" : window.location.pathname)]);
					else
						throw err;
					// this will allow the code to proceed further even if there is an error in slaving
					// we probably need to do something here rather than fail silently
				}
				finally
				{
					if(record == null)
						RecordDelegate.setFieldNoSlaving(fieldInfo, false);
				}
			}
		}

		function applySlaveValueToRecord(RecordDelegate, slaveResult, fieldInfo)
		{
			var fireFieldChangeEvent = slaveResult.hasOwnProperty(SlaveResultKey.FIRE_FIELDCHANGE);
			var isClientSlaving = slaveResult.hasOwnProperty(SlaveResultKey.IS_CLIENT_SLAVING);

			RecordDelegate.setFieldNoSlaving(fieldInfo, !fireFieldChangeEvent);

			var options = slaveResult[SlaveResultKey.OPTIONS];
			if(options)
			{
				var oldValue = RecordDelegate.getValue(fieldInfo);

				var isOldValueInOptions = false;
				RecordDelegate.removeOption(fieldInfo); // clear all options
				for(var j = 0; j < options.length; j++)
				{
					var option = options[j];
					RecordDelegate.insertOption(fieldInfo, option[0], option[1]);
					if(oldValue === option[0])
						isOldValueInOptions = true;
				}

				var preserveOriginalValueWhenOptionSlavingOnly = (RecordDelegate.isValEmpty(slaveResult[SlaveResultKey.VALUE]) && !RecordDelegate.isValEmpty(oldValue) && isOldValueInOptions);
				if(preserveOriginalValueWhenOptionSlavingOnly)
					RecordDelegate.setValue(fieldInfo, oldValue, false);
			}

			/* skip slaving when there is old value */
			if(slaveResult[SlaveResultKey.NO_OVERRIDE] != null && !RecordDelegate.isValEmpty(RecordDelegate.getValue(fieldInfo)))
				return;

			/* skip slaving when condition is not met */
			var slavingCondition = typeof slaveResult[SlaveResultKey.CONDITION] === 'boolean' ? slaveResult[SlaveResultKey.CONDITION] : RecordDelegate.eval(slaveResult[SlaveResultKey.CONDITION]);
			if(slaveResult.hasOwnProperty(SlaveResultKey.CONDITION) && !slavingCondition)
				return;

			if(slaveResult.hasOwnProperty(SlaveResultKey.TEXT))
				RecordDelegate.setSelectValue(fieldInfo, slaveResult[SlaveResultKey.VALUE], slaveResult[SlaveResultKey.TEXT], fireFieldChangeEvent, isClientSlaving);
			else if(slaveResult.hasOwnProperty(SlaveResultKey.VALUE))
				RecordDelegate.setValue(fieldInfo, slaveResult[SlaveResultKey.VALUE],  fireFieldChangeEvent, isClientSlaving);
		}


		/**
		 * redraws edit machines in case new slaving response is used.
		 * @param machinedata
		 */
		function redrawEditMachines(machinedata)
		{
			for (var machineName in machinedata)
			{

				var slaveMachineData =  machinedata[machineName];

				if( slaveMachineData['edit'] != null && (slaveMachineData["nooverride"] == null || document.forms[0].elements['next' + machineName  + 'idx'].value == 1))
				{
					var data = slaveMachineData['data'];
					var strValue='';
					for (var i = 0; data && i < data.length; i++)
					{
						var row = data[i];
						for (var j = 0; row && j < row.length; j++)
						{
							if(strValue != '')
								strValue += String.fromCharCode(1);
							strValue +=row[j];
						}
						if(i != data.length -1)
							strValue += String.fromCharCode(2);
					}
					document.forms[0].elements[machineName+'data'].value=strValue;
					clearLineArray(name);

					document.forms[0].elements['next'+ machineName  + 'idx'].value=data==null?1:data.length+1;
					document.forms[0].elements[machineName+'valid'].value='T';
					setMachineContentUpdated(machineName, true);
					clearLineArray(name);
					if (parent.document.forms.main_form.elements[machineName+'loaded'] != null) parent.document.forms.main_form.elements[machineName+'loaded'].value = 'T';
					if (parent.document.forms.main_form.elements[machineName+'dotted'] != null) parent.document.forms.main_form.elements[machineName+'dotted'].value = 'T';
					if(window[machineName+'_machine'] != null)
					{
						window[machineName+'_machine'].refresheditmachine(true);

						window[machineName+'_machine'].recalc();
					}
					var tabTD = parent.document.getElementById(machineName+'lnkdot');
					if (tabTD != null) { tabTD.style.display='';}
				}
				if(isFunction(slaveMachineData['metadata']))
				{
					slaveMachineData['metadata'].call();
					continue;
				}
			}
		}

		function getOptionValues(fldnam,type)
		{
			var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)]+'_form'] : document.forms[0];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).getValues();
				else
					return getDropdown(fld,window).getValues();
			else
				return null;
		}
		function getOptionTexts(fldnam,type)
		{
			var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)]+'_form'] : document.forms[0];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).textArray;
				else
					return getDropdown(fld,window).getTexts();
			else
				return null;
		}
		function getLineItemOptionValues(machine,fldnam, type)
		{
			var form = document.forms[machine+'_form'];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).getValues();
				else
					return getDropdown(fld,window).getValues();
			else
				return null;
		}
		function getLineItemOptionTexts(machine,fldnam, type)
		{
			var form = document.forms[machine+'_form'];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).textArray;
				else
					return getDropdown(fld,window).getTexts();
			else
				return null;
		}

		return {
				cleanupQueryURL: cleanupQueryURL,
				getQueryRequest: getQueryRequest,
				getURL: getURL,
				processSlavingValues:processSlavingValues,
				verifySlavingValues:verifySlavingValues,
				redrawEditMachines:redrawEditMachines
			};
	}();

if (typeof Object.freeze == 'function')
	slavingUtil = Object.freeze(slavingUtil);

    return slavingUtil;});

/**
 * @private
 */
define('N/restricted/localizationApiBridge',['N/restricted/reflet'], function(reflet){ return util.extend({bridge :'localizationApiBridge'}, reflet); });

/**
 * SuiteScript localization module
 *
 * @module N/localization
 * @suiteScriptVersion 2.x
 *
 */

define('N/localization',['N/restricted/localizationApiBridge', 'N/restricted/invoker', 'N/utilityFunctions'],
	function (localizationApi, invoker, utilityFunctions)
	{

		function guessContext(options)
		{
			var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
			return invoker(localizationApi, "guessContext", [recordType], utilityFunctions.isPromiseCallback(this) ? this : undefined);
		}

		guessContext.promise = function()
		{
			return utilityFunctions.promiseTo(
				guessContext, arguments, function(options){
					return options.result;
				});
		};

		function getContext(options, fields)
		{
			var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
			var significantFields = (options && options.hasOwnProperty('fields')) ? options.fields : fields;
			return invoker(localizationApi, "getContext", [recordType, JSON.stringify(significantFields)], utilityFunctions.isPromiseCallback(this) ? this : undefined);
		}

		getContext.promise = function()
		{
			return utilityFunctions.promiseTo(
				getContext, arguments, function(options){
					return options.result;
				});
		};

		function getSignificantFields(options)
		{
			var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
			return invoker(localizationApi, "getSignificantFields", [recordType], utilityFunctions.isPromiseCallback(this) ? this : undefined);
		}

		getSignificantFields.promise = function()
		{
			return utilityFunctions.promiseTo(
				getSignificantFields, arguments, function(options){
					return options.result;
				});
		};

		return Object.freeze({
			guessContext: guessContext,
			getContext: getContext,
			getSignificantFields: getSignificantFields
		});
	});

/**
 * SuiteScript module
 *
 * This is the localization context implementation for both legacy DOM current record and dynamic record
 *
 * @private
 * @module N/localeContext
 * @NApiVersion 2.x
 */
define('N/localeContext',['N/localization'], function(localizationService) {

	function LocaleContextHandler(options) {
		if (!options || !options.hasOwnProperty('recordType'))
			throw "Invalid argument options: " + options;
		var recordType = options.recordType;
		var localeObject = (util.isString(options.defaultLocale) ? JSON.parse(options.defaultLocale) : options.defaultLocale) || {};
		var activeLocale = null;
		var targetLocale = null;
		var loadScriptsForLocale;
		var localizationContextEnter;
		var localizationContextExit;
		var initialized = false;
		var fields = localeObject.fields || [];  //body fields
		var pendingChangeCalls = [];

		// initialize target locale to default
		setTargetLocale(localeObject.country || null);

		/**
		 * Function to initialize the callbacks needed to perform the context change.
		 * Each of the callback is expected to return a promise
		 *
		 * @public
		 * @param {Object} options
		 * @param {function} options.localizationContextEnter
		 * @param {function} options.localizationContextExit
		 * @param {function} options.loadScriptsForLocale
		 */
		function setupCallbacks(options) {
			if (!options
				|| !util.isFunction(options.localizationContextEnter)
				|| !util.isFunction(options.localizationContextExit)
				|| !util.isFunction(options.loadScriptsForLocale))
			{
				throw "Invalid argument options: " + options;
			}
			if (!initialized) {
				loadScriptsForLocale = options.loadScriptsForLocale;
				localizationContextEnter = options.localizationContextEnter;
				localizationContextExit = options.localizationContextExit;
				initialized = true;
			}
		}

		function getActiveLocale() { return activeLocale || null; }

		function clearActiveLocale() { activeLocale = null; }

		function getTargetLocale() { return targetLocale || null; }

		function setTargetLocale(locale) {
			if (locale != null && !(util.isString(locale) || util.isArray(locale)))
				throw "Invalid argument locale: " + locale;
			if (util.isString(locale))
				targetLocale = locale.split(',');
			else if (util.isArray(locale))
				targetLocale = locale.length > 0 ? locale : null;
			else
				targetLocale = locale;
			if (!targetLocale || !targetLocale.length)
				targetLocale = null;
		}

		function syncActiveLocale() { activeLocale = targetLocale; }

		function getLocaleFields() { return fields.slice(); }

		function shouldCheckForLocaleChange(sublistId, fieldId) {
			return !sublistId && fields.indexOf(fieldId) > -1;
		}

		function localizedScriptLimit() {
			return localeObject.limit || null;
		}

		function getSignificantFieldValueMap(getter)
		{
			// so far we expect only body fields to drive context
			return (fields || []).reduce(function(result, fieldId) {
				result[fieldId] = getter(fieldId); return result;
			}, {});
		}

		/**
		 * Function to check whether the locale should be changed or not.
		 * Once the new locale is decided the localization context change is triggered.
		 * Currently only body fields can trigger context change.
		 *
		 * @public
		 * @param {Object} options
		 * @param {String} options.fieldId
		 * @param {String} [options.sublistId]
		 * @param {function} options.valueGetter
		 */
		function checkLocaleAndTriggerContextChange(options)
		{
			if (!options || !options.fieldId || !util.isFunction(options.valueGetter))
				throw "Invalid arguments options: " + options;

			if (!shouldCheckForLocaleChange(options.sublistId, options.fieldId)) {
				return;
			}

			function onSuccess(result) {
				pendingChangeCalls.pop();
				if (pendingChangeCalls.length === 0 && result !== getTargetLocale()) {
					setTargetLocale(result);
					_localizationContextChange();
				}
			}
			function onError(error) {
				pendingChangeCalls = [];
				throw error;
			}

			var fieldValues  = getSignificantFieldValueMap(options.valueGetter);
			pendingChangeCalls.push(fieldValues);
			localizationService.getContext.promise(recordType, fieldValues).then(onSuccess, onError);
		}

		function _localizationContextChange() {
			var targetLocale = getTargetLocale();
			if (getActiveLocale() === targetLocale || !localizationContextExit)
				return; // nothing to do

			localizationContextExit(targetLocale).then(function exitCurrentLocale(result) {
				if (result && result.executed) {
					clearActiveLocale(); // no locale should be active after exit
					loadScriptsForLocale(targetLocale).then(function reloadScriptsForNewLocale(result) {
						localizationContextEnter(targetLocale).then(function enterNewLocale(result) {
							if (result && result.executed && targetLocale === getTargetLocale())
							{
								// we're done here
								syncActiveLocale();
							}
							else
							{
								// enter didn't finish correctly or locale changed so start over
								triggerLocalizationContextChange();
							}
						});
					});
				}
				else
				{
					// exit didn't finish correctly or locale changed so start over
					triggerLocalizationContextChange();
				}
			});
		}

		/**
		 * Triggers the localizationContextExit and localizationContextEnter
		 * in case target locale differs from actual.  To be called after pageInit.
		 *
		 * @public
		 */
		function triggerLocalizationContextChange() {
			if (typeof setTimeout !== "undefined")
				setTimeout(_localizationContextChange, 0);
			else
				_localizationContextChange();
		}

		return ({
			getActiveLocale: getActiveLocale,
			getTargetLocale: getTargetLocale,
			getLocaleFields: getLocaleFields,
			checkLocaleAndTriggerContextChange: checkLocaleAndTriggerContextChange,
			setupCallbacks: setupCallbacks,
			triggerLocalizationContextChange: triggerLocalizationContextChange,
			localizedScriptLimit: localizedScriptLimit
		});
	}

	return {
		createLocaleContext: function (options) { return new LocaleContextHandler(options); }
	}
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/readOnlyRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/readOnlyRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * ReadOnly Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @returns {ReadOnlyRecord} (proxied record.Record)
		 * @constructor* @since 2016.2
		 */
		function ReadOnlyRecord(delegate, isInteractive, isCurrentRecord)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros.bind(null, this);

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro (@see Macro) specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro.bind(null, this);

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = delegate.executeMacro.bind(null, this);

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = delegate.executeMacro.promise.bind(null, this);

			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return delegate.id; });

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (ReadOnlyRecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.RECORD_MODE.READ_ONLY_RECORD;};
			if (isCurrentRecord)
				this.toString = function () {return constants.CURRENT_RECORD_MODE.READ_ONLY_CURRENT_RECORD;};

			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * @name Action
			 * @function
			 * @param {Object} params
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 */

			/**
			 * Provides available record actions for this record instance.
			 * @returns {Object} a set of actions (@see Action) defined on the record type indexed by action ID
			 */
			this.getActions = delegate.getActions;
			/**
			 * Returns an executable record action for this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @returns {?Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.getAction = delegate.getAction;
			/**
			 * Executes record action and returns its result. Record ID and type is automatically taken from this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @param {Object} [options.params] action arguments
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeAction = delegate.executeAction;

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = delegate.getSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {boolean}
			 */
			this.hasSublistSubrecord = delegate.hasSublistSubrecord;

			/**
			 * get the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record} [requested subrecord]
			 */
			this.getSublistSubrecord = function getSublistSubrecord()
			{
				var subrecord = delegate.getSublistSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/* If we are being asked to create a proxy wrapper for the current record, add/remove these methods. */
			if (isCurrentRecord)
			{
				/* Strip out and do not expose these methods on the wrapper when the underlying implementation lacks them (DomCurrentRecord). */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
				{
					delete(this.toJSON);
					delete(this.getFields);
					delete(this.getSublists);
					delete(this.getSublistFields);
				}
			}


			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/* Nothing shoukd ever try to wrap the DOM current record as interactive, as the underlying support isn't there. */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);

				/**
				 * return true if record is read-only.
				 * @name Record#isReadOnly
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isReadOnly', function () { return true; });

				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				/**
				 * get query url and parameters
				 * @name Record#query
				 * @type Object
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'query', function getQuery() { return delegate.query; });

				this.getLine = delegate.getLine;

				this.getLines = function(options)
				{
					util.extend(options, {isCommitted: true}); // force set isCommitted to true in ReadOnlyRecords.
					return delegate.getLines(options);
				}
				this.getLinesIterator = delegate.getLinesIterator;

				/**
				 * Call restricted method.
				 * @param {Object} options
				 * @param {Object} options.token  token required for access to restricted methods
				 * @param {string} options.methodName  name of the method to invoke
				 * @param {Array} options.args  (optional) arguments to pass to the method
				 */
				Object.defineProperty(this, 'callRestrictedMethod', {
					get: function ()
					{
						return delegate.callRestrictedMethod;
					}
				});
			}

			return this;
		}

		ReadOnlyRecord.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlyRecord);

		return ReadOnlyRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/deferredDynamicRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/deferredDynamicRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = This should NEVER be true because it's not supported for current record to be deferred-dynamic.
		 * @returns {DeferredDynamicRecord} (proxied record.Record)
		 * @constructor
		 */
		function DeferredDynamicRecord(delegate, isInteractive, isCurrentRecord)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/* Nothing should ever try to wrap the current record as deferred dynamic, because it is an unsupported case that should never occur. */
			if (isCurrentRecord)
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return delegate.id; });

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */
			this.save = delegate.save;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DeferredDynamicRecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.RECORD_MODE.DEFERRED_DYNAMIC_RECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {string[]}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				delegate.setValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 *
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				delegate.setText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				var line = delegate.insertLine.apply(delegate, arguments);
				var sublistId = arguments[0]? (arguments[0].sublistId? arguments[0].sublistId : arguments[0]) : null;
				if (delegate.isMultilineEditable(sublistId))
					return line;
				else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * set the value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistValue = function setSublistValue()
			{
				delegate.setSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * set the value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistText = function setSublistText()
			{
				delegate.setSublistText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = delegate.getSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 */
			this.removeSubrecord = function removeSubrecord()
			{
				delegate.removeSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {boolean}
			 */
			this.hasSublistSubrecord = delegate.hasSublistSubrecord;

			/**
			 * get the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record} [requested subrecord]
			 */
			this.getSublistSubrecord = function getSublistSubrecord()
			{
				var subrecord = delegate.getSublistSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record}
			 */
			this.removeSublistSubrecord = function removeSublistSubrecord()
			{
				delegate.removeSublistSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * set the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixHeaderValue = function setMatrixHeaderValue()
			{
				delegate.setMatrixHeaderValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * set the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixSublistValue = function setMatrixSublistValue()
			{
				delegate.setMatrixSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;
			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/* This is added server-side only. It comes from server implementation of N/record/recordService */
			if (delegate._addToTemplateRenderer)
				this._addToTemplateRenderer = delegate._addToTemplateRenderer;

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				/**
				 * Save record updates to the system and return object with additional information about the saved record.
				 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
				 *
				 * @param {Object} options
				 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
				 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
				 * @returns {Object} contains id of submitted record
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'saveAndFetch', function getFunc_saveAndFetch() { return delegate.saveAndFetch; });

				this.getLine = delegate.getLine;
				this.getLines = delegate.getLines;
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		DeferredDynamicRecord.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicRecord);

		return DeferredDynamicRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/dynamicRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/dynamicRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @returns {DynamicRecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function DynamicRecord(delegate, isInteractive, isCurrentRecord)
		{
			function augmentWithInteractive(args)
			{
				return utilityFunctions.augmentArguments(args, "isInteractive", isInteractive)
			}

			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros.bind(null, this);

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro (@see Macro) specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro.bind(null, this);

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = delegate.executeMacro.bind(null, this);

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise =  delegate.executeMacro.promise.bind(null, this);

			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return delegate.id; });

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */
			this.save = delegate.save;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DynamicRecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.RECORD_MODE.DYNAMIC_RECORD;};
			if (isCurrentRecord)
				this.toString = function () {return constants.CURRENT_RECORD_MODE.CURRENT_RECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {string[]}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				delegate.setValue.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				delegate.setText.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				var line = delegate.insertLine.apply(delegate, arguments);
				var sublistId = arguments[0]? (arguments[0].sublistId? arguments[0].sublistId : arguments[0]) : null;
				if (delegate.isMultilineEditable(sublistId))
					return line;
				else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or field is missing
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * cancel the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 * @restriction only available in dynamic record
			 */
			this.cancelLine = function cancelLine()
			{
				delegate.cancelLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * commit the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 * @restriction only available in dynamic record
			 */
			this.commitLine = function commitLine()
			{
				delegate.commitLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * select line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 * @restriction only available in dynamic record
			 */
			this.selectLine = function selectLine()
			{
				var line = delegate.selectLine.apply(delegate, arguments);
				var sublistId = arguments[0]? (arguments[0].sublistId? arguments[0].sublistId : arguments[0]) : null;
				if (delegate.isMultilineEditable(sublistId))
    					return line;
				else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * select a new line at the end of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 * @restriction only available in dynamic record
			 */
			this.selectNewLine = function selectNewLine()
			{
				var line = delegate.selectNewLine.apply(delegate, arguments);
				var sublistId = arguments[0]? (arguments[0].sublistId? arguments[0].sublistId : arguments[0]) : null;
				if (delegate.isMultilineEditable(sublistId))
    					return line;
				else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistValue = delegate.getCurrentSublistValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * set the value for field in the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistValue = function setCurrentSublistValue()
			{
				delegate.setCurrentSublistValue.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistText = delegate.getCurrentSublistText;

			/**
			 * return value of a sublist field in text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 * @restriction only available in dynamic record
			 */
			this.setCurrentSublistText = function setCurrentSublistText()
			{
				delegate.setCurrentSublistText.apply(delegate, augmentWithInteractive(arguments));
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number of current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistIndex = delegate.getCurrentSublistIndex;

			/**
			 * return a value indicating if the field has a subrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = function getSubrecord()
			{
				var subrecord = delegate.getSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 */
			this.removeSubrecord = function removeSubrecord()
			{
				delegate.removeSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @returns {boolean}
			 */
			this.hasSublistSubrecord = delegate.hasSublistSubrecord;

			/**
			 * return a value indicating if the associated sublist field has a subrecord on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 * @restriction only available in dynamic record
			 */
			this.hasCurrentSublistSubrecord = delegate.hasCurrentSublistSubrecord;

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistSubrecord = function getCurrentSublistSubrecord()
			{
				var subrecord = delegate.getCurrentSublistSubrecord.apply(delegate, arguments);
				return !subrecord ? null : subrecord.proxy(proxyOptions);
			};

			/**
			 * remove the subrecord for the associated sublist field on the current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @restriction only available in dynamic record
			 */
			this.removeCurrentSublistSubrecord = function removeCurrentSublistSubrecord()
			{
				delegate.removeCurrentSublistSubrecord.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record's sublist current line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @restriction only available in dynamic record
			 */
			this.getCurrentSublistField = delegate.getCurrentSublistField;

			/**
			 * set the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixHeaderValue = function setMatrixHeaderValue()
			{
				delegate.setMatrixHeaderValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the associated header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * get the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * set the value for the associated field in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Record}
			 */
			this.setMatrixSublistValue = function setMatrixSublistValue()
			{
				delegate.setMatrixSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * set the value for the line currently selected in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @returns {Record}
			 */
			this.setCurrentMatrixSublistValue = function setCurrentMatrixSublistValue()
			{
				delegate.setCurrentMatrixSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get the value for the line currently selected in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 * @restriction only available in dynamic record
			 */
			this.getCurrentMatrixSublistValue = delegate.getCurrentMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/**
			 * Notes about the callback passed to on() and off():
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback eventCallback
			 * @param {Object} event
			 */

			/**
			 * Start listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} same record
			 */
			this.on = function on()
			{
				delegate.on.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * Stop listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} same record
			 */
			this.off = function off()
			{
				delegate.off.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * Call restricted method.
			 * @param {Object} options
			 * @param {Object} options.token  token required for access to restricted methods
			 * @param {string} options.methodName  name of the method to invoke
			 * @param {Array} options.args  (optional) arguments to pass to the method
			 */
			Object.defineProperty(this, 'callRestrictedMethod', {
				get: function ()
				{
					return delegate.callRestrictedMethod;
				}
			});

			/* This is added server-side only. It comes from server implementation of N/record/recordService */
			if (delegate._addToTemplateRenderer)
				this._addToTemplateRenderer = delegate._addToTemplateRenderer;

			/* If we are being asked to create a proxy wrapper for the current record, add/remove these methods. */
			if (isCurrentRecord)
			{
				/* Strip out and do not expose these methods on the wrapper when the underlying implementation lacks them (DomCurrentRecord). */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
				{
					delete(this.save);
					delete(this.toJSON);
					delete(this.removeField);
					delete(this.getFields);
					delete(this.getSublists);
					delete(this.getSublistFields);
					delete(this.getCurrentSublistField);
					delete(this.on);
					delete(this.off);
					delete(this._addToTemplateRenderer);
				}
			}

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/* Nothing shoukd ever try to wrap the DOM current record as interactive, as the underlying support isn't there. */
				if (delegate.toString() === constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD)
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);

				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				/**
				 * copy the current line of the sublist to the new line
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @returns {Record | Line}
				 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
				 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
				 */
				this.copyLine = function copyLine()
				{
					var line = delegate.copyLine.apply(delegate, arguments);
					return !!line ? line : delegate.proxy(proxyOptions);
				};

				/**
				 * get query url and parameters
				 * @name Record#query
				 * @type Object
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'query', function getQuery() { return delegate.query; });

				/**
				 * Save record updates to the system and return object with additional information about the saved record.
				 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
				 *
				 * @param {Object} options
				 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
				 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
				 * @returns {Object} contains id of submitted record
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'saveAndFetch', function getFunc_saveAndFetch() { return delegate.saveAndFetch; });

				this.getLine = delegate.getLine;
				this.getLines = delegate.getLines;
				this.getLinesIterator = delegate.getLinesIterator;

				/**
				 * Creates a new line to the specified sublist and adds it to the end of the sublist sequentially.
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @return {Line} the Line object that was created.
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
				 */
				this.addNewLine = delegate.addNewLine;

			}

			return this;
		}

		DynamicRecord.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicRecord);

		return DynamicRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/readOnlySubrecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/readOnlySubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentSubrecord = (optional) true if we are proxy-wrapping to create subrecord for a current record object.
		 * @returns {ReadOnlySubrecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function ReadOnlySubrecord(delegate, isInteractive, isCurrentSubrecord)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return null; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return null; });

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = function getMacros()
			{
				return delegate.getMacros();
			};

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = function getMacro(options)
			{
				return delegate.getMacro(options);
			};

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = function executeMacro(options)
			{
				return delegate.executeMacro(options, isInteractive);
			};

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = function executeMacroPromise(options)
			{
				return delegate.executeMacro.promise(options, isInteractive);
			};

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (ReadOnlySubrecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.SUBRECORD_MODE.READ_ONLY_SUBRECORD;};
			if (isCurrentSubrecord)
				this.toString = function () { return constants.CURRENT_SUBRECORD_MODE.READ_ONLY_CURRENT_SUBRECORD;};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {string[]}
			 */
			this.getFields = delegate.getFields;

			/**
			 * return array of names of all sublists
			 * @returns {string[]}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist﻿
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {string[]}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined﻿
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array|boolean}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array|boolean}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * return value of a sublist field in text representation﻿
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}﻿
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is read-only.
				 * @name Record#isReadOnly
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isReadOnly', function () { return true; });

				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				this.getLine = delegate.getLine;
				this.getLines = delegate.getLines;
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		ReadOnlySubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlySubrecord);

		return ReadOnlySubrecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/deferredDynamicSubrecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/deferredDynamicSubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/environment'],
	function (nsobject, constants, utilityFunctions, environment)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {Record} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @returns {DeferredDynamicSubrecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function DeferredDynamicSubrecord(delegate, isInteractive)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return null; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return null; });

			/**
			 * return true if record is a dynamic record
			 * @name Subrecord#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DeferredDynamicSubrecord)
			 * @returns {string}
			 */
			this.toString = function () {return constants.SUBRECORD_MODE.DEFERRED_DYNAMIC_SUBRECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {Array}
			 */
			this.getFields = delegate.getFields;

			/**
			 * return array of names of all sublists
			 * @returns {Array}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist﻿
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined﻿
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				delegate.setValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 *
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				delegate.setText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = delegate.getSublistField;

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid﻿ or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				var line = delegate.insertLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid﻿ or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			this.getSublistValue = delegate.getSublistValue;

			/**
			 * set the value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {number|Date|string|Array} options.value
			 * @returns {Record}﻿
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistValue = function setSublistValue()
			{
				delegate.setSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field in text representation﻿
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}﻿
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			this.getSublistText = delegate.getSublistText;

			/**
			 * set the value of a sublist field in text representation﻿
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @returns {Record}﻿
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			this.setSublistText = function setSublistText()
			{
				delegate.setSublistText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

				this.getLine = delegate.getLine;
				this.getLines = delegate.getLines;
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		DeferredDynamicSubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicSubrecord);

		return DeferredDynamicSubrecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/dynamicSubrecord
 * @suiteScriptVersion 2.x
 */
define('N/record/proxy/dynamicSubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error', 'N/environment'],
	function (nsobject, constants, utilityFunctions, error, environment)
	{
		/**
		 * Dynamic Record interface (with the interactive API)
		 * @param {Record} (recordDefinition.Record)
		 * @returns {Record} (proxied record.Record)
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @constructor
		 * @since 2015.2
		 */
		function DynamicSubrecord(delegate, isInteractive)
		{
			var proxyOptions = Object.freeze({isInteractive: isInteractive});

			var that = this;

			/* This check is needed for every API, but only for dynamic subrecord. */
			function validateIfSubrecordIsDereferencedFromParent()
			{
				if (delegate.isDereferencedFromParent && delegate.isDereferencedFromParent())
					utilityFunctions.throwSuiteScriptError(error.Type.OPERATION_IS_NOT_ALLOWED);
			}

			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name Record#id
			 * @type number
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function getId() { return null; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name Record#type
			 * @type string
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function getType() { return null; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = function getMacros()
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getMacros(that);
			};

			/**
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = function getMacro(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getMacro(that, options);
			};

			/**
			 * performs macro operation and returns result
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = function executeMacro(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.executeMacro(that, options);
			};

			/**
			 * same as excuteMacro but returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro.promise = function executeMacroPromise(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.executeMacro.promise(that, options);
			};

			/**
			 * return true if record is a dynamic record
			 * @name Subrecord#isDynamic
			 * @type boolean
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function getIsDynamic() { return delegate.isDynamic; });

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (record.DynamicSubrecord)
			 * @returns {string}
			 */
			this.toString = function(){ return constants.SUBRECORD_MODE.DYNAMIC_SUBRECORD;};

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.removeField = function removeField()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.removeField.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @returns {Array}
			 */
			this.getFields = function getFields()
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getFields();
			};

			/**
			 * returns the specified sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [sublist, or null if sublist not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = function getSublist(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublist(options);
			};

			/**
			 * return array of names of all sublists
			 * @returns {Array}
			 */
			this.getSublists = function getSublists()
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublists();
			};

			/**
			 * return array of names of all fields in a sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = function getSublistFields(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistFields(options);
			};

			/**
			 * return value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getValue = function getValue(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getValue(options);
			};

			/**
			 * set value of the field
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setValue = function setValue()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getText = function getText(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getText(options);
			};

			/**
			 * set value of the field by text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setText = function setText()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return field object from record
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = function getField(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getField(options);
			};

			/**
			 * return field object from record's sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			this.getSublistField = function getSublistField(options, fieldId, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistField(options, fieldId, line);
			};

			/**
			 * return line count of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = function getLineCount(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getLineCount(options);
			};

			/**
			 * insert a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = function insertLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				var line = delegate.insertLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * remove a sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = function removeLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.removeLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {number}
			 */
			this.findSublistLineWithValue = function findSublistLineWithValue(options, fieldId, value)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.findSublistLineWithValue(options, fieldId, value);
			};

			/**
			 * cancel the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 */
			this.cancelLine = function cancelLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.cancelLine.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * commit the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			this.commitLine = function commitLine(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.commitLine(options);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * select line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 */
			this.selectLine = function selectLine(options, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				var line = delegate.selectLine(options, line);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * select a new line at the end of sublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 */
			this.selectNewLine = function selectNewLine()
			{
				validateIfSubrecordIsDereferencedFromParent();
				var line = delegate.selectNewLine.apply(delegate, arguments);
/*deleteme*/	if (isInteractive)
/*deleteme*/		return line;
/*deleteme*/	else
					return delegate.proxy(proxyOptions);
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			this.getCurrentSublistValue = function getCurrentSublistValue(options, fieldId)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getCurrentSublistValue(options, fieldId);
			};

			/**
			 * return value of a sublist field
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistValue = function getSublistValue(options, fieldId, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistValue(options, fieldId, line);
			};

			/**
			 * set the value for field in the current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistValue = function setCurrentSublistValue()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setCurrentSublistValue.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			this.getCurrentSublistText = function getCurrentSublistText(options, fieldId)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getCurrentSublistText(options, fieldId);
			};

			/**
			 * return value of a sublist field in text representation?
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}?
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			this.getSublistText = function getSublistText(options, fieldId, line)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getSublistText(options, fieldId, line);
			};

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {Record}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			this.setCurrentSublistText = function setCurrentSublistText()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.setCurrentSublistText.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * return the line number of current selected line
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getCurrentSublistIndex = function getCurrentSublistIndex(options)
			{
				validateIfSubrecordIsDereferencedFromParent();
				return delegate.getCurrentSublistIndex(options);
			};

			/**
			 * validate the subrecord
			 * @returns {Record}
			 */
			this.validate = function validate()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.validate.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * copy the subrecord inorder to perform cancellable actions
			 * @returns {Record}
			 */
			this.clone = function clone()
			{
				validateIfSubrecordIsDereferencedFromParent();
				var clone = delegate.clone.apply(clone, arguments);
				return clone.proxy(proxyOptions);
			};

			/**
			 * merge changes into original subrecord
			 * @returns {Record}
			 */
			this.merge = function merge()
			{
				validateIfSubrecordIsDereferencedFromParent();
				delegate.merge.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback eventCallback
			 * @param {Object} event
			 */

			/**
			 * Start listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} record
			 */
			this.on = function on()
			{
				delegate.on.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/**
			 * Stop listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {Record} record
			 */
			this.off = function off()
			{
				delegate.off.apply(delegate, arguments);
				return delegate.proxy(proxyOptions);
			};

			/* If we are being asked to create a proxy wrapper for interactive mode, add the interactive-only API's. */
			if (isInteractive)
			{
				/**
				 * copy the current line of the sublist to the new line
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @returns {Record}
				 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
				 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
				 */
/*
                // Re-enable after fixing Issue 481847        
				this.copyLine = function copyLine()
				{
					validateIfSubrecordIsDereferencedFromParent();
					delegate.copyLine.apply(delegate, arguments);
					return delegate.proxy(proxyOptions);
				};
*/
				/**
				 * return true if record is being seen in interactive mode.
				 * @name Record#isInteractive
				 * @type boolean
				 * @readonly
				 * @throws READ_ONLY when setting the property is attempted
				 */
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return true; });

            	this.getLine = function getLine()
            	{
            		validateIfSubrecordIsDereferencedFromParent();
            	    return delegate.getLine.apply(delegate, arguments);
            	};
				
				this.getLines = function getLines()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getLines.apply(delegate, arguments);
				}

				//
				// !!@TODO - write properly formed JSDoc here for this new MLB API
				//
				this.getLinesIterator = function getLines()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.getLinesIterator.apply(delegate, arguments);
				}

				/**
				 * Creates a new line to the specified sublist and adds it to the end of the sublist sequentially.
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @return {Line} the Line object that was created.
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
				 */
				this.addNewLine = function()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.addNewLine.apply(delegate, arguments);
				};

				/**
				 * same as commitLine, but returns a Promise
				 * @param {Object} options
				 * @param {string} options.sublistId
				 * @returns {Object} a promise with the record object
				 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
				 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
				 */
				this.commitLine.promise = function commitLine()
				{
					validateIfSubrecordIsDereferencedFromParent();
					return delegate.commitLine.promise(delegate, arguments, proxyOptions);
				};
			}

			return this;
		}

		DynamicSubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicSubrecord);

		return DynamicSubrecord;
	});

/**
 * SuiteScript record proxy module.
 *
 * Creates a wrapper around the record that selectively exposes the record interface.
 *
 * @private
 * @module N/record/recordProxy
 * @NApiVersion 2.x
 */
define(
	'N/record/recordProxy',['N/utilityFunctions', 'N/record/recordConstants', 'N/error',
		'N/record/proxy/readOnlyRecord', 'N/record/proxy/deferredDynamicRecord', 'N/record/proxy/dynamicRecord',
		'N/record/proxy/readOnlySubrecord', 'N/record/proxy/deferredDynamicSubrecord', 'N/record/proxy/dynamicSubrecord', 'N/environment'],
	function (utilityFunctions, constants, error,
		ReadOnlyRecord, DeferredDynamicRecord, DynamicRecord,
		ReadOnlySubrecord, DeferredDynamicSubrecord, DynamicSubrecord, environment)
	{
		/**
		 * returns a record  proxy based on the input configuration
		 *
		 * @param options
		 * @param {Record} options.delegate = the actual underlying record instance (from recordDefinition)
		 * @param {boolean} options.isReadOnly = true if the record instance is read only instance
		 * @param {boolean} options.isSubrecord = true if the record instance is a subrecord
		 * @param {boolean} options.isDynamic = true if the record instance is a dynamic record
		 * @param {boolean} options.isInteractive = true if the record instance is an interactive record
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @return {ReadOnlyRecord|DeferredDynamicRecord|DynamicRecord|ReadOnlySubrecord|DeferredDynamicSubrecord|DynamicSubrecord} (proxied
		 *     record.Record)
		 */
		function wrap(options, isCurrentRecord)
		{
			var wrappedRecord;
			var record = options.delegate;
			var isReadOnly = !!options.isReadOnly;
			var isSubrecord = !!options.isSubrecord;
			var isDynamic = !!options.isDynamic;
			var isInteractive = !!options.isInteractive;

			if (isReadOnly)
			{
				wrappedRecord = isSubrecord ? new ReadOnlySubrecord(record, isInteractive, isCurrentRecord) : new ReadOnlyRecord(record, isInteractive, isCurrentRecord);
			}
			else if (!isDynamic)
			{
				wrappedRecord = isSubrecord ? new DeferredDynamicSubrecord(record, isInteractive, isCurrentRecord) : new DeferredDynamicRecord(record, isInteractive, isCurrentRecord);
			}
			else if (isDynamic)
			{
				wrappedRecord = isSubrecord ? new DynamicSubrecord(record, isInteractive, isCurrentRecord) : new DynamicRecord(record, isInteractive, isCurrentRecord);
			}
			else
			{
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
			}

			Object.freeze(wrappedRecord);

			return wrappedRecord;
		}

		/**
		 * These are the signatures of other underlying record implementations (other than recordDefinition)
		 * that can be wrapped.
		 * @param kind
		 * @returns {boolean}
		 */
		function isKindToAlwaysWrap(kind)
		{
			return constants.ALL_RECORD_UNDERLYING_IMPL_NAMES.indexOf(kind) >= 0;
		}

		/**
		 * These are other known names of a the proxy of an already wrapped record. Don't try to re-wrap tham.
		 * @param kind
		 * @returns {boolean}
		 */
		function isKindToNeverWrap(kind)
		{
			return constants.ALL_RECORD_PROXY_NAMES.indexOf(kind) >= 0;
		}

		/*
		 * We do this to be double-proxy resilient. Check if the the record is already a correct record proxy.
		 * If so, caller should not try to proxy it.
		 */
		function alreadyIsProxy(options)
		{
			var record = options.delegate;
			var kind = record.toString();

			/* For better performance, we do these checks as early as possible when proxying is or isn't needed. */
			if (isKindToAlwaysWrap(kind))
			{
				return false;
			}
			if (isKindToNeverWrap(kind))
			{
				return true;
			}

			/* If we get here, we assume the object is a wrappable pseudo-record, probably created by a unit test.
			 * We will let the caller try to wrap it.*/
			return false;
		}

		function supportsInteractiveApi(options)
		{
			if (!!options.isClientRecord)
			{
				if (!!options.isCurrentRecord)
				{
					return environment.isNewUI();
				}
				else
				{
					return environment.isDebug();
				}
			}
			else
			{
				return false;
			}
		}

		/**
		 * Method used to get a user-facing, sealed proxy of the recordDefinition.
		 *
		 * @param {boolean} proxyOptions.isInteractive = true to get back a record object whose record API has the new, interactive
		 *     API.
		 */
		function proxy(proxyCache, proxyDelegate, recordCreationOptions, proxyOptions)
		{
			var recordProxyOptions = util.extend({}, recordCreationOptions);
			recordProxyOptions.delegate = proxyDelegate;
			recordProxyOptions.isInteractive = false;
			if (supportsInteractiveApi(recordCreationOptions))
			{
				// get isInteractive from the calling context if interactive mode is supported
				if (proxyOptions && proxyOptions.hasOwnProperty('isInteractive'))
				{
					recordProxyOptions.isInteractive = proxyOptions.isInteractive;
				}
				else
				{
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, 'recordProxy#proxy', 'proxyOptions.isInteractive');
				}
			}
			else
			{
				recordProxyOptions.isInteractive = false;
			}
			return proxyCache.getCachedRecordInterfaceProxy(recordProxyOptions);
		}

		/**
		 * Initialize a proxy cache for a given record instance and initial recordOptions
		 * @param {Record} proxyDelegate - instance of underlying record implementation
		 * @param {Object} recordOptions - options used to create the record instance
		 * @return {Function} proxy
		 */
		function initProxyCache(proxyDelegate, recordOptions)
		{
			return proxy.bind(null, new RecordInterfaceProxyCache(), proxyDelegate, recordOptions);
		}

		/**
		 * Cache of all unique proxy instances for a given record delegate
		 * @return {Object}
		 */
		function RecordInterfaceProxyCache()
		{
			var proxyCache = [];

			/**
			 * @param options = Record API expression options
			 * @param {Record} options.delegate underlying record implementation
			 * @param {boolean} options.isSubrecord = true if the record instance is a subrecord
			 * @param {boolean} options.isReadOnly = true if the record instance is read only instance
			 * @param {boolean} options.isDynamic = true if the record instance is a dynamic record
			 * @param {boolean} options.isInteractive = true if the record API to be used for dynamic mode is the new, interactive
			 *     API
			 * @param {boolean} options.isCurrentRecord = true if the record is the current record of the page
			 */
			function getCachedRecordInterfaceProxy(options)
			{
				var isReadOnly = options.isReadOnly || false;
				var isSubrecord = options.isSubrecord || false;
				var isDynamic = options.isDynamic || false;
				var isInteractive = options.isInteractive || false;
				var isCurrentRecord = options.isCurrentRecord || false;
				var unproxiedRecord = options.delegate;

				var wrapOptions = {
					delegate: unproxiedRecord,
					isReadOnly: isReadOnly,
					isSubrecord: isSubrecord,
					isDynamic: isDynamic,
					isInteractive: isInteractive
				};

				if (alreadyIsProxy(wrapOptions))
				{
					return unproxiedRecord;
				}

				var cacheKey = isReadOnly + ':'
					+ isSubrecord + ':'
					+ isDynamic + ':'
					+ isInteractive + ':'
					+ isCurrentRecord;

				var wrappedRecord = proxyCache[cacheKey];
				if (!wrappedRecord)
				{
					wrappedRecord = wrap(wrapOptions, isCurrentRecord);
					proxyCache[cacheKey] = wrappedRecord;
				}
				return wrappedRecord;
			}

			return {
				getCachedRecordInterfaceProxy: getCachedRecordInterfaceProxy
			};

		}

		return Object.freeze({
			initialize: initProxyCache,
			supportsInteractiveApi: supportsInteractiveApi
		});
	}
);

/**
 * SuiteScript RelatedRecord module
 * @private Ignore for JSDoc stub generation
 * @module N/record/relatedRecord
 * @NApiVersion 2.x
 *
 */
define('N/record/relatedRecord',['N/restricted/remoteApiBridge', 'N/restricted/invoker','N/error', 'N/nsobject', 'N/util/slaving', 'N/pagination/paginationObject', 'N/utilityFunctions', 'N/format'],
       function (remoteApi, invoker, error, nsobject, slaving, paginationObject, utilityFunctions, format){

    var SORTING_DIRECTION = ["ASC", "DESC"];
    var freezeObjectIfPossible = utilityFunctions.freezeObjectIfPossible;

    var LINK_TYPE = Object.freeze({
        NONE: "NONE",
        REGULAR: "REGULAR",
        POPUP: "POPUP"
    });

    /**
     * Data model for search result machine
     *
     * @protected
     * @param {Object} options
     * @return {RelatedRecord}
     * @constructor
     */
    function RelatedRecord(options)
    {
        var that = this,
                id = options.id,
                notify = options.notify,
                sourceRecordType = options.owningRecordType,
                queryField = options.queryField,
                formUrl = options.queryUrl,
                currentView,
                customViews,
                exposedUtil = { notify: notify, getQueryRequest: getQueryRequest };

        var searchDefinition;

        function initializeRelatedRecord(config)
        {
            var views = config.customViews;
            var _customViews = [];
            views.forEach(function(v){
                if(v.isSelected)
                    currentView = v.id;

                _customViews.push(new CustomView(v));
            });
            utilityFunctions.checkArgs([currentView], ['currentView'], 'relatedRecord.initialize');

            customViews = freezeObjectIfPossible(_customViews);
            initializeSearchDefinition(config)
        }
        initializeRelatedRecord(options);

        function validateView(viewId)
        {
            var found = null;
            customViews.forEach(function(v){
                if(v.id === String(viewId))
                    found = v;
            });

            if(!found)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_CUSTOM_VIEW_VALUE, viewId);
            return found;
        }

        function setView(view)
        {
            var oldView = currentView;
            var result = validateView(view);
            currentView = String(view);
            postViewChanged(view, oldView);
            return result;
        }

        function postViewChanged(view, oldView)
        {
            var request = getQueryRequest(queryField);
            var relatedRecordObj = invoker(remoteApi, "getRelatedRecord", [sourceRecordType, request.url, request.payload], null /* callback */, false /* parseResult */);
            relatedRecordObj.currentView = view;
            initializeSearchDefinition(relatedRecordObj);
        }

        function getQueryRequest(queryField)
        {
            var request = slaving.cleanupQueryURL(formUrl);
            request.payload.q = queryField;
            request.payload.si = "0"; //default loading first page
            request.payload.machine = id;
            request.payload.si_searchid = currentView;

            return request;
        }

        function initializeSearchDefinition(relatedRecordObj)
        {
            relatedRecordObj.util = exposedUtil;
            searchDefinition = new RelatedRecordSearchDefinition(relatedRecordObj);
        }

        function toJSON()
        {
            return {
                id: that.id,
                currentView: that.currentView,
                customViews: that.customViews
            }
        }

        function toString()
        {
            return "record.RelatedRecord"
        }

        /**
         * Search definition of the related record
         * @name RelatedRecord#searchDefinition
         * @type SearchDefinition
         * @readonly
         */
        Object.defineProperty(this, 'searchDefinition', {
            get: function() {
                return searchDefinition
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition');
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The list of available custom views
         * @name RelatedRecord#customViews
         * @type CustomView[]
         * @readonly
         */
        Object.defineProperty(this, 'customViews', {
            get: function() {
                return customViews;
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'customViews');
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Return the currently selected custom view (as CustomView object)
         * @name RelatedRecord#currentView
         * @type CustomView
         * @readonly
         */
        Object.defineProperty(this, 'currentView', {
            get: function() {
                return validateView(currentView)
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'currentView');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Select custom view with the given ID
         * @param {Object} options  the options object
         * @param {string} options.id  ID of the view
         * @returns {CustomView} object corresponding to the selected view
         * @throws {SuiteScriptError} INVALID_CUSTOM_VIEW_VALUE if input value is invalid
         */
        this.selectView = function selectView(options)
        {
            var id;
            if(options !== undefined && options !== null)
            {
                id = options.id;
            }
            utilityFunctions.checkArgs([id], ['id'], 'RelatedRecord.selectView');
            
            return setView(id);
        };
        /**
         * JSON.stringify() implementation
         * @returns {Object}
         */
        this.toJSON = toJSON;
        /**
         * Returns the object type name
         * @returns {string}
         */
        this.toString = toString;
    }
    RelatedRecord.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecord);


    function ReadonlyRelatedRecordSearchDefinition(searchDefinition)
    {
        Object.defineProperty(this, 'type', {
            value : searchDefinition.type,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'columns', {
            value : searchDefinition.columns,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'filters', {
            value : searchDefinition.filters,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'sortBy', {
            value : searchDefinition.sortBy,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'settings', {
            value : searchDefinition.settings,
            enumerable: true,
            configurable: false,
	    });
        this.getFilterValue = searchDefinition.getFilterValue;
        this.toJSON = searchDefinition.toJSON;
        this.toString = function (){ return searchDefinition.toString() + "(readonly)"; }
    }
    ReadonlyRelatedRecordSearchDefinition.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(ReadonlyRelatedRecordSearchDefinition);


    function RelatedRecordSearchDefinition(options)
    {
        var that = this,
                notify = options.notify,
                currentView = options.currentView,
                _util = options.util,
                id = options.id,
                queryField = options.queryField,
                sourceRecordType = options.owningRecordType,
                searchType = options.recordType,
                formUrl = options.queryUrl,
                filterFieldMetadata, /* internal map */
                returnFieldMetadata, /* internal map */
                filters,
                columns,
                settings,
                filterFields,
                sortBy;

        function initializeSearchDefinition(config)
        {
            var rawFilterFields = config.filterFields,
                rawReturnFields = config.fields,
                _returnFieldMetadata = {},
                _columns = [],
                _settings = [],
                _filterFieldMetadata = {},
                _filterFields = [],
                _sortBy;

            // initialize filters
            filters = {};

            rawReturnFields.forEach(function(field){
                _returnFieldMetadata[field.id] = field;
                var c = new Column(field);
                _columns.push(freezeObjectIfPossible(c));
            });
            rawFilterFields.forEach(function(field){
                _filterFieldMetadata[field.id] = field;
                var f = new FilterField(field);

                _filterFields.push(freezeObjectIfPossible(f));
                setDefaultValue(filters, field);
            });

            if(config.defaultSortCol)
            {
                _sortBy = {};
                _sortBy.columnId = config.defaultSortCol;
                _sortBy.direction = config.defaultSortDir;
            }

            returnFieldMetadata = freezeObjectIfPossible(_returnFieldMetadata);
            columns = freezeObjectIfPossible(_columns);
            settings = freezeObjectIfPossible(_settings);
            sortBy = freezeObjectIfPossible(_sortBy);
            filterFieldMetadata = freezeObjectIfPossible(_filterFieldMetadata);
            filterFields = freezeObjectIfPossible(_filterFields);
        }
        initializeSearchDefinition(options);

        function resetFilters()
        {
            filterFields.forEach(function(fieldObj) {
                setDefaultValue(filters, filterFieldMetadata[fieldObj.id]);
            });
        }

        function setDefaultValue(data, metadata)
        {
            if(metadata.defaultValue)
            {
                if(metadata.type === 'select')
                {
                    if(!!metadata.isMultiSelect)
                        data[metadata.id] = metadata.defaultValue.split(String.fromCharCode(5));
                    else
                        data[metadata.id] = metadata.defaultValue;
                }
                else
                    data[metadata.id] = parseFilterValue(metadata, metadata.defaultValue);
            }
        }

        function runPaged(){
            var pagedDataOptions = doGetPagedData(null);
            var pagedData = new RelatedRecordPagedData(postGetRelatedRecordPagedData(pagedDataOptions));
            return new paginationObject.PagedData(pagedData);
        }

        function runPagedPromise()
        {
            return new Promise(function(resolve, reject){
                function callback(result, exception) {
                    if (exception) {
                        reject(exception);
                    }
                    else {

                        var pagedData = new RelatedRecordPagedData(postGetRelatedRecordPagedData(result));
                        resolve(new paginationObject.PagedData(pagedData));
                    }
                }

                try {
                    doGetPagedData(callback);
                }
                catch(e)
                {
                    reject(e);
                }
            });
        }

        function getQueryRequestWithDynamicValues()
        {
            var request = _util.getQueryRequest(queryField);
            updateSortingForQueryRequest(request.payload);
            updateFilterValuesForQueryRequest(request.payload);
            return request;
        }

        function doGetPagedData(callback)
        {
            var request = getQueryRequestWithDynamicValues();
            return invoker(remoteApi, 'getRelatedRecordPagedData', [sourceRecordType, request.url, request.payload], callback, true /* parseResult */);
        }

        function postGetRelatedRecordPagedData(pagedDataOptions)
        {
            pagedDataOptions.parent = that;
            var requestorConfiguration = {
                rawUrl: formUrl,
                id: id,
                view: currentView,
                recordType: sourceRecordType,
                queryField: queryField,
                pageRanges: pagedDataOptions.pageRanges,
                dynamicValues: {}
            };
            updateSortingForQueryRequest(requestorConfiguration.dynamicValues);
            updateFilterValuesForQueryRequest(requestorConfiguration.dynamicValues);
            pagedDataOptions.pageRequestor = new RelatedRecordPageRequestor(requestorConfiguration);
            pagedDataOptions.returnFieldMetadata = returnFieldMetadata;
            return pagedDataOptions;
        }

        function updateSortingForQueryRequest(payload){
            if(sortBy)
            {
                payload.si_sortcol = returnFieldMetadata[sortBy.columnId].alias_key;
                payload.si_sortdir = sortBy.direction;
            }
        }

        function updateFilterValuesForQueryRequest(payload){
            for(var fieldId in filters)
            {
                if(filters.hasOwnProperty(fieldId))
                    payload['si_' + fieldId] = formatFilterValue(filterFieldMetadata[fieldId]);
            }
        }

        function setSortBy(options)
        {
            var columnId, direction;
            if(options !== undefined && options !== null)
            {
                columnId = options.columnId;
                direction = options.direction || 'ASC';
            }
            utilityFunctions.checkArgs([columnId], ['columnId'], 'RelatedRecord.sortBy');

            validateColumnId(columnId);
            validateDirection(direction);

            sortBy = {columnId: columnId, direction: direction};
        }

        function validateColumnId(columnId)
        {
            if(!returnFieldMetadata.hasOwnProperty(columnId))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLUMN_FOR_SORTING, columnId);
        }

        function validateDirection(dir)
        {
            if(SORTING_DIRECTION.indexOf(dir) === -1)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_DIRECTION_FOR_SORTING, dir);
        }

        function getSortBy()
        {
            return sortBy;
        }

        function getFilterValue(options)
        {
            var fieldId;
            if(options !== undefined && options !== null)
            {
                fieldId = options.fieldId;
            }
            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'RelatedRecord.getFilterValue');

            return doGetFilterValue(fieldId);
        }

        function doGetFilterValue(fieldId)
        {
            if(filterFieldMetadata.hasOwnProperty(fieldId))
                return (filters[fieldId] !== undefined) ? filters[fieldId] : "";
            else
                return undefined;
        }

        function setFilterValue(options)
        {
            var fieldId, value;
            if(options !== undefined && options !== null)
            {
                fieldId = options.fieldId;
                value = options.value;
            }
            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'RelatedRecord.setFilterValue');

            doSetFilterValue(fieldId, value);
        }

        function doSetFilterValue(fieldId, value)
        {
            var metadata = filterFieldMetadata[fieldId];
            if(!!metadata.isMultiSelect && !util.isArray(value))
                value = [value];

            filters[fieldId] = validateAndFormatFilterValue(metadata, value);
        }

        function validateAndFormatFilterValue(metadata, value)
        {
            if(!metadata)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FILTER_FIELD_FOR_CURRENT_VIEW, metadata.id);

            var formattedValue = '';
            if(value && value !== 0 && value !== false)
            {
                if(metadata.type === 'select')
                {
                    formattedValue = validateSelectFilter(metadata, value);
                }
                else if(metadata.type === 'date')
                    formattedValue = validateDateFilter(metadata, value);
                else
                    formattedValue = String(value);
            }

            return formattedValue;
        }

        function validateSelectFilter(metadata, value)
        {
            var input = util.isArray(value) ? value : [value];

            input.forEach(function(v){
                var isValid = false;
                for(var index in metadata.options)
                {
                    if(v === metadata.options[index].id)
                    {
                        isValid = true;
                        break;
                    }
                }

                if(!isValid)
                    utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_VALUE, v, metadata.id);
            });

            return value;
        }

        function validateDateFilter(metadata, toValidate)
        {
            if (!(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]'))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_VALUE, toValidate, metadata.id);

            return toValidate;
        }

        function formatFilterValue(metadata)
        {
            var formattedValue;
            var value = filters[metadata.id];
            if(!value || value === '')
            {
                formattedValue = '';
            }
            else if(metadata.type === 'select' && !!metadata.isMultiSelect)
            {
                value = (util.isArray(value)) ? value : [value];
                formattedValue = value.join(String.fromCharCode(5));
            }
            else
            {
                formattedValue = String(format.format({value: value, type: metadata.type}));
            }

            return formattedValue;
        }

        function parseFilterValue(metadata, value)
        {
            if(metadata.type === 'date')
            {
                value = format.parse({value: value, type: metadata.type});
            }
            return value;
        }

        function toJSON()
        {
            return {
                type: that.type,
                sortBy: that.sortBy,
                filters: filters,
                columns: that.columns,
                settings: that.settings
            }
        }

        function toString()
        {
            return "SearchDefinition"
        }

        /**
         * The type of the related record
         * @name RelatedRecordSearchDefinition#type
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'type', {
            get: function () {
                return searchType;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The list of return columns
         * @name RelatedRecordSearchDefinition#columns
         * @type Column[]
         * @readonly
         */
        Object.defineProperty(this, 'columns', {
            get: function () {
                return columns;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
            },
            enumerable: true,
            configurable: false
        });

	    /**
	     * The list of settings
	     * @name RelatedRecordSearchDefinition#settings
	     * @type Setting[]
	     * @readonly
	     */
	    Object.defineProperty(this, 'settings', {
		    get: function () {
			    return settings;
		    },
		    set: function () {
			    utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'settings' );
		    },
		    enumerable: true,
		    configurable: false
	    });


	    /**
         * The list of return filter fields
         * @name RelatedRecordSearchDefinition#filters
         * @type FilterField[]
         * @readonly
         */
        Object.defineProperty(this, 'filters', {
            get: function () {
                return filterFields;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'filters' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The property determines how related record is sorted. The value is an object with two properties:
         * columnId - determines column for sorting
         * direction - sorting order, values are "ASC" or "DESC"
         * @name RelatedRecordSearchDefinition#sortBy
         * @type Object
         * @throws {SuiteScriptError} INVALID_COLUMN_FOR_SORTING if columnId is invalid
         * @throws {SuiteScriptError} INVALID_DIRECTION_FOR_SORTING if direction is invalid
         */
        Object.defineProperty(this, 'sortBy', {
            get: getSortBy,
            set: setSortBy,
            enumerable: true,
            configurable: false
        });

        /**
         * Change the filter value for related record query
         * @param {Object} options the options object
         * @param {string} options.fieldId the id of the filter field
         * @param {Object} options.value value to be set
         * @throws {SuiteScriptError} INVALID_FILTER_FIELD_FOR_CURRENT_VIEW if options.fieldId is invalid
         * @throws {SuiteScriptError} INVALID_FIELD_VALUE if options.value is invalid
         */
        this.setFilterValue = setFilterValue;
        /**
         * Return the filter value for related record query
         * @param {Object} options the options object
         * @param {string} options.fieldId the id of the filter field
         * @returns {Object} current filter setting for the given filter field
         */
        this.getFilterValue = getFilterValue;
        /**
         * Reset the filter values to the default state for the currently selected custom view
         */
        this.resetFilters = resetFilters;
        /**
         * Pagination API for related record
         * @returns {PagedData}
         * @since 2016.1
         */
        this.runPaged = runPaged;
        /**
         * Pagination API for related record using promise
         * @returns {Promise}
         * @since 2016.1
         */
        this.runPaged.promise = runPagedPromise;
        /**
         * JSON.stringify() implementation
         * @returns {Object}
         */
        this.toJSON = toJSON;
        /**
         * Returns the object type name
         * @returns {string}
         */
        this.toString = toString;
    }
    RelatedRecordSearchDefinition.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordSearchDefinition);


    /**
    * Requestor for Related Record Page
    *
    * @private
    * @param {Object} config
    * @param {String} config.rawUrl the raw url for record handler, which includes some default parameters
    * @param {String} config.recordType the source record type
    * @param {String} config.queryField the page range field id
    * @param {String} config.id the id of the search result machine
    * @param {String} config.view the selected custom view of the search result machine
    * @param {Object} config.dynamicValues the dynamic values of the search result machine
    * @return {RelatedRecordPageRequestor}
    * @constructor
    */
    function RelatedRecordPageRequestor(config){
        var pageRequest = slaving.cleanupQueryURL(config.rawUrl);
        var sourceRecordType = config.recordType;
        var recordUrl = pageRequest.url;
        var payload = util.extend({
            q: config.queryField,
            machine: config.id,
            si_searchid: config.view
        }, pageRequest.payload);
        payload = util.extend(config.dynamicValues, payload);

        function request(index, callback){
            payload.si = String(index);
            return invoker(remoteApi, 'getRelatedRecordPage', [sourceRecordType, recordUrl, payload], callback, true /* parseResult */);
        }

        this.request = request;
    }

    /**
     * Data model for relatedrecord filter field
     *
     * @private
     * @param {Object} field
     * @return {FilterField}
     * @constructor
     */
    function FilterField(field)
    {
        var that = this, options;

        /**
         * The ID of the filter field
         * @name FilterField#id
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'id', {
            get: function () {
                return field.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });
        /**
        * The label of the filter field
        * @name FilterField#label
        * @type string
        * @readonly
        */
        Object.defineProperty(this, 'label', {
            get: function () {
                return field.label;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' );
            },
            enumerable: true,
            configurable: false
        });
        /**
        * The type of the filter field
        * @name FilterField#type
        * @type string
        * @readonly
        */
        Object.defineProperty(this, 'type', {
            get: function () {
                return field.type;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The hidden property of the filter field
         * @name FilterField#isHidden
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'isHidden', {
            get: function () {
                return field.isHidden;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isHidden' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The multi-select property of the filter field
         * @name FilterField#isMultiSelect
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'isMultiSelect', {
            get: function () {
                return field.isMultiSelect;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isMultiSelect' );
            },
            enumerable: true,
            configurable: false
        });

        function getSelectOptions()
        {
            if(!options)
            {
                var options = [];
                if(field.options)
                {
                    field.options.forEach(function (v) {
                        options.push(freezeObjectIfPossible({value: v.id, text: v.text}));
                    });
                }
            }
            return options;
        }


        function toJSON()
        {
            return {
                id: that.id,
                type: that.type,
                label: that.label,
                isHidden: that.isHidden,
                isMultiSelect: that.isMultiSelect
            }
        }
        if(that.type === 'select')
        {
            /**
             * Return available options for select type filter field
             * @returns {Object[]}
             */
            this.getSelectOptions = getSelectOptions;
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.FilterField"; }
    }
    FilterField.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(FilterField);



    /**
     * Data model for relatedrecord setting field
     *
     * @private
     * @param {Object} field
     * @return {SettingField}
     * @constructor
     */
    function Setting(field)
    {
    	var that = this;

        /**
         * The Name of the setting field
         * @name Setting#name
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'name', {
    	       get: function () {
    		       return field.name;
    	       },
    	       set: function () {
    		       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
    	       },
    	       enumerable: true,
    	       configurable: false
        });
        /**
         * The Value of the setting field
         * @name Setting#value
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'value', {
    	       get: function () {
    		       return field.value;
    	       },
    	       set: function () {
    		       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value' );
    	       },
    	       enumerable: true,
    	       configurable: false
        });


        function toJSON()
        {
    	       return {
    		       name: that.name,
    		       value: that.value
    	       }
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.Setting"; }
    }
    Setting.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(Setting);


    /**
     * Data model for relatedrecord column
     *
     * @private
     * @param {Object} field
     * @return {Column}
     * @constructor
     */
    function Column(field)
    {
        var that = this;
        /**
         * The index of the column
         * @name Column#index
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'index', {
            get: function () {
                return field.index;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The ID of the column
         * @name Column#columnId
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'columnId', {
            get: function () {
                return field.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columnId' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The label of the column
         * @name Column#label
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'label', {
            get: function () {
                return field.label;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The value type of the column
         * @name Column#type
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'type', {
            get: function () {
                return field.type;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Record type of the column, if applicable
         * @name Column#recordType
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'recordType', {
            get: function () {
                return field.rec_type ? field.rec_type : null;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'recordType' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Indicates whether the data returned in this column is expected to contain a link URL
         * @name Column#hasLink
         * @type boolean
         * @readonly
         * @deprecated [use linkType instead]
         */
        Object.defineProperty(this, 'hasLink', {
            get: function () {
                return field.has_link;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'hasLink' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Indicates what kind of link URL is expected in the data returned for this column. Uses values from the LinkType enum:
         * NONE = no link URL
         * REGULAR = link URL that should be opened in the same window
         * POPUP = link URL that should be opened in a new window
         * @name Column#linkType
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'linkType', {
            get: function () {
                return Object.keys(LINK_TYPE)[field.linktype];
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'linkType' );
            },
            enumerable: true,
            configurable: false
        });
        function toJSON()
        {
            return {
                index: that.index,
                columnId: that.columnId,
                label: that.label,
                type: that.type,
                recordType: that.recordType,
                hasLink: that.hasLink,
                linkType: that.linkType
            }
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.Column"; }
    }
    Column.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(Column);

    /**
     * Data model for custom view option
     *
     * @private
     * @param {Object} view
     * @return {CustomView}
     * @constructor
     */
    function CustomView(view)
    {
        var that = this;

        /**
         * The ID of the custom view
         * @name CustomView#id
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'id', {
            get: function () {
                return view.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The name of the custom view
         * @name CustomView#text
         * @type string
         * @readonly
         */
        Object.defineProperty(this, 'text', {
            get: function () {
                return view.text;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'text' );
            },
            enumerable: true,
            configurable: false
        });

        function toJSON()
        {
            return {id: that.id, text: that.text};
        }

        function toString()
        {
            return "RelatedRecord.CustomView";
        }

        this.toJSON = toJSON;
        this.toString = toString;
    }
    CustomView.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(CustomView);

    /**
     * PageRange implementation for RelatedRecord
     *
     * @private
     * @param {Object} options JS Object for RelatedRecordPageRange
     * @return {RelatedRecordPageRange}
     * @constructor
     */
    function RelatedRecordPageRange(options)
    {
        function getIndex() { return parseInt(options.id, 10);};
        function getCompoundLabel() { return options.text; };

        Object.defineProperty(this, 'index', {
            get: function () {
                return getIndex();
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
            },
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(this, 'compoundLabel', {
            get: function () {
                return getCompoundLabel();
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'compoundLabel' );
            },
            enumerable: true,
            configurable: false
        });
        this.getIndex = getIndex;
        this.getCompoundLabel = getCompoundLabel;
    }
    RelatedRecordPageRange.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPageRange);

    /**
     * PagedData implementation for RelatedRecord
     *
     * @protected
     * @param {Object} options JS Object for RelatedRecordPagedData
     * @return {RelatedRecordPagedData}
     * @constructor
     */
    function RelatedRecordPagedData(options)
    {
        var that = this,
            pageRequestor = options.pageRequestor,
            readOnlyRelatedRecord = new ReadonlyRelatedRecordSearchDefinition(options.parent),
            returnFieldMetadata = options.returnFieldMetadata,
            totalRows = isNaN(options.totalRows) ? -1 : options.totalRows,
            pageSize = isNaN(options.pageSize) ? -1 : options.pageSize,
            pageRanges = Array.isArray(options.pageRanges) && options.pageRanges.map(function(v,i,a){return new RelatedRecordPageRange(v);}) || [],
            firstPageData = options.firstPageData; //createRelatedRecordPageInstance({index : 0, page: options.firstPageData});

        function createRelatedRecordPageInstance(configs)
        {
            var options = {
                parent: that,
                isFirst: configs.index === 0,
                isLast: configs.index === pageRanges.length-1,
                pageRange: pageRanges[configs.index]
            };

            if(configs.page && util.isArray(configs.page.data))
            {
                var page = [];
                configs.page.data.forEach(function(row){
                    page.push(new RelatedRecordResult({columns: configs.page.columns, row: row, returnFieldMetadata: returnFieldMetadata}));
                });
                options.data = page;
            }
            return new RelatedRecordPage(options);
        }

        function validateIndex(index)
        {
            if(index < 0 || index >= pageRanges.length)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch' );
            }
        }

        function getPage(index)
        {
            validateIndex(index);
            var pageData = doGetPageRawResult(index, null);
            var page = createRelatedRecordPageInstance({index : index, page: pageData});
            return new paginationObject.Page(page);
        }

        function getPagePromise(index)
        {
            var result;
            if(index < 0 || index >= pageRanges.length)
            {
                result = Promise.reject(error.create({
                                                         name: error.Type.INVALID_PAGE_RANGE,
                                                         message: 'Invalid page range: fetch.promise.',
                                                         notifyOff: false
                                                     }));
            }
            else
            {
                result = new Promise(function(resolve, reject){
                    function callback(result, exception) {
                        if (exception) {
                            reject(exception);
                        }
                        else {
                            var page = createRelatedRecordPageInstance({index : index, page: result});
                            resolve(new paginationObject.Page(page));
                        }
                    }

                    try {
                        doGetPageRawResult(index, callback);
                    }
                    catch(e)
                    {
                        reject(e);
                    }
                });
            }
            return result;
        }

        function doGetPageRawResult(index, callback)
        {
            var pageData;
            if(index === 0)
            {
                pageData = (callback) ? callback(firstPageData) : firstPageData;
            }
            else
            {
                pageData = pageRequestor.request(index, callback);
            }
            return pageData;
        }

        function toJSON(){
            return {
                count: that.count,
                pageRanges: that.pageRanges,
                pageSize: that.pageSize,
                searchDefinition: that.searchDefinition
            }
        }

        function toString()
        {
            return "search.PagedData"
        }

        this.searchDefinition = readOnlyRelatedRecord;
        this.pageRanges = pageRanges;
        this.pageSize = pageSize;
        this.count = totalRows;
        this.fetch = getPage;
        this.fetch.promise = getPagePromise;
        this.toJSON = toJSON;
        this.toString = toString;
    }
    RelatedRecordPagedData.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPagedData);

    function RelatedRecordPage(options)
    {
        var that = this,
            parentPagedData = options.parent,
            pageRange = options.pageRange;

        function getNextPage()
        {
            if(that.isLast)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'next' );
            }
            return parentPagedData.fetch(pageRange.getIndex()+1);
        }
        function getPrevPage()
        {
            if(that.isFirst)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'prev' );
            }
            return parentPagedData.fetch(pageRange.getIndex()-1);
        }
        function getNextPagePromise()
        {
            var result;
            if(that.isLast)
            {
                result = Promise.reject(error.create({
                                                         name: error.Type.INVALID_PAGE_RANGE,
                                                         message: 'Invalid page range: next.promise.',
                                                         notifyOff: false
                                                     }));
            }
            else
            {
                result = parentPagedData.fetch.promise(pageRange.getIndex()+1);
            }
            return result;
        }
        function getPrevPagePromise()
        {
            var result;
            if(that.isFirst)
            {
                result = Promise.reject(error.create({
                                                name: error.Type.INVALID_PAGE_RANGE,
                                                message: 'Invalid page range: prev.promise.',
                                                notifyOff: false
                                            }));
            }
            else
            {
                result = parentPagedData.fetch.promise(pageRange.getIndex() - 1);
            }
            return result;
        }

        this.data = options.data;
        this.pagedData = options.parent;
        this.pageRange = options.pageRange;
        this.isFirst = options.isFirst;
        this.isLast = options.isLast;
        this.next = getNextPage;
        this.prev = getPrevPage;
        this.next.promise = getNextPagePromise;
        this.prev.promise = getPrevPagePromise;
    }
    RelatedRecordPage.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPage);

    function RelatedRecordResult(options)
    {
        var returnFieldMetadata = options.returnFieldMetadata,
            dataByIndex = [],
            dataByFieldId= {};

        (function(opt){
            var columns = opt.columns;
            var row = opt.row;
            row.forEach(function(v,i){
                dataByIndex[i] = v;
                dataByFieldId[columns[i]] = v;
            })
        })(options);

        function getValue(options)
        {
            var index, columnId;
            if(options instanceof Column)
            {
                index = options.index;
                columnId = options.columnId;
            }
            else if(!!options && utilityFunctions.isObject(options))
            {
                columnId = options.columnId;
            }

            utilityFunctions.checkArgs([columnId],['columnId'], 'Result.getValue');

            return doGetValue(index, columnId);
        }
        function doGetValue(index, id)
        {
            var returnValue = doGetValueById(id);
            return returnValue;
        }

        function doGetValueByIndex(index)
        {
            if(index < 0 || index >= dataByIndex.length)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_INDEX, index );

            return dataByIndex[index];
        }

        function doGetValueById(id)
        {
            if(!returnFieldMetadata.hasOwnProperty(id))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_ID, id );

            return dataByFieldId[returnFieldMetadata[id].alias];
        }

        function toJSON()
        {
            var toRet = {};
            for(var id in returnFieldMetadata)
            {
                if(returnFieldMetadata.hasOwnProperty(id))
                    toRet[id] = dataByFieldId[returnFieldMetadata[id].alias];
            }

            return toRet;
        }
        function toString()
        {
            return "RelatedRecord.Result";
        }

        this.getValue = getValue;
        this.toJSON = toJSON;
        this.toString = toString;
    }
    RelatedRecordResult.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordResult);

    function doGetRelatedRecord(options, callback)
    {
        var rec = options != null ? options.record : null;
        var sublistId = options != null ? options.sublistId : null;
        utilityFunctions.checkArgs([rec, sublistId], ['record', 'sublistId'], 'relatedRecord.get');

        var request = rec.query;
        if (!request)
            utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD); // not supported on this type of record object
        request.payload['machine'] = sublistId;
        request.payload['r'] = "T";
        return invoker(remoteApi, "getRelatedRecord", [rec.type, request.url, request.payload], callback, false /* parseResult */);
    }

    function getRelatedRecord(options)
    {
        var relatedRecordObj = doGetRelatedRecord(options, null);
        relatedRecordObj.owningRecordType = options.record.type;

        return new RelatedRecord(relatedRecordObj);
    }

    function promiseToGetRelatedRecord(options)
    {
        var myPromise = new Promise(function (resolve, reject)
        {
            function callback(result, exception)
            {
                if (exception)
                {
                    reject(exception);
                    return;
                }
                result.owningRecordType = options.record.type;
                resolve(new RelatedRecord(result));
            }

            try
            {
                doGetRelatedRecord(options, callback);
            }
            catch (e)
            {
                reject(e);
            }
        });
        return myPromise;
    }

    getRelatedRecord.promise = promiseToGetRelatedRecord;

    return {
        /**
         * Obtain the related record object that can be used to fetch search result machine data.
         *
         * @param {Object} options
         * @param {Record} options.record  the record object that the sublist is related to
         * @param {string} options.sublistId  the ID of the sublist
         * @return {RelatedRecord}
         *
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if one of the arguments is missing
         * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if options.sublistId is incorrect
         *
         * @since 2017.1
         */
        get: getRelatedRecord,

        /**
         * Enum for link types contained within column data.
         * @enum {string}
         */
        LinkType: LINK_TYPE
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/subrecordUtilityFunctions
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/subrecordUtilityFunctions',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions'],
       function(error, utilityFunctions, recordUtil){

    var getNextSysId = (function(){
       var nextSysId = Date.now();

       return function getNextSysId(isNew){
           return String((isNew ? -1 : 1) * (nextSysId++));
       };
    }());

    /**
     * validate if the given field is summary field
     * @param {RecordField} field
     * @param {string} fieldId
     * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD
     */
    function validateIfSummaryField(field, fieldId)
    {
        if (field === null || field.getType() !== 'summary')
        {
            utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
        }
    }

    return {
        SYS_OP: 'sys_op',
        SYS_ID: 'sys_id',
        SYS_PARENT_ID: 'sys_parentid',
        getNextSysId: getNextSysId,
        validateIfSummaryField: validateIfSummaryField
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistLine
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLine',['N/record/recordUtilityFunctions', 'N/record/sublistLineEvent', 'N/eventEmitter'],
	function(recordUtil, sublistLineEvent, eventEmitter)
	{
	    /**
	     * data structure to hold the sublist line data
	     *
	     * @param {Object} options
	     * @param {SublistLine} [options.toBeCloned]
	     * @param {string} options.id sublistId
	     * @param {number} options.lineIndex
	     * @param {Object} [options.defaultLineData={}]
	     * @return {SublistLine}
	     * @constructor
	     */
	    function SublistLine(options)
	    {
	        var that = this;
	        var id, lineIndex, data = {};
	        var emitter = eventEmitter.create();

	        if(options.toBeCloned)
	        {
	            var toBeCloned = options.toBeCloned;
	            var noCopyToDefaultMap = options.noCopyToDefaultMap;
	            id = toBeCloned.id;
	            if(options.lineIndex || options.lineIndex === 0)
	            {
	                lineIndex = options.lineIndex;
	            }
	            else
	                lineIndex =  -1;
	            setValues(toBeCloned, noCopyToDefaultMap);
	        }
	        else
	        {
	            id = options.id;
	            if(options.lineIndex || options.lineIndex === 0)
	            {
	                lineIndex = options.lineIndex;
	            }
	            else
	                lineIndex =  -1;
	            if(options.defaultLineData)
	            {
	                recordUtil.forEachProperty(options.defaultLineData, function(fieldId, value){
	                    data[fieldId] = {value: value, legacyStringValue: value};
	                })

	            }
	        }

	        /**
	         * sublist id
	         * @name SublistLine#id
	         * @type {string}
	         */
	        Object.defineProperty(this, 'id', {
	            get: function ()
	            {
	                return id;
	            },
	            enumerable: true,
	            configurable: false
	        });

	        /**
	         * sublist id
	         * @name SublistLine#index
	         * @type {number}
	         */
	        Object.defineProperty(this, 'index', {
	            get: function ()
	            {
	                return lineIndex;
	            },
	            set: function (idx)
	            {
	                lineIndex = parseInt(idx,10);
	            },
	            enumerable: true,
	            configurable: false
	        });

	        function setValues(anotherLine, noCopyToDefaultMap)
	        {
		        noCopyToDefaultMap = noCopyToDefaultMap || {};
	            recordUtil.forEachProperty(anotherLine.getData(), function(fieldId, value){
	                var oldValue = getFieldValue(fieldId);
	                if(noCopyToDefaultMap.hasOwnProperty(fieldId))
	                {
	                	value = {value: undefined, legacyStringValue: noCopyToDefaultMap[fieldId]};
	                }
	                else if(!recordUtil.matchRecordFieldValueSchema(value))
	                {
	                    value = util.isArray(value) && value.length === 1 ? value[0] : value;
	                    value = {value: undefined, legacyStringValue: value};
	                }
	                data[fieldId] = {value: value.value, legacyStringValue: value.legacyStringValue};
	                var newValue = getFieldValue(fieldId);
	                if(oldValue !== newValue)
	                {
	                    sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue);
	                }
	            });
	        }
	        this.setValues = setValues;

	        function removeFieldValue(fieldId)
	        {
	            if(data.hasOwnProperty(fieldId))
	            {
	                var oldValue = getFieldValue(fieldId);
	                delete data[fieldId];
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue);
	            }
	        }
	        this.removeFieldValue = removeFieldValue;

	        function setPrimitiveValue(fieldId, value)
	        {
	            var oldValue = getFieldValue(fieldId);
	            if(hasFieldValue(fieldId))
	                data[fieldId].value = value;
	            else
	                data[fieldId] = {value: value, legacyStringValue: undefined};
	            var newValue = getFieldValue(fieldId);
	            if(oldValue !== newValue)
	            {
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue, true);
	            }
	        }
	        this.setPrimitiveValue = setPrimitiveValue;

	        function hasFieldValue(fieldId) {
	            return data.hasOwnProperty(fieldId);
	        }
	        this.hasFieldValue = hasFieldValue;

	        function setFieldValue(fieldId, recordFieldValue)
	        {
	            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
	            var oldValue = getFieldValue(fieldId);
	            data[fieldId] = recordFieldValue;
	            var newValue = getFieldValue(fieldId);
	            if(oldValue !== newValue)
	            {
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue);
	            }
	        }
	        this.setFieldValue = setFieldValue;

	        function getFieldValue(fieldId)
	        {
	            var fieldValue = "";
	            if(util.isObject(data[fieldId]))
	            {
	                if(!!data[fieldId].value || data[fieldId].value === "" || data[fieldId].value === 0 || data[fieldId].value === false)
	                    fieldValue = data[fieldId].value;
	                else
	                    fieldValue = recordUtil.emptyIfNullOrUndefined(data[fieldId].legacyStringValue);
	            }

	            return fieldValue;
	        }
	        this.getFieldValue = getFieldValue;

	        function getValueAsLegacyString(fieldId)
	        {
	            var fieldValue = "";
	            if(util.isObject(data[fieldId]))
	            {
	                if(!!data[fieldId].legacyStringValue || data[fieldId].legacyStringValue === "" || data[fieldId].legacyStringValue === 0 || data[fieldId].legacyStringValue === false)
	                    fieldValue = data[fieldId].legacyStringValue;
	            }
	            return fieldValue;
	        }
	        this.getValueAsLegacyString = getValueAsLegacyString;

	        function getData()
	        {
	            var toRet = {};
	            recordUtil.forEachProperty(data, function(fieldId, value){
	                toRet[fieldId] = value;
	            });
	            return toRet;
	        }
	        this.getData = getData;

	        function toJSON()
	        {
	            return data;
	        }
	        this.toJSON = toJSON;

	        this.on = emitter.on;
	        this.off = emitter.off;
	    }



	    return {
	        /**
	         * create record sublist line data storage
	         * @param options
	         * @returns {SublistLine}
	         */
	        create: function (options){
	            return new SublistLine(options);
	        },
	        /**
	         * return true if object is an instance of SublistLine
	         * @param {Object} obj
	         * @returns {boolean}
	         */
	        isInstance: function(obj) { return obj instanceof SublistLine; }
	    }
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/selectFieldOptionTextCache
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/selectFieldOptionTextCache',[], function(){

	function createKey(sublistId, fieldId, value){
		return [sublistId, fieldId, value].join(String.fromCharCode(1));
	}

	function SelectFieldOptionTextCache()
	{
		var cache = {};

		function set(sublistId, fieldId, value, text){
				cache[createKey(sublistId, fieldId, value)] = text;
		}
		this.set = set;

		function get(sublistId, fieldId, value){
				return cache[createKey(sublistId, fieldId, value)];
		}
		this.get = get;

		function has(sublistId, fieldId, value){
				return cache.hasOwnProperty(createKey(sublistId, fieldId, value));
		}
		this.has = has;

		return this;
	}

	return {
		create: function(){
			return new SelectFieldOptionTextCache();
		}
	};
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/uuid
 * @NApiVersion 2.x
 *
 */
define('N/util/uuid',[], function () {
	function getRandomHexString(length)
	{
		var result = '';

		while(result.length < length)
		{
			result += getHexString(getRandomValue());
		}

		return result;
	}

	function getRandomValue()
	{
		return Math.floor(Math.random() * 16);
	}

	function getHexString(value)
	{
		return value.toString(16);
	}


	function generateV4()
	{
		return getRandomHexString(8) + '-' +
			getRandomHexString(4) + '-' +
			'4' + getRandomHexString(3) + '-' +
			getHexString(getRandomValue(1) & 11 | 8) + getRandomHexString(3) + '-' +
			getRandomHexString(12);
	}

	/**
	 * @alias N/util/uuid
	 */
	return Object.freeze({
		generateV4: generateV4
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/model
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/model',['N/record/recordUtilityFunctions', 'N/record/subrecordUtilityFunctions', 'N/record/sublistLine', 'N/record/selectFieldOptionTextCache',
        'N/record/modelEvent', 'N/eventEmitter',
        'N/util/uuid'],
    function(recordUtil, subrecordUtil, sublistLine, selectOptionTextCache,
             modelEvent, eventEmitter,
             uuid){

    function SublistsController()
    {
        var that = this;
        var ID_FIELD = '_id';
        var SEQUENCE_FIELD = '_sequence';
        var sublists = {};

        function getLineInstanceId(sublistLine)
        {
            return sublistLine.getFieldValue(ID_FIELD);
        }

        function getLineSequence(sublistLine)
        {
            return sublistLine.getFieldValue(SEQUENCE_FIELD);
        }

        function sublistExists(sublistId)
        {
            return sublists.hasOwnProperty(sublistId);
        }
        this.sublistExists = sublistExists;

        function getSublist(sublistId)
        {
            if (!sublistExists(sublistId))
            {
                sublists[sublistId] = {};
            }

            return sublists[sublistId];
        }

        function getSublists(){
            return Object.keys(sublists);
        }
        this.getSublists = getSublists;

        function hasSublistLine(sublistId, lineInstanceId)
        {
            var hasLine = false;
            var hasSublist = sublistExists(sublistId);

            if(hasSublist)
            {
                var sublist = getSublist(sublistId);
                hasLine = sublist.hasOwnProperty(lineInstanceId);
            }

            return hasLine;
        }
        this.hasSublistLine = hasSublistLine;

        function getSublistLine(sublistId, lineInstanceId)
        {
            var sublistLine = null;
            var hasLine = hasSublistLine(sublistId, lineInstanceId);

            if(hasLine)
            {
                var sublist = getSublist(sublistId);
                sublistLine = sublist[lineInstanceId];
            }

            return sublistLine;
        }
        this.getSublistLine = getSublistLine;

        function putSublistLine(sublistLine)
        {
            var sublistId = sublistLine.id;
            var lineInstanceId = getLineInstanceId(sublistLine);
            var previousSublistLine = getSublistLine(sublistId, lineInstanceId);

            getSublist(sublistId)[lineInstanceId] = sublistLine;

            return previousSublistLine;
        }
        this.putSublistLine = putSublistLine;

        function removeSublistLine(sublistId, lineInstanceId)
        {
            var removedSublistLine = getSublistLine(sublistId, lineInstanceId);
            delete getSublist(sublistId)[lineInstanceId];

            return removedSublistLine;
        }
        this.removeSublistLine = removeSublistLine;

        function getSublistLineCount(sublistId)
        {
            return sublistExists(sublistId) && Object.keys(getSublist(sublistId)).length || 0;
        }
        this.getSublistLineCount = getSublistLineCount;

        function getSublistLinesAsOrderedList(sublistId)
        {
            return Object.keys(getSublist(sublistId)).
                map(function(lineInstanceId){ return getSublistLine(sublistId, lineInstanceId); }).
                sort(function(line1, line2){return getLineSequence(line1) - getLineSequence(line2)});
        }
        this.getSublistLinesAsOrderedList = getSublistLinesAsOrderedList;

	    function getSublistLineInstanceIdsAsOrderedList(sublistId)
	    {
		    return Object.keys(getSublist(sublistId)).
		    sort(function(line1, line2){
			    return getLineSequence(getSublistLine(sublistId, line1))
				    - getLineSequence(getSublistLine(sublistId, line2))
		    });
	    }
	    this.getSublistLineInstanceIdsAsOrderedList = getSublistLineInstanceIdsAsOrderedList;

        function getSequenceToInstanceIdMap(sublistId)
        {
            return Object.keys(getSublist(sublistId)).
                reduce(function(result, lineInstanceId){
                    result[getLineSequence(getSublistLine(sublistId, lineInstanceId))] = lineInstanceId;

                    return result;
                }, {});
        }
        this.getSequenceToInstanceIdMap = getSequenceToInstanceIdMap;
    }

    function SublistsSequenceToInstanceId(sublistsController)
    {
        var sublists = {};

        function update(sublistId)
        {
            sublists[sublistId] = sublistsController.getSequenceToInstanceIdMap(sublistId);
        }
        this.update = update;

        function get(sublistId, line)
        {
            var sublist = sublists[sublistId];
            if(!sublist)
            {
                update(sublistId);
                sublist = sublists[sublistId];
            }
            return sublist[line];
        }
        this.get = get;
    }

    function SelectedLineController()
    {
        var that = this;
        var sublists = {};

        function sublistExists(sublistId)
        {
            return sublists.hasOwnProperty(sublistId);
        }

        function has(sublistId)
        {
            var result = false;
            var hasSublist = sublistExists(sublistId);
            
            if(hasSublist)
            {
                var thisIdList = sublists[sublistId];
                result = !!thisIdList && (thisIdList.length > 0);
            }
            
            return result;
        }
        this.has = has;

        function getLastAndPop(sublistId, shouldPop)
        {
            var result = null;
            if(has(sublistId))
            {
                var thisIdList = sublists[sublistId];
                if (!shouldPop)
                    thisIdList = thisIdList.slice(-1);

                result = thisIdList.pop();
            }

            return result;
        }

        function get(sublistId)
        {
            return getLastAndPop(sublistId, false);
        }
        this.get = get;

        function put(sublistId, lineInstanceId)
        {
            var previousCurrentSublistLineInstanceId = get(sublistId);
            if (!has(sublistId))
                sublists[sublistId] = [lineInstanceId];
            else
                sublists[sublistId].push(lineInstanceId);
            return previousCurrentSublistLineInstanceId;
        }
        this.put = put;

        function update(sublistId, lineInstanceId)
        {
            remove(sublistId);
            put(sublistId, lineInstanceId);
        }
        this.update = update;

        function remove(sublistId)
        {
            return getLastAndPop(sublistId, true);
        }
        this.remove = remove;
    }

    /**
     * object holds the record data
     *
     * @param {Object} options
     * @param {String} options.type record type
     * @param {RecordCacheController} options.subrecordCache
     * @param {{bodyField:*, sublist: *, sublistFieldState:*, subrecord:* }} options.data serialized data
     * @return {Model}
     * @constructor
     */
    function Model(options)
    {
        var that = this;
        var recordType = options.type;
        var recordDataObj = options.data;
        var recordInitialization = recordDataObj.initialization;
	    var isNew = !recordInitialization || recordInitialization.method !== 'loadRecord';
        var emitter = eventEmitter.create();
        var bodyFields = {};
        var subrecordData = {cache: options.subrecordCache};
        var sublists = new SublistsController();
        var sublistsLinesSequencesToInstanceIds = new SublistsSequenceToInstanceId(sublists);
        var sublistsBuffers = new SublistsController();
        var sublistsBuffersLinesSequencesToInstanceIds = new SublistsSequenceToInstanceId(sublistsBuffers);
        var sublistsSelectedLineInstanceIds = new SelectedLineController();
        var optionTextCache = selectOptionTextCache.create();

        (function constructor(recordDataObj)
        {
            function bindCachingFunction(sublistId, fieldId){
                return function(value, text){
                    optionTextCache.set(sublistId, fieldId, value, text);
                }
            }

            (function initSubrecord(data)
            {
                subrecordData.link = data.link || {};

            })(recordDataObj.subrecord || {});

            (function initBodyFields(fields)
            {

                recordUtil.forEachProperty(fields, function(fieldId, value)
                {
                    var cacher = bindCachingFunction(undefined, fieldId);
                    if(!recordUtil.matchRecordFieldValueSchema(value))
                    {
                        value = util.isArray(value) && value.length === 1 ? value[0] : value;
                        value = recordUtil.transformRawValueToFieldValueSchema(value, cacher);
                    }

                    bodyFields[fieldId] = value;
                });

                if (bodyFields[subrecordUtil.SYS_ID] === undefined)
                {
                    var valueForSystemId = subrecordUtil.getNextSysId(isNew);
                    bodyFields[subrecordUtil.SYS_ID] = {value: valueForSystemId, legacyStringValue: valueForSystemId};

                    bodyFields[subrecordUtil.SYS_PARENT_ID] = {value: "0", legacyStringValue: "0"};
                }
            })(recordDataObj.bodyField || {});


            (function initSublists(sublistData)
            {
                for (var sublistId in sublistData)
                {
                    if (sublistData.hasOwnProperty(sublistId))
                    {
                        var lines = sublistData[sublistId];
                        lines.forEach(function (line, index)
                                      {
                                          var uniqueId = uuid.generateV4();

                                          var sublistline = createSublistLine({
                                              id: sublistId,
                                              lineIndex: index,
                                              sequence: index,
                                              lineInstanceId: uniqueId
                                          });
                                          sublists.putSublistLine(sublistline);

                                          recordUtil.forEachProperty(line, function(fieldId, value){
                                              var cacher = bindCachingFunction(sublistId, fieldId);
                                              if(!recordUtil.matchRecordFieldValueSchema(value))
                                              {
                                                  value = util.isArray(value) && value.length === 1 ? value[0] : value;
                                                  value = recordUtil.transformRawValueToFieldValueSchema(value, cacher)
                                              }

                                              sublistline.setFieldValue(fieldId, value);
                                          });


                                          if (!!subrecordData.link[sublistId])
                                          {
                                              if (sublistline.getFieldValue(subrecordUtil.SYS_ID) === undefined)
                                              {
                                                  var sys_id = subrecordUtil.getNextSysId(isNew);
                                                  sublistline.setFieldValue(subrecordUtil.SYS_ID, {
                                                      value: sys_id,
                                                      legacyStringValue: sys_id
                                                  });
                                                  sublistline.setFieldValue(subrecordUtil.SYS_PARENT_ID, {
                                                      value: "0",
                                                      legacyStringValue: "0"
                                                  });
                                              }
                                          }
                                      });
                        sublistsLinesSequencesToInstanceIds.update(sublistId);
                    }
                }
            })(recordDataObj.sublist || {});

        })(recordDataObj);

        this.on = emitter.on;
        this.off = emitter.off;

        function createSublistLine(options)
        {
            var newSublistLine = sublistLine.create({
                    id: options.id,
                    lineIndex: options.lineIndex,
                    toBeCloned: options.toBeCloned,
                    defaultLineData: options.defaultLineData,
                    noCopyToDefaultMap: options.noCopyToDefaultMap
                });

            var lineInstanceId = options.lineInstanceId || uuid.generateV4();
            newSublistLine.setPrimitiveValue('_id', lineInstanceId);

            var sequence = isNaN(options.sequence) ? -1 : options.sequence;
            newSublistLine.setPrimitiveValue('_sequence', sequence);

            var asBuffer = !!options.asBuffer;

            modelEvent.forwardSublistLineEvents(emitter, newSublistLine, asBuffer);
            modelEvent.createLine(emitter, newSublistLine, asBuffer, options.origin, options.suppressEmit);

            return newSublistLine;
        }

        //TODO: Support Private

        function getSublistLineForInstance(sublistId, lineInstanceId, isCommitted, suppressEmit)
        {
            function getSublistCommittedLineForInstance(sublistId, lineInstanceId)
            {
	            return sublists.getSublistLine(sublistId, lineInstanceId);
            }

            function getSublistBufferedLineForInstance(sublistId, lineInstanceId)
            {
                var sublistLineBuffer = sublistsBuffers.getSublistLine(sublistId, lineInstanceId);

                if (!sublistLineBuffer)
                {
                    var sublistLine = getSublistCommittedLineForInstance(sublistId, lineInstanceId);
                    if(!!sublistLine)
                    {
                        sublistLineBuffer = createBuffer({line: sublistLine, suppressEmit: !!suppressEmit});
                    }
                }

                return sublistLineBuffer;
            }

            return (isCommitted ? getSublistCommittedLineForInstance : getSublistBufferedLineForInstance)(sublistId, lineInstanceId);
        }
	    this.getSublistLineForInstance = getSublistLineForInstance;

        function getSublistSelectedLine(sublistId)
        {
            var isCommitted = false;
            var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
            return sublistLineBuffer;
        }

	    function removeLineBufferForInstance(sublistId, lineInstanceId, suppressEmit, origin)
        {
        	var removedLine = null;
            if(sublistsBuffers.hasSublistLine(sublistId, lineInstanceId))
            {
                var bufferIsSelected = lineInstanceId === sublistsSelectedLineInstanceIds.get(sublistId);
                if (bufferIsSelected) {
                    //TODO this can not be removed during a commit
                    // a dead zone exists where data has been moved but the knowledge of the selected line exists
                    // some scripts are taking advantage of this
                    // nlapiGetLineItemField with no line param is being called during recalc
                    //sublistsSelectedLineInstanceIds.remove(sublistId);
                }

	            removedLine = sublistsBuffers.removeSublistLine(sublistId, lineInstanceId);
                modelEvent.unforwardSublistLineEvents(removedLine);
                sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
                var isBuffer = true;
                modelEvent.deleteLine(emitter, removedLine, isBuffer, origin, !!suppressEmit);
            }
            return removedLine;
        }

        function removeCurrentLine(sublistId)
        {
            if(sublistsSelectedLineInstanceIds.has(sublistId))
            {
                var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
                removeLineBufferForInstance(sublistId, lineInstanceId);
            }
        }

        function updateSublistLineSequenceFromStartByAmount(sublistId, start, amount)
        {
            sublists.getSublistLinesAsOrderedList(sublistId).
                filter(function(sublistline){ return start <= sublistline.getFieldValue('_sequence');}).
                forEach(function(sublistline){
                    var newSequence = sublistline.getFieldValue('_sequence') + amount;
                    sublistline.setPrimitiveValue('_sequence', newSequence);
                    sublistline.index += amount;

                    var id = sublistline.getFieldValue('_id');
                    if(sublistsBuffers.hasSublistLine(sublistId, id))
                    {
                        var sublistlineBuffer = sublistsBuffers.getSublistLine(sublistId, id);
                        sublistlineBuffer.setPrimitiveValue('_sequence', newSequence);
                        sublistlineBuffer.index += amount;
                    }
                });

            sublistsBuffers.getSublistLinesAsOrderedList(sublistId).
                filter(function(sublistlineBuffer){
                    var isStartOrGreater = start <= sublistlineBuffer.getFieldValue('_sequence');
                    var isUncommitted = !sublists.hasSublistLine(sublistId, sublistlineBuffer.getFieldValue('_id'));

                    return isStartOrGreater && isUncommitted;
                }).
                forEach(function(sublistlineBuffer){
                    var newSequence = sublistlineBuffer.getFieldValue('_sequence') + amount;
                    sublistlineBuffer.setPrimitiveValue('_sequence', newSequence);
                    sublistlineBuffer.index += amount;
                });
        }

        function updateSublistLineSequenceFromStartByPos1(sublistId, start)
        {
            updateSublistLineSequenceFromStartByAmount(sublistId, start, 1);
        }

        function updateSublistLineSequenceFromStartByNeg1(sublistId, start)
        {
            updateSublistLineSequenceFromStartByAmount(sublistId, start, -1);
        }

        function runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList)
        {
        	try
	        {
	            sublistsSelectedLineInstanceIds.put(sublistId, lineInstanceId);
	            func.apply(thisArg, argList);
	        }
	        finally
	        {
	            sublistsSelectedLineInstanceIds.remove(sublistId);
	        }
        }
        this.runFunctionWhileSilentlySelectingLine = runFunctionWhileSilentlySelectingLine;

        function doSelect(sublistId, sublistline, isMultilineEditable)
        {
            var isBuffer = true;
            var previousSelectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            if(previousSelectedLineInstanceId !== null && !sublists.hasSublistLine(sublistId, previousSelectedLineInstanceId) && !isMultilineEditable)
            {
                removeLineBufferForInstance(sublistId, previousSelectedLineInstanceId);
            }

            sublistsSelectedLineInstanceIds.update(sublistId, sublistline.getFieldValue('_id'));
            modelEvent.selectLine(emitter, sublistline, isBuffer);
        }

        function doAdd(sublistId, sublistline, isInsertLineWhileMultilineEditable)
        {
	        //Check for MLB to avoid committing line after insertion.
	        if(isInsertLineWhileMultilineEditable)
	        {
		        sublistsBuffers.putSublistLine(sublistline);
	        }
	        else
	        {
		        sublists.putSublistLine(sublistline);
	        }

	        sublistsLinesSequencesToInstanceIds.update(sublistId);
	        sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
	        modelEvent.insertLine(emitter, sublistline);
        }

        function doInsert(sublistId, sublistline, isMultilineEditable)
        {
            var line = sublistline.getFieldValue('_sequence');
            updateSublistLineSequenceFromStartByPos1(sublistId, line);
	        doAdd(sublistId, sublistline, isMultilineEditable);
        }

        function doUpdate(sublistId, sublistline)
        {
            sublists.putSublistLine(sublistline);
            modelEvent.updateLine(emitter, sublistline);
        }

        function createBuffer(options){
            var sublistLineOptions = {
                asBuffer: true,
	        suppressEmit: options.suppressEmit || false
            };

            sublistLineOptions.suppressEmit = options.suppressEmit;

            if(!!options.line)
            {
                sublistLineOptions.id = options.line.id;
                sublistLineOptions.lineInstanceId = options.line.getFieldValue('_id');
                sublistLineOptions.lineIndex = options.line.index;
                sublistLineOptions.sequence = options.line.getFieldValue('_sequence');
                sublistLineOptions.toBeCloned = options.line;
            }
            else
            {
                sublistLineOptions.id = options.sublistId;
                sublistLineOptions.lineInstanceId = options.lineInstanceId;
                sublistLineOptions.lineIndex = options.index;
                sublistLineOptions.sequence = options.sequence;
                sublistLineOptions.defaultLineData = options.defaultLineData;
            }

            var sublistlineBuffer = createSublistLine(sublistLineOptions);

            sublistsBuffers.putSublistLine(sublistlineBuffer);
            sublistsBuffersLinesSequencesToInstanceIds.update(sublistLineOptions.id);
            //modelEvent.insertLine(emitter, sublistline); TODO Event for opening buffer - multiline - should be independent from select???

            return sublistlineBuffer;
        }

        function updateNewLineBufferWithCopy(sublistLineOptions)
        {
        	var fromBuffer = true;
        	util.extend(sublistLineOptions, {origin: modelEvent.Origin.COPY});
	        removeLineBufferForInstance(sublistLineOptions.id, sublistLineOptions.lineInstanceId);

	        var newNewLineBuffer = doCopyLine(sublistLineOptions);
	        modelEvent.updateLine(emitter, newNewLineBuffer, fromBuffer);
	        modelEvent.selectLine(emitter, newNewLineBuffer, fromBuffer);
	        return newNewLineBuffer.getFieldValue('_id');
        }
        this.updateNewLineBufferWithCopy = updateNewLineBufferWithCopy;

        function doCopyLine(sublistLineOptions)
        {
	        var newNewLineBuffer = createSublistLine(sublistLineOptions);
	        sublistsBuffers.putSublistLine(newNewLineBuffer);
	        sublistsBuffersLinesSequencesToInstanceIds.update(sublistLineOptions.id);
	        return newNewLineBuffer;
        }

		function putCopyIntoNewLineBuffer(sublistId, line, isMultilineEditable, noCopyToDefaultMap)
		{
			var isCommitted = false;
			var newLineIndex = isMultilineEditable? getNextNewLineIndex_MLB(sublistId) : getSublistNewLineIndex(sublistId);// _MLB version is actually making a new one vs old way getting the previous new index
			var previousNewLineInstanceId = getSublistLineInstanceIdForIndex(sublistId, newLineIndex, isCommitted);
			var wasPreviousNewLineSelected = sublistsSelectedLineInstanceIds.get(sublistId) === previousNewLineInstanceId;
			var sublistLineOptions = {
				asBuffer: !isCommitted,
				id: sublistId,
				lineIndex: newLineIndex,
				sequence: newLineIndex,
				toBeCloned: line,
				origin: modelEvent.Origin.COPY,
				noCopyToDefaultMap: noCopyToDefaultMap
			};

			if(!isMultilineEditable)
			{
				removeLineBufferForInstance(sublistId, previousNewLineInstanceId);
			}

			var newNewLineBuffer = doCopyLine(sublistLineOptions);
			var newNewLineInstanceId = newNewLineBuffer.getFieldValue('_id');

			if (!isMultilineEditable)
			{
				modelEvent.selectLine(emitter, newNewLineBuffer, !isCommitted); // select the newly created line only in SLB mode.

				if(wasPreviousNewLineSelected)
				{
					sublistsSelectedLineInstanceIds.update(sublistId, newNewLineInstanceId);
				}
			}

			return newNewLineInstanceId;
		}
		this.putCopyIntoNewLineBuffer = putCopyIntoNewLineBuffer;

        //TODO: Support Public
        function getSublists()
        {
            return sublists.getSublists();
        }
        this.getSublists = getSublists;

        //TODO: [MLB] Followup 3A - chance for misuse. Sweep for safety
        function getSublistLineCount(sublistId)
        {
            return sublists.getSublistLineCount(sublistId);
        }
        this.getSublistLineCount = getSublistLineCount;

	    function getSublistLineCountWithAllNewLines(sublistId)
	    {
		    return sublistsBuffers.getSublistLineCount(sublistId);
	    }
	    this.getSublistLineCountWithAllNewLines = getSublistLineCountWithAllNewLines;

	    //TODO: [MLB] Followup 3B - chance for misuse. Sweep for safety
        function getSublistNewLineIndex(sublistId)
        {
            return getSublistLineCount(sublistId);
        }
        this.getSublistNewLineIndex = getSublistNewLineIndex;

	    function getNextNewLineIndex_MLB(sublistId)
	    {
		    var lastUncommitted = sublistsBuffers.getSublistLinesAsOrderedList(sublistId).slice(-1).pop();
		    var lastCommitted   = sublists.getSublistLinesAsOrderedList(sublistId).slice(-1).pop();

		    var lastUncommittedIndex = !!lastUncommitted ? lastUncommitted.getFieldValue("_sequence") : -1;
		    var lastCommittedIndex   = !!lastCommitted   ? lastCommitted.getFieldValue("_sequence")   : -1;

		    return Math.max(lastCommittedIndex, lastUncommittedIndex) + 1;
	    }
	    this.getNextNewLineIndex_MLB = getNextNewLineIndex_MLB;

        function getSublistSelectedLineInstanceId(sublistId)
        {
            return sublistsSelectedLineInstanceIds.get(sublistId);
        }
        this.getSublistSelectedLineInstanceId = getSublistSelectedLineInstanceId;

        function isSublistLineInstanceIdSelected(sublistId, lineInstanceId)
        {
            var selectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);

            return lineInstanceId === selectedLineInstanceId;
        }
        this.isSublistLineInstanceIdSelected = isSublistLineInstanceIdSelected;

        function isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted, allowFallback)
        {
            var sublistsController = !isCommitted ? sublistsBuffers : sublists;
            var isValid = sublistsController.hasSublistLine(sublistId, lineInstanceId);

	        // allowFallback=T means as long as the instanceId exists you should return True even if isCommitted=F was False.
            if (!isValid && !isCommitted && !!allowFallback)
            	isValid = sublists.hasSublistLine(sublistId, lineInstanceId);

            return isValid;
        }
        this.isSublistLineInstanceIdValid = isSublistLineInstanceIdValid;

        function getSublistLineInstanceIdForIndex(sublistId, line, isCommitted)
        {
            var lineInstanceId = null;
            if(!isCommitted)
            {
                lineInstanceId = sublistsBuffersLinesSequencesToInstanceIds.get(sublistId, line);
            }
            else
            {
                lineInstanceId = sublistsLinesSequencesToInstanceIds.get(sublistId, line);
            }

            lineInstanceId = lineInstanceId || null;

            return lineInstanceId;
        }
        this.getSublistLineInstanceIdForIndex = getSublistLineInstanceIdForIndex;

// ==================== NEW SEQUENCE OBTAINING APIs ADDED HERE
	    function getAllPossibleSequenceToLineInstanceIdsMap_MLB(sublistId)
	    {
		    var committedMap = sublists.getSequenceToInstanceIdMap(sublistId);
		    var uncommittedMap = sublistsBuffers.getSequenceToInstanceIdMap(sublistId);
		    var mismatch = Object.keys(committedMap).filter({}.hasOwnProperty.bind(uncommittedMap))
			    .filter(function (seq) { return committedMap[seq] !== uncommittedMap[seq]; });
		    if(mismatch.length > 0)
			    throw "ERROR ERROR. MISMATCH OF SEQUENCE TO LINEIDs FOUND: comm[" + JSON.stringify(committedMap) + "] uncomm[" + JSON.stringify(uncommittedMap) + "] bad idxs:"+ mismatch;
		    return util.extend(util.extend({}, committedMap), uncommittedMap);
	    }

        function getSpecifiedLineInstanceIdByIndex(sublistId, index)
        {
	        var allSeqToInstId = getAllPossibleSequenceToLineInstanceIdsMap_MLB(sublistId);
			return allSeqToInstId.hasOwnProperty(index) ? allSeqToInstId[index] : null;
        }
        this.getSpecifiedLineInstanceIdByIndex = getSpecifiedLineInstanceIdByIndex;

	    function lineIndexIsNewLine_MLB(sublistId, line)
	    {
		    var uncommitted = sublistsBuffersLinesSequencesToInstanceIds.get(sublistId, line);
		    var committed = sublistsLinesSequencesToInstanceIds.get(sublistId, line);
		    return (uncommitted !== undefined) && (committed === undefined)
	    }
	    this.lineIndexIsNewLine_MLB = lineIndexIsNewLine_MLB;

	    function updateCurrentLineToANewLine_MLB(sublistId, lineObj)
	    {
		    var isCommitted = false;
		    sublistsSelectedLineInstanceIds.update(sublistId, lineObj.getFieldValue('_id'));
		    modelEvent.selectLine(emitter, lineObj, !isCommitted);
	    }
	    this.updateCurrentLineToANewLine_MLB = updateCurrentLineToANewLine_MLB;

	    function getSublistLineInstanceIds(sublistId, isCommitted)
	    {
		    var sublistList = [];

		    if (isCommitted)
		    {
			    sublistList = sublists.getSublistLineInstanceIdsAsOrderedList(sublistId);
		    }
		    else // may not have one created yet, if there's a committed, it can have an uncommitted.
		    {
			    var allSequenceToIdsMap = getAllPossibleSequenceToLineInstanceIdsMap_MLB(sublistId);
			    sublistList = Object.keys(allSequenceToIdsMap).sort(function(a,b) { return a-b }).map(function(seq){ return allSequenceToIdsMap[seq]; });
		    }
		    return sublistList;
	    }
	    this.getSublistLineInstanceIds = getSublistLineInstanceIds;
// ==================================================================

        function getBodyFieldIds()
        {
            var fieldIds = [];
            for (var fieldId in bodyFields)
                fieldIds.push(fieldId);

            return fieldIds;
        }
        this.getBodyFieldIds = getBodyFieldIds;

        function getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted)
        {
            var fieldIds = null;
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);

            if (!!sublistLine)
            {
                fieldIds = Object.keys(sublistLine.getData());
            }
            return fieldIds;
        }
        this.getSublistLineFieldIds = getSublistLineFieldIds;

        function getBodyValue(fieldId)
        {
            var fieldValue = "";
            if (util.isObject(bodyFields[fieldId]))
            {
                if (!!bodyFields[fieldId].value || bodyFields[fieldId].value === "" || bodyFields[fieldId].value === 0 || bodyFields[fieldId].value === false)
                    fieldValue = bodyFields[fieldId].value;
                else
                    fieldValue = recordUtil.emptyIfNullOrUndefined(bodyFields[fieldId].legacyStringValue);
            }

            return fieldValue;
        }
        this.getBodyValue = getBodyValue;

        function getSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var value = null;
	        if (doesSublistExist(sublistId, isCommitted))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
                if (!!sublistline)
                {
                    value = sublistline.getFieldValue(fieldId);
                }
            }

            return value;
        }
        this.getSublistLineValue = getSublistLineValue;

        function getBodyValueAsLegacyString(fieldId)
        {
            var fieldValue = "";
            if(util.isObject(bodyFields[fieldId]))
            {
                if(!!bodyFields[fieldId].legacyStringValue || bodyFields[fieldId].legacyStringValue === "" || bodyFields[fieldId].legacyStringValue === 0 || bodyFields[fieldId].legacyStringValue === false)
                    fieldValue = bodyFields[fieldId].legacyStringValue;
            }
            return fieldValue;
        }
        this.getBodyValueAsLegacyString = getBodyValueAsLegacyString;

        function getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var value = null;

            if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

	        if (doesSublistExist(sublistId, isCommitted))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
                if(!!sublistline)
                {
                    value = sublistline.getValueAsLegacyString(fieldId);
                }
            }
            return value;
        }
        this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

        function setBodyValue(fieldId, recordFieldValue)
        {
            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
            var oldValue = getBodyValue(fieldId);
            bodyFields[fieldId] = recordFieldValue;
            var newValue = getBodyValue(fieldId);
            if(oldValue !== newValue)
            {
                modelEvent.updateField(emitter, fieldId, oldValue, newValue);
            }
        }
        this.setBodyValue = setBodyValue;

        function setSublistLineValue(sublistId, lineInstanceId, fieldId, recordFieldValue, isCommitted)
        {
            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
            var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
            if(!!sublistline)
            {
                sublistline.setFieldValue(fieldId, recordFieldValue);
            }
        }
        this.setSublistLineValue = setSublistLineValue;

        function setBodyValuePrimitive(fieldId, value)
        {
            var oldValue = getBodyValue(fieldId);
            if (hasBodyValue(fieldId))
                bodyFields[fieldId].value = value;
            else
                bodyFields[fieldId] = {value: value, legacyStringValue: undefined};
            var newValue = getBodyValue(fieldId);
            if(oldValue !== newValue)
            {
                modelEvent.updateField(emitter, fieldId, oldValue, newValue, true);
            }
        }
        this.setBodyValuePrimitive = setBodyValuePrimitive;

        function setSublistLineValuePrimitive(sublistId, lineInstanceId, fieldId, value, isCommitted)
        {
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
            sublistLine.setPrimitiveValue(fieldId, value);
        }
        this.setSublistLineValuePrimitive = setSublistLineValuePrimitive;

        function hasBodyValue(fieldId)
        {
            return bodyFields.hasOwnProperty(fieldId);
        }
        this.hasBodyValue = hasBodyValue;

        function hasSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var result = false;
	        if (doesSublistExist(sublistId, isCommitted))
            {
            	var suppressEmit = true; // to avoid firing CREATE_LINE event on getValue()
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted, suppressEmit);
                if(!!sublistline)
                {
                    result = sublistline.hasFieldValue(fieldId);
                }
            }
            return result;
        }
        this.hasSublistLineValue = hasSublistLineValue;

	    function doesSublistExist(sublistId, isCommitted)
	    {
		    var sublistContainer = !isCommitted ? sublistsBuffers : sublists;
		    return sublistContainer.sublistExists(sublistId);
	    }
	    this.doesSublistExist = doesSublistExist;

        function removeBodyValue(fieldId)
        {
            if (bodyFields.hasOwnProperty(fieldId)) {
                var oldValue = getBodyValue(fieldId);
                delete bodyFields[fieldId];
                modelEvent.updateField(emitter, fieldId, oldValue);
            }
        }
        this.removeBodyValue = removeBodyValue;

        function removeSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
            sublistline.removeFieldValue(fieldId);
        }
        this.removeSublistLineValue = removeSublistLineValue;

        function insertSublistLine(sublistId, beforeLineInstanceId, isMultilineEditable)
        {
            var isCommitted = null;
            var beforeSublistline = null;

            if(sublists.hasSublistLine(sublistId, beforeLineInstanceId))
            {
                isCommitted = true;
            }
            else if(sublistsBuffers.hasSublistLine(sublistId, beforeLineInstanceId))
            {
                isCommitted = false;
            }

            if(isCommitted !== null)
            {
                beforeSublistline = getSublistLineForInstance(sublistId, beforeLineInstanceId, isCommitted);
            }

	        var line = !!beforeSublistline ? beforeSublistline.index : Math.max(getNextNewLineIndex_MLB(sublistId), 0);
            var sublistline = createSublistLine({id: sublistId, lineIndex: line, sequence: line, asBuffer: !isCommitted});
            doInsert(sublistId, sublistline, isMultilineEditable);

            return sublistline.getFieldValue('_id');
        }
        this.insertSublistLine = insertSublistLine;

        function removeSublistLine(sublistId, lineInstanceId)
        {
            if (sublists.hasSublistLine(sublistId, lineInstanceId))
            {
                cancelSublistLine(sublistId, lineInstanceId, true);

                var sublistline = sublists.removeSublistLine(sublistId, lineInstanceId);
                modelEvent.unforwardSublistLineEvents(sublistline);
                var line = sublistline.getFieldValue('_sequence');
                updateSublistLineSequenceFromStartByNeg1(sublistId, line);
                sublistsLinesSequencesToInstanceIds.update(sublistId);
                sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
                modelEvent.deleteLine(emitter, sublistline);
            }
        }
        this.removeSublistLine = removeSublistLine;

        function selectSublistLine(sublistId, lineInstanceId, isMultilineEditable)
        {
            var isCommitted = true;
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
            var sublistlineBuffer = createBuffer({line: sublistLine});

            doSelect(sublistId, sublistlineBuffer, isMultilineEditable);
        }
        this.selectSublistLine = selectSublistLine;

        function selectNewSublistLine(sublistId, defaultValues)
        {
            //var isBuffer = true;
            var line = getSublistNewLineIndex(sublistId);
            //resetCurrentSublistLine(sublistId, line, defaultValues);

            var selectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            var wasCommitted = sublists.hasSublistLine(sublistId, selectedLineInstanceId);
            if(!wasCommitted)
            {
                removeSublistLine(sublistId, selectedLineInstanceId);
            }

            var newSublistline = createBuffer({
                    sublistId: sublistId,
                    index: line,
                    sequence: line,
                    defaultLineData: defaultValues
                });

            doSelect(sublistId, newSublistline);

            return sublistsSelectedLineInstanceIds.get(sublistId);
        }
        this.selectNewSublistLine = selectNewSublistLine;

	    function addNewSublistLine(sublistId, defaultValues)
	    {
		    var newLineIdx = getNextNewLineIndex_MLB(sublistId);
		    var newSublistline = createBuffer({
			    sublistId: sublistId,
			    index: newLineIdx,
			    sequence: newLineIdx,
			    defaultLineData: defaultValues
		    });
		    return newSublistline.getFieldValue('_id');
	    }
	    this.addNewSublistLine = addNewSublistLine;

        function cancelSublistLine(sublistId, lineInstanceId, suppressEmit, originNotCancel)
        {
        	var removedLine = null;
            if(sublistsBuffers.hasSublistLine(sublistId, lineInstanceId))
            {
                var origin = originNotCancel ? undefined : modelEvent.Origin.CANCEL;
	            removedLine = removeLineBufferForInstance(sublistId, lineInstanceId, !!suppressEmit, origin);
            }
            // update indexes after this since this is not necessarily the last line anymore (MLB)
            if(!sublists.hasSublistLine(sublistId, lineInstanceId) && removedLine != null)
            {
	            updateSublistLineSequenceFromStartByNeg1(sublistId, removedLine.getFieldValue("_sequence"));
	            sublistsLinesSequencesToInstanceIds.update(sublistId);
	            sublistsBuffersLinesSequencesToInstanceIds.update(sublistId);
            }
        }
        this.cancelSublistLine = cancelSublistLine;

        function resetSublistLine(sublistId, lineInstanceId, defaultValues, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

            if(isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
                var newSublistlineOptions = {
                        asBuffer: !isCommitted,
                        id: sublistline.id,
                        lineInstanceId: sublistline.getFieldValue('_id'),
                        lineIndex: sublistline.index,
                        sequence: sublistline.getFieldValue('_sequence'),
                        defaultLineData: defaultValues
                    };

                var resetSublistline = createSublistLine(newSublistlineOptions);

                var sublistsController = !isCommitted ? sublistsBuffers : sublists;
                sublistsController.putSublistLine(resetSublistline);
            }
        }
        this.resetSublistLine = resetSublistLine;

        function getSublistSelectedLineIndex(sublistId)
        {
            var result = -1;
            var sublistline = getSublistSelectedLine(sublistId);
            if(!!sublistline)
            {
                result = sublistline.index;
            }

            return result;
        }
        this.getSublistSelectedLineIndex = getSublistSelectedLineIndex;

        function commitSublistLine(sublistId, lineInstanceId, isMultiLineEditable)
        {
            var isCommitted = false;
            var sublistlineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);

            if (!!sublistlineBuffer)
            {
	            var isSelected = sublistsSelectedLineInstanceIds.get(sublistId) === lineInstanceId;
                removeLineBufferForInstance(sublistId, lineInstanceId, true);

                modelEvent.forwardSublistLineEvents(emitter, sublistlineBuffer, false);

                if(!sublists.hasSublistLine(sublistId, sublistlineBuffer.getFieldValue('_id')))
                {
                    doAdd(sublistId, sublistlineBuffer);
	                if (isSelected && !isMultiLineEditable) // ensure the SELECT event is not lost due to the previous REMOVE event
		                modelEvent.selectLine(emitter, sublistlineBuffer, !isCommitted);
                }
                else
                {
                    doUpdate(sublistId, sublistlineBuffer);
                }
            }
        }
        this.commitSublistLine = commitSublistLine;

        function emitLineIsCommittableEvent(sublistId, lineInstanceId)
        {
        	var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, false);
        	modelEvent.committableLine(emitter, sublistLineBuffer);
        }
        this.emitLineIsCommittableEvent = emitLineIsCommittableEvent;

	    function emitLineIsNotCommittableEvent(sublistId, lineInstanceId)
	    {
		    var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, false);
		    modelEvent.notCommittableLine(emitter, sublistLineBuffer);
	    }
	    this.emitLineIsNotCommittableEvent = emitLineIsNotCommittableEvent;

	    function emitRecordIsSavableEvent()
	    {
		    modelEvent.savableRecord(emitter);
	    }
	    this.emitRecordIsSavableEvent = emitRecordIsSavableEvent;

	    function emitRecordIsNotSavableEvent()
	    {
		    modelEvent.notSavableRecord(emitter);
	    }
	    this.emitRecordIsNotSavableEvent = emitRecordIsNotSavableEvent;

        function getSubrecordDataForSubmission()
        {
            var result;

            var subrecordLinks = Object.keys(subrecordData.link);
            if (subrecordLinks.length > 0)
            {
                result = {};
                result['subrecord_parent'] = {
                    fields: ['parent'],
                    size: subrecordLinks.length,
                    data: subrecordLinks.map(function (v, i, a)
                                             {
                                                 return [v];
                                             })
                };
            }

            subrecordLinks.forEach(function (sublistId, i1, a1)
                                   {
                                       var link = subrecordData.link[sublistId];

                                       result['children_' + sublistId] = {
                                           fields: ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
                                           size: link.length,
                                           data: link.map(function (v2, i2, a2)
                                                          {
                                                              return [v2.childfieldname, v2.childmachinename, v2.childlinktype, v2.childtype];
                                                          })
                                       };

                                       link.forEach(function (v2, i2, a2)
                                                    {
                                                        var fieldId = v2.childfieldname,
                                                                subrecords;

                                                        if(!!v2.sublinks && v2.sublinks.length > 0)
                                                        {
                                                            result['children_' + v2.childmachinename] = {
                                                                fields : ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
                                                                size : v2.sublinks.length,
                                                                data : v2.sublinks.map(function(v3, i3, a3){
                                                                    return [v3.childfieldname || null, v3.childmachinename, v3.childlinktype, v3.childtype];
                                                                })
                                                            };
                                                        }

                                                        if(!!v2.sublinks && v2.sublinks.length > 0)
                                                        {
                                                            result['children_' + v2.childmachinename] = {
                                                                fields : ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
                                                                size : v2.sublinks.length,
                                                                data : v2.sublinks.map(function(v3, i3, a3){
                                                                    return [v3.childfieldname || null, v3.childmachinename, v3.childlinktype, v3.childtype];
                                                                })
                                                            };
                                                        }

                                                        if (sublistId === recordType)
                                                        {
                                                            subrecords = subrecordData.cache.get(null, fieldId);
                                                            subrecords = subrecords === undefined ? [] : [subrecords];
                                                        }
                                                        else
                                                        {
                                                            subrecords = subrecordData.cache.getSublist(sublistId);
                                                            subrecords = subrecords === undefined ? [] :
                                                                Object.keys(subrecords).map(function(lineInstanceId){
                                                                    var cache = subrecords[lineInstanceId];
                                                                    return !!cache && cache.get(fieldId) || undefined;
                                                                }).reduce(function (p, c){
                                                                    if (c !== undefined)
                                                                    {
                                                                        p.push(c);
                                                                    }
                                                                    return p;
                                                                }, []);
                                                        }

                                                        if (subrecords.length > 0)
                                                        {

                                                            subrecords.forEach(function (v3, i3, a3)
                                                                               {
                                                                                   var initial = v3.initial, current = v3.current;

                                                                                   var isExistingSubrecord = !!initial && !!current && initial.getValueAsLegacyString(subrecordUtil.SYS_ID) === current.getValueAsLegacyString(subrecordUtil.SYS_ID);
                                                                                   if (isExistingSubrecord)
                                                                                   {
                                                                                       storeSubrecordAsSublist(result, current, 'EDIT', v2.childmachinename, v2.sublinks);
                                                                                   }
                                                                                   else
                                                                                   {
                                                                                       var isNewSubrecord = !!current;
                                                                                       if (isNewSubrecord)
                                                                                       {

                                                                                           storeSubrecordAsSublist(result, current, 'CREATE', v2.childmachinename, v2.sublinks);
                                                                                       }
                                                                                       var isSubrecordDeleted = !!initial;
                                                                                       if (isSubrecordDeleted)
                                                                                       {
                                                                                           storeSubrecordAsSublist(result, initial, 'DELETE', v2.childmachinename, v2.sublinks);

                                                                                       }
                                                                                   }
                                                                               });
                                                        }
                                                    });
                                   });
            return result;
        }
        this.getSubrecordDataForSubmission = getSubrecordDataForSubmission;

        function storeSubrecordAsSublist(data, record, operation, childmachinename, sublinks)
        {
            var fieldIds = [subrecordUtil.SYS_OP].concat(Array.prototype.sort.apply(record.getFields()));
            var values = fieldIds.map(function(fieldId){return recordUtil.emptyIfNullOrUndefined(record.getValueAsLegacyString(fieldId));});
            values[0] = operation;

            storeAsSublist(data, childmachinename, fieldIds, values);
            storeSubrecordSublistsAsSublist(data, record, operation, sublinks);
        }
        function storeSubrecordSublistsAsSublist(data, record, operation, sublinks)
        {
            if(!!sublinks && sublinks.length > 0)
            {
                sublinks.forEach(function (sublink){
                    storeSubrecordSublistAsSublist(data, record, sublink.childtype, operation, sublink.childmachinename, sublink.childfieldname);
                });
            }
        }
        function storeSubrecordSublistAsSublist(data, record, sublistId, operation, childmachinename, childfieldname)
        {
            var fieldIds, values;

            if (childfieldname === 'null')
            {
                fieldIds = [subrecordUtil.SYS_OP, subrecordUtil.SYS_PARENT_ID, subrecordUtil.SYS_ID].concat(Array.prototype.sort.apply(record.getSublistFields(sublistId)));

                for (var line_0 = 0; line_0 < record.doGetLineCount(sublistId); line_0 += 1)
                {
                    values = fieldIds.map(function (fieldId) {return recordUtil.emptyIfNullOrUndefined(record.getSublistLineValueAsLegacyString(sublistId, fieldId, line_0));});
                    values[0] = operation;

                    if (operation === 'EDIT')
                    {
                        if (!record.getSublistState(sublistId).isLineChanged(line_0))
                        {
                            values[0] = 'VIEW';
                        }
                        if (record.getSublistState(sublistId).isLineInserted(line_0))
                        {
                            values[0] = 'CREATE';
                        }
                    }

                    storeAsSublist(data, childmachinename, fieldIds, values);
                }
            }
        }

        function storeAsSublist(sublistData, sublistId, fieldIds, values)
        {
            sublistData[sublistId] = sublistData[sublistId] || {};
            sublistData[sublistId].fields = sublistData[sublistId].fields || fieldIds;
            sublistData[sublistId].data = sublistData[sublistId].data || [];
            sublistData[sublistId].data.push(values);
            sublistData[sublistId].size = sublistData[sublistId].data.length;
        }


        function getData()
        {
            return {body: bodyFields, sublists: getSublistData()};
        }
        this.getData = getData;

        function getSublistData()
        {
            var sublistData = {};
	        sublists.getSublists().forEach(function(sublistId){
                var currentLine = getSublistSelectedLine(sublistId);
                sublistData[sublistId] = {currentline: (!!currentLine ? currentLine.toJSON() : {})};

                sublists.getSublistLinesAsOrderedList(sublistId).
                    forEach(function(sublistline) {
                        sublistData[sublistId]['line ' + sublistline.getFieldValue('_sequence')] = sublistline.toJSON();
                    });
            });

            return sublistData;
        }
        this.getSublistData = getSublistData;

	    function getSublistLineJSON(sublistId, lineInstanceId, isCommitted)
	    {
		    return getSublistLineForInstance(sublistId, lineInstanceId, isCommitted).toJSON();
	    }
	    this.getSublistLineJSON = getSublistLineJSON;

        function getClonedData()
        {
            return {
                        bodyField: getClonedBodyFields(),
                        sublist: getClonedSublistData(),
                        subrecord: recordDataObj.subrecord
                    };
        }
        this.getClonedData = getClonedData;

        function cloneRecordValue(val)
        {
            var clone = val;
            if(util.isObject(val))
            {
                clone = recordUtil.clone({},val);
            }
            else if(util.isArray(val))
            {
                clone = val.map(function(entry){
                    return cloneRecordValue(entry);
                })
            }
            else if(util.isDate(val))
            {
                clone = new Date(val);
            }

            return clone;
        }

        function getClonedBodyFields()
        {
            var clone = {};
            recordUtil.forEachProperty(bodyFields, function(fieldId, value){
                clone[fieldId] = cloneRecordValue(value);
            });

            return clone;
        }

        function getClonedSublistData()
        {
            return getSublists().reduce(function(result, sublistId){
                result[sublistId] = sublists.getSublistLinesAsOrderedList(sublistId).
                    map(function(sublistline){
                        var rawData = sublistline.getData();
                        var clonedLine = {};
                        recordUtil.forEachProperty(rawData, function(fieldId, value){
                            clonedLine[fieldId] = cloneRecordValue(value);
                        });

                        return clonedLine;
                    });

                return result;
            }, {});
        }

        function toJSON()
        {
            var currentLines = {};
            return {
                body: bodyFields,
                sublists: getSublists().reduce(function(result, sublistId){
                    result[sublistId] = sublists.getSublistLinesAsOrderedList(sublistId);

                    return result;
                },{}),
                currentsublists: sublistsBuffers.getSublists().reduce(function(result, sublistId){
                    if(sublistsSelectedLineInstanceIds.has(sublistId))
                    {
                        var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
                        result[sublistId] = sublistsBuffers.getSublistLine(sublistId, lineInstanceId);
                    }

                    return result;
                },{})
            };
        }

        function shouldSetupSublistSystemId(id)
        {
            var hasExplicitLink = !!subrecordData.link[id];
            var hasImplicitLink = !!getBodyValue(subrecordUtil.SYS_ID) &&
                                  !!getBodyValue(subrecordUtil.SYS_PARENT_ID) && getBodyValue(subrecordUtil.SYS_PARENT_ID) !== '0';

            return hasExplicitLink || hasImplicitLink;
        }
        this.shouldSetupSublistSystemId = shouldSetupSublistSystemId;

        /**
         * retrieve the select option text from the cache by value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         */
        function getSelectOptionTextFromCache(sublistId, fieldId, value)
        {
        	var values = util.isArray(value) ? value : [value];
	        values = values.map(optionTextCache.get.bind(optionTextCache, sublistId, fieldId));
            return values;
        }
        this.getSelectOptionTextFromCache = getSelectOptionTextFromCache;

        /**
         * cache the option text into cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         * @param {string} text
         */
        function cacheSelectOptionText(sublistId, fieldId, value, text)
        {
	        var values = util.isArray(value) ? value : [value];
	        var texts = util.isArray(text) ? text : [text];
	        for (var i = 0; i < values.length && i < texts.length; i++)
		        optionTextCache.set(sublistId, fieldId, values[i], texts[i]);
        }
        this.cacheSelectOptionText = cacheSelectOptionText;
    }

    return {
        /**
         * create record model
         * @param options
         * @returns {Model}
         */
        create: function create(options)
        {
            return new Model(options);
        }
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordCache
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordCache',[], function(){

    /**
     * javascript object for holding cached object for record
     *
     * @protected
     * @return {RecordCache}
     * @constructor
     */
    function RecordCache()
    {
        var cache = {};

        /**
         * return true if entry existed
         *
         * @param {string} fieldId
         * @return {boolean}
         */
        function has(fieldId)
        {
            return cache.hasOwnProperty(fieldId);
        }
        this.has = has;

        /**
         * cache an entry
         *
         * @param {string} fieldId
         * @param {*} object
         */
        function put(fieldId, object)
        {
            cache[fieldId] = object;
        }
        this.put = put;

        /**
         * return a cached entry
         *
         * @param {string} fieldId
         * @return {*}
         */
        function get(fieldId)
        {
            return cache[fieldId];
        }
        this.get = get;

        /**
         * delete a cached entry
         *
         * @param {string} fieldId
         */
        function invalidate(fieldId)
        {
            delete cache[fieldId];
        }
        this.invalidate = invalidate;

        /**
         * get all cache keys
         *
         */
        function keys()
        {
            var keys = [];
            for(var k in cache)
                if(cache.hasOwnProperty(k))
                    keys[keys.length] = k;

            return keys;
        }
        this.keys = keys;
        return this;
    }

    return {
        /**
         * return a new instance of RecordCache
         * @returns {RecordCache}
         */
        create: function() { return new RecordCache(); }
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordCacheController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordCacheController',['N/record/recordCache'], function(recordCache){

    /**
     * record cache controller
     *
     * @protected
     * @return {RecordCacheController}
     * @constructor
     */
    function RecordCacheController()
    {
        var body = recordCache.create();
        var sublists = {};
        var sublistsBuffers = {};

        /**
         * put an entry into given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} isCommitted
         */
        function has(sublistId, fieldId, lineId, isCommitted)
        {
            var result = false;
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            if(cache)
                result = cache.has(fieldId);

            return result;
        }
        this.has = has;

        /**
         * put an entry into given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} isCommitted
         * @param {*} object
         */
        function put(sublistId, fieldId, lineId, object, isCommitted)
        {
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            if(cache)
                cache.put(fieldId, object);
        }
        this.put = put;

        /**
         * get an entry from given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} isCommitted
         * @return {RecordCache}
         */
        function get(sublistId, fieldId, lineId, isCommitted)
        {
            var obj;
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            if(cache)
                obj = cache.get(fieldId);

            return obj;
        }
        this.get = get;

        /**
         * invalidate an entry for given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} isCommitted
         */
        function invalidate(sublistId, fieldId, lineId, isCommitted)
        {
            var cache = null;

            if(!sublistId)
            {
                cache = getRecordCache();
            }
            else
            {
                if(!!lineId)
                {
                    if(!!fieldId)
                    {
                        cache = getRecordCache(sublistId, lineId, isCommitted);
                    }
                    else
                    {
                        var sublist = !isCommitted ? getSublistBuffer(sublistId) : getSublist(sublistId);
                        delete sublist[lineId];
                    }
                }
                else
                {
                    if(!isCommitted)
                    {
                        delete sublistsBuffers[sublistId];
                    }
                    else
                    {
                        delete sublists[sublistId];
                    }
                }
            }

            if(!!cache)
            {
                cache.invalidate(fieldId);
            }
        }
        this.invalidate = invalidate;

        /**
         * invalidate the sublist cache
         * @param {String} sublistId
         */
        function invalidateSublist(sublistId)
        {
            invalidate(sublistId, null, null, false);
        }
        this.invalidateSublist = invalidateSublist;

        /**
         * get record cache
         *
         * @param {string} sublistId
         * @param {string} lineId
         * @param {boolean} isCommitted
         * @return {RecordCache}
         */
        function getRecordCache(sublistId, lineId, isCommitted)
        {
            var cache = null;
            if (!!sublistId)
            {
                cache = getSublistCache(sublistId, lineId, isCommitted);
            }
            else
            {
                cache = body
            }

            return cache;
        }

        /**
         * get sublist cache
         *
         * @param {string} sublistId
         * @return {Object} sublist cache with sublistId as key
         */
        function getSublist(sublistId)
        {
            if (!sublists.hasOwnProperty(sublistId))
                sublists[sublistId] = {};
            return sublists[sublistId];
        }
        this.getSublist = getSublist;

        /**
         * get sublist buffer cache
         *
         * @param {string} sublistId
         * @return {Object} sublist buffer cache with sublistId as key
         */
        function getSublistBuffer(sublistId)
        {
            if (!sublistsBuffers.hasOwnProperty(sublistId))
                sublistsBuffers[sublistId] = {};
            return sublistsBuffers[sublistId];
        }
        this.getSublistBuffer = getSublistBuffer;

        /**
         * get sublist cache by line id
         *
         * @param {string} sublistId
         * @param {string} lineId
         * @param {boolean} isCommitted
         * @return {RecordCache}
         */
        function getSublistCache(sublistId, lineId, isCommitted)
        {
            var sublist = !isCommitted ? getSublistBuffer(sublistId) : getSublist(sublistId);

            var cache = sublist[lineId] || null;
            if(!cache)
            {
                cache = sublist[lineId] = recordCache.create();
            }
            return cache;
        }

        function fields(sublistId, lineId, isCommitted)
        {
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            return cache.keys();
        }
        this.fields = fields;

        /**
         * copy/clone the data from sublist cache to sublist buffer cache
         * @param {String} sublistId
         * @param {String} lineId
         * @param {Function} function to migrate the cache arg1 is fieldId, arg2 is the entry to be migrated, arg3 is sublist buffer cache
         */
        function migrateFromSublistToSublistBuffer(sublistId, lineId, functionToMigrate)
        {
                    var sublistBufferCache = getSublistCache(sublistId, lineId, false);
            var sublistCache = getSublistCache(sublistId, lineId, false);

            sublistCache.keys().forEach(function(cacheKey){
                functionToMigrate(cacheKey, sublistCache.get(cacheKey), sublistBufferCache);
            });
        }
        this.migrateFromSublistToSublistBuffer = migrateFromSublistToSublistBuffer;


        /**
         * commit the data in sublist buffer cache to sublist cache
         * @param {String} sublistId
         * @param {String} lineId
         * @param {Function}functionToCommit function to commit the sublist buffer cache: arg1 is fieldId, arg2 is the entry to be committed, arg3 is sublist cache
         */
        function commitFromSublistBufferToSublist(sublistId, lineId, functionToCommit)
        {
            var sublistCache = getSublistCache(sublistId, lineId, true);
            var sublistBufferCache = getSublistCache(sublistId, lineId, false);

            sublistBufferCache.keys().forEach(function(cacheKey){
                functionToCommit(cacheKey, sublistBufferCache.get(cacheKey), sublistCache);
            });
        }
        this.commitFromSublistBufferToSublist = commitFromSublistBufferToSublist;

        return this;
    }


    return {
        /**
         * get a new instance of RecordCacheController
         * @return {RecordCacheController}
         */
        create: function()
        {
            return new RecordCacheController();
        }
    }
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/modelController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/modelController',['N/record/model', 'N/record/recordCacheController', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/subrecordUtilityFunctions'],
	function(model, recordCacheController, utilityFunctions, recordUtil, subrecordUtil){

    /**
     *
     * @param {Object} options
     * @param {string} options.type recordType
     * @param {string} options.sublistFieldState recordType
     * @returns {ModelController}
     * @constructor
     */
    function ModelController(options)
    {
        var recordType = options.type;
        var sublistFieldStates = {};
        var fieldObjectCache = recordCacheController.create();
        var userFieldCache = recordCacheController.create();
        var selectOptionsCache = recordCacheController.create();
        var subrecordCache = recordCacheController.create();
        var subrecordTracker = {};
        var slavingTrackingMap = {};
        var scriptTrackingArray = [];
        var scriptTrackingNextSerial = 1;
        var pendingCalls = {};
        var saveRecordScriptTriggered = false;

        options.subrecordCache = subrecordCache;
        var _model = model.create(options);


        (function setSublistFieldState(sublistFieldState)
        {
            recordUtil.forEachProperty(sublistFieldState, function(sublistId, lines){
                sublistFieldStates[sublistId] = [];
                for (var line = 0; line < lines.length; line++)
                {
                    sublistFieldStates[sublistId][line] = {};
                    for (var fieldId in lines[line])
                    {
                        if (lines[line].hasOwnProperty(fieldId))
                        {
                            var state = lines[line][fieldId];
                            sublistFieldStates[sublistId][line][fieldId] = util.extend({}, state);
                        }
                    }
                }
            })
        })(options.sublistFieldState || {});


        /**
         * get the persisted field states
         * @param {string} sublistId
         * @param {Number} line
         * @returns {Object}
         */
        function getSublistFieldStates(sublistId, line)
        {
            return sublistFieldStates.hasOwnProperty(sublistId) &&
                   line >= 0 ? sublistFieldStates[sublistId][line] : null;
        }
        this.getSublistFieldStates = getSublistFieldStates;

        /**
         * return true if field exists
         * @param fieldId
         * @returns {boolean}
         */
        function hasFieldValue (fieldId) {
            return _model.hasBodyValue(fieldId);
        }
        this.hasFieldValue = hasFieldValue;

        function getSublistSelectedLineInstanceId(sublistId)
        {
            return _model.getSublistSelectedLineInstanceId(sublistId);
        }
        this.getSublistSelectedLineInstanceId = getSublistSelectedLineInstanceId;

        function isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted, allowFallback)
        {
            return _model.isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted, allowFallback);
        }
        this.isSublistLineInstanceIdValid = isSublistLineInstanceIdValid;

        function getSublistLineForInstance(sublistId, lineInstanceId, isCommitted, suppressEmit)
        {
            return _model.getSublistLineForInstance(sublistId, lineInstanceId, isCommitted, suppressEmit);
        }
        this.getSublistLineForInstance = getSublistLineForInstance;

        function isSublistLineInstanceIdSelected(sublistId, lineInstanceId)
        {
            return _model.isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
        }
        this.isSublistLineInstanceIdSelected = isSublistLineInstanceIdSelected;

        /**
         * set value by js primitive form for body field
         * @param {string} fieldId
         * @param {Object} value
         */
        function setParsedValueForBodyField(fieldId, value)
        {
            _model.setBodyValuePrimitive(fieldId, value);
        }
        this.setParsedValueForBodyField = setParsedValueForBodyField;

        function setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted)
        {
            _model.setSublistLineValuePrimitive(sublistId, lineInstanceId, fieldId, value, isCommitted);
        }
        this.setParsedValueForSublistFieldForInstance = setParsedValueForSublistFieldForInstance;

        /**
         * set value by js primitive form for sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param value
         */
        function setParsedValueForSublistField(sublistId, fieldId, line, value)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted);
        }
        this.setParsedValueForSublistField = setParsedValueForSublistField;

        /**
         * set value by js primitive form for current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param value
         */
        function setParsedValueForCurrentSublistField(sublistId, fieldId, value)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);
            setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted);
        }
        this.setParsedValueForCurrentSublistField = setParsedValueForCurrentSublistField;

        function setParsedValueForSublistLineBufferField(sublistId, lineInstanceId, fieldId, value)
        {
            var isCommitted = false;
            setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted);
        }
        this.setParsedValueForSublistLineBufferField = setParsedValueForSublistLineBufferField;

        /**
         * set field value
         * @param {string} fieldId
         * @param {Object} recordFieldValue
         * @param {string|Number|Boolean|Date} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setFieldValue(fieldId, recordFieldValue)
        {
            _model.setBodyValue(fieldId, recordFieldValue);
        }
        this.setFieldValue = setFieldValue;

        /**
         * return the primitive value for body field
         * @param {string} fieldId
         * @returns {string}
         */
        function getFieldValue(fieldId)
        {
            return hasFieldValue(fieldId) ? _model.getBodyValue(fieldId) : "";
        }
        this.getFieldValue = getFieldValue;

        /**
         * return the value for body field as legacy string format
         * @param {string} fieldId
         * @returns {string}
         */
        function getValueAsLegacyString(fieldId)
        {
            return hasFieldValue(fieldId) ? _model.getBodyValueAsLegacyString(fieldId) : null;
        }
        this.getValueAsLegacyString = getValueAsLegacyString;

        /**
         * return list of all body fields with value
         * @returns {string[]}
         */
        function getBodyFieldIds()
        {
            return _model.getBodyFieldIds();
        }
        this.getBodyFieldIds = getBodyFieldIds;

        /**
         * remove field
         * @param {string} fieldId
         */
        function removeFieldValue(fieldId)
        {
            _model.removeBodyValue(fieldId);
            invalidateRecordCacheForInstance(null, fieldId, null, false);
        }
        this.removeFieldValue = removeFieldValue;

        /**
         * remove all sublist line
         * @param {string} sublistId
         */
        function clearSublistData(sublistId, isMultilineEditable)
        {
	        //TODO: [MLB] Followup 3C: will probably cause an issue in MLB if there's just a new line in the middle somewhere (can't remove a line unless it's committed... need to call cancel instead).

            for(var line = getNextNewLineIndex_MLB(sublistId)-1; line >= 0; line --)
            {
	            if(isMultilineEditable && lineIndexIsNewLine_MLB(sublistId, line))
	            {
		            // line isn't committed, call cancel
		            var lineInstanceId = doGetLineInstanceId(sublistId, line, false);
		            cancelSublistLineForInstance(sublistId, lineInstanceId);
	            }
	            else
	            {
		            //line is committed, call remove
		            removeSublistLine(sublistId,line);
	            }
            }
        }
        this.clearSublistData = clearSublistData;

        /**
         * @returns {string[]} list of sublist in model
         */
        function getSublists()
        {
            return _model.getSublists();
        }
        this.getSublists = getSublists;

        /**
         * get sublist line count
         * @param {string} sublistId
         * @returns {Number}
         */
        function getSublistLineCount(sublistId)
        {
            return _model.getSublistLineCount(sublistId);
        }
        this.getSublistLineCount = getSublistLineCount;

	    /**
	     * get sublist line count, including all new lines
	     * @param {string} sublistId
	     * @returns {Number}
	     */
        function getSublistLineCountWithAllNewLines(sublistId)
        {
        	return _model.getSublistLineCountWithAllNewLines(sublistId);
        }
        this.getSublistLineCountWithAllNewLines = getSublistLineCountWithAllNewLines;

        function getSpecifiedLineInstanceIdByIndex(sublistId, index)
        {
			return _model.getSpecifiedLineInstanceIdByIndex(sublistId, index);
        }
        this.getSpecifiedLineInstanceIdByIndex = getSpecifiedLineInstanceIdByIndex;

	    /**
	     * returns all instance ids for a given sublistId & its bufferState, ordered by sequence
	     * @param {string} sublistId
	     * @param {boolean} isCommitted
	     * @returns {string[]} list of lineInstanceIds in order of sequence
	     */
	    function getSublistLineInstanceIds(sublistId, isCommitted)
	    {
		    return _model.getSublistLineInstanceIds(sublistId, isCommitted)
	    }
	    this.getSublistLineInstanceIds = getSublistLineInstanceIds;

	    /**
	     * get sublist line count
	     * @param {string} sublistId
	     * @returns {Number}
	     */
	    function doesSublistExist(sublistId, isCommitted)
	    {
		    return _model.doesSublistExist(sublistId, isCommitted);
	    }
	    this.doesSublistExist = doesSublistExist;	    

        /**
         * get the index for new line (pre-MLB)
         * @param {string} sublistId
         * @return {Number} new line index
         */
        function getNewLineIndex(sublistId)
        {
            return _model.getSublistNewLineIndex(sublistId);
        }
        this.getNewLineIndex = getNewLineIndex;

	    /**
	     * get the index that the next new line will be assigned
	     * @param sublistId
	     */
	    function getNextNewLineIndex_MLB(sublistId)
	    {
	    	return _model.getNextNewLineIndex_MLB(sublistId);
	    }
	    this.getNextNewLineIndex_MLB = getNextNewLineIndex_MLB;

	    function lineIndexIsNewLine_MLB(sublistId, line)
		{
			return _model.lineIndexIsNewLine_MLB(sublistId, line);
		}
		this.lineIndexIsNewLine_MLB = lineIndexIsNewLine_MLB;

	    function updateCurrentLineToANewLine_MLB(sublistId, line)
	    {
		    var isCommitted = false;
		    var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
		    if(!isSublistLineInstanceIdSelected(sublistId, lineInstanceId))
		    {
			    var lineObj = getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
			    _model.updateCurrentLineToANewLine_MLB(sublistId, lineObj);
		    }
		    return lineInstanceId;
	    }
	    this.updateCurrentLineToANewLine_MLB = updateCurrentLineToANewLine_MLB;

        function hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return _model.hasSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.hasSublistLineValueForInstance = hasSublistLineValueForInstance;

        /**
         * return true if sublist field has value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @returns {Boolean}
         */
        function hasSublistLineValue(sublistId, fieldId, line)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            var result = hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);

            return result;
        }
        this.hasSublistLineValue = hasSublistLineValue;

        function getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return _model.getSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.getSublistLineValueForInstance = getSublistLineValueForInstance;

        /**
         * return the primitive value for sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @returns {string|Number|Boolean|Date}
         */
        function getSublistLineValue(sublistId, fieldId, line)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            var result = getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);

            return result;
        }
        this.getSublistLineValue = getSublistLineValue;

        function getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return _model.getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.getSublistLineValueAsLegacyStringForInstance = getSublistLineValueAsLegacyStringForInstance;

        /**
         * return the value for sublist field as legacy string format
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @returns {string}
         */
        function getSublistLineValueAsLegacyString(sublistId, fieldId, line)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            var result = getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted);

            return result;
        }
        this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

        function setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, isCommitted)
        {
            _model.setSublistLineValue(sublistId, lineInstanceId, fieldId, recordFieldValue, isCommitted);
        }
        this.setSublistLineValueForInstance = setSublistLineValueForInstance;

        /**
         * set sublist value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {Object} recordFieldValue
         * @param {string|Number|Boolean|Date} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setSublistLineValue(sublistId, fieldId, line, recordFieldValue)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            var result = setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, isCommitted);

            return result;
        }
        this.setSublistLineValue = setSublistLineValue;

        function insertSublistLineForInstance(sublistId, beforeLineInstanceId, isMultilineEditable)
        {
            var lineInstanceId = _model.insertSublistLine(sublistId, beforeLineInstanceId, isMultilineEditable);
            if(!!lineInstanceId)
            {
                setupSublistSubrecordSystemId(sublistId, lineInstanceId);
                insertLineForRecordCacheForInstance(sublistId, lineInstanceId);
            }

            return lineInstanceId;
        }
        this.insertSublistLineForInstance = insertSublistLineForInstance;

        /**
         * insert sublist line
         * @param {string} sublistId
         * @param {Number} line 0 based index
         */
        function insertSublistLine(sublistId, line)
        {
            var isCommitted = true;
            var beforeLineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            if (!beforeLineInstanceId)
                beforeLineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, false);
            var lineInstanceId = insertSublistLineForInstance(sublistId, beforeLineInstanceId);

            return lineInstanceId;
        }
        this.insertSublistLine = insertSublistLine;

        function updateNewLineBufferWithCopy(sublistId, lineToCopy, noCopyToDefaultMap)
        {
	        var isCommitted = false;
	        var currentNewLineIndex = getNewLineIndex(sublistId);
	        var currentNewLineInstanceId = getSublistLineInstanceIdForLine(sublistId, currentNewLineIndex, isCommitted);
	        var sublistLineOptions = {
		        asBuffer: !isCommitted,
		        id: sublistId,
		        lineInstanceId: currentNewLineInstanceId,
		        lineIndex: currentNewLineIndex,
		        sequence: currentNewLineIndex,
		        toBeCloned: lineToCopy,
		        noCopyToDefaultMap: noCopyToDefaultMap
	        };
	        return _model.updateNewLineBufferWithCopy(sublistLineOptions);
        }
        this.updateNewLineBufferWithCopy = updateNewLineBufferWithCopy;

        function makeCopyForInstance(sublistId, lineToCopy, isMultilineEditable, noCopyToDefaultMap)
        {
	        return _model.putCopyIntoNewLineBuffer(sublistId, lineToCopy, isMultilineEditable, noCopyToDefaultMap);
        }
        this.makeCopyForInstance = makeCopyForInstance;

        function setupSublistSubrecordSystemId(sublistId, lineInstanceId)
        {
            if (_model.shouldSetupSublistSystemId(sublistId))
            {
                var sys_id = subrecordUtil.getNextSysId(true);
                var parent_sys_id =  String(getFieldValue(subrecordUtil.SYS_ID));
                var isCommitted = true;
                setSublistLineValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, {value: sys_id, legacyStringValue: sys_id}, isCommitted);
                setSublistLineValueForInstance(sublistId, subrecordUtil.SYS_PARENT_ID, lineInstanceId, {value: parent_sys_id, legacyStringValue: parent_sys_id}, isCommitted);
            }
        }

        function setupCurrentSublistSubrecordSystemId(sublistId)
        {
            if (_model.shouldSetupSublistSystemId(sublistId))
            {
                var sys_id = subrecordUtil.getNextSysId(true);
                var parent_sys_id =  String(getFieldValue(subrecordUtil.SYS_ID));
                setCurrentSublistLineValue(sublistId, subrecordUtil.SYS_ID, {value: sys_id, legacyStringValue: sys_id});
                setCurrentSublistLineValue(sublistId, subrecordUtil.SYS_PARENT_ID, {value: parent_sys_id, legacyStringValue: parent_sys_id});
            }
        }


        function removeSublistLineForInstance(sublistId, lineInstanceId)
        {
            var isCommitted = true;
            var lineExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted);

            if(lineExists)
            {
                _model.removeSublistLine(sublistId, lineInstanceId);
                removeLineForRecordCacheForInstance(sublistId, lineInstanceId);
                return lineInstanceId;
            }
        }
        this.removeSublistLineForInstance = removeSublistLineForInstance;

        /**
         * remove sublist line
         * @param {string} sublistId
         * @param {Number} line 0 based index
         */
        function removeSublistLine(sublistId, line)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);

            return removeSublistLineForInstance(sublistId, lineInstanceId);
        }
        this.removeSublistLine = removeSublistLine;

        function removeSublistFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            if(isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted))
            {
                _model.removeSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted);
                invalidateRecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
            }
        }
        this.removeSublistFieldValueForInstance = removeSublistFieldValueForInstance;

        /**
         * remove sublist field value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line 0 based index
         */
        function removeSublistFieldValue(sublistId, fieldId, line)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);

            removeSublistFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.removeSublistFieldValue = removeSublistFieldValue;

        /**
         * get a list of fields in the currently selected sublist line
         * @param {string} sublistId
         * @return {string[]}
         */
        function getCurrentSublistFieldIds(sublistId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted);
        }
        this.getCurrentSublistFieldIds = getCurrentSublistFieldIds;

        function getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted)
        {
            return _model.getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted);
        }
        this.getSublistLineFieldIds = getSublistLineFieldIds;

        function selectSublistLineForInstance(sublistId, lineInstanceId, isMultilineEditable)
        {
            var resultLineInstanceId = null;
            var isCommitted = true;
            var lineInstanceExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted);

            if(lineInstanceExists)
            {
                resultLineInstanceId = lineInstanceId;
                var lineInstanceIsSelected = isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
                if(!lineInstanceIsSelected)
                {
                    var selectedLineInstanceId = getSublistSelectedLineInstanceId(sublistId);
                    var selectedLineIsUncommitted = !isSublistLineInstanceIdValid(sublistId, selectedLineInstanceId, isCommitted);
                    if(selectedLineIsUncommitted && !isMultilineEditable)
                    {
                        removeLineForRecordCacheForInstance(sublistId, selectedLineInstanceId);
                    }

                    invalidateCurrentSublistRecordCache(sublistId);
                    _model.selectSublistLine(sublistId, lineInstanceId, isMultilineEditable);
                }
            }

            return resultLineInstanceId;
        }
        this.selectSublistLineForInstance = selectSublistLineForInstance;

        /**
         * select line
         * @param {string} sublistId
         * @param {Number} line
         */
        function selectSublistLine(sublistId, line, isMultilineEditable)
        {
            var lineInstanceId = getSpecifiedLineInstanceIdByIndex(sublistId, line);
            lineInstanceId = selectSublistLineForInstance(sublistId, lineInstanceId, isMultilineEditable);

            return lineInstanceId;
        }
        this.selectSublistLine = selectSublistLine;

        /**
         * select new line
         * @param {string} sublistId
         * @param {Object} defaultValues
         */
        function selectNewSublistLine(sublistId, defaultValues)
        {
            var lineInstanceId = _model.getSublistSelectedLineInstanceId(sublistId);

            if(getCurrentSublistLineIndex(sublistId) != getNewLineIndex(sublistId))
            {
                lineInstanceId = _model.selectNewSublistLine(sublistId, defaultValues);
                setupCurrentSublistSubrecordSystemId(sublistId);
            }

            return lineInstanceId;
        }
        this.selectNewSublistLine = selectNewSublistLine;

	    function addNewSublistLine(sublistId, defaultValues)
	    {
		    var lineInstanceId = _model.addNewSublistLine(sublistId, defaultValues);
		    setupCurrentSublistSubrecordSystemId(sublistId);
		    return lineInstanceId
	    }
	    this.addNewSublistLine = addNewSublistLine;

        function cancelSublistLineForInstance(sublistId, lineInstanceId, originNotCancel)
        {
            invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
            _model.cancelSublistLine(sublistId, lineInstanceId, false, originNotCancel);
        }
        this.cancelSublistLineForInstance = cancelSublistLineForInstance;

        function cancelCurrentSublistLine(sublistId, originNotCancel)
        {
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            cancelSublistLineForInstance(sublistId, lineInstanceId, originNotCancel);
        }
        this.cancelCurrentSublistLine = cancelCurrentSublistLine;

        function resetSublistLineForInstance(sublistId, lineInstanceId, defaultValues, isCommitted)
        {
            if(!isCommitted)
            {
                invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
            }

            _model.resetSublistLine(sublistId, lineInstanceId, defaultValues);
        }
        this.resetSublistLineForInstance = resetSublistLineForInstance;

        function resetSublistLine(sublistId, line, defaultValues)
        {
            var isCommitted = true;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);

            if(!!lineInstanceId)
            {
                resetSublistLineForInstance(sublistId, lineInstanceId, defaultValues, isCommitted);
            }
        }
        this.resetSublistLine = resetSublistLine;

        function runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList)
        {
	        argList = argList || [];
	        if (util.isFunction(func) && util.isArray(argList))
	        {
        	    _model.runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList);
	        }
        }
        this.runFunctionWhileSilentlySelectingLine = runFunctionWhileSilentlySelectingLine;

        /**
         * get index for currently selected line
         * @returns {Number}
         */
        function getCurrentSublistLineIndex(sublistId)
        {
            return _model.getSublistSelectedLineIndex(sublistId);
        }
        this.getCurrentSublistLineIndex = getCurrentSublistLineIndex;

        function getSublistLineInstanceIdForLine(sublistId, line, isCommitted)
        {
            return _model.getSublistLineInstanceIdForIndex(sublistId, line, isCommitted);
        }
        this.getSublistLineInstanceIdForLine = getSublistLineInstanceIdForLine;

        function getSublistLineInstanceIdForLineWithFallback(sublistId, line, isCommitted)
        {
	        var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
	        if (!isCommitted && !lineInstanceId)
		        lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, !isCommitted);
	        return lineInstanceId || null;
        }

        /**
         * get field value in the currently selected line
         * @param {string} sublistId
         * @param {string} fieldId
         */
        function getCurrentSublistLineValue(sublistId, fieldId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getCurrentSublistLineValue = getCurrentSublistLineValue;

        function getSublistLineBufferValueForInstance(sublistId, lineInstanceId, fieldId)
        {
            var isCommitted = false;

            return getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getSublistLineBufferValueForInstance = getSublistLineBufferValueForInstance;

        /**
         * return the value for sublist field as legacy string format
         * @param {string} sublistId
         * @param {string} fieldId
         * @returns {string}
         */
        function getCurrentSublistLineValueAsLegacyString(sublistId, fieldId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return _model.getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.getCurrentSublistLineValueAsLegacyString = getCurrentSublistLineValueAsLegacyString;

        /**
         * update the field in the currently selected line
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Object} recordFieldValue
         * @param {string|Number|Boolean|Date} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setCurrentSublistLineValue(sublistId, fieldId, recordFieldValue)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

			setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, isCommitted);
        }
        this.setCurrentSublistLineValue = setCurrentSublistLineValue;

        function setSublistLineBufferValueForInstance(sublistId, lineInstanceId, fieldId, recordFieldValue)
        {
            var isCommitted = false;

            setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, isCommitted);
        }
        this.setSublistLineBufferValueForInstance = setSublistLineBufferValueForInstance;

        function hasCurrentSublistLineValue(sublistId, fieldId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);

            return hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasCurrentSublistLineValue = hasCurrentSublistLineValue;

        function commitSublistLineForInstance(sublistId, lineInstanceId, isMultiLineEditable)
        {
            var isCommitted = true;
            var lineInstanceIdIsUncommitted = !isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted);
            if(lineInstanceIdIsUncommitted)
            {
                insertLineForRecordCacheForInstance(sublistId, lineInstanceId);
            }

            _model.commitSublistLine(sublistId, lineInstanceId, isMultiLineEditable);
            handleRecordCacheWhileCommittingLine(sublistId, lineInstanceId);
        }
        this.commitSublistLineForInstance = commitSublistLineForInstance;

        /**
         * commit currently selected line
         * @param sublistId
         * @param line
         */
        function commitSublistLine(sublistId, line)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
            commitSublistLineForInstance(sublistId, lineInstanceId);
        }
        this.commitSublistLine = commitSublistLine;

        function handleRecordCacheWhileCommittingLine(sublistId, lineInstanceId)
        {
            handleFieldWhileCommittingLine(sublistId, lineInstanceId);
            handleSubrecordsWhileCommittingLine(sublistId, lineInstanceId);
        }

        function handleFieldWhileCommittingLine(sublistId, lineInstanceId)
        {
            fieldObjectCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                sublistCache.put(fieldId, entryToBeCommitted);
                fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, false);
            });

            userFieldCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                sublistCache.put(fieldId, entryToBeCommitted);
                userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, false);
            });
        }

        function handleSubrecordsWhileCommittingLine(sublistId, lineInstanceId)
        {
            subrecordCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                var subrecord = entryToBeCommitted.current;
                var isCommitted = true;
                doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
	            isCommitted = false;
                subrecordCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            });
        }


        /**
         * insert a line buffer to cache
         * @param {string} sublistId
         * @param {string} lineInstanceId
         */
        function insertLineForRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var isCommitted = true;

            userFieldCache.get(sublistId, null, lineInstanceId, isCommitted);
            fieldObjectCache.get(sublistId, null, lineInstanceId, isCommitted);
            selectOptionsCache.get(sublistId, null, lineInstanceId, isCommitted);
            subrecordCache.get(sublistId, null, lineInstanceId, isCommitted);
        }

        /**
         * remove a line buffer to cache
         * @param {string} sublistId
         * @param {string} lineInstanceId
         */
        function removeLineForRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var isCommitted = true;

            userFieldCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            fieldObjectCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            selectOptionsCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            subrecordCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
        }

	    /**
	     * invalidate a cache object
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {number} lineInstanceId
	     * @param {boolean} isCommitted
	     */
        function invalidateRecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            selectOptionsCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            subrecordCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
        }

	    /**
	     * invalidate a the field Object Caches when fieldState update occurs.
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     */
	    function flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId)
	    {
		    var isCommitted = false;
		    userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
		    fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
	    }
	    this.flushBufferCacheForFieldStateUpdate = flushBufferCacheForFieldStateUpdate;

        function invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var isCommitted = false;

            fieldObjectCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
	        userFieldCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            selectOptionsCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            if(isSublistLineInstanceIdSelected(sublistId, lineInstanceId))
            {
                setCurrentSublistSubrecordCaheEntrysDereferenced(sublistId);
            }
            subrecordCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
        }

        /**
         * invalidate the cache for sublist buffer
         * @param {string} sublistId
         */
        function invalidateCurrentSublistRecordCache(sublistId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, getCurrentSublistLineIndex(sublistId), isCommitted);

            invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
        }

	    function shouldUseCommitted(line, isCommitted)
	    {
		    return (line !== -1) && isCommitted;
	    }

	    function doGetLineInstanceId(sublistId, line, isCommitted)
	    {
		    var useThisLine = (line === -1) ? getCurrentSublistLineIndex(sublistId) : line;
		    return getSublistLineInstanceIdForLine(sublistId, useThisLine, shouldUseCommitted(line, isCommitted));
	    }

	    function getPendingCommitPromise(internalOptions)
	    {
		    var delegateFunction = internalOptions.delegateFunction;
		    var unproxiedRecord = internalOptions.unproxiedRecord;
		    var lineInstanceId = internalOptions.lineInstanceId;
		    var sublistId = internalOptions.sublistId;
		    var pendingPromise = getFromPendingCalls("commit", lineInstanceId);

		    if (!pendingPromise) {
			    var isPending = true;
			    var promise = new Promise(function(resolve, reject) {
				    var resolveWhenCommittable = function (delegateFunction, lineInstanceId, event) {
					    if (event && event.lineId !== lineInstanceId)
						    return;
					    try {
						    resolve(delegateFunction());
					    } catch (e) {
						    reject(e);
					    } finally {
						    removePendingCommitPromise(lineInstanceId);
						    if (event) {
							    off({
								    types: ['LINE_COMMITTABLE'],
								    listener: resolveWhenCommittable
							    });
						    }
					    }
				    }.bind(null, delegateFunction, lineInstanceId);

				    if (isSelectedLineCommittable(lineInstanceId))
				    {
					    resolveWhenCommittable();
					    isPending = false;
				    }
				    else
				    {
					    on({
						    types: ['LINE_COMMITTABLE'],
						    listener: resolveWhenCommittable
					    });
				    }
			    });
			    if (isPending)
			    {
				    addPendingCommitPromise(lineInstanceId, promise)
			    }
			    return promise;
		    }
		    return pendingPromise;
	    }
	    this.getPendingCommitPromise = getPendingCommitPromise;

	    function getPendingSavePromise(internalOptions)
	    {
		    var delegateFunction = internalOptions.delegateFunction;
		    var pendingPromise = getFromPendingCalls("save");

		    if (!pendingPromise) {
			    var isPending = true;
			    var promise = new Promise(function(resolve, reject) {
				    var resolveWhenSavable = function (delegateFunction, event) {
					    try {
						    delegateFunction({resolve: resolve, reject: reject});
					    } catch (e) {
						    reject(e);
					    } finally {
						    removePendingSavePromise();
						    if (event) {
							    off({
								    types: ['RECORD_SAVABLE'],
								    listener: resolveWhenSavable
							    });
						    }
					    }
				    }.bind(null, delegateFunction);

				    if (isRecordSavable())
				    {
					    resolveWhenSavable();
					    isPending = false;
				    }
				    else
				    {
					    on({
						    types: ['RECORD_SAVABLE'],
						    listener: resolveWhenSavable
					    });
				    }
			    });
			    if (isPending)
			    {
				    addPendingSavePromise(promise)
			    }
			    return promise;
		    }
		    return pendingPromise;
	    }
	    this.getPendingSavePromise = getPendingSavePromise;

        function getFromPendingCalls(call, lineInstanceId)
        {
	        var pendingCallKey = call + (lineInstanceId? "_" + lineInstanceId : "");
	        if (!!pendingCalls[pendingCallKey])
	        {
		        return pendingCalls[pendingCallKey];
	        }
	        else
	        {
		        return null;
	        }
        }

	    function addPendingCommitPromise(lineInstanceId, commitPromise)
	    {
		    addToPendingCalls("commit",  commitPromise, lineInstanceId);
	    }
	    this.addPendingCommitPromise = addPendingCommitPromise;

        function addPendingSavePromise(promise)
        {
        	addToPendingCalls("save", promise);
        }

	    function addToPendingCalls(call, promise, lineInstanceId)
	    {
		    var pendingCallKey = call + (lineInstanceId? "_" + lineInstanceId : "");
		    pendingCalls[pendingCallKey] = promise;
	    }

	    function removeFromPendingCalls(call, lineInstanceId)
	    {
		    var pendingCallKey = call + (lineInstanceId? "_" + lineInstanceId : "");
		    if (!!pendingCalls[pendingCallKey])
		    {
			    pendingCalls[pendingCallKey] = null;
		    }
	    }

	    function removePendingCommitPromise(lineInstanceId)
	    {
		    removeFromPendingCalls("commit", lineInstanceId);
	    }
	    this.removePendingCommitPromise = removePendingCommitPromise;

	    function removePendingSavePromise() {
		    removeFromPendingCalls("save");
	    }
	    this.removePendingSavePromise = removePendingSavePromise;

	    function addToSlavingSet(sublistId, fieldId, lineInstanceId, slavingId)
	    {
		    var slavingTrackingMapKey = getSlavingTrackingMapKey(lineInstanceId, fieldId);
		    if (!!lineInstanceId && isSelectedLineCommittable(lineInstanceId))
		    {
			    emitLineIsNotCommittableEvent(sublistId, lineInstanceId);
		    }
		    if (isRecordSavable())
		    {
			    emitRecordIsNotSavableEvent();
		    }
        	if (!!slavingTrackingMap[slavingTrackingMapKey])
        	{
        		slavingTrackingMap[slavingTrackingMapKey].push(slavingId);
	        }
	        else
	        {
        		slavingTrackingMap[slavingTrackingMapKey] = [slavingId];
	        }
	    }
	    this.addToSlavingSet = addToSlavingSet;

	    function removeFromSlavingSet(sublistId, fieldId, lineInstanceId, slavingId)
	    {
		    var slavingTrackingMapKey = getSlavingTrackingMapKey(lineInstanceId, fieldId);
		    var slavingQueue = slavingTrackingMap[slavingTrackingMapKey];
		    var i = slavingQueue.indexOf(slavingId);
		    if (i !== -1) slavingQueue.splice(i, 1);
		    if (!!slavingQueue && slavingQueue.length === 0)
		    {
			    delete slavingTrackingMap[slavingTrackingMapKey];
		    }
		    if (!!lineInstanceId && isSelectedLineCommittable(lineInstanceId))
		    {
			    emitLineIsCommittableEvent(sublistId, lineInstanceId);
		    }
		    if (isRecordSavable())
		    {
			    emitRecordIsSavableEvent();
		    }
	    }
	    this.removeFromSlavingSet = removeFromSlavingSet;

	    function isSelectedLineCommittable(lineInstanceId)
	    {
	    	var slavingTrackingMapKey = getSlavingTrackingMapKey(lineInstanceId);
	    	return slavingTrackingMap[slavingTrackingMapKey] ? (slavingTrackingMap[slavingTrackingMapKey].length === 0) : true;
	    }
	    this.isSelectedLineCommittable = isSelectedLineCommittable;

	    this.addToScriptSet = function addToScriptSet()
	    {
		    if (isRecordSavable())
		    {
			    emitRecordIsNotSavableEvent();
		    }
		    var serial = scriptTrackingNextSerial++;
		    scriptTrackingArray.push(serial);
		    return serial;
	    };

	    this.removeFromScriptSet = function removeFromScriptSet(serial)
	    {
		    var index = scriptTrackingArray.indexOf(serial);
		    if (index === -1)
		    {
			    return;
		    }
		    scriptTrackingArray.splice(index, 1);
		    if (isRecordSavable())
		    {
			    emitRecordIsSavableEvent();
		    }
	    };

	    function isRecordSavable()
	    {
	    	return JSON.stringify(slavingTrackingMap) === "{}" && scriptTrackingArray.length === 0;
	    }
	    this.isRecordSavable = isRecordSavable;

	    function getSlavingTrackingMapKey(lineInstanceId, fieldId)
	    {
	    	if (!!lineInstanceId)
	    	{
	    		return "line" + "_" + lineInstanceId;
		    }
		    else if (fieldId)
		    {
	    		return "body" + "_" + fieldId;
		    }
		    else
		    {
	    		return null;
		    }
	    }
	    this.getSlavingTackingMapKey = getSlavingTrackingMapKey;


	    function emitLineIsCommittableEvent(sublistId, lineInstanceId)
	    {
	    	_model.emitLineIsCommittableEvent(sublistId, lineInstanceId);
	    }
	    this.emitLineIsCommittableEvent = emitLineIsCommittableEvent;

	    function emitLineIsNotCommittableEvent(sublistId, lineInstanceId)
	    {
		    _model.emitLineIsNotCommittableEvent(sublistId, lineInstanceId);
	    }
	    this.emitLineIsNotCommittableEvent = emitLineIsNotCommittableEvent;

	    function emitRecordIsSavableEvent()
	    {
		    _model.emitRecordIsSavableEvent();
	    }
	    this.emitRecordIsSavableEvent = emitRecordIsSavableEvent;

	    function emitRecordIsNotSavableEvent()
	    {
		    _model.emitRecordIsNotSavableEvent();
	    }
	    this.emitRecordIsNotSavableEvent = emitRecordIsNotSavableEvent;

	    function isSaveRecordScriptTriggered()
	    {
	    	return saveRecordScriptTriggered;
	    }
	    this.isSaveRecordScriptTriggered = isSaveRecordScriptTriggered;

	    function setSaveRecordScriptTriggered()
	    {
	    	saveRecordScriptTriggered = true;
	    }
	    this.setSaveRecordScriptTriggered = setSaveRecordScriptTriggered;

	    function unsetSaveRecordScriptTriggered()
	    {
	    	saveRecordScriptTriggered = false;
	    }
	    this.unsetSaveRecordScriptTriggered = unsetSaveRecordScriptTriggered;

        /**
         * return cache of selec options
         * @returns {RecordCacheController}
         */
        function getSelectOptionCache()
        {
            return selectOptionsCache;
        }
        this.getSelectOptionCache = getSelectOptionCache;

        function cacheSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, options, isCommitted)
        {
            selectOptionsCache.put(sublistId, fieldId, lineInstanceId, options, isCommitted);
        }
        this.cacheSelectOptionsForInstance = cacheSelectOptionsForInstance;

        /**
         * cache select options
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {*} options
         * @param {boolean} isCommitted
         */
        function cacheSelectOptions(sublistId, fieldId, line, options, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

	        isCommitted = shouldUseCommitted(line, isCommitted);
			var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            cacheSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, options, isCommitted);
        }
        this.cacheSelectOptions = cacheSelectOptions;

        function getSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return selectOptionsCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getSelectOptionsForInstance = getSelectOptionsForInstance;

        /**
         * get select option from cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} isCommitted
         * @returns {*}
         */
        function getSelectOptions(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return getSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getSelectOptions = getSelectOptions;

        function cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, field, isCommitted)
        {
            fieldObjectCache.put(sublistId, fieldId, lineInstanceId, field, isCommitted);
        }
        this.cacheRecordFieldForInstance = cacheRecordFieldForInstance;

        /**
         * cache record field object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param field
         * @param {boolean} isCommitted
         */
        function cacheRecordField(sublistId, fieldId, line, field, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, field, isCommitted);
        }
        this.cacheRecordField = cacheRecordField;

        function getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return fieldObjectCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getRecordfieldForInstance = getRecordfieldForInstance;

        /**
         * get cached record field object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} isCommitted
         * @returns {RecordField}
         */
        function getRecordfield(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getRecordfield = getRecordfield;

        function cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, field, isCommitted)
        {
            userFieldCache.put(sublistId, fieldId, lineInstanceId, field, isCommitted);
        }
        this.cacheUserFieldForInstance = cacheUserFieldForInstance;

        /**
         * cache user field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param field
         * @param {boolean} isCommitted
         */
        function cacheUserField(sublistId, fieldId, line, field, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, field, isCommitted);
        }
        this.cacheUserField = cacheUserField;

        function getUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return userFieldCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getUserFieldForInstance = getUserFieldForInstance;

        /**
         * get cached user field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} isCommitted
         * @returns {RecordField}
         */
        function getUserField(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return getUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getUserField = getUserField;

        function hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return userFieldCache.has(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasUserFieldForInstance = hasUserFieldForInstance;
        /**
         * contain cached user field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} isCommitted
         * @returns {boolean}
         */
        function hasUserField(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasUserField = hasUserField;

        function doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, subrecordObj, isCommitted)
        {
            subrecordCache.put(sublistId, fieldId, lineInstanceId, subrecordObj, isCommitted);
        }

        /**
         * cache subrecrd object
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {*} subrecordObj
         * @param {boolean} isCommitted
         */
        function doCacheSubrecord(sublistId, fieldId, line, subrecordObj, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, subrecordObj, isCommitted);
        }

        function doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return subrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        /**
         * get the cached subrecord object
         * @param {string} sublistId uses null if not sublist field
         * @param {string} fieldId
         * @param {Number} line uses -1 if querying for current sublist field
         * @param {boolean} isCommitted
         * @returns {*} subrecordObj
         */
        function doGetCachedSubrecord(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        function _doHasValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return recordUtil.executeRecordGetterFunctionsForInstance(
                sublistId, fieldId, lineInstanceId, isCommitted,
                hasFieldValue, hasSublistLineValueForInstance);
        }

        function _doHasValue(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return _doHasValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        function _doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return recordUtil.executeRecordGetterFunctionsForInstance(
                sublistId, fieldId, lineInstanceId, isCommitted,
                getFieldValue, getSublistLineValueForInstance);
        }

        function _doGetValue(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return _doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        function doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            var cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
            var hasSubrecord = !!cachedSubrecord && cachedSubrecord.current !== null;

            if(!hasSubrecord && _doHasValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted))
            {
                hasSubrecord = !!_doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
            }

            return hasSubrecord;
        }

        /**
         * universal function of hasSubrecord for body field, sublist field, and current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {number} line
         * @param {boolean} isCommitted
         * @returns {boolean}
         */
        function doHasSubrecord(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        function doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            var cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);

            return !!cachedSubrecord ? cachedSubrecord.current : null;
        }
	    this.doGetSubrecordForInstance = doGetSubrecordForInstance;
        /**
         * universal function of getSubrecord for body field, sublist field, and current sublist field
         * @param sublistId
         * @param fieldId
         * @param line
         * @param {boolean} isCommitted
         * @returns {*}
         */
        function doGetSubrecord(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        function doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord)
        {
            var cachedEntry = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
            if(!cachedEntry)
            {
                cachedEntry = {};
                var existingSubrecordId = parseInt(_doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted));
                var isValidRecordId = !isNaN(existingSubrecordId);

                if(isValidRecordId)
                {
                    var hasExistingSubrecord = !!subrecord && subrecord.id === existingSubrecordId;
                    if(hasExistingSubrecord)
                        cachedEntry.initial = subrecord;
                    else
                        cachedEntry.initial = createSubrecordReference(existingSubrecordId);
                }

                doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, cachedEntry, isCommitted);
            }
            cachedEntry.current = subrecord;

            if(!!subrecord)
            {
                var subrecordSystemId = subrecord.doGetValue(subrecordUtil.SYS_ID);
                if(!subrecordSystemId || subrecordSystemId === "0")
                {
                    var sys_id = subrecordUtil.getNextSysId(cachedEntry.initial !== subrecord);
                    subrecord.doSetValue(subrecordUtil.SYS_ID, sys_id);
                    updateDependentSysIds();
                }
                if(!subrecord.doGetValue(subrecordUtil.SYS_PARENT_ID))
                {
                    var systemParentId = String(_doGetValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, isCommitted));
                    subrecord.doSetValue(subrecordUtil.SYS_PARENT_ID, systemParentId);
                }
            }

            var isCurrentSublistSubrecord = !isCommitted && isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
            if(!isCurrentSublistSubrecord)
            {
                var parentSystemId = getParentSystemIdForInstance(sublistId, lineInstanceId);

                subrecordTracker[parentSystemId] = subrecordTracker[parentSystemId] || {};
                subrecordTracker[parentSystemId][fieldId] = { isDeleted: !subrecord };
            }
        }

        /**
         * universal function of setSubrecord for body field, sublist field, and current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {Record} subrecord
         * @param {boolean} isCommitted
         */
        function doSetSubrecord(sublistId, fieldId, line, subrecord, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
        }

        function hasNewlyCommittedSublistSubrecord(systemId, fieldId)
        {
            return subrecordTracker.hasOwnProperty(systemId)
                   && subrecordTracker[systemId][fieldId]
                   && !subrecordTracker[systemId][fieldId].isDeleted;
        }
        this.hasNewlyCommittedSublistSubrecord = hasNewlyCommittedSublistSubrecord;

        function getParentSystemIdForInstance(sublistId, lineInstanceId, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

            var sys_parent_id = !!sublistId ?
                    getSublistSystemIdForInstance(sublistId, lineInstanceId, isCommitted) :
                    getSystemId();

            return sys_parent_id;
        }
        this.getParentSystemIdForInstance = getParentSystemIdForInstance;

        function getParentSystemId(sublistId, line, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return getParentSystemIdForInstance(sublistId, lineInstanceId, isCommitted);
        }
        this.getParentSystemId = getParentSystemId;

        function getSystemId()
        {
            return getFieldValue(subrecordUtil.SYS_ID);
        }
        this.getSystemId = getSystemId;

        function getSublistSystemIdForInstance(sublistId, lineInstanceId, isCommitted)
        {
            return getSublistLineValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, isCommitted);
        }
        this.getSublistSystemIdForInstance = getSublistSystemIdForInstance;

        function getSublistSystemId(sublistId, line, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return getSublistSystemIdForInstance(sublistId, lineInstanceId, isCommitted);
        }
        this.getSublistSystemId = getSublistSystemId;

        function getCurrentSublistSystemId(sublistId)
        {
            return getCurrentSublistLineValue(sublistId, subrecordUtil.SYS_ID);
        }
        this.getCurrentSublistSystemId = getCurrentSublistSystemId;

        function createSubrecordReference(id)
        {
            var data = {}, result = {};

            data[subrecordUtil.SYS_ID] = subrecordUtil.getNextSysId(false);
            data[subrecordUtil.SYS_PARENT_ID] = getParentSystemId(subrecordUtil.SYS_ID);
            data.id = String(id);
            result.id = parseInt(data.id, 10);
            result.getFields = function(){
                return Object.keys(data);
            };

            function fetchValue(fieldId) { return data[fieldId]; }
	        function fetchValueAsString(fieldId)
	        {
		        var returnMe = data[fieldId];
		        return utilityFunctions.isValEmpty(returnMe) ? null : String(returnMe);
	        }
            result.getValue = fetchValue;
            result.doGetValue = fetchValue;
            result.getFieldValue = fetchValue;
	        result.getValueAsLegacyString = fetchValueAsString;
            return result;
        }

        function updateDependentSysIds()
        {
            //TODO: update sublist lines sys_parentid field
        }

        /**
         * return true if field has a subrecord instance
         * @param {string} fieldId
         * @returns {boolean}
         */
        function hasSubrecord(fieldId)
        {
	        var isCommitted = true;
            return doHasSubrecord(null, fieldId, -1, isCommitted);
        }
        this.hasSubrecord = hasSubrecord;

        /**
         * return the subrecord instance of given field
         * @param {string} fieldId
         * @returns {*}
         */
        function getSubrecord(fieldId)
        {
	        var isCommitted = true;
            return doGetSubrecord(null, fieldId, -1, isCommitted);
        }
        this.getSubrecord = getSubrecord;

        /**
         * update the subrecord instance of the given field
         * @param {string} fieldId
         * @param {*} subrecord
         */
        function cacheSubrecord(fieldId, subrecord)
        {
	        var isCommitted = true;
            return doSetSubrecord(null, fieldId, -1, subrecord, isCommitted);
        }
        this.cacheSubrecord = cacheSubrecord;

        function hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasSublistSubrecordForInstance = hasSublistSubrecordForInstance;
        /**
         * return true if sublist field has a subrecord instance
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} isCommitted
         */
        function hasSublistSubrecord(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasSublistSubrecord = hasSublistSubrecord;

        /**
         * return the subrecord instance of given sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {boolean} isCommitted
         * @returns {*} subrecordObject
         */
        function getSublistSubrecord(sublistId, fieldId, line, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

	        return doGetSubrecord(sublistId, fieldId, line, isCommitted);
        }
        this.getSublistSubrecord = getSublistSubrecord;

        function cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord)
        {
            return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
        }
        this.cacheSublistSubrecordForInstance = cacheSublistSubrecordForInstance;
	    
        function clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
	        return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, null);
        }
	    this.clearSubrecordCacheForInstance = clearSubrecordCacheForInstance;	    
	    
        /**
         * update the subrecord instance of the given sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {Number} line
         * @param {*} subrecord
         * @param {boolean} isCommitted
         */
        function cacheSublistSubrecord(sublistId, fieldId, line, subrecord, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            return cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
        }
        this.cacheSublistSubrecord = cacheSublistSubrecord;


        /**
         * return true if current sublist field has a subrecord instance
         * @param {string} sublistId
         * @param {string} fieldId
         */
        function hasCurrentSublistSubrecord(sublistId, fieldId)
        {
	        var isCommitted = false;
            return doHasSubrecord(sublistId, fieldId, -1, isCommitted);
        }
        this.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

        /**
         * return the subrecord instance of given current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @returns {*}
         */
        function getCurrentSublistSubrecord(sublistId, fieldId)
        {
	        var isCommitted = false;
            return doGetSubrecord(sublistId, fieldId, -1, isCommitted);
        }
        this.getCurrentSublistSubrecord = getCurrentSublistSubrecord;

        /**
         * update the subrecord instance of the current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {*} subrecord
         */
        function setCurrentSublistSubrecord(sublistId, fieldId, subrecord)
        {
	        var isCommitted = false;
            return doSetSubrecord(sublistId, fieldId, -1, subrecord, isCommitted);
        }
        this.setCurrentSublistSubrecord = setCurrentSublistSubrecord;

        function getData()
        {
            return _model.getData();
        }
        this.getData = getData;

        function getSublistData()
        {
            return _model.getSublistData();
        }
        this.getSublistData = getSublistData;

        function getSubrecordDataForSubmission()
        {
            return _model.getSubrecordDataForSubmission();
        }
        this.getSubrecordDataForSubmission = getSubrecordDataForSubmission;

        function clone()
        {
            return new ModelController({
                type: options.type,
                sublistFieldState: options.sublistFieldState,
                data: _model.getClonedData()
            });
        }
        this.clone = clone;


        function validateCurrentSublistSubrecords(sublistId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, getCurrentSublistLineIndex(sublistId), isCommitted);
            validateCurrentSublistSubrecordsForInstance(sublistId, lineInstanceId);
        }
        this.validateCurrentSublistSubrecords = validateCurrentSublistSubrecords;

        function validateCurrentSublistSubrecordsForInstance(sublistId, lineInstanceId)
        {
            var isCommitted = true;
            var fields = subrecordCache.fields(sublistId, lineInstanceId, isCommitted);
            fields.forEach(function(fieldId){
                var entry = subrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
                var subrecord = entry ? entry.current : null;
                if(subrecord != null && !subrecord.isValidated())
                {
                    subrecord.validate();
                    subrecord.setDereferencedFromParent(true);
                }
            })
        }
        this.validateCurrentSublistSubrecordsForInstance = validateCurrentSublistSubrecordsForInstance;

        function setSubrecordCacheEntryDereferencedForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            var entry = subrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
            var subrecord = entry ? entry.current : null;
            if(subrecord != null)
            {
                subrecord.setDereferencedFromParent(true);
            }
        }

        function setSubrecordCacheEntryDereferenced(sublistId, fieldId, line, isCommitted)
        {
	        isCommitted = shouldUseCommitted(line, isCommitted);
	        var lineInstanceId = doGetLineInstanceId(sublistId, line, isCommitted);

            setSubrecordCacheEntryDereferencedForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }

        function setCurrentSublistSubrecordCaheEntrysDereferenced(sublistId)
        {
            var isCommitted = false;
            var lineInstanceId = getSublistLineInstanceIdForLine(sublistId, getCurrentSublistLineIndex(sublistId), isCommitted);
            var fields = subrecordCache.fields(sublistId, lineInstanceId, isCommitted);
            fields.forEach(function(fieldId){
                var entry = subrecordCache.get(sublistId, fieldId);
                var subrecord = entry ? entry.current : null;
                if(subrecord != null)
                {
                    subrecord.setDereferencedFromParent(true);
                }
            });
        }

	    function getSublistLineJSON(sublistId, lineInstanceId, isCommitted)
	    {
		    return _model.getSublistLineJSON(sublistId, lineInstanceId, isCommitted);
	    }
	    this.getSublistLineJSON = getSublistLineJSON;

        /**
         * retrieve the select option text from the cache by value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         */
        function getSelectOptionTextFromCache(sublistId, fieldId, value)
        {
            return _model.getSelectOptionTextFromCache(sublistId, fieldId, value)
        }
        this.getSelectOptionTextFromCache = getSelectOptionTextFromCache;

        /**
         * cache the option text into cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         * @param {string} text
         */
        function cacheSelectOptionText(sublistId, fieldId, value, text)
        {
            _model.cacheSelectOptionText(sublistId, fieldId, value, text);
        }
        this.cacheSelectOptionText = cacheSelectOptionText;

        function on(options)
        {
            _model.on(options);
        }
        this.on = on;

        function off(options)
        {
            _model.off(options);
        }
        this.off = off;

        return this;
    }

    return {
        /**
         * return a new instance of ModelController
         * @param {Object} options
         * @returns {ModelController}
         */
        create: function create(options){
            return new ModelController(options);
        },
        /**
         * return true if object is an instance of ModelController
         * @param {Object} obj
         * @returns {boolean}
         */
        isInstance: function(obj) { return obj instanceof ModelController; }
    };
});

/**
 * SuiteScript dynamic record impl
 *
 * @private
 * @module N/record/dynamicRecordImpl
 * @NApiVersion 2.x
 *
 */
define(
	'N/record/dynamicRecordImpl',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/util/validator'],
	function (recordUtil, utilityFunctions, validator)
	{
		/**
		 * Dynamic Record Implementation for record behavior
		 * @param {Record} record
		 * @constructor
		 */
		function DynamicRecordImpl(record)
		{
			var that = this;
			var undef = undefined;
			var recordScriptingScope;

			function initRecord(record, scope)
			{
				recordScriptingScope = scope;
				recordScriptingScope.pageInit();
			}

			this.initRecord = initRecord;

			function isDynamic() { return true; }

			this.isDynamic = isDynamic;

			this.validateTextApi = recordUtil.no_op_function;

			function getLineInstanceId(sublistId, line, isCommitted)
			{
				return record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
			}

			this.getLineInstanceId = getLineInstanceId;

			function shouldValidateFieldPermissions()
			{
				return 'T' === record.getRecordRequestContext().enablefieldpermissions && !record.isInternal();
			}

			this.shouldValidateFieldPermissions = shouldValidateFieldPermissions;

			function validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive)
			{
				lineNumberIndex = parseInt(lineNumberIndex, 10);
				recordUtil.assertValidSublistOperation(lowerBoundInclusive <= lineNumberIndex && lineNumberIndex < upperBoundExclusive)
			}

			this.validateLineIndex = validateLineIndex;

			function getCachedOptionsForRecordField(sublistId, fieldId, line)
			{
				return record.getModelController().getSelectOptions(sublistId, fieldId, line);
			}

			this.getCachedOptionsForRecordField = getCachedOptionsForRecordField;

			function doGetText(fieldId, delegator)
			{
				return delegator.getTextValue(fieldId);
			}

			this.doGetText = doGetText;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				return delegator.getParsedValue(fieldId, true);
			}

			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting)
			{
				value = recordUtil.emptyIfNullOrUndefined(value);
				if (record.isFieldMultiSelect(undef, fieldId))
					value = recordUtil.formatValueToArrayType(value);
				else if (record.isFieldRadio(undef, fieldId))
					value = String(value);
				var validatedValue = noValidationAndFormatting ? value : record.validateAndFormatFieldValue(undef, fieldId, value, undefined, allowPercentage);
				record.doSetFieldValue(fieldId, validatedValue, fireFieldChange, noSlaving, undefined, noValidationAndFormatting);
			}

			this.doSetValue = doSetValue;

			function doSetText(fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				var value, recordField;
				var isCommitted = true;
				noSlaving = !!noSlaving;
				noValidationAndFormatting = !!noValidationAndFormatting;
				if (record.isFieldMultiSelect(undef, fieldId))
				{
					var texts = recordUtil.formatValueToArrayType(text);
					record.doSetTexts(fieldId, texts, fireFieldChange, noSlaving, noValidationAndFormatting);
				}
				else if (record.isFieldSelectType(undef, fieldId))
				{
					value = "";
					var unwrappedText = recordUtil.formatArrayToStringType(text);
					if (unwrappedText || unwrappedText === "")
					{
						recordField = record.getCachedRecordField(undef, fieldId, -1, isCommitted);
						value = recordField.validateSelectFieldByText(text);
					}
					record.doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true, noValidationAndFormatting);
				}
				else if (record.isFieldRadio(undef, fieldId))
				{
					var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
					value = validator.validateRadioFieldByText(fieldId, text, fieldLevelMetadata.radioSet);
					record.doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true, noValidationAndFormatting);
				}
				else
				{
					if (record.isFieldCheckbox(undef, fieldId)) {
						validator.validateCheckBoxField(fieldId, text);
						text = "" + text; // to keep legacy behavior where only "T" is accepted as true by parser
					}
					var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
					value = recordUtil.parseValue(record.isValidBodyField(fieldId), fieldLevelMetadata, text);
					record.doSetValue(fieldId, value, fireFieldChange, noSlaving, undefined, true, noValidationAndFormatting);
				}

				record.getFieldState(fieldId).useTextApi = true;
			}

			this.doSetText = doSetText;

			function validateAndFormatFieldValue(sublistId, fieldId, value, skipParsing, allowPercentage)
			{
				var isCommitted = !sublistId;
				var lineInstanceId = (!!sublistId) ? record.getModelController().getSublistSelectedLineInstanceId(sublistId) : null;
				return validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, value, undefined, allowPercentage);
			}

			this.validateAndFormatFieldValue = validateAndFormatFieldValue;

			function validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, value, isInteractive, allowPercentage)
			{
				if (record.isValidField(sublistId, fieldId))
				{
					var field = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					value = field.validateAndFormatFieldValue(value, isInteractive, allowPercentage);
				}

				return value;
			}

			this.validateAndFormatFieldValueForInstance = validateAndFormatFieldValueForInstance;

			function getSublistSubrecord(sublistId, fieldId, line)
			{
				return record.doGetSublistSubrecord(sublistId, fieldId, line);
			}
			this.getSublistSubrecord = getSublistSubrecord;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				return delegator.getParsedValue(fieldId, true);
			}

			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			this.setSublistValue = recordUtil.no_op_function;

			function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				return delegator.getTextValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			this.setSublistText = recordUtil.no_op_function;


			function preInsertLine(sublistId, line)
			{
				var selectedInstanceId;
				if (!record.isMultilineEditable(sublistId)) {
					if (record.doGetCurrentSublistIndex(sublistId) !== line && line < record.doGetLineCount(sublistId))
						selectedInstanceId = record.doSelectLine(sublistId, line).instanceId;
					else
					{
						if (record.getSublistState(sublistId).isLineInserted(line)) {
							record.doRemoveSublistLine(sublistId, line);
						}
						record.getSublistState(sublistId).removeCurrentLineState();
						selectedInstanceId = record.getModelController().getSpecifiedLineInstanceIdByIndex(sublistId, line);
					}
				}
				record.triggerValidateInsertScript(sublistId);
				return selectedInstanceId;
			}

			this.preInsertLine = preInsertLine;

			function preInsertLineForInstance(sublistId, beforeLineInstanceId)
			{
				var newBeforeLineInstanceId = beforeLineInstanceId;
				if (record.isMultilineEditable(sublistId))
					record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, beforeLineInstanceId, record.triggerValidateInsertScript, that, [sublistId]);
				else
					newBeforeLineInstanceId = preInsertLine(sublistId, record.getLineIndexFromInstanceId(sublistId, beforeLineInstanceId, true));
				return newBeforeLineInstanceId;
			}

			this.preInsertLineForInstance = preInsertLineForInstance;

			function postInsertLine(sublistId, line, ignoreRecalc)
			{
				var lineObj;
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'insert');
				record.doResetSublistLine(sublistId, line, record.getMetadata().getSublistDefaultValue(sublistId));

				if(!record.isMultilineEditable(sublistId))
				{
					record.getSublistState(sublistId).resetCurrentLineState(line);
					/*
					in this case, this method is gonna return null (lineObj), which is fine
					becasue it doesn't seem like anything is using it. if needed at some point,
					then you can get the line object from the cache using the provided line.
					 */
					lineObj = record.doSelectLine(sublistId, line);
				}
				return lineObj;
			}

			this.postInsertLine = postInsertLine;

			function postInsertLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				var lineObj;
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'insert');
				record.doResetSublistLineForInstance(sublistId, lineInstanceId, record.getMetadata().getSublistDefaultValue(sublistId));

				if(!record.isMultilineEditable(sublistId))
				{
					record.getSublistState(sublistId).resetBufferLineStateForInstance(lineInstanceId, false);
					/*
					 in this case, this method is gonna return null (lineObj), which is fine
					 becasue it doesn't seem like anything is using it. if needed at some point,
					 then you can get the line object from the cache using the provided line.
					 */
					lineObj = record.doSelectLineForInstance(sublistId, lineInstanceId);
				}
				return lineObj;
			}

			this.postInsertLineForInstance = postInsertLineForInstance;

			function removeSublistLine(sublistId, line, ignoreRecalc, noValidation)
			{
				var lineObj;
				if (record.doGetCurrentSublistIndex(sublistId) !== line)
					lineObj = record.doSelectLine(sublistId, line);
				if (!noValidation)
					record.triggerValidateDeleteScript(sublistId);
				record.doRemoveSublistLine(sublistId, line);
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'remove');
				return lineObj;
			}

			this.removeSublistLine = removeSublistLine;

			function doRemoveSublistLine(sublistId, lineInstanceId, ignoreRecalc, noValidation)
			{
				if (!noValidation)
					record.triggerValidateDeleteScript(sublistId);
				record.doRemoveSublistLineForInstance(sublistId, lineInstanceId);
				if (!ignoreRecalc)
					record.triggerRecalcScript(sublistId, false, 'remove');
			}

			function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc, noValidation)
			{
				if (record.isMultilineEditable(sublistId))
					record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, doRemoveSublistLine, that, [sublistId, lineInstanceId, ignoreRecalc, noValidation]);
				else
					doRemoveSublistLine(sublistId, lineInstanceId, ignoreRecalc, noValidation);
			}

			this.removeSublistLineForInstance = removeSublistLineForInstance;

			function postRemoveLine(sublistId, line, isMultilineEditable)
			{
				var lineObj = null;
				record.postDeleteLine(sublistId, line);
				if (!isMultilineEditable)
				{
					if (line < record.doGetLineCount(sublistId))
						lineObj = record.doSelectLine(sublistId, line);
					else
						lineObj = record.doSelectNewLine(sublistId);
				}
				return lineObj;
			}

			this.postRemoveLine = postRemoveLine;

			function postRemoveLineForInstance(sublistId, lineInstanceId, isCommitted)
			{
				record.postDeleteLineForInstance(sublistId, lineInstanceId, isCommitted)
			}

			this.postRemoveLineForInstance = postRemoveLineForInstance;

			function addNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("addLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				return record.doAddNewLine(sublistId);
			}
			this.addNewLine = addNewLine;

			function selectLine(options, line)
			{
				var sublistId, lineInstanceId, lineObj;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					lineInstanceId = options.lineInstanceId;

					utilityFunctions.checkMutuallyExclusiveArguments(line, lineInstanceId, 'line', 'lineInstanceId');
				}

				if (line != undef)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], record.getMissingArgumentErrorMessageFillerValue("selectLine"));
					lineObj = record.doSelectLine(sublistId, line);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], record.getMissingArgumentErrorMessageFillerValue('selectLine'));
					lineObj = record.doSelectLineForInstance(sublistId, lineInstanceId);
				}

				return lineObj;
			}

			this.selectLine = selectLine;

			function selectNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("selectNewLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				return record.doSelectNewLine(sublistId);
			}

			this.selectNewLine = selectNewLine;

			function cancelLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("cancelLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				record.doCancelLine(sublistId);
			}

			this.cancelLine = cancelLine;

			function cancelLineForInstance(sublistId, lineInstanceId)
			{
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				if (record.isMultilineEditable(sublistId))
					record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, record.doCancelLineForInstance, that, [sublistId, lineInstanceId]);
				else
					record.doCancelLineForInstance(sublistId, lineInstanceId);
			}

			this.cancelLineForInstance = cancelLineForInstance;

			function commitLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("commitLine"));
				var ignoreRecalc = options !== undef && options !== null && options.hasOwnProperty('ignoreRecalc') ? options.ignoreRecalc : false;
				recordUtil.assertValidSublistOperation(record.isSublistEditable(sublistId));
				record.doCommitLine(sublistId, ignoreRecalc);
			}

			this.commitLine = commitLine;

			function commitLineForInstance(sublistId, lineInstanceId)
			{
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				var ignoreRecalc = false;
				if(record.isMultilineEditable(sublistId))
					record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, record.doCommitLineForInstance, that, [sublistId, lineInstanceId, ignoreRecalc]);
				else
					record.doCommitLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
			}

			this.commitLineForInstance = commitLineForInstance;

			function getCurrentSublistValue(options, fieldId, delegator)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("getCurrentSublistValue"));

				var lineInstanceId = record.getModelController().getSublistSelectedLineInstanceId(sublistId);
				var lineDefinitionObject = record.getLineObjectFromCache(sublistId, lineInstanceId, false);
				return lineDefinitionObject.getParsedValueForBodyField(fieldId);
			}

			this.getCurrentSublistValue = getCurrentSublistValue;

			function setCurrentSublistValue(options, fieldId, value, isInteractive)
			{
				var sublistId, fireFieldChange = true, noSlaving = false, forceSyncSourcing = false, fireSlavingSync = false;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setCurrentSublistValue"));
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				var sourcingMetadata = record.getSlavingMetadata(sublistId, fieldId);
				var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !record.getIsCurrentRecord();
				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				if (sourcingMetadata && forceSyncSourcing) {
					sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
				}
				record.doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChange, noSlaving, isInteractive);
				if (sourcingMetadata && forceSyncSourcing) {
					sourcingMetadata.forceSyncSlaving = metadataForceSync;
				}

			}

			this.setCurrentSublistValue = setCurrentSublistValue;

			function setSublistBufferValue(options)
			{
				var sublistId = options.sublistId,
					fieldId = options.fieldId,
					lineInstanceId = options.lineInstanceId,
					value = options.value,
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : true,
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : false;

				utilityFunctions.checkArgs([sublistId, fieldId, lineInstanceId], ['sublistId', 'fieldId', 'lineInstanceId'], record.getMissingArgumentErrorMessageFillerValue("setSublistBufferValue"));
				recordUtil.validateAgainstSqlInjection(fieldId, value);

				record.doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving);
			}

			this.setSublistBufferValue = setSublistBufferValue;

			function getCurrentSublistText(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("getCurrentSublistText"));

				var lineInstanceId = record.getModelController().getSublistSelectedLineInstanceId(sublistId);
				var lineDefinitionObject = record.getLineObjectFromCache(sublistId, lineInstanceId, false);
				return lineDefinitionObject.doGetText(fieldId);
			}

			this.getCurrentSublistText = getCurrentSublistText;

			function setCurrentSublistText(options, fieldId, text, isInteractive)
			{
				var sublistId, fireFieldChange = true, noSlaving = false, forceSyncSourcing = false, fireSlavingSync = false;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					text = options.text;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setCurrentSublistText"));
				var sourcingMetadata = record.getSlavingMetadata(sublistId, fieldId);
				var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !record.getIsCurrentRecord();
				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				if (sourcingMetadata && forceSyncSourcing)
				{
					sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
				}
				record.doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChange, noSlaving, false, isInteractive);
				if (sourcingMetadata && forceSyncSourcing)
				{
					sourcingMetadata.forceSyncSlaving = metadataForceSync;
				}
			}

			this.setCurrentSublistText = setCurrentSublistText;

			function postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, fireFieldChange, noSlaving, noValidation)
			{
				var internalFieldChangeScriptFieldId = 'nlapiFC';
				if (fireFieldChange === undef)
					fireFieldChange = true;

				if (noSlaving === undef)
					noSlaving = false;

				var nlapiFCValue = null;
				if (!fireFieldChange && !utilityFunctions.isValEmpty(record.doGetValue(internalFieldChangeScriptFieldId)) && !record.isInternal())
				{
					fireFieldChange = true;
					nlapiFCValue = record.getModelController().getFieldValue(internalFieldChangeScriptFieldId);
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: '', legacyStringValue: ''});
				}

				if (fireFieldChange)
				{
					var line = -1;
					if (record.isSublistAListMachine(sublistId) || record.isMultilineEditable(sublistId))
					{
						line = record.getModelController().getSublistLineValueForInstance(sublistId, '_sequence', lineInstanceId, isCommitted);
						line = recordUtil.getOneBasedIndex(line);
					}
					if (record.isMultilineEditable(sublistId))
					{
						if (!noValidation)
							record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, triggerValidateFieldScript, that, [sublistId, fieldId, line]);
						record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, triggerFieldChangeEventForInstance, that, [sublistId, fieldId, line, lineInstanceId, dbValue, noSlaving]);
					}
					else
					{
						if (!noValidation)
							record.triggerValidateFieldScript(sublistId, fieldId, line);
						record.triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, dbValue, noSlaving);
					}
				}

				if (!nlapiFCValue)
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: nlapiFCValue, legacyStringValue: nlapiFCValue});

				record.locale.checkLocaleAndTriggerContextChange({sublistId:sublistId, fieldId:fieldId, valueGetter: record.getValue});
			}

			this.postSetFieldValueForInstance = postSetFieldValueForInstance;

			function triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving)
			{
				record.triggerFieldChangeScript(sublistId, fieldId, line);
				record.doSlaving(sublistId, fieldId, line, value, noSlaving);
			}

			this.triggerFieldChangeEvent = triggerFieldChangeEvent;

			function triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving)
			{
				record.triggerFieldChangeScript(sublistId, fieldId, line);
				record.doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving);
			}

			this.triggerFieldChangeEventForInstance = triggerFieldChangeEventForInstance;

			function doProcessSlavingValues(slaveValues, sublistId, fieldId, line)
			{
				if (!!slaveValues)
				{
					record.applySlaveValues(postProcessSlaveValues(slaveValues));
					record.triggerCustomPostSourcingScript(sublistId, fieldId, line);
				}
			}

			function doGetClientSlavingResultFromMetadata(clientSlavingMetadata, stringifiedVal, getMetadataFunction, forceSync)
			{
				if (forceSync)
					return recordUtil.getClientSlavingResultFromMetadata(clientSlavingMetadata, stringifiedVal, getMetadataFunction);
				else
					return new Promise(function (resolve, reject)
					{
						try
						{
							resolve(recordUtil.getClientSlavingResultFromMetadata(clientSlavingMetadata, stringifiedVal, getMetadataFunction));
						}
						catch (e)
						{
							reject(e);
						}
					});
			}

			function doPerformSlaving(sublistId, fieldId, lineNum, lineInstanceId, value, noSlaving, restrictField)
			{
				if (noSlaving === undef)
					noSlaving = false;
				var modelController = record.getModelController();
				var slaveValues,
					metadata = record.getSlavingMetadata(sublistId, fieldId),
					clientSlavingMetadata = record.getClientSlavingMetadata(sublistId, fieldId),
					forceSync = (metadata && metadata.forceSyncSlaving) ? metadata.forceSyncSlaving : !record.getIsCurrentRecord(),
				    slavingId = String(sublistId? sublistId : " ") + String(fieldId? fieldId : " ") + Date.now().toString();

				if (modelController.isSaveRecordScriptTriggered()) {
					forceSync = true;
				}

				if (!noSlaving)
				{
					if (metadata && metadata.noSlavingValue !== String(value) && String(value).indexOf(metadata.noSlavingPrefix) !== 0)
					{
						var ln = (record.isSublistAListMachine(sublistId)) ? record.doGetCurrentSublistIndex(sublistId) : null;
						var fieldToSlave = (restrictField && typeof restrictField !== 'boolean') ? restrictField : 'T';
						var masterInfo = {queryFieldName: String(fieldId), queryFieldValue: String(value), sublistId: sublistId ? String(sublistId) : undef, fieldspec: fieldToSlave, lineNum: lineNum, lineInstanceId: lineInstanceId};

						slaveValues = record.sendSlavingRequest(postProcessSlavingMetadata(metadata), masterInfo);
					}
					else if (clientSlavingMetadata)
					{
						slaveValues = doGetClientSlavingResultFromMetadata(clientSlavingMetadata, String(value), record.getClientSlavingMetadata, forceSync);
					}
				}
				if (!!slaveValues)
				{
					if (forceSync)
						doProcessSlavingValues(slaveValues, sublistId, fieldId, lineNum);
					else {
						modelController.addToSlavingSet(sublistId, fieldId, lineInstanceId, slavingId);
						slaveValues.then(function (result) {
								function doThis(obj) {
									var retMe = obj;
									if (obj.hasOwnProperty("machine")) retMe.lineInstanceId = lineInstanceId;
									return retMe;
								}

								if (!!result && !!result.fields)
									result.fields = result.fields.map(doThis);
								record.getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, doProcessSlavingValues, that, [result, sublistId, fieldId, lineNum]);
							    modelController.removeFromSlavingSet(sublistId, fieldId, lineInstanceId, slavingId);
							},
							function (reason) { throw reason; }); // TODO: (Issue 407340) This needs to be updated when Chris checks in his event CLs
					}
				}
			}

			function doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField)
			{
				var isCommitted = false,
					lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, isCommitted);

				doPerformSlaving(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			}

			this.doSlaving = doSlaving;

			function doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			{
				doPerformSlaving(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			}

			this.doSlavingForInstance = doSlavingForInstance;

			function postProcessSlavingMetadata(metadata)
			{
				var REQUIRED_SCRIPT = 'requiredScript';

				var auxfields = metadata['auxfields'];
				for (var idx = 0; auxfields && idx < auxfields.length; idx++)
				{
					var auxfld = auxfields[idx];
					if (auxfld.hasOwnProperty(REQUIRED_SCRIPT))
					{
						auxfld.isRequired = recordScriptingScope.runInternalScriptAndReturnBooleanResult(auxfld[REQUIRED_SCRIPT]);
					}
				}

				return metadata;
			}

			function postProcessSlaveValues(slaveValues)
			{
				var CONDITION = 'condition';

				for (var idx = 0; slaveValues.body && idx < slaveValues.body.length; idx++)
				{
					if (slaveValues.body[idx].hasOwnProperty(CONDITION))
					{
						slaveValues.body[idx][CONDITION] = recordScriptingScope.runInternalScriptAndReturnBooleanResult(slaveValues.body[idx][CONDITION]);
					}
				}

				return slaveValues;
			}


			function triggerPageInitScript()
			{
				recordScriptingScope.pageInit();
			}

			this.triggerPageInitScript = triggerPageInitScript;

			function triggerLocalizationContextChange() {
				record.locale.triggerLocalizationContextChange();
			}

			this.triggerLocalizationContextChange = triggerLocalizationContextChange;

			function triggerLineInitScript(sublistId)
			{
				recordScriptingScope.lineInit(sublistId);
			}

			this.triggerLineInitScript = triggerLineInitScript;

			function triggerPostDeleteLineScript(sublistId, line_1)
			{
				recordScriptingScope.postDeleteLine(sublistId, line_1)
			}

			this.triggerPostDeleteLineScript = triggerPostDeleteLineScript;

			function triggerLineCommitScript(sublistId, line_1)
			{
				recordScriptingScope.lineCommit(sublistId, line_1)
			}

			this.triggerLineCommitScript = triggerLineCommitScript;

			function triggerValidateLineScript(sublistId)
			{
				recordScriptingScope.validateLine(sublistId);
			}

			this.triggerValidateLineScript = triggerValidateLineScript;

			function triggerValidateInsertScript(sublistId)
			{
				recordScriptingScope.validateInsert(sublistId);
			}

			this.triggerValidateInsertScript = triggerValidateInsertScript;

			function triggerValidateDeleteScript(sublistId)
			{
				recordScriptingScope.validateDelete(sublistId);
			}

			this.triggerValidateDeleteScript = triggerValidateDeleteScript;

			function triggerValidateFieldScript(sublistId, fieldId, line_1, matrixColumn)
			{
				recordScriptingScope.validateField(sublistId, fieldId, line_1, matrixColumn);
			}

			this.triggerValidateFieldScript = triggerValidateFieldScript;

			function triggerFieldChangeScript(sublistId, fieldId, line_1, matrixColumn)
			{
				recordScriptingScope.fieldChange(sublistId, fieldId, line_1, matrixColumn);
			}

			this.triggerFieldChangeScript = triggerFieldChangeScript;

			function triggerCanCreateSubrecordScript(sublistId, fieldId, line_1)
			{
				recordScriptingScope.canCreateSubrecord(sublistId, fieldId, line_1)
			}

			this.triggerCanCreateSubrecordScript = triggerCanCreateSubrecordScript;

			function triggerSaveRecordScript(ignoreMandatoryFields)
			{
				recordScriptingScope.saveRecord(ignoreMandatoryFields);
			}

			this.triggerSaveRecordScript = triggerSaveRecordScript;

			function triggerRecalcScript(sublistId, localRecalc, operation)
			{
				recordScriptingScope.recalc(sublistId, localRecalc, operation);
			}

			this.triggerRecalcScript = triggerRecalcScript;

			function triggerMachinePostSourcing(postSourcingScript)
			{
				recordScriptingScope.postSublistSourcing(postSourcingScript);
			}

			this.triggerMachinePostSourcing = triggerMachinePostSourcing;

			function triggerCustomPostSourcingScript(sublistId, fieldId, line)
			{
				recordScriptingScope.postSourcing(sublistId, fieldId, line);
			}

			this.triggerCustomPostSourcingScript = triggerCustomPostSourcingScript;
		}

		function create(record)
		{
			return new DynamicRecordImpl(record);
		}

		return {
			/**
			 * create a dynamic record implementation that will supplement record behavior
			 * @param {Record} record
			 */
			create: create
		};
	});

/**
 * SuiteScript dynamic record impl
 *
 * @private
 * @module N/record/deferredDynamicRecordImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/deferredDynamicRecordImpl',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/error'],
	function(recordUtil, utilityFunctions, error)
	{
		/**
		 * Deferred Dynamic Record Implementation for record behavior
		 * @param {Record} record
		 * @constructor
		 */
		function DeferredDynamicRecordImpl(record)
		{
			var undef = undefined;

			function initRecord(record, scope)
			{
				if(record.getIsReadOnlyRecord())
					return;
				record.resetsetRecordStateController();
			}
			this.initRecord = initRecord;
			this.shouldValidateFieldPermissions = recordUtil.no_op_function;

			function isUnchangedExistingRecord(fieldState)
			{
				return !record.isNewRecord() && !fieldState.isChanged;
			}

			function validateTextApi(isTextApi, fieldState, setterMethod, suggestedMethod)
			{
				if (((isTextApi && !fieldState.useTextApi) || (!isTextApi && fieldState.useTextApi)) && !isUnchangedExistingRecord(fieldState))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_API_USAGE, suggestedMethod, setterMethod)
				}
			}

			this.validateTextApi = validateTextApi;

			this.validateLineIndex = recordUtil.no_op_function;

			this.getCachedOptionsForRecordField = recordUtil.no_op_function;

			function isSublistAScriptableMachine(sublistId)
			{
				return record.getSublistMetadata(sublistId) && record.getSublistMetadata(sublistId).isScriptableMachine;
			}

			function insertLineIfNewLineAndGetNewInstanceId(sublistId, line, isCommitted)
			{
				var isScriptableOrEditable = (isSublistAScriptableMachine(sublistId) || record.isSublistAnEditMachine(sublistId));
				var allowInsertLine = line <= Math.max(record.doGetLineCount(sublistId), 0);
				if (isScriptableOrEditable && allowInsertLine)
					record.doInsertLine(sublistId, line);
				return record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, true);
			}

			function getLineInstanceId(sublistId, line, isCommitted)
			{
				var lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, true);
				return lineInstanceId || null;
			}
			this.getLineInstanceId = getLineInstanceId;

			function getOrCreateLineInstanceId(sublistId, line)
			{
				var lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line, true);
				if (lineInstanceId === null)
					lineInstanceId = insertLineIfNewLineAndGetNewInstanceId(sublistId, line, true);
				return lineInstanceId;
			}

			function doGetText(fieldId, delegator)
			{
				var value = undef;
				var fieldState = record.getFieldState(fieldId);
				if (isUnchangedExistingRecord(fieldState))
				{
					value = delegator.getTextValue(fieldId);
				}
				else
					value = record.doGetValue(fieldId);

				return value;
			}

			this.doGetText = doGetText;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				var isFieldChange = record.getFieldState(fieldId).isChanged;
				if (!isFieldChange)
					return delegator.getParsedValue(fieldId, true);
				else
					return record.doGetValue(fieldId);
			}
			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function doSetValue(fieldId, value, fireFieldChange, noSlaving)
			{
				record.doSetFieldValue(fieldId, value, false, true);
			}

			this.doSetValue = doSetValue;

			this.postSetFieldValueForInstance = recordUtil.no_op_function;

			function doSetText(fieldId, text)
			{
				var fireFieldChanged = false;
				var noSlaving = true;
				record.doSetFieldValue(fieldId, text, fireFieldChanged, noSlaving);
				record.getFieldState(fieldId).useTextApi = true;
			}

			this.doSetText = doSetText;

			this.validateAndFormatFieldValue = recordUtil.no_op_function;
			this.validateAndFormatFieldValueForInstance = recordUtil.no_op_function;

			function getSublistSubrecord(sublistId, fieldId, line)
			{
				getOrCreateLineInstanceId(sublistId, line);
				return record.doGetSublistSubrecord(sublistId, fieldId, line);
			}
			this.getSublistSubrecord = getSublistSubrecord;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				var value = undef;
				var isFieldChanged = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true).isChanged;
				if (!isFieldChanged)
				{
					value = delegator.getParsedValue(fieldId, true);
				}
				else
				{
					value = record.doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, true);
				}

				return value;
			}
			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			function setSublistValue(options, fieldId, line, value)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef && value != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
					value = options.value;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], record.getMissingArgumentErrorMessageFillerValue("setSublistValue"));
				if (line < 0)
					return;
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				getOrCreateLineInstanceId(sublistId, line);
				record.doSetSublistValue(sublistId, fieldId, line, value);
				record.getSublistFieldState(sublistId, fieldId, line, true).useTextApi = false;
			}

			this.setSublistValue = setSublistValue;

			function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				var value = undef;
				var fieldState = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true);
				if (isUnchangedExistingRecord(fieldState))
				{
					value = delegator.getTextValueForInstance(sublistId, fieldId, lineInstanceId, true);
				}
				else
					value = record.doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, true);

				return value;
			}
			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			function setSublistText(options, fieldId, line, text)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef && text != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
					text = options.text;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], record.getMissingArgumentErrorMessageFillerValue("setSublistText"));
				recordUtil.validateAgainstSqlInjection(fieldId, text);
				getOrCreateLineInstanceId(sublistId, line);
				record.doSetSublistValue(sublistId, fieldId, line, text);
				record.getSublistFieldState(sublistId, fieldId, line, true).useTextApi = true;
			}

			this.setSublistText = setSublistText;

			this.preInsertLine = recordUtil.no_op_function;
			function preInsertLineForInstance(sublistId, beforeLineInstanceId) {
				return beforeLineInstanceId;
			}
			this.preInsertLineForInstance = preInsertLineForInstance;
			this.postInsertLine = recordUtil.no_op_function;
			this.postInsertLineForInstance = recordUtil.no_op_function;

			function removeSublistLine(sublistId, line, ignoreRecalc)
			{
				record.doRemoveSublistLine(sublistId, line);
			}
			this.removeSublistLine = removeSublistLine;
			function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				record.doRemoveSublistLineForInstance(sublistId, lineInstanceId);
			}
			this.removeSublistLineForInstance = removeSublistLineForInstance;

			this.doSlaving = recordUtil.no_op_function;

			this.postRemoveLine = recordUtil.no_op_function;
			this.postRemoveLineForInstance = recordUtil.no_op_function;

			this.addNewLine = recordUtil.no_op_function;

			this.selectLine = recordUtil.no_op_function;

			this.selectNewLine = recordUtil.no_op_function;

			this.cancelLine = recordUtil.no_op_function;

			this.cancelLineForInstance = recordUtil.no_op_function;

			this.commitLine = recordUtil.no_op_function;

			this.commitLineForInstance = recordUtil.no_op_function;

			this.getCurrentSublistValue = recordUtil.no_op_function;

			this.setCurrentSublistValue = recordUtil.no_op_function;

			this.getCurrentSublistText = recordUtil.no_op_function;

			this.setCurrentSublistText = recordUtil.no_op_function;

			this.triggerFieldChangeEvent = recordUtil.no_op_function;

			this.triggerPageInitScript = recordUtil.no_op_function;

			this.triggerLocalizationContextChange = recordUtil.no_op_function;

			this.triggerLineInitScript = recordUtil.no_op_function;

			this.triggerPostDeleteLineScript = recordUtil.no_op_function;

			this.triggerLineCommitScript = recordUtil.no_op_function;

			this.triggerValidateLineScript = recordUtil.no_op_function;

			this.triggerValidateInsertScript = recordUtil.no_op_function;

			this.triggerValidateDeleteScript = recordUtil.no_op_function;

			this.triggerValidateFieldScript = recordUtil.no_op_function;

			this.triggerFieldChangeScript = recordUtil.no_op_function;

			this.triggerCanCreateSubrecordScript = recordUtil.no_op_function;

			this.triggerSaveRecordScript = recordUtil.no_op_function;

			this.triggerRecalcScript = recordUtil.no_op_function;

			this.triggerMachinePostSourcing = recordUtil.no_op_function;

			this.triggerCustomPostSourcingScript = recordUtil.no_op_function;
		}

		function create(record)
		{
			return new DeferredDynamicRecordImpl(record);
		}

		return {
			/**
			 * create a deferred dynamic record implementation that will supplement record behavior
			 * @param {Record} record
			 */
			create : create
		};
	});

/**
 * SuiteScript record impl factory
 *
 * @private
 * @module N/record/recordImplementation
 * @NApiVersion 2.x
 *
 */
define('N/record/recordImplementation',['N/record/dynamicRecordImpl', 'N/record/deferredDynamicRecordImpl'], function(dynamicRecordImpl, deferredDynamicRecordImpl){

    function create(isDynamicRecord, record)
    {
        return isDynamicRecord ? dynamicRecordImpl.create(record) : deferredDynamicRecordImpl.create(record);
    }

    return {
        /**
         * create the corresponding implementation for record object based on the record mode
         * @param {boolean} isDynamicRecord
         * @param {Record} record object
         */
        create : create
    };
});

/**
 * @private
 */
define('N/restricted/scopeRemoteApiBridge',['N/restricted/reflet'], function(reflet){ return reflet; });

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/subrecordController
 * @suiteScriptVersion 2.x
 */
define('N/record/subrecordController',[ 'N/utilityFunctions', 'N/error', 'N/record/matrix', 'N/util/currencyUtility', 'N/util/date', 'N/util/formatter', 'N/record/recordCacheController'],
    function(utilityFunctions, error, matrix, currency, date, formatter, recordCacheController){

        function subrecordController(record)
        {
            var uncommittedSubrecordCache = recordCacheController.create();

            function createSubrecord(fieldId)
            {
                var result = null;
                var field, type, id;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'createSubrecord');

                result = uncommittedSubrecordCache.get(null, fieldId);

                if(!!result || record.hasSubrecord(fieldId))
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD,fieldId);
                }
                else
                {
                    result = record.doGetBodySubrecord(fieldId);
                    result = result.internalClone();
                    uncommittedSubrecordCache.put(null, fieldId, null, result);
                }

                return result;
            }

            function editSubrecord(fieldId)
            {
                var result = null;
                var field, type, id;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'editSubrecord');

                result = uncommittedSubrecordCache.get(null, fieldId);

                if(!result && record.hasSubrecord(fieldId)){
                    result = record.doGetBodySubrecord(fieldId);
                    result = result.internalClone();
                    uncommittedSubrecordCache.put(null, fieldId, null, result);
                }

                return result;
            }

            function viewSubrecord(fieldId)
            {
                var result = null;
                var field, type, id;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'viewSubrecord');

                result = uncommittedSubrecordCache.get(null, fieldId);

                if(!result && record.hasSubrecord(fieldId)){
                    result = record.doGetBodySubrecord(fieldId);
                    result = result.internalClone();
                }

                return result;
            }

            function removeSubrecord(fieldId)
            {
                uncommittedSubrecordCache.invalidate(null, fieldId);
                record.performSubrecordRemoval(fieldId);
            }

            function createCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var result = null;
                var isCommitted = false;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted);

                if(record.hasCurrentSublistSubrecord(sublistId, fieldId) || uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted) != null)
                {
                    utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD,sublistId + "." +fieldId);
                }
                else
                {
                    result = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
                    uncommittedSubrecordCache.put(null, fieldId, null, result);
                }

                return result;
            }

            function editCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var isCommitted = false;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted);
                var result = uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);

                if(!result && record.hasCurrentSublistSubrecord(sublistId, fieldId))
                {
                    result = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
                    result = result.internalClone();
                    uncommittedSubrecordCache.put(sublistId, fieldId, lineInstanceId, result, isCommitted);
                }

                return !result ? null : result;
            }

            function removeCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var isCommitted = false;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted);

                uncommittedSubrecordCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
                record.doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
            }

            function viewCurrentLineItemSubrecord(sublistId, fieldId)
            {
                var isCommitted = false;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted);
                var result = uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);

                if(!result && record.hasCurrentSublistSubrecord(sublistId, fieldId))
                {
                    result = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
                    result = result.internalClone();
                }

                if(!!result)
                {
                    result.setReadonly();
                }

                return !result ? null : result;
            }

            function viewLineItemSubrecord(sublistId, fieldId, line)
            {
                var useSelectedLineBuffer = line === -1;
                var isCommitted = !useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
                var result = uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);

                if (!result && record.hasSublistSubrecord(sublistId, fieldId, line))
                {
                    result = record.doGetSublistSubrecord(sublistId, fieldId, line);
                    result = result.internalClone();
                }

                if(!!result)
                {
                    result.setReadonly();
                }

                return !result ? null : result;
            }

            function commit(subrecordToCommit)
            {
                var subrecord, sublistId, fieldId;

                if(!!record.subrecordParent)
                {
                    record.triggerSaveRecordScript();
                    record.subrecordParent.commit(record);
                }
                else if(!record.subrecordParent && !!subrecordToCommit)
                {
                    sublistId = subrecordToCommit.subrecordSublistId || null;
                    fieldId = subrecordToCommit.subrecordFieldId;

                    if (sublistId === null)
                    {
                        if (subrecordToCommit === uncommittedSubrecordCache.get(null, fieldId))
                        {
                            subrecord = record.getSubrecord(fieldId);
                            subrecord.setModelController(subrecordToCommit.getModelController());
                            subrecord.setRecordStateController(subrecordToCommit.getRecordStateController());
                            uncommittedSubrecordCache.invalidate(null, fieldId);
                            record.triggerFieldChangeEvent(null, fieldId, -1, record.getFieldValue(fieldId), false);
                        }
                    }
                    else
                    {
                        /*
                         if(subrecord === uncommittedSubrecordCache.get(sublistId, fieldId, -1))
                         {

                         }
                         else
                         {
                         record.triggerFieldChangeEvent(null, fieldId, -1, getFieldValue(fieldId), false);
                         }
                         */
                    }
                }
            }

            function getUncommittedSubrecord(sublistId, fieldId, line0)
            {
                sublistId = sublistId || null;
                line0 = (!isNaN(line0) && line0 >= 0 && line0) || -1;

                var useSelectedLineBuffer = line0 === -1;
                var isCommitted = !useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line0, isCommitted);

                return uncommittedSubrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
            }

            function invalidateSubrecordCacheForV1RecordScope()
            {
                uncommittedSubrecordCache = recordCacheController.create();
            }

            function invalidateSubrecordCacheEntry(sublistId, fieldId, line_0)
            {
                var useSelectedLineBuffer = line_0 === -1;
                var isCommitted = !useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line_0, isCommitted);
                uncommittedSubrecordCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            }

            function insertLineForSubrecordCache(sublistId, line)
            {
                var useSelectedLineBuffer = line === -1;
                var isCommitted = !useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
                uncommittedSubrecordCache.get(sublistId, null, lineInstanceId, isCommitted);
            }

            function removeLineForSubrecordCache(sublistId, line)
            {
                var useSelectedLineBuffer = line === -1;
                var isCommitted = !useSelectedLineBuffer;
                var modelController = record.getModelController();
                var lineInstanceId = useSelectedLineBuffer ?
                        modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted) :
                        modelController.getSublistLineInstanceIdForLine(sublistId, line, isCommitted);
                uncommittedSubrecordCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            }

            function invalidateCurrentSublistLineForSubrecordCache(sublistId)
            {
                var isCommitted = false;
                var modelController = record.getModelController();
                var lineInstanceId = modelController.getSublistLineInstanceIdForLine(sublistId, modelController.getCurrentSublistLineIndex(sublistId), isCommitted);

                uncommittedSubrecordCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            }

            return {
                createSubrecord: createSubrecord,
                editSubrecord: editSubrecord,
                viewSubrecord: viewSubrecord,
                removeSubrecord: removeSubrecord,
                createCurrentLineItemSubrecord: createCurrentLineItemSubrecord,
                editCurrentLineItemSubrecord: editCurrentLineItemSubrecord,
                removeCurrentLineItemSubrecord: removeCurrentLineItemSubrecord,
                viewCurrentLineItemSubrecord: viewCurrentLineItemSubrecord,
                viewLineItemSubrecord: viewLineItemSubrecord,
                commit: commit,
                getUncommittedSubrecord: getUncommittedSubrecord,
                invalidateSubrecordCacheForV1RecordScope: invalidateSubrecordCacheForV1RecordScope,
                invalidateSubrecordCacheEntry: invalidateSubrecordCacheEntry,
                insertLineForSubrecordCache: insertLineForSubrecordCache,
                removeLineForSubrecordCache: removeLineForSubrecordCache,
                invalidateCurrentSublistLineForSubrecordCache: invalidateCurrentSublistLineForSubrecordCache
            }
        }

        function create(record)
        {
            return new subrecordController(record);
        }


        return Object.freeze({create: create});
    }
);

/**
 * SuiteScript nlobjrecord implementation for version 2 record
 *
 * @private
 * @module N/record/legacyNLObjects
 * @NApiVersion 2.x
 *
 */
define('N/record/legacyNLObjects',['N/restricted/remoteApiBridge', 'N/restricted/invoker', 'N/utilityFunctions', 'N/runtime'],
function(remoteApi, invoker, utilityFunctions, runtime) {

	var getModule = (function() {
		var moduleCache = {};
		return function getRecordModule(name, isInternal)
		{
			if (!!moduleCache[name])
				return moduleCache[name];

			var wasSync = require.isSync();
			require.forceSync(true);
			var wasInternal = require.isInternal();
			if (!!isInternal) require.setInternal(true);
			try
			{
				require([name], function(rm) { moduleCache[name] = rm; });
			}
			finally
			{
				if (!!isInternal) require.setInternal(wasInternal);
				require.forceSync(wasSync);
			}
			return moduleCache[name];
		}
	})();

	var getRecordModule = getModule.bind(null, 'N/record', false);
	var getRecordImplModule = getModule.bind(null, 'N/record/recordImpl', true);
	var getRecordImplV1Module = getModule.bind(null, 'N/record/recordImplV1', true);

	var getRecordImplV1 = function(rawRecord) {
		if (!rawRecord) return null;
		var constructorName = utilityFunctions.getConstructorName(rawRecord);
		if (constructorName === 'RecordImplV1') return rawRecord;
		if (constructorName === 'Record') return getRecordImplV1Module().create({record: rawRecord});
		return null;
	};

	var nlobjRecordGetter = (function()
	{
		var nlobjRecord;
		return function nlobjRecordGetter()
		{
			if (!nlobjRecord)  // must be defined only once so the instanceOf works properly
			{
				nlobjRecord = function nlobjRecord(type, id) {
					this.type = type;
					this.id = id;
					this.fields = {};
					this.fieldnames = [];
					this.lineitems = [];
					this.linetypes = {};
					this.linefields = {};
					this.matrixfields = {};
					this.currentlineitems = {};
					this.currentlineitemindexes = {};
					this.initialized = false;
					this.operations = [];
				};
				nlobjRecord.prototype.getId = function () { return this.id; };
				nlobjRecord.prototype.getRecordType = function () { return this.type; };
				nlobjRecord.prototype.setFieldValue = function (name, value) {
					this.fields[name] = value;
					this.logOperation("setFieldValue", {"field": name, "value": value})
				};
				nlobjRecord.prototype.setFieldValues = function (name, values) {
					this.fields[name] = values;
					this.logOperation("setFieldValues", {"field": name, "value": values})
				};
				nlobjRecord.prototype.getFieldValue = function (name) { return !!this.fields[name] ? this.fields[name] : null; };
				nlobjRecord.prototype.getFieldValues = function (name) { return !!this.fields[name] ? this.fields[name] : null; };
				nlobjRecord.prototype.getAllFields = function () {
					var s = [];
					for (var f in this.fields)
						if (this.fields.hasOwnProperty(f))
							s[s.length++] = f;
					for (var i = 0; i < this.fieldnames.length; i++)
						utilityFunctions.arrayAdd(s, this.fieldnames[i]);
					return s;
				};
				nlobjRecord.prototype.getAllLineItems = function () {
					var s = [];
					for (var f in this.lineitems)
						if (this.lineitems.hasOwnProperty(f))
							s[s.length++] = f;
					return s;
				};
				nlobjRecord.prototype.getAllLineItemFields = function (name) {
					var linegroup = this.linefields[name];
					if (!linegroup)
						return null;

					var s = [];
					for (var i = 0; i < this.linefields[name].length; i++)
						s[s.length++] = this.linefields[name][i];
					return s;
				};
				nlobjRecord.prototype.setLineItemValue = function (group, name, line, value) {
					assertTrue(line > 0 && line - 1 <= this.getLineItemCount(group), 'SSS_INVALID_SUBLIST_OPERATION');
					/* Special case setting fields on the next line for edit machines and UI object list machines (backward compatiblity) */
					if (line - 1 === this.getLineItemCount(group))
						this.selectNewLineItem(group);
					else if (line <= this.getLineItemCount(group))
						this.selectLineItem(group, line);
					this.setCurrentLineItemValue(group, name, value);
					this.commitLineItem(group)
				};
				nlobjRecord.prototype.setAndCommitLineItemValue = function (group, name, line, value) {
					var linegroup = this.lineitems[group];
					if (!linegroup) {
						linegroup = [];
						this.lineitems[group] = linegroup;
					}
					var lineitem = linegroup[line];
					if (!lineitem) {
						lineitem = new Array(1);
						linegroup[line] = lineitem;
					}
					lineitem[name] = value;
				};
				nlobjRecord.prototype.insertLineItem = function (type, line) {
					assertTrue(this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					if (this.getCurrentLineItemIndex(type) === -1) {
						if (line - 1 === this.getLineItemCount(type) || isNaN(parseInt(line)))
							this.selectNewLineItem(type);
						else if (line <= this.getLineItemCount(type))
							this.selectLineItem(type, line)
					}
					var linegroup = this.lineitems[type];
					if (!linegroup) {
						linegroup = new Array(1);
						this.lineitems[type] = linegroup;
					}
					linegroup.splice(line, 0, []);
					this.logOperation("insertLineItem", {"type": type})
				};
				nlobjRecord.prototype.removeLineItem = function (type, line) {
					assertTrue(this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					if (this.getCurrentLineItemIndex(type) === -1) {
						if (line - 1 === this.getLineItemCount(type) || isNaN(parseInt(line)))
							this.selectNewLineItem(type);
						else if (line <= this.getLineItemCount(type))
							this.selectLineItem(type, line)
					}

					var linegroup = this.lineitems[type];
					if (!linegroup || this.getLineItemCount(type) < line)
						return;
					linegroup.splice(line, 1);
					this.logOperation("removeLineItem", {"type": type});
					if (this.getCurrentLineItemIndex(type) !== -1) {
						this.currentlineitems[type] = null;
						this.currentlineitemindexes[type] = null;
					}
				};
				nlobjRecord.prototype.getLineItemValue = function (group, name, line) {
					var value = null;
					var linegroup = this.lineitems[group];
					if (!!linegroup) {
						var lineitem = linegroup[line];
						if (!!lineitem)
							value = lineitem[name];
					}
					return value != null ? value : null;
				};
				nlobjRecord.prototype.getLineItemCount = function (group) {
					var linegroup = this.lineitems[group];
					return !!linegroup ? linegroup.length - 1 /* zeroth line is unused. */ : 0;
				};
				nlobjRecord.prototype.setLineItemMatrixValue = function (type, fldnam, linenum, column, value) {
					if (this.isMatrixField(type, fldnam))
						this.setLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), linenum, value)
				};
				nlobjRecord.prototype.getLineItemMatrixValue = function (type, fldnam, linenum, column) {
					if (this.isMatrixField(type, fldnam))
						return this.getLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), linenum);
					return null;
				};
				nlobjRecord.prototype.findLineItemValue = function (type, fldnam, value) {
					for (var linenum = 1; linenum <= this.getLineItemCount(type); linenum++)
						if (value == this.getLineItemValue(type, fldnam, linenum))
							return linenum;
					return -1;
				};
				nlobjRecord.prototype.findLineItemMatrixValue = function (type, fldnam, column, value) {
					if (this.isMatrixField(type, fldnam))
						return this.findLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), value);
					return -1;
				};
				nlobjRecord.prototype.setMatrixValue = function (type, fldnam, column, value) {
					if (this.isMatrixField(type, fldnam)) {
						this.fields[this.getFieldValue(type + 'header') + column] = value;
						this.logOperation("setMatrixValue", {"type": type, "field": name, "column": column, "value": value})
					}
				};
				nlobjRecord.prototype.getMatrixValue = function (type, fldnam, column) {
					return this.isMatrixField(type, fldnam) ? this.getFieldValue(this.getFieldValue(type + 'header') + column) : null;
				};
				nlobjRecord.prototype.getMatrixCount = function (type, fldnam) {
					return this.isMatrixField(type, fldnam) ? this.getFieldValue(this.getFieldValue(type + 'headercount')) : null;
				};
				nlobjRecord.prototype.selectLineItem = function (type, linenum) {
					assertTrue(!!this.linetypes[type] && linenum > 0 && linenum <= this.getLineItemCount(type), 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = {};
					this.currentlineitemindexes[type] = linenum;
					var flds = this.getAllLineItemFields(type);
					for (var i = 0; i < flds.length; i++)
						this.currentlineitems[type][flds[i]] = this.getLineItemValue(type, flds[i], linenum)
					this.logOperation("selectLineItem", {"type": type, "linenum": linenum})
				};
				nlobjRecord.prototype.selectNewLineItem = function (type) {
					assertTrue(!!this.linetypes[type] && this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = {};
					this.currentlineitemindexes[type] = this.getLineItemCount(type) + 1;
					this.logOperation("selectNewLineItem", {"type": type})
				};
				nlobjRecord.prototype.cancelLineItem = function (type) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = null;
					this.currentlineitemindexes[type] = null;
					this.logOperation("cancelLineItem", {"type": type})
				};
				nlobjRecord.prototype.commitLineItem = function (type) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					var flds = this.getAllLineItemFields(type);
					var linenum = this.getCurrentLineItemIndex(type);
					for (var i = 0; i < flds.length; i++)
						this.setAndCommitLineItemValue(type, flds[i], linenum, this.currentlineitems[type][flds[i]])
					this.currentlineitems[type] = null;
					this.currentlineitemindexes[type] = null;
					this.logOperation("commitLineItem", {"type": type})
				};
				nlobjRecord.prototype.getCurrentLineItemIndex = function (type) { return !!this.currentlineitems[type] ? this.currentlineitemindexes[type] : -1; };
				nlobjRecord.prototype.getCurrentLineItemValue = function (type, name) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					return this.currentlineitems[type][name]
				};
				nlobjRecord.prototype.setCurrentLineItemValue = function (type, name, value) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type][name] = value;
					this.logOperation("setCurrentLineItemValue", {"type": type, "field": name, "value": value})
				};
				nlobjRecord.prototype.setCurrentLineItemMatrixValue = function (type, fldnam, column, value) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type][this.getMatrixFieldName(type, fldnam, column)] = value;
					this.logOperation("setCurrentLineItemMatrixValue", {
						"type": type,
						"field": fldnam,
						"column": column,
						"value": value
					})
				};
				nlobjRecord.prototype.getCurrentLineItemMatrixValue = function (type, fldnam, column) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					return this.currentlineitems[type][this.getMatrixFieldName(type, fldnam, column)]
				};
				/* field text APIs and field metadata APIs not yet supported via nlobjRecord interface in Client SuiteScript */

				nlobjRecord.prototype.setFieldText = function (name, text) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.setFieldTexts = function (name, texts) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldText = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldTexts = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemText = function (type, name, line) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getCurrentLineItemText = function (type, name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.setCurrentLineItemText = function (type, name, text) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getSublist = function (type) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getMatrixField = function (type, fldnam) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemField = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemField = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldDisabled = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldMandatory = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldDisplay = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldVisibility = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldLabel = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemDisplay = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemDisabled = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemMandatory = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemLabel = function (type, name) { throwLegacyUnsupportedError(); };

				/* internal nlobjRecord helper methods */
				nlobjRecord.prototype.isMatrixField = function (type, fld) {
					return this.getFieldValue(type + 'matrixfields') != null && utilityFunctions.arrayIndexOf(this.getFieldValue(type + 'matrixfields')
						.split(","), fld) !== -1;
				};
				nlobjRecord.prototype.getMatrixFieldName = function (type, fldnam, column) { return this.isMatrixField(type, fldnam) ? fldnam + "_" + column + "_" : null; };
				nlobjRecord.prototype.logOperation = function (operation, args) {
					if (this.initialized) this.operations.push({
						"operation": operation,
						"args": args
					});
				};
				nlobjRecord.prototype.getDateTimeValue = function (fldname, timezone) {
					if (!timezone)
						return this.getFieldValue(fldname);
					else {
						var storedDateTime = this.getFieldValue(fldname);
						var preferredTimeZone = runtime.getCurrentUser().getPreference("TIMEZONE");
						if (preferredTimeZone === timezone)
							return storedDateTime;
						else
							return invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [storedDateTime, timezone]);
					}
				};

				nlobjRecord.prototype.setDateTimeValue = function (fldname, value, timezone) {
					if (!timezone)
						return this.setFieldValue(fldname, value);
					else {
						var preferredTimeZone = runtime.getCurrentUser().getPreference("TIMEZONE");
						if (preferredTimeZone === timezone)
							return this.setFieldValue(fldname, value);
						else {
							var newVal = invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [value, timezone]);
							return this.setFieldValue(fldname, newVal);
						}
					}
				};

				// this is only supported on server-side dynamic record
				nlobjRecord.prototype.calculateTax = function () { throwLegacyUnsupportedError(); };
			}
			return nlobjRecord;
		};
	})();

	var nlobjRecordWrapper = function(record, operation, options)
	{
		if (!record) return record;

		var v1Record = getRecordImplV1(record);
		if (v1Record)
		{
			var nlobjrecord = new (nlobjRecordGetter())(v1Record.getRecordType(), v1Record.getId());

			nlobjrecord.fieldnames = v1Record.getAllFields() || [];
			nlobjrecord.fieldnames.forEach(function (fld) {
				var val = v1Record.getFieldValue(fld);
				nlobjrecord.setFieldValue(fld, val);
			});

			nlobjrecord.linetypes = (function () {
				var linetypes = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					linetypes[sl] = v1Record.getSublistType(sl);
				});
				return linetypes;
			})();

			nlobjrecord.linefields = (function () {
				var linefields = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {

					linefields[sl] = v1Record.getAllLineItemFields(sl) || [];

					var backwardCompatibilityMap = (v1Record._getSubrecordBackwardCompatibilityMap(sl) || []);
					backwardCompatibilityMap.forEach(function (fld) {
						if (linefields[sl].indexOf(fld) == -1 && linefields[sl].indexOf(fld + '_initialvalue') > -1)
							linefields[sl].push(fld);
					});

					var lineCount = v1Record.getLineItemCount(sl);
					for (var line_1 = 1; line_1 < lineCount+1; line_1++)
					{
						linefields[sl].forEach(function (lineFld) {
							var val = v1Record.getLineItemValue(sl, lineFld, line_1);
							nlobjrecord.setAndCommitLineItemValue(sl, lineFld, line_1, val);
						});
					}
				});
				return linefields;
			})();

			nlobjrecord.matrixfields = (function () {
				var matrixfields = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					var mfv = v1Record.getFieldValue(sl + 'matrixfields');
					if (!!mfv) matrixfields[sl] = mfv.split(',');
				});
				return matrixfields;
			})();

			nlobjrecord.initialized = true;

			nlobjrecord.logOperation(operation, {'defaultValues': options.defaultValues});

			return nlobjrecord;
		}
	};

	var nlobjSublistGetter = (function()
	{
		var nlobjSubList;

		return function nlobjSublistGetter(record)
		{
			var getSublist = function(name) {
				var sl = null;
				var v1Record = getRecordImplV1(record);
				if (!v1Record)
					return sl;
				return v1Record.getSublist(name) || null;
			};

			if (!nlobjSubList)  // must be defined only once so the instanceOf works properly
			{
				nlobjSubList = function nlobjSubList(name) {
					var sl = getSublist(name);
					this.name = name;
					this.type = sl ? sl.getType() : null;
					this.label = null;
					this.hidden = false;
					this.display = true;
				};

				nlobjSubList.prototype.getName = function () { return this.name; };
				nlobjSubList.prototype.getType = function () { return this.type; };
				nlobjSubList.prototype.getLabel = function () { return this.label != null ? this.label : ""; };
				nlobjSubList.prototype.isHidden = function () { return this.hidden; };
				nlobjSubList.prototype.isDisplay = function () { return this.display; };
				nlobjSubList.prototype.isChanged = function () {
					var sl = getSublist(this.name);
					return sl ? sl.isChanged() : false;
				};

				nlobjSubList.prototype.setLabel = function (label) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setHelpText = function (help) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setDisplayType = function (type) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemValue = function (field, line, value) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemMatrixValue = function (field, line, column, value) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemValues = function (values) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getField = function (name) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getAllFields = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getAllHeaderFields = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addField = function (name, type, label, source, group) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addHeaderField = function (name, type, label, source) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setAmountField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setUniqueField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getMatrixCount = function (field) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addButton = function (name, label, script) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getButton = function (name) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addRefreshButton = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addMarkAllButtons = function () { throwLegacyUnsupportedError(); };
			}
			return nlobjSubList;
		};
	})();

	var nlobjSublistWrapper = function(record, sublist)
	{
		if (!sublist) return sublist;

		var nlobjsublist = new (nlobjSublistGetter(record))(sublist.getName());
		nlobjsublist.type = sublist.getType();
		nlobjsublist.hidden = !!sublist.isHidden();
		nlobjsublist.display = !!sublist.isDisplay();
		return  nlobjsublist;
	};

	var nlobjFieldGetter = (function()
	{
		var nlobjField;

		return function nlobjFieldGetter(record)
		{
			var getField = function(name, sublist, line_1)
			{
				var fld = null;
				var v1Record = getRecordImplV1(record);
				if (!v1Record)
					return fld;

				if (sublist) {
					fld = v1Record.getLineItemField(sublist, name, line_1);
				}
				else {
					fld = v1Record.getField(name);
				}
				return fld;
			};

			if (!nlobjField)  // must be defined only once so the instanceOf works properly
			{
				nlobjField = function nlobjField(name, type, sublist) {
					this.name = name;
					this.type = type;
					this.noslaving = false;
					this.sublist = sublist;
					this.label = null;
					this.required = false;
					this.disabled = false;
					this.hidden = false;
					this.display = false;
					this.visible = false;
					this.popup = false;
					this.readonly = false;
					this.parent = null;
					this.uifield = null;
					this.linenum = -1;
				};

				nlobjField.prototype.getName = function () { return this.name; };
				nlobjField.prototype.getType = function () { return this.type; };
				nlobjField.prototype.getLabel = function () { return this.label != null ? this.label : "" };
				nlobjField.prototype.getSubList = function () { return this.sublist; };
				nlobjField.prototype.getParent = function () { return this.parent; };
				nlobjField.prototype.getLine = function () { return this.linenum; };
				nlobjField.prototype.getUIField = function () { return this.uifield; };
				nlobjField.prototype.noSlaving = function () { return this.noslaving; };
				nlobjField.prototype.isMandatory = function () { return this.required; };
				nlobjField.prototype.isDisabled = function () { return this.disabled; };
				nlobjField.prototype.isHidden = function () { return this.hidden; };
				nlobjField.prototype.isPopup = function () { return this.popup; };
				nlobjField.prototype.isDisplay = function () { return this.display; };
				nlobjField.prototype.isVisible = function () { return this.visible; };
				nlobjField.prototype.isReadOnly = function () { return this.readonly; };

				nlobjField.DISPLAY_TYPE =
					{
						INLINE: 'inline', //not yet supported, throws SSS_NOT_YET_SUPPORTED
						HIDDEN: 'hidden',
						READ_ONLY: 'readonly', //only works for text area or rich text (different from server, where only text area works)
						ENTRY: 'entry',   //does not override Display Type : "Disabled" or "Hidden" UI setting
						DISABLED: 'disabled',
						NORMAL: 'normal'  //does override Display Type : "Disabled" or "Hidden" UI setting
					};

				nlobjField.prototype.setDisplayType = function (displayType) {
					checkArgs([displayType], ['displayType'], 'nlobjField.setDisplayType');
					console.log('setDisplayType: ' + displayType);

					var fld = getField(this.name, this.sublist, this.line);
					if (!fld)
						return;

					switch (displayType.toLowerCase()) {
						case nlobjField.DISPLAY_TYPE.INLINE:
							throwLegacyUnsupportedError();
							break;

						case nlobjField.DISPLAY_TYPE.HIDDEN:
							fld.setDisplay(false);
							fld.setVisible(false);

							this.hidden = true;
							this.visible = false;
							this.display = false;
							break;

						case nlobjField.DISPLAY_TYPE.READ_ONLY:
							if (!this.type || this.type !== "textarea")
								return;
							fld.setDisabled(true);
							this.disabled = true;
							break;

						case nlobjField.DISPLAY_TYPE.ENTRY:
							if (this.hidden || this.disabled)
								return;

							fld.setDisabled(false);
							fld.setDisplay(true);
							fld.setVisible(true);

							this.hidden = false;
							this.visible = true;
							this.display = true;
							this.disabled = false;
							break;

						case nlobjField.DISPLAY_TYPE.DISABLED:
							fld.setDisabled(true);
							this.disabled = true;
							break;

						case nlobjField.DISPLAY_TYPE.NORMAL:
							fld.setDisabled(false);
							fld.setDisplay(true);
							fld.setVisible(true);

							this.hidden = false;
							this.visible = true;
							this.display = true;
							this.disabled = false;
							break;

						default:
							break;
					}
				};

				nlobjField.prototype.setLabel = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setAlias = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDefaultValue = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDisabled = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setMandatory = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setMaxLength = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setLayoutType = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setLinkText = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setHelpText = function (text) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDisplaySize = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setPadding = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.addSelectOption = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.getSelectOptions = function (token) { throwLegacyUnsupportedError(); };
			}
			return nlobjField;
		}
	})();

	var nlobjFieldWrapper = function(record, field, linenum)
	{
		if (!field) return field;

		var fieldState = record && record.hasOwnProperty("getFieldState") ? record.getFieldState(field.getName()) : null;

		var nlobjfield = new (nlobjFieldGetter(record))(field.getName(), field.getType(), field.getSublistName());

		nlobjfield.noslaving = field.noSlaving();
		nlobjfield.label = field.getLabel();
		nlobjfield.required = field.isMandatory();
		nlobjfield.disabled = field.isDisabled();
		nlobjfield.hidden = (fieldState && fieldState.isHidden) || false;
		nlobjfield.display = field.isDisplay();
		nlobjfield.visible = field.isVisible();
		nlobjfield.popup = field.isPopup();
		nlobjfield.readonly = field.isReadOnly();
		nlobjfield.parent = null; // most likely not doable in NEW UI
		nlobjfield.uifield = null;  // most likely not doable in NEW UI
		nlobjfield.linenum = linenum != null ? linenum : -1;

		return nlobjfield;
	};

	var nlobjErrorGetter = (function()
	{
		var nlobjError;

		return function nlobjErrorGetter()
		{
			function stacktrace()
			{
				var stackstring = "stacktrace: ";
				var history = [];
				var func = arguments.callee.caller;

				while (func != null)
				{
					var funcName = getFuncName(func);
					var funcArgs = getFuncArgs(func);
					var caller = func.caller;
					var infiniteLoopDetected = history.indexOf(funcName) !== -1;
					var historyTooLong = history.length > 50;
					var callerIsSelf = (caller === func);

					if (infiniteLoopDetected || historyTooLong || callerIsSelf)
						break;

					stackstring += funcName + funcArgs + "\n\n";
					history.push(funcName);
					func = caller;
				}
				return stackstring;
			}

			function getFuncArgs(a)
			{
				var s = "arguments: {";
				for (var i = 0; i < a.arguments.length; i++)
				{
					if (typeof a.arguments[i] == "undefined")
						s += '\'undefined\'';
					else if (a.arguments[i] == null)
						s += 'null';
					else if (typeof a.arguments[i] == "string")
						s += "'" + a.arguments[i].toString() + "'";
					else
						s += a.arguments[i].toString();
					if (i < a.arguments.length -1)
						s += ",";
				}
				s += "}";
				return s;
			}

			function getFuncName(f)
			{
				var s = f.toString();
				if (s.indexOf("anonymous") >= 0)
				{
					if (s.length > 100)
						return s.substr(0, 100) + "\n";
					else
						return s + "\n";
				}
				else
				{
					s = s.match(/function[^{]*/);
					if (s !== null)
						s = s[0];
				}
				if ((s == null) || (s.length == 0)) return "anonymous \n";
				return s;
			}

			if (!nlobjError)
			{
				nlobjError = function nlobjError(code, error, suppressnotification)
				{
					this.id = null;
					this.code = code;
					this.details = error;
					this.stacktrace = stacktrace();
					this.suppressnotification = suppressnotification;
					if (code instanceof nlobjError)
					{
						this.id = code.getId();
						this.code = code.getCode();
						this.details = code.getDetails();
						this.stacktrace = code.getStackTrace();
					}
					this.name = this.code;
					this.message = this.details;
					this.description = this.details;
				};
				nlobjError.prototype.getId = function( ) { return this.id; };
				nlobjError.prototype.getCode = function( ) { return this.code; };
				nlobjError.prototype.getDetails = function( ) { return this.details; };
				nlobjError.prototype.getStackTrace = function( ) { return this.stacktrace; };
			}
			return nlobjError;
		}
	})();

	var nlobjErrorWrapper = function(exception)
	{
		return exception && exception.hasOwnProperty('notifyOff') ? new (nlobjErrorGetter())(exception.name, exception.message, exception.notifyOff) : exception;
	};
	nlobjErrorWrapper.wrapEmitLegacyError = function(func)
	{
		var fun = func;
		return function()
		{
			try {
				return fun.apply(this, arguments);
			}
			catch (e)
			{
				throw nlobjErrorWrapper(e);
			}
		}
	};

	function throwLegacyError(code, error, suppressnotification) { throw new (nlobjErrorGetter())(code, error, suppressnotification); }
	function throwLegacyUnsupportedError() { throwLegacyError('SSS_NOT_YET_SUPPORTED'); }

	var assertTrue = nlobjErrorWrapper.wrapEmitLegacyError(utilityFunctions.assertTrue);

	var checkArgs = nlobjErrorWrapper.wrapEmitLegacyError(utilityFunctions.checkArgs);

	var nonRecordV1Functions = function() {

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(type, initializeValues)
		{
			var options = {type: type, defaultValues: initializeValues};

			return nlobjRecordWrapper(getRecordImplModule().create_raw(options), 'createRecord', options);
		}
		this.createRecord = nlobjErrorWrapper.wrapEmitLegacyError(createRecord);

		function copyRecord(type, id, initializeValues)
		{
			var options = {type: type, id: id, defaultValues: initializeValues};
			return nlobjRecordWrapper(getRecordImplModule().copy_raw(options), 'copyRecord', options);
		}
		this.copyRecord = nlobjErrorWrapper.wrapEmitLegacyError(copyRecord);

		function loadRecord(type, id, initializeValues)
		{
			var options = {type: type, id: id, defaultValues: initializeValues};
			return nlobjRecordWrapper(getRecordImplModule().load_raw(options), 'loadRecord', options);
		}
		this.loadRecord = nlobjErrorWrapper.wrapEmitLegacyError(loadRecord);

		function transformRecord(type, id, transformType, transformValues)
		{
			var options = {fromType: type, fromId: id, toType: transformType, defaultValues: transformValues};
			return nlobjRecordWrapper(getRecordImplModule().transform_raw(options), 'transformRecord', options);
		}
		this.transformRecord = nlobjErrorWrapper.wrapEmitLegacyError(transformRecord);

		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		function deleteRecord(type, id)
		{
			var options = {type: type, id: id};
			getRecordModule()['delete'](options);
		}
		this.deleteRecord = nlobjErrorWrapper.wrapEmitLegacyError(deleteRecord);

		function submitField(type, id, fields, values, doSourcing)
		{
			checkArgs([type, id, fields], ['type', 'id', 'fields'], 'nlapiSubmitField');

			try
			{
				var valuesObj = {};
				var flds = util.isArray(fields) ? fields : [fields];
				var vals = util.isArray(values) ? values : [values];
				for (var i = 0; i < flds.length; i++)
					valuesObj[flds[i]] = vals[i];
				var options = {type: type, id: id, values: valuesObj, enableSourcing: doSourcing};
				getRecordModule().submitFields(options);
			}
			catch(e)
			{
				throw nlobjErrorWrapper(utilityFunctions.getConstructorName(e) === 'SuiteScriptError' ? e : utilityFunctions.createSuiteScriptError(e));
			}
		}
		this.submitField = nlobjErrorWrapper.wrapEmitLegacyError(submitField);

		function attachRecord(type, id, type2, id2, attributes)
		{
			var options = {record: {type: type, id: id}, to: {type: type2, id: id2}, attributes: attributes};
			getRecordModule().attach(options);
		}
		this.attachRecord = nlobjErrorWrapper.wrapEmitLegacyError(attachRecord);

		function detachRecord(type, id, type2, id2, attributes)
		{
			var options = {record: {type: type, id: id}, from: {type: type2, id: id2}, attributes: attributes};
			getRecordModule().detach(options);
		}
		this.detachRecord = nlobjErrorWrapper.wrapEmitLegacyError(detachRecord);

		function submitRecord(nlobjRecord, options, ignoreMandatoryFields)
		{
			checkArgs([nlobjRecord], ['nlobjRecord'], 'nlapiSubmitRecord');

			if (runtime.getCurrentScript().getRemainingUsage() < 0)
				throwLegacyError('SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED', 'Script Execution Usage Limit Exceeded');

			if (utilityFunctions.getConstructorName(nlobjRecord) !== 'nlobjRecord')
				throwLegacyError('SSS_INVALID_RECORD_OBJ', 'The record is not a valid object.');

			try
			{
				var attributes = {
					'enableSourcing':  ""+(options === true || (!!options && options.enableSourcing === true)),
					'disableTriggers': ""+(!!options && options.disableTriggers === true),
					'ignoreMandatoryFields': ""+(ignoreMandatoryFields === true || (!!options && options.ignoreMandatoryFields === true))
				};

				var recordData = JSON.stringify({
					attributes: attributes,
					type: nlobjRecord.type,
					id: nlobjRecord.id,
					load: nlobjRecord.operations[0],
					operations: Array.prototype.slice.call(nlobjRecord.operations, 1)
				});

				var sKey = invoker(remoteApi, 'submitLegacyRecord', [recordData]);
				// TODO: check if need to charge usage
				//nlapiGetContext().setUsage('nlapiSubmitRecord', nlobjRecord.getRecordType());
				return sKey;
			}
			catch(e)
			{
				throw nlobjErrorWrapper(utilityFunctions.getConstructorName(e) === 'SuiteScriptError' ? e : utilityFunctions.createSuiteScriptError(e));
			}
		}
		this.submitRecord = nlobjErrorWrapper.wrapEmitLegacyError(submitRecord);

		return Object.freeze(this);
		/** END: Non-record functions */
	};

	var nlobjWrappers = Object.freeze({
		nlobjRecordWrapper:  nlobjRecordWrapper,
		nlobjSublistWrapper:  nlobjSublistWrapper,
		nlobjFieldWrapper: nlobjFieldWrapper,
		nlobjErrorWrapper: nlobjErrorWrapper
	});
	var nlobjGetters = Object.freeze({
		nlobjRecordGetter: nlobjRecordGetter,
		nlobjSublistGetter: nlobjSublistGetter,
		nlobjFieldGetter: nlobjFieldGetter,
		nlobjErrorGetter: nlobjErrorGetter
	});

	return {
		nonRecordV1Functions: new(nonRecordV1Functions),
		nlobjWrappers: nlobjWrappers,
		nlobjGetters: nlobjGetters
	};
});

/**
 * SuiteScript module that allows access to a record (or subrecord) in a v1 manner based on a v2 record.
 *
 * @private
 * @module N/record/recordImplV1Util
 * @suiteScriptVersion 2.x
 */

define('N/record/recordImplV1Util',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/restricted/invoker', 'N/restricted/remoteApiBridge', 'N/record/sublist', 'N/record/legacyNLObjects'],
	function(error, utilityFunctions, recordUtil, invoker, remoteApi, sublist, legacyNLObjects) {

		/**
		 * @param {Record} record
		 * @param {Object} subrecordControllerV1
		 * @constructor
		 */
		function RecordImplV1(record, subrecordControllerV1)
		{
			var undef = undefined;

			this.nonRecordV1Functions = legacyNLObjects.nonRecordV1Functions;
			this.nlobjects = {
				nlobjRecordWrapper: legacyNLObjects.nlobjWrappers.nlobjRecordWrapper,
				nlobjSublistWrapper:  legacyNLObjects.nlobjWrappers.nlobjSublistWrapper.bind(null, record),
				nlobjFieldWrapper: legacyNLObjects.nlobjWrappers.nlobjFieldWrapper.bind(null, record),
				nlobjErrorWrapper: legacyNLObjects.nlobjWrappers.nlobjErrorWrapper,

				nlobjRecordGetter: legacyNLObjects.nlobjGetters.nlobjRecordGetter,
				nlobjSublistGetter: legacyNLObjects.nlobjGetters.nlobjSublistGetter.bind(null, record),
				nlobjFieldGetter: legacyNLObjects.nlobjGetters.nlobjFieldGetter.bind(null, record),
				nlobjErrorGetter: legacyNLObjects.nlobjGetters.nlobjErrorGetter
			};

			var wrapEmitLegacyError = legacyNLObjects.nlobjWrappers.nlobjErrorWrapper.wrapEmitLegacyError;

			function getDelegate()
			{
				return record;
			}
			this.getDelegate = wrapEmitLegacyError(getDelegate);

			function getId()
			{
				return record.id;
			}
			this.getId = wrapEmitLegacyError(getId);

			function getRecordType()
			{
				return record.getRecordType();
			}
			this.getRecordType = wrapEmitLegacyError(getRecordType);

			function fixNullEmptyBug()
			{
				return true;
			}

			function removeField(fieldId)
			{
				return record.doRemoveField(fieldId);
			}
			this.removeField = wrapEmitLegacyError(removeField);

			function removeLineItemField(sublistId, fieldId, line_1)
			{
				//TODO missing in recordDefinition.js
			}
			this.removeLineItemField = wrapEmitLegacyError(removeLineItemField);

			function getFieldValue(fieldId)
			{
				var value;
				//get redirect
				var subrecordRedirect = record.getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(null, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						value = subrecord.getValueAsLegacyString(subrecordRedirect.fieldId);
					}
					else if (record.hasSubrecord(subrecordRedirect.subrecordFieldId))
					{
						subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
						value = subrecord.getValueAsLegacyString(subrecordRedirect.fieldId);
					}
					else
						value = "";
				}
				else
				{
					value = record.getValueAsLegacyString(fieldId);
					value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				}
				return value;
			}
			this.getFieldValue = wrapEmitLegacyError(getFieldValue);

			this.nlapiGetFieldValue = wrapEmitLegacyError(getFieldValue);

			function getFieldText(fieldId)
			{
				var returnText = "";
				var isMultiSelect = record.isFieldMultiSelect(null, fieldId);
				if (record.isFieldSelectType(null, fieldId) || isMultiSelect)
				{
					var value = record.getValue(fieldId);
					if (!utilityFunctions.isEmpty(value))
					{
						var isCommitted = false;
						returnText = record.doGetTextValueForSelectFieldForInstance(null, fieldId, value, null, isCommitted, isMultiSelect);
					}
				}
				return returnText;
			}
			this.getFieldText = wrapEmitLegacyError(getFieldText);

			function getFieldValues(fieldId)
			{
				var value = null;
				if (record.isFieldMultiSelect(null, fieldId))
				{
					value = record.getValueAsLegacyStringArray(fieldId);
					value = (value) ? value : (fixNullEmptyBug() ? [] : null);
				}

				return value;
			}
			this.getFieldValues = wrapEmitLegacyError(getFieldValues);

			function getFieldTexts(fieldId)
			{
				var value = null;
				if (record.isFieldMultiSelect(null, fieldId))
				{
					value = record.getText(fieldId);
					value = (value) ? value : (fixNullEmptyBug() ? [] : null);
				}
				return value;
			}
			this.getFieldTexts = wrapEmitLegacyError(getFieldTexts);

			function setFieldValue(fieldId, value, fireFieldChange, noSlaving)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;

				var subrecordRedirect = record.getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(null, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, noSlaving, !record.shouldValidateField());
					}

					subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
					subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, noSlaving, !record.shouldValidateField());
				}
				else
				{
					record.setFieldValue(fieldId, value, fireFieldChange, noSlaving, !record.shouldValidateField());
				}
			}
			this.setFieldValue = wrapEmitLegacyError(setFieldValue);

			function setFieldText(fieldId, text, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				record.setFieldtext(fieldId, text, fireFieldChange, !record.shouldValidateField());
			}
			this.setFieldText = wrapEmitLegacyError(setFieldText);

			function setFieldValues(fieldId, values, fireFieldChange, noSlaving)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;

				var subrecordRedirect = record.getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(null, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						subrecord.setFieldValues(subrecordRedirect.fieldId, values, fireFieldChange, noSlaving, !record.shouldValidateField());
					}

					subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
					subrecord.setFieldValues(subrecordRedirect.fieldId, values, fireFieldChange, noSlaving, !record.shouldValidateField());
				}
				else
				{
					record.setFieldValues(fieldId, values, fireFieldChange, noSlaving, !record.shouldValidateField());
				}
			}
			this.setFieldValues = wrapEmitLegacyError(setFieldValues);

			function setFieldTexts(fieldId, texts, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				record.setFieldTexts(fieldId, texts, fireFieldChange, !record.shouldValidateField());
			}this.setFieldTexts = wrapEmitLegacyError(setFieldTexts);

			function calculateGetDateTimeWithTimeZone(dateTime, timeZone)
			{
				var context = invoker(remoteApi, "nlapiGetContext", []);
				if (dateTime && context.getPreference("TIMEZONE") !== timeZone)
				{
					//noinspection JSUnresolvedVariable
					dateTime = invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [dateTime, timeZone]);
				}
				return dateTime;
			}

			function calculateSetDateTimeWithNewTimeZone(dateTime, timeZone)
			{
				var context = invoker(remoteApi, "nlapiGetContext", []);
				if (dateTime && context.getPreference("TIMEZONE") !== timeZone)
				{
					//noinspection JSUnresolvedVariable
					dateTime = invoker(remoteApi, 'calculateSetDateTimeWithNewTimeZone', [dateTime, timeZone]);
				}
				return dateTime;
			}

			function getDateTimeValue(fieldId, timezone)
			{
				var dateTime = getFieldValue(fieldId);
				return calculateGetDateTimeWithTimeZone(dateTime, timezone);
			}
			this.getDateTimeValue = wrapEmitLegacyError(getDateTimeValue);

			function setDateTimeValue(fieldId, value, timezone)
			{
				value = calculateSetDateTimeWithNewTimeZone(value, timezone);
				return setFieldValue(fieldId, value);
			}
			this.setDateTimeValue = wrapEmitLegacyError(setDateTimeValue);

			function _getSubrecordBackwardCompatibilityMap(sublistId)
			{
				return (record.getSublistMetadata(sublistId) || {}).backwardCompatibilityFieldNamesForSubrecord;
			}
			this._getSubrecordBackwardCompatibilityMap = wrapEmitLegacyError(_getSubrecordBackwardCompatibilityMap);

			function getLineItemValue(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var value;

				if ((record.getSublistFields(sublistId) || []).indexOf(fieldId) === -1)
				{
					var backwardCompatibilityMap = _getSubrecordBackwardCompatibilityMap(sublistId) || [];
					if (backwardCompatibilityMap.indexOf(fieldId) > -1)
						fieldId = fieldId + '_initialvalue';
				}
				value = record.getSublistLineValueAsLegacyString(sublistId, fieldId, line_0);

				value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				return value;
			}
			this.getLineItemValue = wrapEmitLegacyError(getLineItemValue);

			function getLineItemText(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var returnText = "";
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (record.isFieldMultiSelect(sublistId, fieldId))
					{
						var values = getLineItemTexts(sublistId, fieldId, line_0);
						returnText = values.join(",");
					}
					else
					{
						returnText = record.getSublistText(sublistId, fieldId, line_0);
					}
				}
				return returnText;
			}
			this.getLineItemText = wrapEmitLegacyError(getLineItemText);

			function getLineItemValues(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);

				var value = null;
				if(record.isFieldMultiSelect(sublistId, fieldId))
				{
					value = getLineItemValue(sublistId, fieldId, line_0);
					value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				}
				return value;
			}
			this.getLineItemValues = wrapEmitLegacyError(getLineItemValues);

			function getLineItemTexts(sublistId, fieldId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var texts = null;
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					texts = record.getSublistText(sublistId, fieldId, line_0);
					texts = (texts) ? texts : (fixNullEmptyBug() ? [] : null);
				}
				return texts;
			}
			this.getLineItemTexts = wrapEmitLegacyError(getLineItemTexts);

			function setLineItemValue(sublistId, fieldId, line_1, value)
			{
				if (record.isSublistValid(sublistId))
				{
					recordUtil.validateAgainstSqlInjection(fieldId, value);
					var line_0 = recordUtil.getZeroBasedIndex(line_1);
					// For list machine UI compatibility, autoset the current line whenever the line item value is set directly
					var autosetCurrentLine = record.isDynamic && record.doGetCurrentSublistIndex(sublistId) == line_1 && record.isSublistAListMachine(sublistId);

					var subrecordRedirect = record.getSubrecordRedirect(sublistId, fieldId);
					var subrecord;
					var fireFieldChange = false;

					value = recordUtil.emptyIfNullOrUndefined(value);
					if (record.getSublistMetadata(sublistId).displayOnly)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD, sublistId);

					/* Special case setting fields on the next line for edit machines and UI object list machines (backward compatiblity) */
					if (record.isSublistAnEditMachine(sublistId) && line_0 === record.getModelController().getNewLineIndex(sublistId))
						record.doInsertLine(sublistId, line_0);
					record.validateLineIndex_MLB(line_0, sublistId, true);

					if (!!subrecordRedirect)
					{
						subrecord = subrecordControllerV1.getUncommittedSubrecord(sublistId, subrecordRedirect.subrecordFieldId, line_0);
						if (!!subrecord)
						{
							subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());
						}

						subrecord = record.doGetSublistSubrecord(sublistId, subrecordRedirect.subrecordFieldId, line_0);
						subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());


						if (autosetCurrentLine)
						{
							subrecord = subrecordControllerV1.getUncommittedSubrecord(sublistId, subrecordRedirect.subrecordFieldId);
							if (!!subrecord)
							{
								subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());
							}

							var currentSubrecord = record.doGetCurrentSublistSubrecord(sublistId, subrecordRedirect.subrecordFieldId);
							currentSubrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());
						}
					}
					else
					{
						record.setLineItemValue(sublistId, fieldId, line_0, value, !record.shouldValidateField());
						// For list machine UI compatibility, autoset the current line whenever the line item value is set directly
						if (autosetCurrentLine)
							setCurrentLineItemValue(sublistId, fieldId, value, false);
					}
				}
			}
			this.setLineItemValue = wrapEmitLegacyError(setLineItemValue);


			function getCurrentLineItemValue(sublistId, fieldId)
			{
				var value;
				if ((record.getSublistFields(sublistId) || []).indexOf(fieldId) === -1)
				{
					var backwardCompatibilityMap = ((record.getSublistMetadata(sublistId) || {}).backwardCompatibilityFieldNamesForSubrecord || []);
					if (backwardCompatibilityMap.indexOf(fieldId) > -1)
						fieldId = fieldId + '_initialvalue';
				}
				value = record.getCurrentSublistLineValueAsLegacyString(sublistId, fieldId);
				value = recordUtil.emptyIfNullOrUndefined(value);
				return value;
			}
			this.getCurrentLineItemValue = wrapEmitLegacyError(getCurrentLineItemValue);

			function getCurrentLineItemText(sublistId, fieldId)
			{
				var returnText = "";
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (record.isFieldMultiSelect(sublistId, fieldId))
					{
						var values = getCurrentLineItemTexts(sublistId, fieldId);
						returnText = values.join(",");
					}
					else
					{
						returnText = record.getCurrentSublistText(sublistId, fieldId);
					}
				}
				return returnText;
			}
			this.getCurrentLineItemText = wrapEmitLegacyError(getCurrentLineItemText);

			function getCurrentLineItemValues(sublistId, fieldId)
			{
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					var value = getCurrentLineItemValue(sublistId, fieldId);
					return recordUtil.formatValueToArrayType(value);
				}
			}
			this.getCurrentLineItemValues = wrapEmitLegacyError(getCurrentLineItemValues);

			function getCurrentLineItemTexts(sublistId, fieldId)
			{
				var texts = null;
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					texts = record.getCurrentSublistText(sublistId, fieldId);
					texts = (texts) ? texts : (fixNullEmptyBug() ? [] : null);
				}
				return texts;
			}
			this.getCurrentLineItemTexts = wrapEmitLegacyError(getCurrentLineItemTexts);

			function setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				var subrecordRedirect = record.getSubrecordRedirect(sublistId, fieldId);
				if (!!subrecordRedirect)
				{
					var subrecord = subrecordControllerV1.getUncommittedSubrecord(sublistId, subrecordRedirect.subrecordFieldId, -1);
					if (!!subrecord)
					{
						subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());
					}

					subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId);
					subrecord.setFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());
				}
				else
				{
					record.setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange, undefined, !record.shouldValidateField());
				}
			}
			this.setCurrentLineItemValue = wrapEmitLegacyError(setCurrentLineItemValue);

			function setCurrentLineItemValues(sublistId, fieldId, values, fireFieldChange)
			{
				setCurrentLineItemValue(sublistId, fieldId, values != null ? values.join(String.fromCharCode(5)) : "", fireFieldChange);
			}
			this.setCurrentLineItemValues = wrapEmitLegacyError(setCurrentLineItemValues);

			function setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				record.setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange, !record.shouldValidateField())
			}
			this.setCurrentLineItemText = wrapEmitLegacyError(setCurrentLineItemText);


			function getCurrentLineItemDateTimeValue(sublistId, fieldId, timeZone)
			{
				var dateTime = getCurrentLineItemValue(sublistId, fieldId);
				return calculateGetDateTimeWithTimeZone(dateTime, timeZone);
			}
			this.getCurrentLineItemDateTimeValue = wrapEmitLegacyError(getCurrentLineItemDateTimeValue);

			function setCurrentLineItemDateTimeValue(sublistId, fieldId, dateTime, timeZone)
			{
				dateTime = calculateSetDateTimeWithNewTimeZone(dateTime, timeZone);
				return setCurrentLineItemValue(sublistId, fieldId, dateTime);
			}
			this.setCurrentLineItemDateTimeValue = wrapEmitLegacyError(setCurrentLineItemDateTimeValue);

			function getLineItemDateTimeValue(sublistId, fieldId, line, timeZone)
			{
				var dateTime = getLineItemValue(sublistId, fieldId, line);
				return calculateGetDateTimeWithTimeZone(dateTime, timeZone);
			}
			this.getLineItemDateTimeValue = wrapEmitLegacyError(getLineItemDateTimeValue);

			function setLineItemDateTimeValue(sublistId, fieldId, lineNum, dateTime, timeZone)
			{
				dateTime = calculateSetDateTimeWithNewTimeZone(dateTime, timeZone);
				return setLineItemValue(sublistId, fieldId, lineNum, dateTime);
			}
			this.setLineItemDateTimeValue = wrapEmitLegacyError(setLineItemDateTimeValue);

			function getCurrentLineItemIndex(sublistId)
			{
				return recordUtil.getOneBasedIndex(record.doGetCurrentSublistIndex(sublistId));
			}
			this.getCurrentLineItemIndex = wrapEmitLegacyError(getCurrentLineItemIndex);

			function lineItemIsChanged(type) {
				var isCommitted = false;
				var isChanged = false;
				var line = record.doGetCurrentSublistIndex(type);
				(record.getSublistFields(type) || []).forEach(function (fld) {
					isChanged |= record.getSublistFieldState(type, fld, line, isCommitted).isChanged;
				});
				return !!isChanged;
			}
			this.lineItemIsChanged = wrapEmitLegacyError(lineItemIsChanged);

			function getSublistType(sublistId) {
				return record.getSublistType(sublistId);
			}
			this.getSublistType = wrapEmitLegacyError(getSublistType);

			function getV1Sublist(sublistId)
			{
				var sublistLevelMetadata = record.getSublistMetadata(sublistId);
				return (sublistLevelMetadata != null) ? sublist.newInstanceOfV1Sublist({
					type: sublistLevelMetadata.nlobjSublistConstructorType,
					sublistState: record.getSublistState(sublistId),
					sublistFields: sublistLevelMetadata.fieldMetadata
				}) : null;
			}
			this.getV1Sublist = wrapEmitLegacyError(getV1Sublist);

			function getSublist(sublistId)
			{
				return getV1Sublist(sublistId);
			}
			this.getSublist = wrapEmitLegacyError(getSublist);

			function getLineItemCount(sublistId)
			{
				return record.doGetLineCount(sublistId);
			}
			this.getLineItemCount = wrapEmitLegacyError(getLineItemCount);

			function findLineItemValue(sublistId, fieldId, value)
			{
				var index = record.doFindSublistLineWithValue(sublistId, fieldId, value);
				return recordUtil.getOneBasedIndex(index);
			}
			this.findLineItemValue = wrapEmitLegacyError(findLineItemValue);

			function findLineItemMatrixValue(options, fieldId, column_1, value)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var index = record.findMatrixSublistLineWithValue(options, fieldId, column_0, value);
				return recordUtil.getOneBasedIndex(index);
			}
			this.findLineItemMatrixValue = wrapEmitLegacyError(findLineItemMatrixValue);

			function getMatrixField(options, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getMatrixHeaderField(options, fieldId, column_0);
			}
			this.getMatrixField = wrapEmitLegacyError(getMatrixField);

			function getMatrixCount(options, fieldId)
			{
				return record.getMatrixHeaderCount(options, fieldId);
			}
			this.getMatrixCount = wrapEmitLegacyError(getMatrixCount);

			function getMatrixValue(options, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getMatrixHeaderValue(options, fieldId, column_0);
			}
			this.getMatrixValue = wrapEmitLegacyError(getMatrixValue);

			function setMatrixValue(options, fieldId, column_1, value, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.setMatrixHeaderValue(options, fieldId, column_0, value, !fireFieldChange);
			}
			this.setMatrixValue = wrapEmitLegacyError(setMatrixValue);


			function getLineItemMatrixField(sublistId, fieldId, line_1, column_1)
			{
				if(!column_1)
				{
					column_1 = line_1;
					line_1 = -1;
				}
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.getMatrixSublistField(sublistId, fieldId, line_0, column_0);
			}
			this.getLineItemMatrixField = wrapEmitLegacyError(getLineItemMatrixField);

			function getLineItemMatrixValue(sublistId, fieldId, line_1, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.getMatrixSublistValue(sublistId, fieldId, line_0, column_0);
			}
			this.getLineItemMatrixValue = wrapEmitLegacyError(getLineItemMatrixValue);

			function setLineItemMatrixValue(sublistId, fieldId, line_1, column_1, value)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.setMatrixSublistValue(sublistId, fieldId, line_0, column_0, value);
			}
			this.setLineItemMatrixValue = wrapEmitLegacyError(setLineItemMatrixValue);

			function getCurrentLineItemMatrixValue(sublistId, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getCurrentMatrixSublistValue(sublistId, fieldId, column_0);
			}
			this.getCurrentLineItemMatrixValue = wrapEmitLegacyError(getCurrentLineItemMatrixValue);

			function setCurrentLineItemMatrixValue(sublistId, fieldId, column_1, value, fireFieldChange)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				return record.setCurrentMatrixSublistValue(sublistId, fieldId, column_0, value, !fireFieldChange);
			}
			this.setCurrentLineItemMatrixValue = wrapEmitLegacyError(setCurrentLineItemMatrixValue);

			function selectNewLineItem(sublistId, ignoreLineInit)
			{
				var lineObj = record.doSelectNewLine(sublistId, ignoreLineInit);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
				return lineObj;
			}
			this.selectNewLineItem = wrapEmitLegacyError(selectNewLineItem);

			function selectLineItem(sublistId, line_1)
			{
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				var lineObj = record.doSelectLine(sublistId, line_0);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
				return lineObj;
			}
			this.selectLineItem = wrapEmitLegacyError(selectLineItem);

			function insertLineItem(sublistId, line_1, ignoreRecalc)
			{
				if(!line_1)
				{
					line_1 = getCurrentLineItemIndex(sublistId);
				}
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				record.doInsertLine(sublistId, line_0, ignoreRecalc);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}
			this.insertLineItem = wrapEmitLegacyError(insertLineItem);

			function removeLineItem(sublistId, line_1, ignoreRecalc)
			{
				if(!line_1)
				{
					line_1 = getCurrentLineItemIndex(sublistId);
				}
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				record.doRemoveLine(sublistId, line_0, ignoreRecalc, !record.shouldValidateField());
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}
			this.removeLineItem = wrapEmitLegacyError(removeLineItem);

			function cancelLineItem(sublistId)
			{
				record.doCancelLine(sublistId);
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}
			this.cancelLineItem = wrapEmitLegacyError(cancelLineItem);

			function commitLineItem(sublistId, ignoreRecalc)
			{
				record.doCommitLine(sublistId, ignoreRecalc);
				var sublistState = record.getSublistState(sublistId);
				if (!sublistState.allowsNewLine)
					sublistState.resetCurrentLineState(record.getCurrentSublistIndex(sublistId));
				subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);

			}
			this.commitLineItem = wrapEmitLegacyError(commitLineItem);

			function doInsertSelectOption(fld, value, text, selected, isColumnOption)
			{
				try
				{
					fld.insertSelectOption(value, text, selected, isColumnOption);
				}
				catch (e)
				{
					if (e.name !== error.Type.SELECT_OPTION_ALREADY_PRESENT)
						throw e;
				}
			}

			function doRemoveSelectOption(fld, value, isColumnOption)
			{
				try
				{
					fld.removeSelectOption(value, isColumnOption);
				}
				catch (e)
				{
					if (e.name !== error.Type.SELECT_OPTION_NOT_FOUND)
						throw e;
				}
			}

			function insertLineItemOption(type, fldnam, value, text, selected)
			{
				utilityFunctions.assertTrue(type != null && fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getLineItemField(type, fldnam);
				if (fld && fld.hasOwnProperty('insertSelectOption') && !fld.isPopup())
					doInsertSelectOption(fld, value, text, selected, true);
			}
			this.insertLineItemOption = wrapEmitLegacyError(insertLineItemOption);

			function removeLineItemOption(type, fldnam, value)
			{
				utilityFunctions.assertTrue(type != null && fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getLineItemField(type, fldnam);
				if (fld && fld.hasOwnProperty('removeSelectOption') && !fld.isPopup())
				{
					if (value != null)
						doRemoveSelectOption(fld, value, true);
					else // remove all options
						(fld.getSelectOptions() || []).forEach(function (selectOption) {doRemoveSelectOption(fld, selectOption.getId(), true)});
				}
			}
			this.removeLineItemOption = wrapEmitLegacyError(removeLineItemOption);

			function insertSelectOption(fldnam, value, text, selected)
			{
				utilityFunctions.assertTrue(fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getField(fldnam);
				if (fld && fld.hasOwnProperty('insertSelectOption') && !fld.isPopup())
					doInsertSelectOption(fld, value, text, selected);
			}
			this.insertSelectOption = wrapEmitLegacyError(insertSelectOption);

			function removeSelectOption(fldnam, value)
			{
				utilityFunctions.assertTrue(fldnam != null && fldnam.indexOf('custpage') == 0, 'SSS_INVALID_OPERATION');
				var fld = getField(fldnam);
				if (fld && fld.hasOwnProperty('removeSelectOption') && !fld.isPopup())
				{
					if (value != null)
						doRemoveSelectOption(fld, value);
					else // remove all options
						(fld.getSelectOptions() || []).forEach(function (selectOption) {doRemoveSelectOption(fld, selectOption.getId())});
				}
			}
			this.removeSelectOption = wrapEmitLegacyError(removeSelectOption);

			function getField(fieldId)
			{
				var sublistId = undef;
				var lineInstanceId = null;
				var isCommitted = true;
				return record.getCachedRecordField(sublistId, fieldId, lineInstanceId, isCommitted);
			}
			this.getField = wrapEmitLegacyError(getField);

			function getLineItemField(sublistId, fieldId, line_1)
			{
				var line_0;
				if (line_1 === undef || line_1 === -1)
					line_0 = record.getCurrentSublistIndex(sublistId);
				else
					line_0 = recordUtil.getZeroBasedIndex(line_1);
				var isCommitted = !(line_0 === record.getCurrentSublistIndex(sublistId));
				return (line_0 === -1) ? undef : record.getCachedRecordField(sublistId, fieldId, line_0, isCommitted);
			}
			this.getLineItemField = wrapEmitLegacyError(getLineItemField);

			function getAllSublists()
			{
				return record.getSublists()
			}
			this.getAllSublists = wrapEmitLegacyError(getAllSublists);

			function getAllFields()
			{
				return record.getFields();
			}
			this.getAllFields = wrapEmitLegacyError(getAllFields);

			function getAllLineItemFields(sublistId)
			{
				return record.getSublistFields(sublistId);
			}
			this.getAllLineItemFields = wrapEmitLegacyError(getAllLineItemFields);

			function isDynamic()
			{
				return record.isDynamic;
			}
			this.isDynamic = wrapEmitLegacyError(isDynamic);

			function isChanged()
			{
				return record.isChanged();
			}
			this.isChanged = wrapEmitLegacyError(isChanged);

			function isInternal()
			{
				return record.isInternal();
			}
			this.isInternal = wrapEmitLegacyError(isInternal);

			function getFieldDisabled(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isDisabled();
			}
			this.getFieldDisabled = wrapEmitLegacyError(getFieldDisabled);

			function setFieldDisabled(fieldId, disable)
			{
				var field = getField(fieldId);
				if (field)
					field.setDisabled(disable);
			}
			this.setFieldDisabled = wrapEmitLegacyError(setFieldDisabled);

			function getFieldMandatory(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isMandatory();
			}
			this.getFieldMandatory = wrapEmitLegacyError(getFieldMandatory);

			function setFieldMandatory(fieldId, mandatory)
			{
				var field = getField(fieldId);
				if (field)
					field.setMandatory(mandatory);
			}
			this.setFieldMandatory = wrapEmitLegacyError(setFieldMandatory);

			function getFieldDisplay(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isDisplay();
			}
			this.getFieldDisplay = wrapEmitLegacyError(getFieldDisplay);

			function setFieldDisplay(fieldId, display)
			{
				var field = getField(fieldId);
				if (field)
					field.setDisplay(display);
			}
			this.setFieldDisplay = wrapEmitLegacyError(setFieldDisplay);

			function getFieldVisibility(fieldId, visible)
			{
				var field = getField(fieldId);
				if (field)
					return field.isVisible(visible);
			}
			this.getFieldVisibility = wrapEmitLegacyError(getFieldVisibility);

			function setFieldVisibility(fieldId, visible)
			{
				var field = getField(fieldId);
				if (field)
					field.setVisible(visible);
			}
			this.setFieldVisibility = wrapEmitLegacyError(setFieldVisibility);

			function getFieldReadOnly(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isReadOnly();
			}
			this.getFieldReadOnly = wrapEmitLegacyError(getFieldReadOnly);

			function setFieldReadOnly(fieldId, readonly)
			{
				var field = getField(fieldId);
				if (field)
					field.setReadOnly(readonly);
			}
			this.setFieldReadOnly = wrapEmitLegacyError(setFieldReadOnly);

			function getFieldLabel(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.getLabel();
			}
			this.getFieldLabel = wrapEmitLegacyError(getFieldLabel);

			function setFieldLabel(fieldId, label)
			{
				var field = getField(fieldId);
				if (field)
					field.setLabel(label);
			}
			this.setFieldLabel = wrapEmitLegacyError(setFieldLabel);

			function getLineItemDisplay(sublistId)
			{
				var sublistState = record.getSublistState(sublistId);
				return (sublistState) ? sublistState.isDisplay : false;
			}
			this.getLineItemDisplay = wrapEmitLegacyError(getLineItemDisplay);

			function setLineItemDisplay(sublistId, display)
			{
				var sublistState = record.getSublistState(sublistId);
				if (sublistState)
					sublistState.isDisplay = display;
			}
			this.setLineItemDisplay = wrapEmitLegacyError(setLineItemDisplay);

			function doGetSublistFieldState(sublistId, fieldId, line_1)
			{
				var lineInstanceId;
				var isCommitted = true;
				if (record.isSublistAnEditMachine(sublistId))
				{
					isCommitted = false;
					lineInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				}
				else
				{
					var line_0 = recordUtil.getZeroBasedIndex(line_1);
					line_0 = isNaN(line_0) ? record.doGetCurrentSublistIndex(sublistId) : line_0;
					isCommitted = !(line_0 === record.doGetCurrentSublistIndex(sublistId));
					lineInstanceId = record.getModelController().getSublistLineInstanceIdForLine(sublistId, line_0, isCommitted)
				}

				if (lineInstanceId === null && record.isMultilineEditable(sublistId))
					return null;
				else
					return record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function getLineItemDisabled(sublistId, fieldId, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				return (fieldState) ? fieldState.isDisabled : false;
			}
			this.getLineItemDisabled = wrapEmitLegacyError(getLineItemDisabled);

			function setLineItemDisabled(sublistId, fieldId, disabled, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				if (fieldState)
					fieldState.isDisabled = disabled;
			}
			this.setLineItemDisabled = wrapEmitLegacyError(setLineItemDisabled);

			function getLineItemMandatory(sublistId, fieldId, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				return (fieldState) ? fieldState.isMandatory : false;
			}
			this.getLineItemMandatory = wrapEmitLegacyError(getLineItemMandatory);

			function setLineItemMandatory(sublistId, fieldId, mandatory, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				if (fieldState)
					fieldState.isMandatory = mandatory;
			}
			this.setLineItemMandatory = wrapEmitLegacyError(setLineItemMandatory);

			function getLineItemLabel(sublistId, fieldId)
			{
				var isCommitted = false;
				var field = record.getCachedRecordField(sublistId, fieldId, record.doGetCurrentSublistIndex(sublistId), isCommitted);
				return field ? field.getLabel() : null;
			}
			this.getLineItemLabel = wrapEmitLegacyError(getLineItemLabel);

			function setLineItemLabel(sublistId, fieldId, label)
			{
				var isCommitted = false;
				var field = record.getCachedRecordField(sublistId, fieldId, record.doGetCurrentSublistIndex(sublistId), isCommitted);
				if (field)
					field.setLabel(label);
			}
			this.setLineItemLabel = wrapEmitLegacyError(setLineItemLabel);

			function handleChangeCall(params)
			{
				record.handleChangeCall(params);
				invalidateSubrecordCacheForV1RecordScope();
			}
			this.handleChangeCall = wrapEmitLegacyError(handleChangeCall);

			function triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving)
			{
				record.triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving);
			}
			this.triggerFieldChangeEvent = wrapEmitLegacyError(triggerFieldChangeEvent);

			function doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField)
			{
				record.doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField);
			}
			this.doSlaving = wrapEmitLegacyError(doSlaving);

			function invalidateSubrecordCacheForV1RecordScope()
			{
				subrecordControllerV1.invalidateSubrecordCacheForV1RecordScope();
			}
		}

		function create(record, subrecordControllerV1){
			return new RecordImplV1(record, subrecordControllerV1);
		}

		return { create: create };
	});

/**
 * SuiteScript module that adds the subrecord accessors to be accessed in a v1 manner based on a v2 record.
 *
 * @private
 * @module N/record/subrecordImplV1Util
 * @suiteScriptVersion 2.x
 */


define('N/record/subrecordImplV1Util',['N/record/recordUtilityFunctions', 'N/record/recordImplV1Util'],
	function(recordUtil, recordImplV1Util){

		// there is no support for a subrecord within a subrecord, so we don't extend this with subrecord functions.
		function wrappedV1Subrecord(proxiedRecord)
		{
			return !!proxiedRecord ? recordImplV1Util.create(proxiedRecord) : null;
		}

		function createCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.createCurrentLineItemSubrecord(sublistId, fieldId));
		}

		function editCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.editCurrentLineItemSubrecord(sublistId, fieldId));
		}

		function removeCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.removeCurrentLineItemSubrecord(sublistId, fieldId));
		}

		function viewCurrentLineItemSubrecord(subrecordControllerV1, sublistId, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.viewCurrentLineItemSubrecord(sublistId, fieldId));
		}

		function viewLineItemSubrecord(subrecordControllerV1, sublistId, fieldId, line_1)
		{
			var line_0 = recordUtil.getZeroBasedIndex(line_1);
			return wrappedV1Subrecord(subrecordControllerV1.viewLineItemSubrecord(sublistId, fieldId, line_0));
		}

		function createSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.createSubrecord(fieldId));
		}

		function editSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.editSubrecord(fieldId));
		}

		function viewSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.viewSubrecord(fieldId));
		}

		function removeSubrecord(subrecordControllerV1, fieldId)
		{
			return wrappedV1Subrecord(subrecordControllerV1.removeSubrecord(fieldId));
		}

		function commit(subrecordControllerV1, subrecordToCommit)
		{
			return wrappedV1Subrecord(subrecordControllerV1.commit(subrecordToCommit));
		}

		function invalidateSubrecordCacheEntry(subrecordControllerV1, sublistId, fieldId, line_0)
		{
			subrecordControllerV1.invalidateSubrecordCacheEntry(sublistId, fieldId, line_0);
		}

		function insertLineForSubrecordCache(subrecordControllerV1, sublistId, line)
		{
			subrecordControllerV1.insertLineForSubrecordCache(sublistId, line);
		}

		function removeLineForSubrecordCache(subrecordControllerV1, sublistId, line)
		{
			subrecordControllerV1.removeLineForSubrecordCache(sublistId, line);
		}

		function invalidateCurrentSublistLineForSubrecordCache(subrecordControllerV1, sublistId)
		{
			subrecordControllerV1.invalidateCurrentSublistLineForSubrecordCache(sublistId);
		}

		//TODO: cancel

		function extendWithSubrecord(recordObject, subrecordV1)
		{
			if (!!recordObject)
			{			
				recordObject.commit = commit.bind(null, subrecordV1);
				recordObject.createCurrentLineItemSubrecord = createCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.createSubrecord = createSubrecord.bind(null, subrecordV1);
				recordObject.editCurrentLineItemSubrecord = editCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.editSubrecord = editSubrecord.bind(null, subrecordV1);
				recordObject.insertLineForSubrecordCache = insertLineForSubrecordCache.bind(null, subrecordV1);
				recordObject.invalidateCurrentSublistLineForSubrecordCache = invalidateCurrentSublistLineForSubrecordCache.bind(null, subrecordV1);
				recordObject.invalidateSubrecordCacheEntry = invalidateSubrecordCacheEntry.bind(null, subrecordV1);
				recordObject.removeCurrentLineItemSubrecord = removeCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.removeLineForSubrecordCache = removeLineForSubrecordCache.bind(null, subrecordV1);
				recordObject.removeSubrecord = removeSubrecord.bind(null, subrecordV1);
				recordObject.viewCurrentLineItemSubrecord = viewCurrentLineItemSubrecord.bind(null, subrecordV1);
				recordObject.viewLineItemSubrecord = viewLineItemSubrecord.bind(null, subrecordV1);
				recordObject.viewSubrecord = viewSubrecord.bind(null, subrecordV1);
			}
			return recordObject;
		}
		
		return { extendWithSubrecord : extendWithSubrecord }
	});

/**
 * SuiteScript record implementation for version one based on version 2 record
 *
 * @private
 * @module N/record/recordImplV1
 * @NApiVersion 2.x
 *
 */
define('N/record/recordImplV1',['N/record/subrecordController', 'N/record/recordImplV1Util', 'N/record/subrecordImplV1Util'],
       function(subrecordController, recordImplV1Util, subrecordImplV1Util){

    function create(options){
	    var record = options.record;
	    var subrecordControllerV1 = subrecordController.create(record);
        var v1RecordObj = recordImplV1Util.create(record, subrecordControllerV1);
	    return subrecordImplV1Util.extendWithSubrecord(v1RecordObj, subrecordControllerV1);
    }

    return { create: create };
});

/**
 * SuiteScript scope
 *
 * @private
 * @module N/scope
 * @NApiVersion 2.x
 *
 */
define('N/scope',[], function(){
    var blacklist = ['blacklist'];

    // HIDE SCOPE loadCallback
    blacklist = blacklist.concat('error', 'parent', 'responseObj', 'scriptInfo');

    // HIDE SCOPE require.load
    blacklist = blacklist.concat('argList', 'context', 'getParentPath', 'loadCallback', 'method', 'moduleName',
        'pageMode', 'parentMap', 'parentPath', 'recordType', 'url');

    // HIDE SCOPE undefined
    blacklist = blacklist.concat('SuiteScriptModuleLoaderError', 'addModuleNameToDefineModuleList', 'define',
        'dependencyCheck', 'doLogExecution', 'forceSync', 'global', 'internals', 'isApiPath', 'isFilePathLike',
        'isModuleNameAlreadyDefined', 'log', 'makeServerCall', 'namesOfDefinedModules', 'old_define', 'p', 'require',
        'requirejs', 'serverCallAsync', 'serverCallSync', 'stripApiPath', 'toEmptyString', 'util');

    // HIDE SCOPE undefined
    blacklist = blacklist.concat('callURL', 'createNode', 'getGlobalScope', 'legacyCallURL', 'nlRequestId', 'nlapi');

    return function(){
        eval(function(blacklist){
            return !!blacklist && blacklist.map(function(v){ return 'var ' + v + ' = undefined;' ;}).join('');
        }.bind(null, blacklist)());

        eval(function(blacklist){
            return !!blacklist && blacklist.map(function(v){ return 'var ' + v + ' = undefined;' ;}).join('');
        }.bind(null, arguments[0] && arguments[0].blacklist)());

        eval(function(whitelist){
            return !!whitelist && Object.keys(whitelist).map(function(v){
                    return 'var ' + v + ' = arguments[0].whitelist["' + v + '"];';
                }).join('');
        }.bind(null, arguments[0] && arguments[0].whitelist)());

        eval(function(libraries){
            return !!libraries && libraries.join(';');
        }.bind(null, arguments[0] && arguments[0].libraries)());

        return function(){
            return eval(arguments[0]);
        };
    };
});

(function () {
var _NS_define = define;
/**
 * Loader for V2.x scripts
 *
 * @private
 * @module N/scriptLoader
 * @NApiVersion 2.x
 */
define('N/scriptLoader',[], function () {
	var inEmulatedTestEnvironment = typeof globalTestExposures !== 'undefined';

	function getEntryPointRequire(config) {
		var configuredRequire = require.config(config);

		var retrievalId = String.fromCharCode(95, 36, 89, 36);
		_NS_define(retrievalId, ["require"], function (sysRequire) { return sysRequire; });
		configuredRequire([retrievalId], function () {});

		return function entryPointRequire(deps, callback) {
			return configuredRequire([retrievalId], function (systemRequire) {
				return systemRequire(deps, callback);
			});
		};
	}

	function v2ScriptLoader(systemId, moduleObject, loadCallback) {

		var script =  moduleObject.script;

		var rConfig = JSON.parse(script.amdConfig);
		rConfig["context"] = script.scriptInfo;
		if (systemId && !inEmulatedTestEnvironment) {
			rConfig["context"] = String(systemId + ':' + rConfig["context"]);
		}

		// we need to tell NsRequire to shield the client scripts from using some of our internal stuff
		rConfig["shieldV2Callback"] = false;
		// we need to extend the config with the parent path since this is
		// the only way how to make this work in NEW UI
		// see FormScriptMetadataFactory for cases when the parent path is set
		if (script.parentModulePath)
			rConfig["parentModulePath"] = script.parentModulePath;

		var entryPointRequire = getEntryPointRequire(rConfig);

		entryPointRequire([script.scriptInfo], function (handler) {
			moduleObject.load(handler);
			if (util.isFunction(loadCallback)) {
				loadCallback();
			}
		});
	}

	/**
	 * Object describing the client script
	 *
	 * @public
	 * @param {Object} options
	 * @param {Function} options.script - script info for the client script
	 * @param {String} [options.enabled]
	 * @param {Number} [options.localizationScriptLimit]
	 * @constructor
	 */
	function ModuleDescriptor(options) {

		var that = this;

		if (!util.isObject(options) || !options || !util.isObject(options.script))
			throw "Error need init object with script";

		var moduleObject = {
			'script': options.script,
			'handler': null,
			'enabled': false,
			'active': false,
			'loaded': false,
			'locale': undefined,
			'localized': false
		};
		var readonly = ['script', 'locale', 'localized'];
		var internal = ['handler'];

		if (options.script.locale && util.isString(options.script.locale)) {
			var _locale = options.script.locale.split(',');
			if (_locale[0]) {
				moduleObject.locale = _locale;
				moduleObject.localized = true;
			}
		}

		// generate property getters for general use
		Object.getOwnPropertyNames(moduleObject).forEach(function(prop) {
			if (internal.indexOf(prop)!==-1)
				return;
			Object.defineProperty(that, prop, {
				get: function () { return moduleObject[prop] },
				set: function () { throw "Cannot set " + prop; },
				configurable: false
			});
		});
		Object.defineProperty(this, 'triggers', {
			get: function () { return Object.getOwnPropertyNames(moduleObject.handler || {}).filter(function(name) { return util.isFunction(name); }); },
			set: function () { throw "Cannot set triggers"; },
			configurable: false
		});

		this.getTrigger = function getTrigger(trigger) {
			return moduleObject.handler ? moduleObject.handler[trigger] : undefined;
		};
		/**
		 * Check whether module's locale matches the input locale
		 * @param locale {String|Array} locales to match with module's locale
		 * @return {boolean} true iff module is localized and matches at least one of the input locales
		 */
		this.hasLocale = function hasLocale(locale) {
			if (!moduleObject.locale || !locale)
				return false;
			var locales = util.isArray(locale) ? locale : [locale];
			return locales.filter(function (locale) { return moduleObject.locale.indexOf(locale) !== -1 }).length > 0;
		};
		this.enable = function enable() {
			moduleObject.enabled = true;
		};
		this.disable = function disable() {
			moduleObject.enabled = false;
		};
		this.activate = function activate() {
			moduleObject.active = true;
		};
		this.deactivate = function deactivate() {
			// need to clear both active and enabled
			moduleObject.active = false;
			moduleObject.enabled = false;
		};
		this.load = function load(handler) {
			moduleObject.handler = handler;
			moduleObject.loaded = true;
			moduleObject.active = !moduleObject.localized;
		};
		this.update = function update(dataObject) {
			if (!dataObject)
				return;
			Object.getOwnPropertyNames(dataObject).forEach(function (prop) {
				if (readonly.indexOf(prop) === -1 && moduleObject.hasOwnProperty(prop))
					moduleObject[prop] = dataObject[prop];
			});
		};

		this.shouldExecuteTrigger = function shouldExecuteTrigger(locale, trigger)
		{
			if (!moduleObject.enabled)
				return false;
			if (!moduleObject.loaded) {
				console.warn("This state shouldn't happen.  Locale: " + locale + ", module: " + JSON.stringify(that));
				return false;
			}
			var isActive = moduleObject.active;
			var isLocalized = moduleObject.localized;
			var isCorrectLocale = that.hasLocale(locale);
			var shouldExecute = false;
			if  (trigger === "pageInit") {
				shouldExecute = !isLocalized && isActive;
			}
			else if (trigger === "localizationContextEnter") {
				shouldExecute = isLocalized && isCorrectLocale && !isActive; // run for all locale scripts with correct locale
			}
			else if (trigger === "localizationContextExit") {
				shouldExecute = isLocalized && !isCorrectLocale && isActive; // run for all locale scripts with incorrect locale
			}
			else {
				shouldExecute = isActive;
			}
			return shouldExecute;
		};

		this.toJSON = function toJSON() {
			var jsonObj = {};
			Object.getOwnPropertyNames(that).forEach(function(prop) {
				if (!util.isFunction(prop))
					jsonObj[prop] = that[prop];
			});
			return jsonObj;
		};

		Object.freeze(this);
		return this;
	}

	/**
	 * Object holding all clients script handlers to be executed.
	 *
	 * @public
	 * @param {Object} options
	 * @param {Array} options.scriptList
	 * @param {String} [options.systemId]
	 * @param {Number} [options.localizationScriptLimit]
	 * @constructor
	 */
	function ModuleKeeper(options) {
		if (!options || !util.isArray(options.scriptList))
			throw "Invalid argument options: " + options;

		var systemId = options.systemId;
		var localizationScriptLimit = options.localizationScriptLimit;
		var scriptList = options.scriptList;
		var modules = {}; // set of unique modules
		var scriptKeys = []; // array of all script keys in order

		scriptList.forEach(function(script) {
			if (util.isObject(script)) {
				var key = getScriptKey(script);
				scriptKeys.push(key);
				if (!getModuleObject(key)) {
					modules[key] = new ModuleDescriptor({script: script});
				}
			}
		});

		function loadModule(moduleObject, locale, callback) {
			var script = moduleObject.script;
			var wasEnabled = moduleObject.enabled;
			shouldEnableModuleForLocale(moduleObject, locale) ? moduleObject.enable() : moduleObject.disable();
			if (!wasEnabled && moduleObject.enabled) {
				if (isLegacySS(script)) {
					var handler = {};
					if (script.scriptInfo && util.isString(script.scriptInfo))
						handler = JSON.parse(script.scriptInfo);
					if (script.scriptInfo && util.isObject(script.scriptInfo))
						handler = script.scriptInfo;
					moduleObject.load(handler);
				} else {
					if (!moduleObject.loaded)
						v2ScriptLoader(systemId, moduleObject, callback);  // do the actual asynchronous loading
				}
			} else {
				if (!moduleObject.enabled && moduleObject.active)
					throw "This state shouldn't happen.  Locale: " + locale + ", module: " + JSON.stringify(moduleObject);
			}
		}

		function isLegacySS(script)
		{
			return !script.version || script.version === '1.0';
		}

		function shouldEnableModuleForLocale(moduleObject, locale)
		{
			return isWithinLimit(moduleObject.script) && (isLegacySS(moduleObject.script) || !moduleObject.localized || (moduleObject.hasLocale(locale)));
		}

		function isWithinLimit(module)
		{
			if (module.localized)
				return !util.isNumber(localizationScriptLimit) || modules.filter(function (module) { return module.localized && module.enabled; }).length <= localizationScriptLimit;
			return true;
		}

		function doLoadModules(locale, callback)
		{
			scriptKeys.forEach(function(key) {
				loadModule(getModuleObject(key), locale, callback);
			});
		}

		function doLoadModulesPromise(locale) {
			return new Promise(function(resolve, reject) {
				function callback() {
					if (!isLoadingModules(locale))
						resolve();
				}
				try {
					doLoadModules(locale, callback);
					callback();
				} catch (e)
				{
					reject(e);
				}
			});
		}

		function loadModules() {
			doLoadModules();
		}
		loadModules.promise = doLoadModulesPromise.bind(this, null);

		function loadModulesWithLocale(locale) {
			doLoadModules(locale);
		}
		loadModulesWithLocale.promise = doLoadModulesPromise;

		function getScriptKey(script) {
			return util.isString(script) ? script : "" + JSON.stringify(script);
		}

		function getModuleObject(script) {
			return modules[getScriptKey(script)];
		}

		function getOrderedModuleInfos() {
			return scriptKeys.map(function(key) { return getModuleObject(key); }) || [];
		}

		function isLoadingModules(locale) {
			return Object.keys(modules).filter(function (key) {
				return (modules[key].enabled && !modules[key].loaded && (!locale || !modules[key].localized || modules[key].hasLocale(locale)));
			}).length !== 0;
		}

		return Object.freeze({
			loadModules: loadModules,
			loadModulesWithLocale: loadModulesWithLocale,
			getModuleObject: getModuleObject,
			getOrderedModuleInfos: getOrderedModuleInfos,
			isLoadingModules: isLoadingModules
		});
	}

	return {
		getEntryPointRequire: getEntryPointRequire,
		createModuleKeeper : function (options) { return new ModuleKeeper(options); }
	};

});
})();

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/recordScripting
 * @suiteScriptVersion 2.x
 */
define('N/util/recordScripting',['N/error', 'N/utilityFunctions', 'N/util', 'N/scriptLoader'],
	function (error, utilityFunctions, util, scriptLoader) {

		/**
		 * Record Scripting Event Handler object for scripting defined in static JS file(s)
		 * @param {Object} options
		 *        {Array} options.handlerModules the list of various event handler modules defined for the record
		 *        {String} options.context the require context name in which the scripting should be evaluated
		 *        {Function} [options.scope] the closure function that should be used to evaluate the event handler files
		 *        {Object} [options.scriptingContext] the object containing dynamic context for the record scripting
		 */
		function RecordScriptingHandler(options) {

			options = options || {};
			var eventHandlerModules = options.handlerModules || [];
			var scriptingContext = options.scriptingContext || {};
			var eventMap = {};
			var context = options.context;
			var scope = options.scope || null;

			function getKey(sublistName, fieldName, eventName) {
				var key = String(String(sublistName || null).toLowerCase() + ':' + String(fieldName || null).toLowerCase() + ':' + String(eventName || null));
				return key;
			}

			function addEvent(sublistName, fieldName, eventName, handler, event) {
				if (util.isFunction(event)) {
					var key = getKey(sublistName, fieldName, eventName);
					if (!eventMap[key]) eventMap[key] = [];
					eventMap[key].push({ handler: handler, event: event });
				}
			}

			(function constructor() {
				if (eventHandlerModules.length > 0) {
					var wasSync = require.isSync();
					require.forceSync(true);
					try {
						var entryPointRequire = scriptLoader.getEntryPointRequire({'context': context, _closure: scope});
						// Need to require the first module beforehand since it contains everything so we don't have to go to server again for the rest of the files
						entryPointRequire([eventHandlerModules[0]], function () {});
						// Due to the setting in JSON File, eventHandlerModules should be executed in reverse order. The last event handler module should be executed first
						for (var i = eventHandlerModules.length - 1; i >= 0; i--) {
							entryPointRequire([eventHandlerModules[i]],
								function (handlerName, recordScriptImpl) {
									var sublists = (recordScriptImpl.sublists || {});
									(Object.keys(sublists) || []).forEach(function (sublistName) {
										var fieldsOrEvents = recordScriptImpl.sublists[sublistName] || {};
										var sublistFields = fieldsOrEvents.fields || {};
										(Object.keys(sublistFields) || []).forEach(function (fieldName) {
											var field = sublistFields[fieldName] || {};
											(Object.keys(field) || []).forEach(function (eventName) {
												addEvent(sublistName, fieldName, eventName, handlerName, field[eventName]);
											});
										});
										(Object.keys(fieldsOrEvents) || []).forEach(function (eventName) {
											addEvent(sublistName, null, eventName, handlerName, fieldsOrEvents[eventName]);
										});
									});
									var fields = recordScriptImpl.fields || {};
									(Object.keys(fields) || []).forEach(function (fieldName) {
										var field = fields[fieldName] || {};
										(Object.keys(field) || []).forEach(function (eventName) {
											addEvent(null, fieldName, eventName, handlerName, field[eventName]);
										});
									});
									var eventNames = Object.keys(recordScriptImpl) || {};
									eventNames.forEach(function (eventName) {
										addEvent(null, null, eventName, handlerName, recordScriptImpl[eventName]);
									});
								}.bind(null, eventHandlerModules[i]));
						}
					} finally {
						require.forceSync(wasSync);
					}
					// call setupHandler methods of all registered event handlers
					initializeHandlers();
				}
			})();

			function handleError(e) {
				var err = e;
				if (e instanceof Error) {
					if (e.userFacing !== undefined && e.userFacing !== null) {
						err = error.create({name: e.name, message: e.message, cause: e, userFacing: e.userFacing});
					} else {
						err = error.create({name: e.name, message: e.message, cause: e});
					}
				}
				throw err;
			}

			function runEvent(args) {
				var key = getKey(args.sublistId, args.fieldId, args.eventName);
				var results = [];
				var listeners = eventMap[key];
				if (listeners) {
					listeners.forEach(function (listener) {
						var event = listener.event;
						try {

							var currResult = event(args);
							results.push({handler: listener.handler, result: currResult})

						} catch (e) {
							handleError(e);
						}
					});
				}
				return results;
			}

			function initializeHandlers()
			{
				// do not include current record reference to avoid misusing this as pre-pageInit call
				runEvent({
					eventName: 'setupHandler',
					scriptingContext: scriptingContext
				});
			}

			/**
			 * Run the event handler defined in static javascript file and return merged result
			 * @param {Object} options object with all arguments for the event execution
			 * @return {array} list of all event results that were executed in format {handler : string, result : Object }
			 */
			this.runStaticEvent = function runStaticEvent(options) {
				var args = util.extend(options || {}, {scriptingContext: scriptingContext});
				return runEvent(args);
			};

			this.hasStaticEvent = function hasStaticEvent(options) {
				var args = options || {};
				var key = getKey(args.sublistId, args.fieldId, args.eventName);
				return !!eventMap[key];
			}
		}

		return {
			create: function (options) {return new RecordScriptingHandler(options); }
		};
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/callRecordScript
 * @suiteScriptVersion 2.x
 */
define('N/util/callRecordScript',['N/util/recordScripting', 'N/utilityFunctions', 'N/contextSwitch'],
	function (recordScriptingModule, utilityFunctions, contextSwitch)
	{
		function RecordScriptCaller(options) {
			var	scriptingHandler = recordScriptingModule.create(options);

			function mergeInternalScriptResults(options, results) {
				var mergedResult = { valid: true, fields: [], messages: [], results: [] };
				for(var i = 0; i < results.length; i++) {
					var currResult = results[i].result;
					if (utilityFunctions.isObject(currResult) && currResult.hasOwnProperty('valid')) {
						mergedResult.results.push(results[i]);
						mergedResult.valid = mergedResult.valid && !!currResult.valid;
						Array.prototype.push.apply(mergedResult.fields, currResult.fields);
						Array.prototype.push.apply(mergedResult.messages, currResult.messages);
					} else {
						mergedResult.results.push(results[i]);
						mergedResult.valid = mergedResult.valid && !!currResult;
					}
				}
				if (!mergedResult.messages.length)
					delete(mergedResult.messages);
				if (!mergedResult.fields.length)
					delete(mergedResult.messages);
				return mergedResult;
			}

			function organizeRecordScriptingArgs(currentRecord, args) {
				var organizedArgs = {currentRecord: currentRecord};
				organizedArgs.eventName = args.eventName;
				organizedArgs.fieldId = args.fieldId;
				organizedArgs.sublistId = args.sublistId;
				organizedArgs.originalArgs = args.arguments;

				if(args.arguments) {
					var callerArgs = args.arguments;
					if(args.eventName === "postDeleteLine") {
						organizedArgs.line =  callerArgs[0];
					} else if(args.eventName === "lineCommit") {
						organizedArgs.line = callerArgs[0];
						organizedArgs.origLineData = callerArgs[1];
					}
				}
				return organizedArgs;
			}

			/**
			 * Call 2.0 record owner event handlers and merge with legacy result.
			 *
			 * @param {Object} currentRecord
			 * @param {Object} options
			 * @param {string} options.eventName
			 * @param {string} (options.fieldId)
			 * @param {string|array} (options.sublistId) - sublist id or a list of all sublist ids on the record in case of saveRecord event
			 * @param {array} (options.arguments) - the arguments from the initial caller of callRecordScript
			 *                                      -   options.arguments[0] - linenum, options.arguments[1] - origLineData
			 *                                      -   when options.eventName === lineCommit: the initial caller is postprocessline and the arguments are (linenum, origLineData)
			 *                                      -   when options.eventName === postDeleteLine: the initial caller is postdeleteline and the arguments are (linenum + 1, origLineData)
			 * @param {boolean} (options.legacyScript) - the result of legacy event handlers, it is false if the legacy validation exists and failed
			 * @return {Object} extended validation object including all partial results
			 */
			function callRecordScript(currentRecord, options) {
				var results = [];
				if (options && options.hasOwnProperty('legacyScript')) {
					results.push({handler: 'legacyHandler', result: options.legacyScript});
				}
				if (scriptingHandler && options.eventName) {
					// organize arguments based on event type
					var args = organizeRecordScriptingArgs(currentRecord, options);
					var argsArray = [];
					if (args.eventName !== "save") {
						if (scriptingHandler.hasStaticEvent(args)) {
							argsArray.push(args);
						}
					} else {
						var sublists = args.sublistId || [];
						// The executing sequence of 2.0 save event handler: save on record -> save on sublist
						sublists = [null].concat(sublists);
						for (var i = 0; i < sublists.length; i++) {
							args.sublistId =  sublists[i];
							if (scriptingHandler.hasStaticEvent(args)) {
								argsArray.push(util.extend({}, args));
							}
						}
					}
					if (argsArray.length > 0) {
						contextSwitch.execute({scriptInfo: {}}, function () {
							for (i = 0; i < argsArray.length; i++) {
								var returnResult = scriptingHandler.runStaticEvent(argsArray[i]);
								Array.prototype.push.apply(results, returnResult);
							}
						});
					}
				}

				return mergeInternalScriptResults(options, results);
			}

			return {
				callRecordScript: callRecordScript
			};
		}

		return {
			/**
			 * @param {Object} options
			 * @param {Array} options.handlerModules
			 * @param {Object} [options.context]
			 * @param {Object} [options.scope]
			 * @param {Object} [options.scriptingContext]
			 */
			create: (function create(options) {
				var opts = options || {};
				utilityFunctions.checkArgs([opts.handlerModules], ["options.handlerModules"], "callRecordScript.create");
				return (new RecordScriptCaller(opts)).callRecordScript;
			})
		}
	});

/**
 * SuiteScript record definition common module
 *
 * @private
 * @module N/record/recordScriptingScope
 * @NApiVersion 2.x
 *
 */
define('N/record/recordScriptingScope',['N/record/recordConstants', 'N/utilityFunctions', 'N/util/currencyUtility', 'N/util/date',
		'N/error', 'N/restricted/invoker', 'N/restricted/scopeRemoteApiBridge', 'N/record/recordImplV1',
		'N/scope', 'N/msgRouter', 'N/search', 'N/search/searchUtil', 'N/environment', 'N/util/callRecordScript',
		'N/util', 'N/contextSwitch', 'N/scriptLoader'],
	function(constants, utilityFunctions, currencyutil, dateutil,
	         error, invoker, remoteApi, recordImpl,
	         jsScope, msgRouter, search, searchUtil, environment, callRecordScriptMod,
	         util, contextSwitch, v2ScriptLoader)
	{
		var undef = undefined;

		var globalScope = (function() { return this; })();

		/* If this is > 0, it means the current script execution is occuring from within a client script. */
		var clientScriptInvocationDepthCount = 0;
		function isExecutionWithinAClientScript()
		{
			return clientScriptInvocationDepthCount > 0;
		}

		function create(options)
		{
			return new Scope(options);
		}

		/**
		 *
		 * @param {Object} options
		 * @param {function} options.record function returns the core record
		 * @param {string} options.libraryScript
		 * @param {string} options.staticScript
		 * @param {string} options.uiFormScript
		 * @param {boolean} options.shouldTriggerCustomFormLevelScript
		 * @param {object} options.formLevelScriptComponent
		 * @param {boolean} options.shouldTriggerCustomClientScript
		 * @param {object} options.clientScriptComponent
		 * @param {string} options.clientScriptComponent.libraryScript
		 * @param {*} options.clientScriptComponent.scriptList
		 * @param {function} options.completePageInit
		 * @constructor
		 */
		function Scope(options)
		{
			var coreRecord = options.record;

			// script defined in NLRecord by internal NS developer
			var recordLibraryScript = options.libraryScript;
			var staticScript = options.staticScript;
			var uiFormScript = options.uiFormScript;
			var internalInitCompleted = false;
			var recordInitialized = false;
			function completeInternalInit() {
				internalInitCompleted = true;
				if (typeof options.completeInternalInit === 'function')
					options.completeInternalInit();
			}
			function completePageInit() {
				recordInitialized = true;
				if (typeof options.completePageInit === 'function')
					options.completePageInit();
			}
			// for backward compatiability UIFormScripts
			var NS;
			function uiFormScriptWrapper() { eval(uiFormScript); }
			(function evaluateUIFormScriptAndCleanUp(scope)	{
				if (coreRecord.getIsCurrentRecord()) {
					scope.NS = scope.NS || {};
					scope.NS.UI = (globalScope.NS || {}).UI;
					scope.location = {search: "?" + coreRecord.getValue("entryformquerystring")};
				}
				var triggerUiFormScriptWrapper = uiFormScriptWrapper.bind(scope);
				triggerUiFormScriptWrapper();
				NS = scope.NS;
				delete scope.NS;
				delete scope.location;
			})(this);

			// record for v1 scripting expected in staticScript togehter with parent for some slaving scripts
			var record = recordImpl.create({record: coreRecord});
			var parent = record;
			eval(staticScript);
			eval(recordLibraryScript);

			function recordScriptingScope() { eval(arguments[0]); }

			/* Use interactive mode only if current scenario permits client scripts to use interactive mode (typically current record of a new UI page, but not remote record). */
			var exposedCurrentRecord = coreRecord.proxy({isInteractive: environment.isNewUI()});

			var eventHandlerModules = undef;
			var callRecordScript = undef;
			if(!utilityFunctions.isValEmpty(coreRecord.eventHandlerModules()))
			{
				eventHandlerModules = JSON.parse(coreRecord.eventHandlerModules());
				if(eventHandlerModules.length > 0) {
					callRecordScript = callRecordScriptMod.create({context: coreRecord.getSystemId(), scope: recordScriptingScope, handlerModules: eventHandlerModules, scriptingContext: coreRecord.getScriptingContext()}).bind(null, exposedCurrentRecord);
				}
			}

			// form-level script information
			var shouldTriggerCustomFormLevelScript = options.shouldTriggerCustomFormLevelScript;
			var formLevelScript = options.formLevelScriptComponent ? options.formLevelScriptComponent.script : null;
			var formLevelScriptAllText = options.formLevelScriptComponent ? options.formLevelScriptComponent.libraryScript : null;

			// client script information
			var shouldTriggerCustomClientScript = options.shouldTriggerCustomClientScript;
			var clientScriptList = options.clientScriptComponent ? options.clientScriptComponent.scriptList : null;
			var clientScriptAllText = options.clientScriptComponent ? options.clientScriptComponent.libraryScript : null;

			// workflow-generated client script
			var workflowScript = options.workflowScript;

			var getV1ScopeSingleton = (function()
			{
				var v1Scope = null;

				return function getV1ScopeSingleton(libraries)
				{
					if (v1Scope === null)
					{
						var readOnly = coreRecord.getIsReadOnlyRecord();
						v1Scope = jsScope({
							blacklist: readOnly ? [] : getV1ApiBlackList(),
							whitelist: readOnly ? {} : utilityFunctions.addParameterToMap(utilityFunctions.addParameterToMap({}, getV1ApiGrayList()), getV1ApiWhiteList()),
							libraries: libraries || []
						});
					}
					return v1Scope;
				}
			}());

			/* Assemble a unified list of V1 and V2 scripts, in script precedence order (form script, if any, followed by client scripts). */
			var formAndClientScriptList = [];
			var formAndClientScriptAllTextList = {};

			if (shouldTriggerCustomFormLevelScript)
			{
				formAndClientScriptList.push(formLevelScript);
				formAndClientScriptAllTextList[formLevelScript.scriptId] = formLevelScriptAllText;
			}

			if (workflowScript)
			{
				var scriptId = 'workflowscript';
				var workflowScriptRepresentation = { version: workflowScript.version || '1.0', scriptId: scriptId};
				formAndClientScriptList.push(workflowScriptRepresentation);
				formAndClientScriptAllTextList['workflowscript'] = workflowScript;
			}

			if (shouldTriggerCustomClientScript)
			{
				for (var i = 0; i < clientScriptList.length; i++)
				{
					var clientScript = clientScriptList[i];
					formAndClientScriptList.push(clientScript);
					formAndClientScriptAllTextList[clientScript.scriptId] = clientScriptAllText[clientScript.scriptId];
				}
			}

			coreRecord.locale.setupCallbacks({
				loadScriptsForLocale: loadScriptsForLocalePromise,
				localizationContextEnter: localizationContextEnter,
				localizationContextExit: localizationContextExit
			});

			//start async load of user scripts as early as possible
			var moduleKeeper = v2ScriptLoader.createModuleKeeper({
				systemId: coreRecord.getSystemId(),
				scriptList: formAndClientScriptList,
				localizationScriptLimit: coreRecord.locale.localizedScriptLimit()
			});
			moduleKeeper.loadModules();
			moduleKeeper.loadModulesWithLocale(coreRecord.locale.getTargetLocale());

			/* Put the scripts into their appropriate scopes, by version, in definition order (form script followed by client scripts). */
			{
				var v1Libraries = formAndClientScriptList.filter(function (script)
				{
					return script.version === '1.0';
				}).map(function (script)
				{
					return formAndClientScriptAllTextList[script.scriptId];
				});
				if (v1Libraries.length > 0) {
					// initialize v1 scope with libraries
					getV1ScopeSingleton(v1Libraries);
				}
			}

			function runInternalScript(scriptContent)
			{
				runInternalScriptAndReturnResult(scriptContent);
			}

			function runInternalScriptAndAssert(scriptContent, code)
			{
				try
				{
					var result = runInternalScriptAndReturnResult(scriptContent);
					_assertValidation(result, code);
					return result;
				}
				catch (e)
				{
					_handleError(e);
				}
			}

			function runMergeAndAssertInternalScript(resultLegacy, optionsV2, errorMessage) {
				try {
					// Run
					var result = resultLegacy;
					if(eventHandlerStaticScriptExists()) {
						if (optionsV2.eventName === "save") {
							optionsV2.sublistId = coreRecord.getSublists();
						}
						optionsV2.legacyScript = resultLegacy;
						result = callRecordScript(optionsV2);
					}

					// Assert
					_assertValidation(result, errorMessage);
					return result;
				} catch (e) {
					_handleError(e);
				}
			}

			function eventHandlerStaticScriptExists() {
				return ((typeof eventHandlerModules !== 'undefined') && (eventHandlerModules.length > 0));
			}

			function getV2RecordScriptOptions(eventName, fieldId, sublistId, callerArgs) {
				return {'eventName':eventName, 'fieldId': fieldId, 'sublistId': sublistId, 'arguments': callerArgs};
			}

			function evaluateSlavingResponse(response)
			{
				var slaveValues;
				eval(response);
				return slaveValues;
			}

			this.evaluateSlavingResponse = evaluateSlavingResponse;

			function runInternalScriptAndReturnResult(scriptContent)
			{
				return contextSwitch.execute({scriptInfo: {}}, function ()
				{
					try
					{
						var toRet = eval(scriptContent);
						return toRet;
					}
					catch (e)
					{
						_handleError(e);
					}
				});
			}

			this.runInternalScriptAndReturnResult = runInternalScriptAndReturnResult;

			function runInternalScriptAndReturnBooleanResult(scriptContent)
			{
				return !!runInternalScriptAndReturnResult(scriptContent);
			}

			this.runInternalScriptAndReturnBooleanResult = runInternalScriptAndReturnBooleanResult;

			function _handleError(e)
			{
				var err = e;
				if (e instanceof Error)
				{
					if (e.userFacing !== undef && e.userFacing !== null) {
						err = error.create({name: e.name, message: e.message, cause: e, userFacing: e.userFacing});
					} else {
						err = error.create({name: e.name, message: e.message, cause: e});
					}
				}
				throw err;
				//TODO - notify error
			}

			function _assertValidation(result, code)
			{
				var allMessages = [];
				var errorObj;

				// check for legacy error messages
				try {
					invoker(remoteApi, 'checkWarningMessageInSession', []);
				} catch (e) {
					errorObj = e;
				}

				// validation script return value uses the extended contract
				if (utilityFunctions.isObject(result) && result.hasOwnProperty('valid'))
				{
					if (!result.valid)
					{
						allMessages = Array.prototype.concat(errorObj && errorObj.message || [], result.messages || []);
						if (allMessages.length)
							errorObj = error.create({name: 'USER_ERROR', message: allMessages.join('\n')});
						else
							errorObj = utilityFunctions.isInternalErrorCode(code) ? utilityFunctions.createSuiteScriptError(code) : error.create({name: 'USER_ERROR', message: code});
						errorObj.validationDetail = result;
						throw errorObj;
					}
				}
				else if (!result)
				{
					if (!errorObj)
						errorObj = utilityFunctions.isInternalErrorCode(code) ? utilityFunctions.createSuiteScriptError(code) : error.create({name: 'USER_ERROR', message: code});
					throw errorObj;
				}
			}

			function _createArgumentsJSExpression(args)
			{
				var innerArgs = JSON.stringify(args);
				innerArgs = innerArgs.substr(1, innerArgs.length - 2);

				return '(' + innerArgs + ')';
			}

			function _getFieldScript(sublistId, fieldId, fieldscripttype)
			{
				var metadata = coreRecord.getMetadata().getFieldMetadata(sublistId, fieldId);
				return (metadata) ? utilityFunctions.returnEmptyIfNull(metadata.getFieldScript(fieldscripttype)) : '';
			}

			function _pageInit()
			{
				var scriptToRun = 'function NLRecordScripting_pageInit() { page_init(); }; NLRecordScripting_pageInit();';
				runInternalScript(scriptToRun);
				runClientScripts(PAGE_INIT_TRIGGER, [coreRecord.id > 0 ? 'edit' : 'create']);
			}

			this.pageInit = _pageInit;

			function localizationContextEnter(locale)
			{
				return new Promise(function (resolve, reject) {
					var args = [locale];
					if(eventHandlerStaticScriptExists()) {
						callRecordScript(getV2RecordScriptOptions(LOC_CONTEXT_ENTER, null, null, args));
					}
					runClientScripts(LOC_CONTEXT_ENTER, args, null, {locale: locale, callback: resolve});
				});
			}

			function localizationContextExit(locale)
			{
				return new Promise(function (resolve, reject) {
					var args = [locale];
					if(eventHandlerStaticScriptExists()) {
						callRecordScript(getV2RecordScriptOptions(LOC_CONTEXT_EXIT, null, null, args));
					}
					runClientScripts(LOC_CONTEXT_EXIT, args, null, {locale: locale, callback: resolve});
				});
			}

			function _validateField(sublistId, fieldId, line, matrixColumn)
			{
				var validationFieldScript = _getFieldScript(sublistId, fieldId, 'validatefield');
				var errorMessage = 'Field validation failed for field: ' + fieldId;
				var resultLegacy = true;
				if (!utilityFunctions.isValEmpty(validationFieldScript))
				{
					var scriptDefinition =
						'function NLRecordScripting_validateField(type,fld,linenum,bucket) {\n' +
						' var valid = ' + validationFieldScript + ';\n' +
						' return valid;\n};\n';
					var args = [sublistId, fieldId];
					if (line > 0)
						args.push(line);
					if (matrixColumn != -1)
						args.push(matrixColumn);
					var scriptInvoker = 'NLRecordScripting_validateField' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
				}
				runMergeAndAssertInternalScript(resultLegacy, getV2RecordScriptOptions('validate', fieldId, sublistId, []), errorMessage);
				runClientScripts(VALIDATE_FIELD_TRIGGER, [sublistId, fieldId, line, matrixColumn], errorMessage);
			}

			this.validateField = _validateField;

			function _canCreateSubrecord(sublistId, fieldId, line)
			{
				var canCreateSubrecordScript = _getFieldScript(sublistId, fieldId, 'canCreateSubrecord');
				if (!utilityFunctions.isValEmpty(canCreateSubrecordScript))
				{
					var wrappedScript = '(function(type,fld,linenum){ ' + canCreateSubrecordScript + '})(type,fld,linenum);';
					var scriptDefinition = 'function NLRecordScripting_canCreateSubrecord(type,fld,linenum) { var is_valid = ' + wrappedScript + '; return is_valid; };\n';
					var args = [sublistId, fieldId];
					if (line > 0)
					{
						args.push(line);
					}
					var scriptInvoker = 'NLRecordScripting_canCreateSubrecord' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScriptAndAssert(scriptToRun, error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD);
				}
			}

			this.canCreateSubrecord = _canCreateSubrecord;

			function _fieldChange(sublistId, fieldId, line, matrixColumn)
			{

				var fieldChangeScript = _getFieldScript(sublistId, fieldId, 'fieldchange');
				if (!utilityFunctions.isValEmpty(fieldChangeScript))
				{
					var scriptDefinition = 'function NLRecordScripting_fieldChange(type,fld,linenum,bucket) { ' + fieldChangeScript + ' }\n';
					var args = [sublistId, fieldId];
					if (line > 0)
					{
						args.push(line);
					}
					if (matrixColumn !== -1)
					{
						args.push(matrixColumn);
					}
					var scriptInvoker = 'NLRecordScripting_fieldChange' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScript(scriptToRun);
				}

				if(eventHandlerStaticScriptExists()) {
					callRecordScript(getV2RecordScriptOptions('onChange', fieldId, sublistId, [line, null]))
				}

				runClientScripts(FIELD_CHANGED_TRIGGER, [sublistId, fieldId, line, matrixColumn]);
			}

			this.fieldChange = _fieldChange;

			function _saveRecord(ignoreMandatoryFields)
			{
				var scriptDefinition =
					'function NLRecordScripting_saveRecord(ignoreMandatoryFields) {\n' +
					' return save_record(ignoreMandatoryFields, true);\n};\n';
				var scriptInvoker = 'NLRecordScripting_saveRecord(' + ignoreMandatoryFields + ')';
				var scriptToRun = scriptDefinition + scriptInvoker;
				var resultLegacy =  runInternalScriptAndReturnResult(scriptToRun);
				runMergeAndAssertInternalScript(resultLegacy, getV2RecordScriptOptions('save', null, null, []),
					error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD);

				runClientScripts(SAVE_RECORD_TRIGGER, [], error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD);
			}

			this.saveRecord = _saveRecord;

			function _getSublistScript(sublistId, scriptingTrigger, args)
			{
				var toRet = '';
				var sublistScripts = coreRecord.getMetadata().getSublistScripts(sublistId, scriptingTrigger);
				if (!utilityFunctions.isValEmpty(sublistScripts))
				{
					toRet = sublistScripts + args;
				}

				return toRet;
			}

			function _lineInit(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var lineInitScript = _getSublistScript(sublistId, 'lineinit', '()');
					if (!utilityFunctions.isValEmpty(lineInitScript))
					{
						var scriptDefinition = 'function NLRecordScripting_lineInit(type) { ' + lineInitScript + '; nlapiLineInit(type);};\n';
						var scriptInvoker = 'NLRecordScripting_lineInit' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}
					if(eventHandlerStaticScriptExists()) {
						callRecordScript(getV2RecordScriptOptions('lineInit', null, sublistId, []));
					}

					runClientScripts(LINE_INIT_TRIGGER, [sublistId]);
				}
			}

			this.lineInit = _lineInit;

			function _lineCommit(sublistId, line)
			{
				var lineCommitScript = _getSublistScript(sublistId, 'linecommit', '(linenum)');
				if (coreRecord.isSublistAnEditMachine(sublistId) && !utilityFunctions.isValEmpty(lineCommitScript))
				{
					var scriptDefinition = 'function NLRecordScripting_lineCommit(type, linenum) { ' + lineCommitScript + '; nlapiLineCommit(type, linenum); };\n';
					var scriptInvoker = 'NLRecordScripting_lineCommit' + _createArgumentsJSExpression([sublistId, line]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScript(scriptToRun);
				}
				if(eventHandlerStaticScriptExists()) {
					callRecordScript(getV2RecordScriptOptions('lineCommit', null, sublistId, [line, null]));
				}
			}

			this.lineCommit = _lineCommit;

			function _postDeleteLine(sublistId, line)
			{
				var postDeleteLineScript = _getSublistScript(sublistId, 'postdeleteline', '');
				if (coreRecord.isSublistAnEditMachine(sublistId) && !utilityFunctions.isValEmpty(postDeleteLineScript))
				{
					//TODO: verify postDeleteLine path.
					var scriptDefinition = 'function NLRecordScripting_postDeleteLine(type, linenum) { var hndlr = ' + postDeleteLineScript + '; hndlr(linenum); };\n';
					var scriptInvoker = 'NLRecordScripting_postDeleteLine' + _createArgumentsJSExpression([sublistId, line]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScript(scriptToRun);
				}

				if(eventHandlerStaticScriptExists()) {
					callRecordScript(getV2RecordScriptOptions('postDeleteLine', null, sublistId, [line, null]));
				}
			}

			this.postDeleteLine = _postDeleteLine;

			function _validateLine(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var validationLineScript = _getSublistScript(sublistId, 'validateline', '()') || 'true';
					var errorMessage = 'Line validation failed for sublist: ' + sublistId;
					var scriptDefinition =
						'function NLRecordScripting_validateLine(type) {\n' +
						' var valid = ' + validationLineScript + ';\n' +
						' if (validationResultToBoolean(valid))\n' +
						'  valid = nlapiValidateLine(type, true);\n' +
						' return valid;\n};\n';
					var scriptInvoker = 'NLRecordScripting_validateLine' + _createArgumentsJSExpression([sublistId]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					var resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
					runMergeAndAssertInternalScript(resultLegacy, getV2RecordScriptOptions('validateLine', null, sublistId, []), errorMessage);
					runClientScripts(VALIDATE_LINE_TRIGGER, [sublistId], errorMessage);
				}
			}

			this.validateLine = _validateLine;

			function _validateInsert(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var validationInsertScript = _getSublistScript(sublistId, 'validateinsert', '()') || 'true';
					var errorMessage = 'Line insert validation failed for sublist: ' + sublistId;
					var scriptDefinition =
						'function NLRecordScripting_validateInsert(type) {\n' +
						' var valid = ' + validationInsertScript + ';\n' +
						' if (validationResultToBoolean(valid))\n' +
						'  valid = nlapiValidateInsert(type);\n' +
						' return valid;\n};\n';
					var scriptInvoker = 'NLRecordScripting_validateInsert' + _createArgumentsJSExpression([sublistId]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					var resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
					runMergeAndAssertInternalScript(resultLegacy, getV2RecordScriptOptions('validateInsert', null, sublistId, []), errorMessage);
					runClientScripts(VALIDATE_INSERT_TRIGGER, [sublistId], errorMessage);
				}
			}

			this.validateInsert = _validateInsert;

			function _validateDelete(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var validationDeleteScript = _getSublistScript(sublistId, 'validatedelete', '()') || 'true';
					var errorMessage = 'Line delete validation failed for sublist: ' + sublistId;
					var scriptDefinition =
						'function NLRecordScripting_validateDelete(type) {\n' +
						' var valid = ' + validationDeleteScript + ';\n' +
						' if (validationResultToBoolean(valid))\n' +
						'  valid = nlapiValidateDelete(type);\n' +
						' return valid;\n};\n';
					var scriptInvoker = 'NLRecordScripting_validateDelete' + _createArgumentsJSExpression([sublistId]);
					var scriptToRun = scriptDefinition + scriptInvoker;
					var resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
					runMergeAndAssertInternalScript(resultLegacy, getV2RecordScriptOptions('validateDelete', null, sublistId, []), errorMessage);
					runClientScripts(VALIDATE_DELETE_TRIGGER, [sublistId], errorMessage);
				}
			}

			this.validateDelete = _validateDelete;

			function _recalc(sublistId, localRecalc, operation)
			{
				if (operation === undef)
				{
					operation = 'commit';
				}
				var recalcScript = _getSublistScript(sublistId, 'recalc', '');
				if (coreRecord.isSublistAnEditMachine(sublistId) || (localRecalc && !coreRecord.isSublistAnEditMachine(sublistId)))
				{
					if (!utilityFunctions.isValEmpty(recalcScript))
					{
						var scriptDefinition = 'function NLRecordScripting_recalc(type) { ' + recalcScript + '; nlapiRecalc(type, false, \'' + operation + '\'); };\n';
						var scriptInvoker = 'NLRecordScripting_recalc(\'' + sublistId + '\');';
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}

					if(eventHandlerStaticScriptExists()) {
						callRecordScript(getV2RecordScriptOptions('recalc', null, sublistId, []));
					}

					runClientScripts(RECALC_TRIGGER, [sublistId, operation]);
				}
			}

			this.recalc = _recalc;

			function _postSublistSourcing(postSourcingScript)
			{
				runInternalScript(postSourcingScript);
			}

			this.postSublistSourcing = _postSublistSourcing;

			function _postSourcing(sublistId, fieldId, line)
			{
				runClientScripts(POST_SOURCING_TRIGGER, [sublistId, fieldId, line]);
			}

			this.postSourcing = _postSourcing;

			function invalidateSubrecordCache(subrecordSublistId, subrecordFieldId, line)
			{
				record.invalidateSubrecordCacheEntry(subrecordSublistId, subrecordFieldId, line);
			}

			this.invalidateSubrecordCache = invalidateSubrecordCache;

			function _notifyInsertLine(sublistId, line)
			{
				record.insertLineForSubrecordCache(sublistId, line);
			}

			this.notifyInsertLine = _notifyInsertLine;

			function _notifyRemoveLine(sublistId, line)
			{
				record.removeLineForSubrecordCache(sublistId, line);

			}

			this.notifyRemoveLine = _notifyRemoveLine;

			function _notifyCurrentSublistLineReset(sublistId)
			{
				record.invalidateCurrentSublistLineForSubrecordCache(sublistId);
			}

			this.notifyCurrentSublistLineReset = _notifyCurrentSublistLineReset;


			//TODO remove to its own module
			var LOC_CONTEXT_ENTER = 'localizationContextEnter';
			var LOC_CONTEXT_EXIT = 'localizationContextExit';
			var PAGE_INIT_TRIGGER = 'pageInit';
			var SAVE_RECORD_TRIGGER = 'saveRecord';
			var LINE_INIT_TRIGGER = 'lineInit';
			var VALIDATE_DELETE_TRIGGER = 'validateDelete';
			var VALIDATE_INSERT_TRIGGER = 'validateInsert';
			var VALIDATE_LINE_TRIGGER = 'validateLine';
			var RECALC_TRIGGER = 'recalc';
			var SUBLIST_CHANGED_TRIGGER = 'sublistChanged';
			var POST_SOURCING_TRIGGER = 'postSourcing';
			var VALIDATE_FIELD_TRIGGER = 'validateField';
			var FIELD_CHANGED_TRIGGER = 'fieldChanged';
			var caresAboutReturn = [SAVE_RECORD_TRIGGER, VALIDATE_DELETE_TRIGGER, VALIDATE_INSERT_TRIGGER, VALIDATE_LINE_TRIGGER, VALIDATE_FIELD_TRIGGER];
			var workflowTriggers = [VALIDATE_FIELD_TRIGGER, FIELD_CHANGED_TRIGGER, POST_SOURCING_TRIGGER, PAGE_INIT_TRIGGER, SAVE_RECORD_TRIGGER];

			function doesTriggerCareAboutReturn(trigger)
			{
				return caresAboutReturn.indexOf(trigger) > -1;
			}

			function isWorkflowTrigger(trigger)
			{
				return workflowTriggers.indexOf(trigger) > -1;
			}

			// TODO: should be split into two - internal and client each running its own scope
			function runLegacyScript(script)
			{
				var scope = getV1ScopeSingleton();
				return scope(script);
			}

			this.runLegacyScript = runLegacyScript;

			function runWorkflowClientScript(trigger, args)
			{
				var scope = getV1ScopeSingleton();
				var script = "workflow_trigger" + _createArgumentsJSExpression([trigger].concat(args));
				return scope(script);
			}

			function stillLoadingScripts()
			{
				return moduleKeeper.isLoadingModules();
			}

			function loadScriptsForLocalePromise(locale)
			{
				return moduleKeeper.loadModulesWithLocale.promise(locale);
			}

			function runClientScripts(trigger, args, errorMessage, options)
			{
				options = options || {};
				var locale = options.locale;
				var callback = util.isFunction(options.callback) ? options.callback : function noop() {};

				if ((trigger !== PAGE_INIT_TRIGGER && !internalInitCompleted)
					|| ((trigger === LOC_CONTEXT_ENTER || trigger === LOC_CONTEXT_EXIT)
						&& (!recordInitialized || locale !== coreRecord.locale.getTargetLocale())) // check for locale being actual because of setTimeout below
					)
				{
					callback({executed: false, locale: locale, trigger: trigger});
					return;
				}

				if ((!internalInitCompleted || (trigger === LOC_CONTEXT_ENTER || trigger === LOC_CONTEXT_EXIT)) && stillLoadingScripts())
				{
					if (typeof setTimeout !== "undefined")
						setTimeout(runClientScripts, 0, trigger, args, errorMessage, options);
					else
						throw new Error("Failed to load record customizations");
					return;
				}

				// at this time we know for sure internal init completed (including script loading) and we are running client scripts
				if (trigger === PAGE_INIT_TRIGGER) {
					completeInternalInit();
				}

				reallyRunClientScripts(trigger, args, errorMessage, locale);

				if (trigger === PAGE_INIT_TRIGGER) {
					completePageInit();
				}

				if (callback)
					callback({executed: true, trigger: trigger, locale: locale});
			}

			function reallyRunClientScripts(trigger, args, errorMessage, locale)
			{
				var returnMatters = doesTriggerCareAboutReturn(trigger);

				if (workflowScript && util.isString(workflowScript) && isWorkflowTrigger(trigger))
				{
					var scriptResult = runWorkflowClientScript(trigger, args);
					returnMatters && _assertValidation(scriptResult, errorMessage);
				}

				if (formLevelScript)
				{
					scriptResult = runClientScriptWithTracking(trigger, args, formLevelScript, locale);
					returnMatters && _assertValidation(scriptResult, errorMessage);
				}

				if (clientScriptList)
				{
					for (var i = 0; i < clientScriptList.length; i++)
					{
						var clientScript = clientScriptList[i];
						scriptResult = runClientScriptWithTracking(trigger, args, clientScript, locale);
						returnMatters && _assertValidation(scriptResult, errorMessage);
					}
				}
			}

			function runClientScriptWithTracking(trigger, args, theScript, locale)
			{
				var isValid;
				clientScriptInvocationDepthCount++;
				try
				{
					isValid = runClientScript(trigger, args, theScript, locale);
				}
				finally
				{
					clientScriptInvocationDepthCount--;
					if (clientScriptInvocationDepthCount < 0)
						utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
				}
				return isValid;
			}

			function runClientScript(trigger, args, theScript, locale)
			{
				var isValid = true;

				try
				{
					var module = moduleKeeper.getModuleObject(theScript);
					var version =  module.script.version || '1.0';
					var realTrigger = (version !== '1.0') && (trigger === RECALC_TRIGGER) ? SUBLIST_CHANGED_TRIGGER : trigger;
					var shouldRun = module.shouldExecuteTrigger(locale, realTrigger);
					var runMe = shouldRun ? module.getTrigger(realTrigger) : undef;

					if (shouldRun && trigger === LOC_CONTEXT_ENTER) {
						module.activate();
					}

					if (!!runMe)
					{
						var context = {
							record: coreRecord,
							scriptInfo: module.script,
							settleCallback: coreRecord.awaitScript(module.script.scriptId)
						};
						var scriptArgs;

						invoker(remoteApi, 'setupScript', [module.script]);

						if (version === '1.0')
						{
							scriptArgs = _createArgumentsJSExpression(args);
							var scope = getV1ScopeSingleton();
							isValid = contextSwitch.execute(context, function() {
								return scope(runMe + scriptArgs);
							});
						}
						else
						{
							scriptArgs = organizeArgs(trigger, args);
							isValid = contextSwitch.execute(context, function() {
								return runMe(scriptArgs);
							});
						}
					}

					if (shouldRun && trigger === LOC_CONTEXT_EXIT) {
						module.deactivate();
					}
				}
				catch (e) {
					util.extend(e, {csError: {trigger: trigger, scriptInfo:invoker(remoteApi, 'getScript', [])}});
					throw (e);
				}
				return isValid;
			}

			function organizeArgs(trigger, args)
			{
				function getZeroBasedIndex(idx)
				{
					if (isNaN(idx))
					{
						return idx;
					}
					else
					{
						idx = parseInt(idx, 10);
						return (idx < 0) ? idx : idx - 1;
					}
				}

				var returnMe;
				switch (trigger)
				{
					case PAGE_INIT_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, mode: args[0]};
						break;

					case SAVE_RECORD_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord};
						break;

					case LINE_INIT_TRIGGER:
					case VALIDATE_DELETE_TRIGGER:
					case VALIDATE_INSERT_TRIGGER:
					case VALIDATE_LINE_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, sublistId: args[0]};
						break;

					case RECALC_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, sublistId: args[0], operation: args[1]};
						break;

					case POST_SOURCING_TRIGGER:
						returnMe = {
							currentRecord: exposedCurrentRecord,
							sublistId: args[0],
							fieldId: args[1],
							line: getZeroBasedIndex(args[2])
						};
						break;

					case VALIDATE_FIELD_TRIGGER:
					case FIELD_CHANGED_TRIGGER:
						returnMe = {
							currentRecord: exposedCurrentRecord,
							sublistId: args[0],
							fieldId: args[1],
							line: getZeroBasedIndex(args[2]),
							column: getZeroBasedIndex(args[3])
						};
						break;
					case LOC_CONTEXT_ENTER:
					case LOC_CONTEXT_EXIT:
						returnMe = { currentRecord: exposedCurrentRecord, locale: args[0] };
						break;
					default:
						returnMe = {};
				}
				return returnMe;
			}
		}

		return {
			create: create,
			isExecutionWithinAClientScript: isExecutionWithinAClientScript
		};
	}
);

/**
 * SuiteScript notification module
 *
 * @private
 * @module N/notification
 * @suiteScriptVersion 2.x
 *
 */
define('N/notification',[],function () {

	var TYPE = Object.freeze({
		CONFIRMATION: 0,
		INFORMATION: 1,
		WARNING: 2,
		ERROR: 3
	});

	function Severity(type)
	{
		Object.defineProperty(this, 'value', {
			get: function ()
			{
				return type;
			},
			enumerable: true,
			configurable: false
		});

		Object.defineProperty(this, 'label', {
			get: function ()
			{
				return getLabel(type);
			},
			enumerable: true,
			configurable: false
		});
	}

	function getLabel(severity)
	{
		/* system default is confirmation */
		var label = 'Confirmation';
		switch(severity)
		{
			case TYPE.INFORMATION:
				label = 'Information';
				break;
			case TYPE.WARNING:
				label = 'Warning';
				break;
			case TYPE.ERROR:
				label = 'Error';
				break;
		}
		return label;
	}

	return Object.freeze({
		Type : TYPE,
		create: function(args)
		{
			return new Severity(args);
		}
	});
});

/**
 * SuiteScript saveResult module
 *
 * @private
 * @module N/saveResult
 * @NApiVersion 2.x
 *
 */
define('N/saveResult',['N/notification','N/utilityFunctions'],
	function (notification, utilityFunctions)
	{

		var SEVERITY = Object.freeze({
			CONFIRMATION: notification.create(notification.Type.CONFIRMATION),
			INFORMATION: notification.create(notification.Type.INFORMATION),
			WARNING: notification.create(notification.Type.WARNING),
			ERROR: notification.create(notification.Type.ERROR)
		});

		/**
		 * @protected
		 * @constructor
		 */
		function SaveResult(options, result)
		{
			Object.defineProperty(this, 'recordData', {
				get: function ()
				{
					return new RecordData(result['recordData']);
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'notifications', {
				get: function ()
				{
					return createArrayMessages(result.notifications);
				},
				enumerable: true,
				configurable: false
			});
		}

		function createArrayMessages(array)
		{
			var result = new Array();
			for(var i = 0; i < array.length; i++)
			{
				var oldMsg = array[i];
				result.push(new SaveMessage(oldMsg, isExpandedErrorMessage(oldMsg)));
			}
			return result;
		}

		/* Determines if the expanded message with stack trace and args should be rendered */
		function isExpandedErrorMessage(oldMsg)
		{
			return !utilityFunctions.isEmpty(oldMsg['errorStack']);
		}

		/**
		 * @protected
		 * @constructor
		 */
		function RecordData(recordData)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return recordData.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return recordData.label;
				},
				enumerable: true,
				configurable: false
			});

			if (recordData.redirectUrl != null) {
				Object.defineProperty(this, 'redirectUrl', {
					get: function ()
					{
						return recordData.redirectUrl;
					},
					enumerable: true,
					configurable: false
				});
			}
		}

		/**
		 * @protected
		 * @constructor
		 */
		function SaveMessage(saveMessage, error)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return saveMessage.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'title', {
				get: function ()
				{
					return saveMessage.title;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'message', {
				get: function ()
				{
					return saveMessage.message;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'severity', {
				get: function ()
				{
					switch(saveMessage.type)
					{
						case notification.Type.INFORMATION:
							return SEVERITY.INFORMATION;
							break;
						case notification.Type.WARNING:
							return SEVERITY.WARNING;
							break;
						case notification.Type.ERROR:
							return SEVERITY.ERROR;
							break;

						default:
							return SEVERITY.CONFIRMATION;
							break;
					}
				},
				enumerable: true,
				configurable: false
			});

			if(error)
			{
				Object.defineProperty(this, 'name', {
					get: function ()
					{
						return saveMessage.name;
					},
					enumerable: true,
					configurable: false
				});

				Object.defineProperty(this, 'errorStack', {
					get: function ()
					{
						return saveMessage.errorStack;
					},
					enumerable: true,
					configurable: false
				});

				Object.defineProperty(this, 'scriptMetadata', {
					get: function ()
					{
						return new ScriptMetadata(saveMessage.scriptMetadata);
					},
					enumerable: true,
					configurable: false
				});
			}
		}

		/**
		 * @protected
		 * @constructor
		 */
		function ScriptMetadata(scriptData)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return scriptData.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return scriptData.type;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'internalId', {
				get: function ()
				{
					return scriptData.internalId;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'deployment', {
				get: function ()
				{
					return new Deployment(scriptData);
				},
				enumerable: true,
				configurable: false
			});

		}

		/**
		 * @protected
		 * @constructor
		 */
		function Deployment(scriptData) {
			Object.defineProperty(this, 'id', {
				get: function () {
					return scriptData.deploymentId;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'internalId', {
				get: function () {
					return scriptData.deploymentInternalId;
				},
				enumerable: true,
				configurable: false
			});
		}


		return Object.freeze({
			create: function (options, results)
			{
				return Object.freeze(new SaveResult(options, results));
			}
		});

	});

/**
 * SuiteScript record macro module
 *
 * @private
 * @module N/macro
 * @suiteScriptVersion 2.x
 */
define(
	'N/macro',['N/utilityFunctions', 'N/record/recordProxy', 'N/error', 'N/environment', 'N/notification', 'N/runtime', 'N/contextSwitch', 'N/scriptLoader'],
	function (utilityFunctions, recordProxy, error, environment, notification, runtime, contextSwitch, scriptLoader)
	{
		function isServerSide() {
			return (typeof(document) === 'undefined');
		}

		function isJavaCall() {
			return (typeof(_java_call) !== 'undefined' && !!_java_call);
		}

		var getCachedMetadata = (function() {

			var macroMetadataCache = [];

			return function getCachedMetadata(options)
			{
				options = options || {};
				var macroMetadata = [];
				var rawRecord = options.rawRecord;
				if (rawRecord && rawRecord.hasOwnProperty('type') && rawRecord.hasOwnProperty('toString'))
				{
					var cacheKey;
					var isReadOnly = !isServerSide() && (rawRecord.hasOwnProperty('getIsReadOnlyRecord') ? rawRecord.getIsReadOnlyRecord() : !rawRecord.isDynamic);
					// view mode record has different macros that edit mode record
					if (rawRecord.type)
						cacheKey = rawRecord.type + (isReadOnly ? "_readOnly" : "");

					if (!macroMetadataCache[cacheKey])
					{
						if (rawRecord && rawRecord.getMacroMetadata)
							macroMetadata = rawRecord.getMacroMetadata() || [];

						if (cacheKey)
							macroMetadataCache[cacheKey] = macroMetadata;
					}
					else
					{
						macroMetadata = macroMetadataCache[cacheKey] || [];
					}

				}

				var macroList = [];
				macroMetadata.forEach(
					function(metadata)
					{
						var macro = {
							// basic info for the user
							id: metadata.id,
							'package': metadata['package'],
							label: metadata.label,
							description: metadata.description,
							attributes: metadata.attributes
						};
						if (!options.limited) {
							// all props for internal use
							for(var data in metadata)
								macro[data] = metadata[data];
						}
						macroList.push(macro);
					});
				return macroList;
			}
		})();

		function getMacroMetadata(options)
		{
			return getCachedMetadata(options).filter(
				function (macro)
				{
					return (macro.id === options.id
						&& macro['package'] === options['package']);
				})[0];
		}

		function getMacros(record)
		{
			var rawRecord = this;
			utilityFunctions.checkArgs([record], ['record'], 'Record.getMacros');
			var Macros = {};
			getCachedMetadata({rawRecord: rawRecord}).forEach(
				function (macroDef)	{
					var macro = getMacroObject(macroDef, record);
					if (!macro['package'])
						Macros[macro.id] = macro;
					else {
						if (Macros[macro['package']] === undefined) {
							Macros[macro['package']] = {};
						}
						Macros[macro['package']][macro.id] = macro;
					}
				});
			return Object.freeze(Macros);
		}

		function getMacro(record, options)
		{
			var rawRecord = this;
			var id, pckgId;
			if (options !== undefined && options !== null)
			{
				id = options.id;
				pckgId = options['package'];
			}
			pckgId = pckgId || '';

			utilityFunctions.checkArgs([record], ['record'], 'Record.getMacro');
			utilityFunctions.checkArgsPresent([id], ['id'], 'Record.getMacro');
			utilityFunctions.assertTrue(util.isString(id), error.Type.SSS_INVALID_TYPE_ARG, 'id');
			utilityFunctions.assertTrue(util.isString(pckgId), error.Type.SSS_INVALID_TYPE_ARG, 'package');

			var macroDef = getMacroMetadata({'id': id, 'package': pckgId, limited: true, rawRecord: rawRecord});

			if (!macroDef)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);

			return getMacroObject(macroDef, record);
		}

		function getMacroObject(macroDefinition, record) {

			var Macro = function Macro(params)
			{
				return record.executeMacro({'id': macroDefinition.id, 'package': macroDefinition['package'], 'params': params});
			};
			Macro.execute = function MacroExecute(params)
			{
				return record.executeMacro({'id': macroDefinition.id, 'package': macroDefinition['package'], 'params': params});
			};
			Macro.promise = function MacroExecutePromise(params)
			{
				return record.executeMacro.promise({
					'id': macroDefinition.id,
					'package': macroDefinition['package'],
					'params': params
				});
			};
			Macro.execute.promise = Macro.promise;

			var jsonDescription = {};

			// add metadata
			for (var attr in macroDefinition)
			{
				if (macroDefinition.hasOwnProperty(attr))
				{
					Macro[attr] = macroDefinition[attr];

					if (!!Macro[attr])
						jsonDescription[attr] = Macro[attr];
				}
			}

			Macro.toJSON = function() {
				return jsonDescription;
			};

			Macro.toString = function() {
				return 'Macro: ' + JSON.stringify(Macro.toJSON());
			};

			return Object.freeze(Macro);
		}

		function getExecuteMacroArgs(options)
		{
			var id, pckgId, params;
			if (options !== undefined && options !== null)
			{
				id = options.id;
				pckgId = options['package'];
				params = options.params;
			}
			if (id === undefined)
				id = null;
			pckgId = pckgId || '';
			if (params === undefined)
				params = null;

			return [id, pckgId, params];
		}

		function clientExecuteMacro(record, options, callback)
		{
			var rawRecord = this;
			var proxiedRecord = record;
			/* As per spec, macros will run in standard mode for the intermediate future. The code to support interactive mode is still in place for the future, but disabled for now. */
			if (!environment.isNewUI())
			{
				if (record.isInteractive)
				{
					// if the record passed in is interactive, but the interactive mode in macros is not allowed
					// we need to get a new non-interactive proxy
					proxiedRecord = rawRecord.proxy ? rawRecord.proxy({isInteractive: false}) : record;
				}
			}

			var args = getExecuteMacroArgs(options);
			var id = args[0];
			var pckgId = args[1];
			var params = args[2];

			utilityFunctions.checkArgs([proxiedRecord], ['record'], 'Record.executeMacro');
			utilityFunctions.checkArgsPresent([id], ['id'], 'Record.executeMacro');
			utilityFunctions.assertTrue(util.isString(id), error.Type.SSS_INVALID_TYPE_ARG, 'id');
			utilityFunctions.assertTrue(util.isString(pckgId), error.Type.SSS_INVALID_TYPE_ARG, 'package');

			var macroDef = getMacroMetadata({'id': id, 'package': pckgId, rawRecord: rawRecord});
			if (!macroDef)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);

 			var notifications = [];
 			var requisites =
		    {
		    	currentRecord: proxiedRecord,
		    	params: params,
		    	scriptingContext: rawRecord.getScriptingContext() || {},
		        notifications:
			        {
				        add: function add(title, message, type)
				        {
					        utilityFunctions.checkArgs([title, message, type], ['title', 'message', 'type'], 'notifications.add');
					        var severity = notification.create(type);
					        notifications.push({title: title, message: message, severity: severity});
					        return this;
				        },
				        addInfo: function addInfo(title, message)
				        {
					        return this.add(title, message, notification.Type.INFORMATION);
				        },
				        addWarning: function addWarning(title, message)
				        {
					        return this.add(title, message, notification.Type.WARNING);
				        },
				        addError: function addError(title, message)
				        {
					        return this.add(title, message, notification.Type.ERROR);
				        }
			        }
		    };

			function getResult(response)
			{
				if (response != null && !util.isObject(response))
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_RETURN_TYPE_EXPECTED_1, 'Object');

				return {
					notifications: notifications,
					response: response || {}
				}
			}

			var requireContext = isServerSide() ? "recordScripting" : rawRecord.getSystemId();
			var entryPointRequire = scriptLoader.getEntryPointRequire({'context': requireContext});
			var modulePath = macroDef.modulePath;
			var functionName = macroDef.id;
			if (callback)
			{
				var macroHasPromise = false;
				entryPointRequire([modulePath], function (mod)
				{
					var requirePromise = new Promise(function (requireResolve, requireReject)
					{
						try
						{
							var macroFunc = mod[functionName];
							if (macroFunc && typeof(macroFunc.promise) === 'function')
							{
								macroFunc = macroFunc.promise;
								macroHasPromise = true;
							}
							if (typeof(macroFunc) === 'function')
								requireResolve(macroFunc);
							else
								requireReject(error.create(error.Type.SSS_INVALID_MACRO_ID));
						}
						catch (e)
						{
							utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
						}
					});
					requirePromise.then(function (macroFunc) {
						var response = macroFunc.apply(this, [requisites]);
						if (response instanceof Promise)
						{
							response.then(getResult).then(callback, callback.bind(null, undefined));
						}
						else
						{
							if (macroHasPromise)
								utilityFunctions.throwSuiteScriptError(error.Type.INVALID_RETURN_TYPE_EXPECTED_1, 'Promise');
							else
								callback(getResult(response));
						}
					})['catch'](function (macroErr) {
						callback(undefined, macroErr);
					});
				});
			}
			else
			{
				var macroFunc;
				wasSync = require.isSync();
				require.forceSync(true);
				try
				{
					entryPointRequire([modulePath], function (mod)
					{
						macroFunc = mod[functionName];
					});
				}
				finally
				{
					require.forceSync(wasSync);
				}
				if (typeof(macroFunc) === 'function')
				{
					var response = macroFunc.apply(this, [requisites]);
				}
				else
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);
				}
				return getResult(response);
			}
		}

		function processServerResult(callback, result, exception)
		{
			if (exception === undefined)
			{
				result = JSON.parse(result);
				if (!callback)
					return result;
				else
					return callback(result);
			}
			else
			{
				if (!callback)
					throw exception;
				else
					return callback(undefined, exception);
			}
		}

		function serverExecuteMacro(record, options, callback)
		{
			var recordObject = this;
			var result, exception;
			try
			{
				result = recordObject.invokeMacro(getExecuteMacroArgs(options), callback && processServerResult.bind(null, callback));
			}
			catch (e)
			{
				exception = e;
			}
			return processServerResult(callback && (function () {}), result, exception);
		}

		var doExecuteMacro = function() { return (isServerSide() && !isJavaCall()) ? serverExecuteMacro.apply(this, arguments) : clientExecuteMacro.apply(this, arguments) };

		var executeMacro = function executeMacro(record, options) {
			return contextSwitch.execute({record: this}, doExecuteMacro.bind(this, record, options, null/*callback*/));
		};

		executeMacro.promise = function executeMacroPromise(record, options) {
			var rawRecord = this;
			return new Promise(
				function (resolve, reject) {
					var callback = function callback(result, exception) {
						if (exception === undefined) {
							resolve(result);
						} else {
							reject(exception);
						}
					};

					return contextSwitch.execute({record: rawRecord}, doExecuteMacro.bind(rawRecord, record, options, callback));
				}
			);
		};

		return Object.freeze(
		{
			getMacros: getMacros,
			getMacro: getMacro,
			executeMacro : executeMacro
		});

	}
);

/**
 * SuiteScript record definition common module
 *
 * @private
 * @module N/common/record/recordDefinition
 * @suiteScriptVersion 2.x
 *
 */
define(
	'N/common/record/recordDefinition',['N/restricted/recordApi', 'N/restricted/recordRemoteApiBridge', 'N/action', 'N/restricted/invoker', 'N/record/recordConstants', 'N/utilityFunctions','N/error',
	 'N/field', 'N/metadata/fieldMetadata', 'N/record/metadata', 'N/record/recordStateController','N/record/recordField','N/record/matrix', 'N/record/sublist', 'N/metadata/sublistMetadata',
	 'N/common/record/line/lineDefinition',
	 'N/util', 'N/util/formatter', 'N/util/validator', 'N/util/slaving', 'N/localeContext',
	 'N/record/recordProxy',
	 'N/record/relatedRecord',
	 'N/record/modelController', 'N/record/recordUtilityFunctions', 'N/record/recordImplementation',
	 'N/record/subrecordUtilityFunctions', 'N/record/recordScriptingScope',
	 'N/common/record/recordDefinitionEvent', 'N/eventEmitter',
	 'N/common/record/recordActualWork', 'N/saveResult', 'N/msgRouter', 'N/macro', 'N/fieldTypeConstants', 'N/contextSwitch'],
	function (apiBridge, remoteApi, action, invoker, constants, utilityFunctions, error,
			  field, fieldMetadata, metadata, recordStateController, recordfield, matrix, sublist, sublistMD,
			  lineDefinition,
			  util, formatter, validator, slaving, localeContext,
			  recordProxy,
			  relatedRecord,
			  modelController, recordUtil, recordImplementation,
			  subrecordUtil, scope,
			  recordDefinitionEvent, eventEmitter,
			  recordBehaviorDelegateService, saveResult, msgRouter, macro, fieldTypeConstants, contextSwitch)
	{
		var undef = undefined;

		function getCopyContainer()
		{
			var result;
			var copies = null;

			function add(obj)
			{
				if (!contains(obj))
				{
					copies = copies || [];
					copies.push(obj);
				}
				return result;
			}

			function clear()
			{
				copies = null;
				return result;
			}

			function contains(obj)
			{
				return copies !== null && copies.some(function (v)
				{
					return v === obj;
				});
			}

			function execute(func)
			{
				if (!!copies)
				{
					copies.forEach(function (copy)
					{
						func(copy);
					});
				}
			}

			result = {
				add: add,
				clear: clear,
				contains: contains,
				execute: execute
			};

			return result;
		}


		/**
		 * Primary object used to encapsulate a record object.
		 *
		 * @protected
		 * @param {Object} options
		 * @param {Object} options.recordObj (server-generated object holding the full metadata and data for a record type,
		 *     including all scripting and customization. See RecordSerializationKey.java)
		 * @param {number} options.recordObj.id
		 * @param {boolean} options.recordObj.isSubrecord = true if the record instance is a subrecord
		 * @param {boolean} options.recordObj.isReadOnly = true if the record instance is read only instance
		 * @param {boolean} options.recordObj.isDynamic = true if the record instance is a dynamic record
		 * @param {boolean} options.recordObj.isCurrentRecord
		 * @param {boolean} options.recordObj.isUserEvent
		 * @param {Object} options.recordObj.recordContext
		 * @param {Metadata} options.recordObj.metadata (record metadata data used to populate the model controller)
		 * @param {ModelController} options.recordObj.data (record data used to populate the model)
		 * @param {RecordStateController} options.recordObj.state (record state to use to pre-populate the model controller)
		 * @return {Record} client-side record implementation
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function Record(options)
		{
			var freshCopies = getCopyContainer();

			var recordObj = util.extend({}, options.recordObj);

			recordObj.id = recordObj.id ? parseInt(recordObj.id, 10) : null;
			recordObj.isSubrecord = !!recordObj.isSubrecord;
			recordObj.isReadOnly = !!recordObj.isReadOnly;
			recordObj.isDynamic = !!recordObj.isDynamic;
			recordObj.isCurrentRecord = !!recordObj.isCurrentRecord;

			var compressEvents = !!recordObj && !!recordObj.data && !!recordObj.data.initialization && !!recordObj.data.initialization.params && typeof recordObj.data.initialization.params.compressEvents !== 'undefined' ?
				!!recordObj.data.initialization.params.compressEvents : true;

			var emitter = eventEmitter.create({
				eventTypes: Object.keys(recordDefinitionEvent.Type).map(function (v) { return recordDefinitionEvent.Type[v]; }),
				async: typeof setTimeout === 'function',
				insulated: true,
				preProcessor: compressEvents ? recordDefinitionEvent.eventCompress : recordDefinitionEvent.eventNoCompress
			});

			var implementation;
			var recordBehaviorDelegate = recordBehaviorDelegateService.create({delegate: this});
			var v1ScopeOptions = null;

			var that = this;

			var _metadata, _modelController, _state, _recordRequestContext, _recordScriptingV1Scope;
			var isInited = false; // should be true once internal page init is complete

			var subrecordParent,
				subrecordSublistId,
				subrecordFieldId,
				subrecordValidated = false,
				subrecordDead = false,
				subrecordReadOnly = false;
			var subrecordIsDereferencedFromParent = false;
			var subrecordSublistState, subrecordFieldState, subrecordCompatibility;

			var SUBRECORD_KEY_FIELDID_REGEX = /^(parent\.){1}\w+$/;

			var lineCache = {};

			function getLineObjectFromCache(sublistId, lineInstanceId, isCommitted)
			{
				var obj = lineCache;
				if (!obj[sublistId])
				{
					obj[sublistId] = {};
				}
				obj = obj[sublistId];

				if (!obj[lineInstanceId])
				{
					obj[lineInstanceId] = {};
				}
				obj = obj[lineInstanceId];

				if (!obj[isCommitted])
				{
					obj[isCommitted] = constructLineObject(sublistId, lineInstanceId, isCommitted);
				}
				obj = obj[isCommitted];

				return obj;
			}
			this.getLineObjectFromCache = getLineObjectFromCache;

			function getExistingLineObjectFromCache(sublistId, lineInstanceId) {
				var BUFFER_KEY = false, COMMITTED_KEY = true;
				var hasBufferLine = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, BUFFER_KEY);
				var hasCommittedLine = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, COMMITTED_KEY);
				// obj can have these keys: true (committed) or false (buffer)
				// creates three possible situations: (a) true & false both exist, (b) true exists, (c) false exists
				// a/c - if a buffer version exisits it should TRY to return it, depending on the sublist multiline editable status
				//       If the sublistId is multiline editable then ALWAYS return it.
				//       If the sublistId is NOT, then only return it if it's also the current line. Otherwise return the committed.
				//   b - there is only the committed version, so return that. No-one has tried to edit the existing line.

				var returnMe, lineState;

				if (hasBufferLine && (isMultilineEditable(sublistId) || doGetCurrentSublistLineInstanceId(sublistId) === lineInstanceId))
				{
					returnMe = getLineObjectFromCache(sublistId, lineInstanceId, BUFFER_KEY);
					lineState = hasCommittedLine ? "EDITED" : "NEW"
				}
				else if (hasCommittedLine)
				{
					returnMe = getLineObjectFromCache(sublistId, lineInstanceId, COMMITTED_KEY);
					lineState = "COMMITTED";
				}
				return {line: returnMe, state: lineState};
			}

			function removeLineObjectFromCache(sublistId, lineInstanceId)
			{
				if (sublistId !== undefined)
				{
					if (lineInstanceId !== undefined)
					{
						if (lineCache && lineCache[sublistId])
						{
							delete lineCache[sublistId][lineInstanceId];
						}
					}
					else
					{
						delete lineCache[sublistId];
					}
				}
				else
				{
					lineCache = {};
				}
			}

			//TODO: consider moving to metadata on a per-record basis.
			var RECORD_SPECIFIC_SAVE_OPTIONS = {'timesheet': ['savesubmit']};

			//TODO move to event module
			var sublistEventListeners = {
				change: [function (data)
				{
					invalidateSubrecordClones();
				}]
			};

			function invalidateSubrecordClones()
			{
				freshCopies.execute(function (clone)
				{
					clone.setDereferencedFromParent(true);
					clone.setReadonly();
				});
				freshCopies.clear();
			}

			this.invalidateSubrecordClones = invalidateSubrecordClones;

			function getRecordStateController() { return _state; }

			this.getRecordStateController = getRecordStateController;

			function setRecordStateController(state)
			{
				invalidateSubrecordClones();
				_state = state;
				recordDefinitionEvent.forwardRecordStateEvents(emitter, that);
			}

			this.setRecordStateController = setRecordStateController;

			function resetsetRecordStateController()
			{
				setRecordStateController(recordStateController.create({
					metadata: getMetadata(),
					data: getModelController(),
					getModelController: getModelController
				}));
			}

			this.resetsetRecordStateController = resetsetRecordStateController;

			function getMetadata() { return _metadata; }

			this.getMetadata = getMetadata;

			function setMetadata(metadata)
			{
				invalidateSubrecordClones();
				_metadata = metadata;
				recordDefinitionEvent.forwardMetadataEvents(emitter, that);
			}

			function getModelController() { return _modelController; }

			this.getModelController = getModelController;

			function setModelController(modelController)
			{
				invalidateSubrecordClones();
				_modelController = modelController;
				recordDefinitionEvent.forwardModelControllerEvents({
					record: that,
					emitter: emitter
				});
			}

			this.setModelController = setModelController;

			function getCurrentRecordDelegate()
			{
				var isCommitted = false;
				return {
					currentRecord: that,
					util: {
						isEditableSublist: isSublistAnEditMachine,
						isFieldMultiSelect: isFieldMultiSelect,
						setFieldNoSlaving: function setFieldNoSlaving(sublistId, fieldId, line, noSlaving)
						{
							var fieldState = !!sublistId ? getSublistFieldState(sublistId, fieldId, line, isCommitted) : getFieldState(fieldId);
							fieldState.ignoreSlaving = noSlaving;
						},
						getFieldOptions: getSelectOptionCache,
						isMultilineEditable: isMultilineEditable
					}
				};
			}

			//TODO remove
			function getHack()
			{
				return that;
			}

			this.getHack = getHack;

			/**
			 * The record id
			 * @property {number} id
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', getId);

			/**
			 * The recordType of the record
			 * @property {string} type
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', getRecordType);

			/**
			 * True if the record is dynamicRecord
			 * @property {boolean} isDynamic
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return getIsDynamicRecord(); });

			/*
			 * Query of the record
			 * @property {string} query
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'query', getQuery);

			var messageService;
			this.getMessageService = function getMessageService()
			{
				if (!messageService)
					messageService = msgRouter.getMessageServiceInstance(that);
				return messageService;
			};

			function getRecordRequestContext() { return _recordRequestContext; }

			this.getRecordRequestContext = getRecordRequestContext;

			function getId() { return recordObj.id ? parseInt(recordObj.id, 10) : null; }

			this.getId = getId;

			function getRecordType() { return _metadata.type; }

			this.getRecordType = getRecordType;

			function getIsSubrecord() { return !!recordObj.isSubrecord; }

			this.getIsSubrecord = getIsSubrecord;

			function getIsReadOnlyRecord() { return !!recordObj.isReadOnly; }

			this.getIsReadOnlyRecord = getIsReadOnlyRecord;

			function getIsDynamicRecord() { return !!recordObj.isDynamic; }

			this.getIsDynamicRecord = getIsDynamicRecord;

			function getIsCurrentRecord() { return !!recordObj.isCurrentRecord; }

			this.getIsCurrentRecord = getIsCurrentRecord;

			function isNewRecord() { return parseInt(getId(), 10) === -1 || getId() === undef || getId() === null; }

			this.isNewRecord = isNewRecord;

			function setIsInited() { isInited = true; }

			function getIsInited() { return isInited; }

			function shouldValidateField()
			{
				return getIsInited() && !isInternal();
			}

			this.shouldValidateField = shouldValidateField;

			function shouldValidateFieldPermissions()
			{
				return implementation.shouldValidateFieldPermissions();
			}

			this.shouldValidateFieldPermissions = shouldValidateFieldPermissions;

			function isInternal()
			{
				var scriptInfo = invoker(remoteApi, 'getScript', []);
				return scriptInfo.scriptId == null || scriptInfo.scriptId === 'internal';
			}

			this.isInternal = isInternal;

			function isChanged()
			{
				return _state.isChanged;
			}

			function getLineInstanceId(sublistId, line, isCommitted)
			{
				return implementation.getLineInstanceId(sublistId, line, isCommitted);
			}

			function getMissingArgumentErrorMessageFillerValue(methodName)
			{
				return 'Record' + '.' + methodName;
			}

			this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

			function isWithinValidLineRange(sublistId, line)
			{
				var lineNumberIndex = parseInt(line, 10);
				return 0 <= lineNumberIndex && lineNumberIndex < doGetLineCount(sublistId);
			}

			function isWithinValidLineRangeForFieldOnly(sublistId, line)
			{
				var lineNumberIndex = parseInt(line, 10);
				return 0 <= lineNumberIndex && lineNumberIndex < (doGetLineCount(sublistId) + (isMultilineEditable(sublistId)? 0 : 1));

			}

			function validateTextApi(isTextApi, fieldState, methodName, suggestedMethod)
			{
				implementation.validateTextApi(isTextApi, fieldState, methodName, suggestedMethod);
			}

			this.validateTextApi = validateTextApi;

			function isMultilineEditable(sublistId)
			{
				return !!sublistId ? doGetSublist(sublistId).isMultilineEditable : false;
			}
			this.isMultilineEditable = isMultilineEditable;

			function validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive)
			{
				if (lineNumberIndex === 0 && lowerBoundInclusive === 0 && upperBoundExclusive === 0)
					warnAboutMLBCurrentIndexProblem("ValidateLineIndex failure on all 0s.\nLikely sign that a selectNewLine should be called instead!\nProbably assuming a new line + selectLine on line 0.");

				implementation.validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive);
			}
			this.validateLineIndex = validateLineIndex;

			function validateLineIndex_MLB(lineNumberIndex, sublistId, allowNewLineForOldWay)
			{
				var adjust = !!allowNewLineForOldWay ? 1 : 0;
				var maxPossible = isMultilineEditable(sublistId) ? getModelController().getNextNewLineIndex_MLB(sublistId)
									                            : doGetLineCount(sublistId) + adjust;

				validateLineIndex(lineNumberIndex, 0, maxPossible)
			}
			this.validateLineIndex_MLB = validateLineIndex_MLB;

			function validateLineInstanceId(sublistId, lineInstanceId, isCommitted, allowFallback)
			{
				var lineInstanceExists = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted, allowFallback);
				recordUtil.assertValidSublistOperation(lineInstanceExists);
			}

			function getCachedOptionsForRecordField(sublistId, fieldId, line)
			{
				return implementation.getCachedOptionsForRecordField(sublistId, fieldId, line);
			}

			function getNoCopyToDefaultMapForSublist(sublistId)
			{
				var sublistMetadata = getSublistMetadata(sublistId);
				var noCopyToDefaultMap = {};
				if (!!sublistMetadata)
				{
					var noCopyList = sublistMetadata.noCopyFields || [];
					noCopyList.forEach(function (fieldId) { noCopyToDefaultMap[fieldId] = sublistMetadata.defaultValue[fieldId];});
				}
				return noCopyToDefaultMap;
			}

			function getSublistMetadata(sublistId)
			{
				return _metadata.getSublistMetadata(sublistId);
			}

			this.getSublistMetadata = getSublistMetadata;

			function getSublistType(sublistId)
			{
				return _metadata.getSublistType(sublistId);
			}

			this.getSublistType = getSublistType;

			function isSublistAnEditMachine(sublistId)
			{
				return getSublistType(sublistId) === 'edit';
			}

			this.isSublistAnEditMachine = isSublistAnEditMachine;

			function isSublistEditable(sublistId)
			{
				return getSublistMetadata(sublistId) && getSublistMetadata(sublistId).isEditable;
			}

			this.isSublistEditable = isSublistEditable;

			function isSublistAListMachine(sublistId)
			{
				return getSublistType(sublistId) === 'list';
			}

			this.isSublistAListMachine = isSublistAListMachine;

			// TODO should be refactored out and utilize recordBehaviorDelegate
			function isValidField(sublistId, fieldId)
			{
				var isValid = false;
				if (sublistId != null)
				{
					isValid = isValidSublistField(sublistId, fieldId);
				}
				else
				{
					isValid = isValidBodyField(fieldId);
				}
				return isValid;
			}

			this.isValidField = isValidField;

			function isValidBodyField(fieldId)
			{
				return _metadata.isValidField(fieldId);
			}

			this.isValidBodyField = isValidBodyField;

			function isValidSublistField(sublistId, fieldId)
			{
				return _metadata.isValidSublistField(sublistId, fieldId);
			}

			this.isValidSublistField = isValidSublistField;

			function getSublistFieldState(sublistId, fieldId, line, isCommitted)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.getSublistFieldState = getSublistFieldState;

			function getSublistState(sublistId)
			{
				return getRecordStateController().getSublistState(sublistId);
			}

			this.getSublistState = getSublistState;

			function getSublistFieldStateForInstance(sublistId, fieldId, lineInstancecId, isCommitted)
			{
				var sublistState = getSublistState(sublistId);
				return sublistState != null ? sublistState.getFieldStateForInstance(fieldId, lineInstancecId, isCommitted) : null;
			}

			this.getSublistFieldStateForInstance = getSublistFieldStateForInstance;

			function setSublistIsChanged(sublistId, value)
			{
				getSublistState(sublistId).isChanged = value;
				return that;
			}

			function getFieldState(fieldId)
			{
				return _state.getFieldState(fieldId);
			}

			this.getFieldState = getFieldState;

			function hasFieldValueOrFieldExisted(fieldId)
			{
				return getModelController().hasFieldValue(fieldId) || _metadata.isValidField(fieldId);
			}

			function hasSublistFieldValueOrSublistFieldExisted(sublistId, fieldId, line)
			{
				var isCommitted = true;
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function hasCurrentSublistFieldValueOrSublistFieldExisted(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				return hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, false);
			}

			function hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				return getModelController().hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
					|| isSublistFieldExisted(sublistId, fieldId);
			}

			function isSublistFieldExisted(sublistId, fieldId)
			{
				return _metadata.isValidSublistField(sublistId, fieldId);
			}

			function isSublistValid(sublistId)
			{
				return _metadata.isValidSublist(sublistId);
			}

			this.isSublistValid = isSublistValid;

			function getFieldLevelMetadataForBodyField(fieldId)
			{
				return _metadata.getFieldMetadata(undef, fieldId);
			}

			this.getFieldLevelMetadataForBodyField = getFieldLevelMetadataForBodyField;

			function getFieldLevelMetadataForSublistField(sublistId, fieldId)
			{
				return _metadata.getFieldMetadata(sublistId, fieldId);
			}

			this.getFieldLevelMetadataForSublistField = getFieldLevelMetadataForSublistField;

			function extractInforFromFieldLevelMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return {
					fieldId: fieldId,
					sublistId: sublistId,
					radioSet: !!fieldLevelMetadata ? fieldLevelMetadata.radioSet : undef,
					hasBlankString: !!fieldLevelMetadata ? fieldLevelMetadata.hasBlankString : undef,
					blankString: !!fieldLevelMetadata ? fieldLevelMetadata.blankString : undef,
					supplementedOptions: !!fieldLevelMetadata ? fieldLevelMetadata.supplementedOptions : undef
				};
			}

			this.extractInforFromFieldLevelMetadata = extractInforFromFieldLevelMetadata;

			function getFieldType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.type : null;
			}

			function isFieldNumeric(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.isNumeric : null;
			}

			function isFieldCurrency(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.isCurrency : null;
			}

			function isFieldTime(sublistId, fieldId)
			{
				return getFieldType(sublistId, fieldId) === recordUtil.FIELD_TYPE.TIME;
			}

			this.isFieldTime = isFieldTime;

			function isFieldTimeTrack(sublistId, fieldId)
			{
				return getFieldType(sublistId, fieldId) === recordUtil.FIELD_TYPE.TIMETRACK;
			}

			this.isFieldTime = isFieldTimeTrack;

			function isFieldMultiSelect(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.MULTISELECT;
			}
			this.isFieldMultiSelect = isFieldMultiSelect;

			function isFieldSelectType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && recordUtil.isSelectType(fieldLevelMetadata.type);
			}

			this.isFieldSelectType = isFieldSelectType;

			function isFieldCheckbox(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX;
			}

			this.isFieldCheckbox = isFieldCheckbox;

			function isFieldRadio(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.RADIO;
			}

			this.isFieldRadio = isFieldRadio;

			function isFieldRateType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && recordUtil.isRateType(fieldLevelMetadata.type);
			}

			this.isFieldRateType = isFieldRateType;

			function isFieldSubrecordField(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE;
			}

			function getSlavingMetadata(sublistId, fieldId)
			{
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return metadata ? metadata.slavingMetadata : null;
			}

			this.getSlavingMetadata = getSlavingMetadata;

			function getClientSlavingMetadata(sublistId, fieldId)
			{
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return metadata ? metadata.clientSlavingMetadata : null;
			}

			this.getClientSlavingMetadata = getClientSlavingMetadata;

			function getMacroMetadata()
			{
				return typeof recordObj.macro !== 'undefined' && recordObj.macro.macroMetadata || [];
			}
			this.getMacroMetadata = getMacroMetadata;

			/*
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/*
			 * provides available macros
			 * @return {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: macro.getMacros.bind(that),
				emitter: emitter
			});


			function getScriptingContext() {
				return typeof recordObj.scriptingContext !== 'undefined' ? recordObj.scriptingContext : null;
			}

			/*
			 * provide scripting context for records
			 * getScriptContext is only in recordDefinition.js and not in dynamicrecord.js.So it is only visible inside NetSuite.
			 */
			this.getScriptingContext = getScriptingContext;


			function getEventHandlerModules() {
				return typeof recordObj.eventHandlerModules !== 'undefined' ? recordObj.eventHandlerModules : null;
			}

			/*
			 * provide scripting context for records
			 */
			this.eventHandlerModules = getEventHandlerModules;

			/*
			 *
			 * provides a macro to execute
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @return {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: macro.getMacro.bind(that),
				emitter: emitter
			});

			/*
			 * performs macro operation and returns result
			 * executeMacro.promise returns a Promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @return {Object} [macro result]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: macro.executeMacro.bind(that),
				emitter: emitter
			});
			this.executeMacro.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: macro.executeMacro.promise.bind(that),
				emitter: emitter
			});

			/*
			 * Executes record action and returns its result. Record ID and type is automatically taken from this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @param {Object} [options.params] action arguments
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the
			 *     response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeAction = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: action.execute.bind(that),
				emitter: emitter
			});
			this.executeAction.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: action.execute.promise.bind(that),
				emitter: emitter
			});

			/*
			 * Provides available record actions for this record instance.
			 * @returns {Object} a set of actions (@see Action) defined on the record indexed by action ID
			 */
			this.getActions = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: action.find.bind(that),
				emitter: emitter
			});
			this.getActions.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: action.find.promise.bind(that),
				emitter: emitter
			});

			/*
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * @name Action
			 * @function
			 * @param {Object} params
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the
			 *     response property
			 */

			/*
			 * Returns an executable record action for this record instance.
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @returns {?Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.getAction = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: action.get.bind(that),
				emitter: emitter
			});
			this.getAction.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: action.get.promise.bind(that),
				emitter: emitter
			});

			function removeField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('removeField'));
				doRemoveField(fieldId);
			}

			/*
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeField,
				emitter: emitter
			});

			function doRemoveField(fieldId)
			{
				if (hasFieldValueOrFieldExisted(fieldId))
				{
					var oldValue = doGetValue(fieldId);

					getModelController().removeFieldValue(fieldId);
					_state.removeFieldState(fieldId);
					subrecord_updateFieldState(true);
				}
			}

			this.doRemoveField = doRemoveField;

			function getFields()
			{
				var allFields = {};
				var bodyfields = getModelController().getBodyFieldIds();
				if (util.isArray(bodyfields))
				{
					bodyfields.forEach(function (fieldId) { allFields[fieldId] = true; });
				}

				var fieldNames = _metadata.fieldIds;
				if (util.isArray(fieldNames))
				{
					fieldNames.forEach(function (fieldId)
					{
						if (isFieldSubrecordField(undef, fieldId))
						{
							delete allFields[fieldId];
						}
						else
						{
							allFields[fieldId] = true;
						}
					});
				}

				var uniqueFieldIds = [];
				recordUtil.forEachProperty(allFields, function (fieldId, value) { uniqueFieldIds[uniqueFieldIds.length] = fieldId; });
				return uniqueFieldIds;
			}

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @governance none
			 * @return {string[]}
			 *
			 * @since 2015.2
			 */
			this.getFields = getFields;

			function getSublists()
			{
				return _metadata.sublistIds;
			}

			/**
			 * return array of names of all sublists
			 * @governance none
			 * @return {string[]}
			 *
			 * @since 2015.2
			 */
			this.getSublists = getSublists;

			function getValue(options)
			{
				return recordBehaviorDelegate.getValue(options);
			}

			/**
			 * Returns the value of a field. Gets a numeric value for rate and ratehighprecision fields.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 *
			 * @since 2015.2
			 */
			this.getValue = getValue;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				return implementation.getParsedValueForBodyField(fieldId, delegator);
			}

			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function getParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var returnValue = doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				var fs = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
				var isCheckbox = fieldLevelMetadata && fieldLevelMetadata.type === recordUtil.FIELD_TYPE.CHECKBOX;

				if ((fs && !fs.isParsed) || (isCheckbox && returnValue === ''))
				{
					var parsedValue = recordUtil.parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, returnValue);
					getModelController()
						.setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, parsedValue, isCommitted);
					fs.isParsed = true;

					returnValue = parsedValue;
				}
				return returnValue;
			}

			function doGetValue(fieldId)
			{
				var hasFieldExisted = hasFieldValueOrFieldExisted(fieldId);
				var value = !hasFieldExisted ? undef : getModelController().getFieldValue(fieldId);
				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(undef, fieldId)
				};
				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(value, metadata);
			}

			this.doGetValue = doGetValue;

			function setParsedValueAndUpdateFieldState(fieldId, value, fieldState)
			{
				getModelController().setParsedValueForBodyField(fieldId, value);
				fieldState.isParsed = true;
			}

			this.setParsedValueAndUpdateFieldState = setParsedValueAndUpdateFieldState;

			function setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted)
			{
				getModelController()
					.setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted);
			}

			this.setParsedValueForSublistFieldForInstance = setParsedValueForSublistFieldForInstance;

			function setValue(options, value, isInteractive)
			{
				var fieldId, fireFieldChange = true, noSlaving = false, forceSyncSourcing = false, fireSlavingSync = false;
				if (value !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					isInteractive = util.isBoolean(options.isInteractive) ? options.isInteractive : false;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}

				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setValue'));
				recordUtil.validateAgainstSqlInjection(fieldId, value);

				var sourcingMetadata = getSlavingMetadata(null, fieldId);
				var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !getIsCurrentRecord();
				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				if (sourcingMetadata && forceSyncSourcing)
				{
					sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
				}
				doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive);
				if (sourcingMetadata && forceSyncSourcing)
				{
					sourcingMetadata.forceSyncSlaving = metadataForceSync;
				}
			}

			function getSourcingMetadata(fieldId) {
				return getslavingMetadata(null, fieldId);
			}
			this.getSourcingMetadata = getSourcingMetadata;

			/**
			 * set value of the field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @param {number|Date|string|Array|boolean} options.value The value to set the field to.
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.setValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setValue,
				emitter: emitter
			});

			function doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting)
			{
				implementation.doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting);
				getFieldState(fieldId).useTextApi = false;
			}

			this.doSetValue = doSetValue;

			function validateAndFormatFieldValue(sublistId, fieldId, value, skipParsing, allowPercentage)
			{
				return implementation.validateAndFormatFieldValue(sublistId, fieldId, value, skipParsing, allowPercentage);
			}

			this.validateAndFormatFieldValue = validateAndFormatFieldValue;

			function validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, value, isInteractive, allowPercentage)
			{
				return implementation.validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, value, isInteractive, allowPercentage);
			}

			this.validateAndFormatFieldValueForInstance = validateAndFormatFieldValueForInstance;

			function doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidation)
			{
				var newThingObject = getSetFieldMetadata(undef, fieldId);
				newThingObject.valueIsFormattedAsString = valueIsFormattedAsString;
				var valueObject = recordBehaviorDelegateService.createObjectToDoSetValue(value, newThingObject);
				getModelController().setFieldValue(fieldId, valueObject);
				var postSetObject = constructPostSetObject(undef, fieldId, valueObject.legacyStringValue,
					fireFieldChange, noSlaving, noValidation);
				var lineInstance = null;
				var isCommitted = true;
				var fieldState = getFieldState(fieldId);
				fieldState.isParsed = !valueIsFormattedAsString;
				fieldState.isChanged = true;
				recordBehaviorDelegateService.postDoSetValueForInstance(that, postSetObject, lineInstance, isCommitted);
			}

			this.doSetFieldValue = doSetFieldValue;

			function postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, fireFieldChange, noSlaving, noValidation)
			{
				implementation.postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, fireFieldChange, noSlaving, noValidation);
			}

			this.postSetFieldValueForInstance = postSetFieldValueForInstance;

			function doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField)
			{
				implementation.doSlaving(sublistId, fieldId, line, value, noSlaving, restrictField);
			}

			this.doSlaving = doSlaving;

			function doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField)
			{
				implementation.doSlavingForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving, restrictField);
			}

			this.doSlavingForInstance = doSlavingForInstance;

			function doPostSendSlavingRequest(slavingRequest, response)
			{
				var slaveValues;
				if (!utilityFunctions.isValEmpty(response))
				{
					slavingCache.put(slavingRequest, response);
					slaveValues = _recordScriptingV1Scope.evaluateSlavingResponse(response);
				}
				return slaveValues;
			}

			function doHandleSlavingRequestAsync(slavingRequest)
			{
				return new Promise(
					function (resolve, reject)
					{
						try
						{
							invoker(remoteApi, 'sendSlavingRequest', [getRecordType(), slavingRequest.url, slavingRequest.payload], callback, false /* parseResult */);
						}
						catch (e)
						{
							reject(e);
						}

						function callback(result, exception)
						{
							if (exception)
							{
								reject(exception);
								return;
							}
							try
							{
								resolve(doPostSendSlavingRequest(slavingRequest, result));
							}
							catch (e)
							{
								reject(e);
							}
						}
					}
				);
			}

			function sendSlavingRequest(slavingMetadata, masterFieldInfo)
			{
				var slaveValuesOrPromise;
				var forceSync = (slavingMetadata && slavingMetadata.forceSyncSlaving) ? slavingMetadata.forceSyncSlaving : !getIsCurrentRecord();
				var slavingRequest = slaving.getQueryRequest(slavingMetadata, masterFieldInfo, getCurrentRecordDelegate());

				if (getModelController().isSaveRecordScriptTriggered()) {
					forceSync = true;
				}

				if (slavingRequest)
				{
					slavingRequest.payload = prepareSlavingPayload(slavingRequest.payload);

					var cachedResponse = slavingCache.get(slavingRequest);

					if (!utilityFunctions.isValEmpty(cachedResponse))
					{
						slaveValuesOrPromise = doPostSendSlavingRequest(null, cachedResponse);
					}
					//noinspection JSUnresolvedVariable
					else if (forceSync)
					{
						var response = invoker(remoteApi, 'sendSlavingRequest', [getRecordType(), slavingRequest.url, slavingRequest.payload], null /* callback */, false /* parseResult */);
						slaveValuesOrPromise = doPostSendSlavingRequest(slavingRequest, response);
					}
					else
					{
						slaveValuesOrPromise = doHandleSlavingRequestAsync(slavingRequest);
					}
				}

				return slaveValuesOrPromise;
			}

			this.sendSlavingRequest = sendSlavingRequest;

			function prepareSlavingPayload(payload)
			{
				payload.newslaving = 'T';
				payload.isCurrentRecord = getIsCurrentRecord();

				return payload;
			}

			function applySlaveValues(slaveValues)
			{
				return contextSwitch.execute({scriptInfo: {}}, function ()
				{
					if (slaveValues['machinesData'])
					{
						applySlaveMachineResults(slaveValues['machinesData']);
					}

					slaving.processSlavingValues(slaveValues['fields'], getCurrentRecordDelegate());
					if (util.isFunction(slaveValues['aspectScript']))
					{
						slaveValues['aspectScript'].call();
					}
				});
			}

			this.applySlaveValues = applySlaveValues;

			function applySlaveMachineResults(machineData)
			{
				for (var sublistId in machineData)
				{
					var sublistData = machineData[sublistId].data;
					var sublistMetadata = machineData[sublistId].metadata;
					var sublistSlaveScript = machineData[sublistId].metadata[0];
					getModelController().clearSublistData(sublistId, isMultilineEditable(sublistId));
					sublistData.forEach(function (sublistLineData, index)
					{
						var line = index;
						getModelController().insertSublistLine(sublistId, line);
						sublistLineData.forEach(function (fieldValue, index)
						{
							var fieldMetadata = sublistMetadata[index + 1];
							var fieldId = fieldMetadata.name;
							var val = (typeof fieldValue === 'object') ? fieldValue.value : fieldValue;

							getModelController().setSublistLineValue(sublistId, fieldId, line, {
								value: val,
								legacyStringValue: val
							});
							if (typeof fieldValue === 'object' && (fieldValue.hasOwnProperty('options') || fieldMetadata.hasOwnProperty('defaultOptions')))
							{
								var options = fieldMetadata.hasOwnProperty('defaultOptions') ? fieldMetadata.defaultOptions : fieldValue.options;

								if (options.length > 0)
								{
									var selectOptions = getSelectOptionCache().get(sublistId, fieldId, line);
									selectOptions = util.isArray(selectOptions) ? selectOptions : [];

									options.forEach(function (option)
									{
										selectOptions.push({
											text: option[1],
											id: option[0]
										});
									});

									getSelectOptionCache().put(sublistId, fieldId, line, selectOptions);
								}
							}
						});
					});

					doResetSublistState(sublistId);
					invalidateSubrecordClones();
					triggerMachinePostSourcing(sublistSlaveScript);
					if (getSublistState(sublistId))
					{
						getSublistState(sublistId).isChanged = true;
					}
				}
			}

			this.awaitScript = function awaitScript()
			{
				if (typeof setTimeout === 'undefined')
				{
					return;
				}

				var modelController = getModelController();
				var serial, timeoutId;

				function settleScript()
				{
					modelController.removeFromScriptSet(serial);
					clearTimeout(timeoutId);
				}

				serial = modelController.addToScriptSet();
				timeoutId = setTimeout(settleScript, 60000);

				return settleScript;
			};

			function doResetSublistState(sublistId)
			{
				_state.addSublist(sublistId, getModelController);
				invalidateSubrecordClones();
			}

			function triggerMachinePostSourcing(postSourcingScript)
			{
				implementation.triggerMachinePostSourcing(postSourcingScript);
			}

			function triggerCustomPostSourcingScript(sublistId, fieldId, line)
			{
				implementation.triggerCustomPostSourcingScript(sublistId, fieldId, line);
			}

			this.triggerCustomPostSourcingScript = triggerCustomPostSourcingScript;


			function getText(options)
			{
				return recordBehaviorDelegate.getText(options);
			}

			/**
			 * get value of the field in text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @return {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.getText = getText;

			function doGetText(fieldId, delegator)
			{
				return implementation.doGetText(fieldId, delegator);
			}

			this.doGetText = doGetText;

			function doGetTextValueForSupplementedSelectFieldForInstance(sublistId, fieldId, value, lineInstanceId, isCommitted)
			{
				var select = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!!select.getSelectOptions)
				{
					var opts = select.getSelectOptions();
					var results = opts.filter(function (v) { return v.getId() === value; });
					if (results.length > 0)
					{
						return results[0].getText();
					}
				}
			}

			this.doGetTextValueForSupplementedSelectFieldForInstance = doGetTextValueForSupplementedSelectFieldForInstance;

			function doGetTextValueForSelectFieldForInstance(sublistId, fieldId, value, lineInstanceId, isCommitted, isMultiSelect)
			{
				var result = getModelController().getSelectOptionTextFromCache(sublistId, fieldId, value);
				if (result.indexOf(undefined) !== -1)
				{
					var select = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					var serverResult = querySelectTextFromServer(value, select, isMultiSelect).split(String.fromCharCode(5));
					serverResult.forEach(function (text, i) { if (text) result[i] = utilityFunctions.unescape(text); });
					getModelController().cacheSelectOptionText(sublistId, fieldId, value, result);
				}
				return result.join(String.fromCharCode(5));
			}

			this.doGetTextValueForSelectFieldForInstance = doGetTextValueForSelectFieldForInstance;

			function querySelectTextFromServer(value, select, isMultiSelect)
			{
				var callback = null;
				var shouldParseResult = false;
				var requestParam = select.getRequestParam();
				requestParam.push(value);
				return invoker(remoteApi, isMultiSelect ? 'getMultiSelectTextValue' : 'getSelectTextValue', requestParam, callback, shouldParseResult);
			}

			function setText(options, text, isInteractive)
			{
				var fieldId, fireFieldChange = true, forceSyncSourcing = false, fireSlavingSync = false, noSlaving = false;
				if (text !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					text = options.text;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}
				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setText'));

				text = recordUtil.emptyIfNullOrUndefined(text);
				recordUtil.validateAgainstSqlInjection(fieldId, text);

				var sourcingMetadata = getSlavingMetadata(null, fieldId);
				var metadataForceSync = (sourcingMetadata && sourcingMetadata.forceSyncSlaving) ? sourcingMetadata.forceSyncSlaving : !getIsCurrentRecord();
				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				if (sourcingMetadata && forceSyncSourcing)
				{
					sourcingMetadata.forceSyncSlaving = forceSyncSourcing;
				}
				doSetText(fieldId, text, fireFieldChange, noSlaving);
				if (sourcingMetadata && forceSyncSourcing)
				{
					sourcingMetadata.forceSyncSlaving = metadataForceSync;
				}
			}

			/**
			 * set value of the field by text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @param {string} options.text ----- The text or texts to change the field value to.
			 *    If the field type is multiselect: - This parameter accepts an array of string values. - This parameter accepts a
			 *     null value. Passing in null deselects all currentlsy selected values. If the field type is not multiselect: this
			 *     parameter accepts only a single string value.
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.setText = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setText,
				emitter: emitter
			});

			function doSetText(fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				implementation.doSetText(fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting);
			}

			function doSetTexts(fieldId, texts, fireFieldChange, noSlaving, noValidation)
			{
				var sublistId = undef;
				var lineInstanceId = null;
				var isCommitted = true;
				var rf = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				var values = rf.validateSelectFieldByText(texts);
				doSetFieldValue(fieldId, values, fireFieldChange, noSlaving, undef, noValidation);
			}

			this.doSetTexts = doSetTexts;

			function findSublistLineWithValue(options, fieldId, value)
			{
				var sublistId;
				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('findSublistLineWithValue'));
				return doFindSublistLineWithValue(sublistId, fieldId, value);
			}

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId The internal ID of the sublist.
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @return {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or field is missing
			 *
			 * @since 2015.2
			 */
			this.findSublistLineWithValue = findSublistLineWithValue;

			function doFindSublistLineWithValue(sublistId, fieldId, value)
			{
				for (var lineIndex = 0; lineIndex < doGetLineCount(sublistId); lineIndex++)
					//purposefully left == so that string/number matches occur for backwards compatibility
				{
					var foundValue = doGetSublistValue(sublistId, fieldId, lineIndex);
					if (value == foundValue || ('F' === foundValue && value === false) || ('T' === foundValue && value === true))
					{
						return lineIndex;
					}
				}
				return -1;
			}

			this.doFindSublistLineWithValue = doFindSublistLineWithValue;

			function getSublistValue(options, fieldId, line)
			{
				var isCommitted = true;
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistValue'));
				validateTextApi(false, getSublistFieldState(sublistId, fieldId, line, isCommitted), 'setSublistText', 'getSublistText');
				return isWithinValidLineRange(sublistId, line) ? doGetParsedSublistValue(sublistId, fieldId, line) : undef;
			}

			/**
			 * return value of a sublist field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 *
			 * @since 2015.2
			 */
			this.getSublistValue = getSublistValue;

			function doGetParsedSublistValue(sublistId, fieldId, line)
			{
				validateLineIndex_MLB(line, sublistId, false);
				var value = undef;
				if (line >= 0)
				{
					var isCommitted = true;
					var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
					var lineDefinitionObject = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
					value = lineDefinitionObject.getParsedValueForBodyField(fieldId);
				}
				return value;
			}

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				return implementation.doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator);
			}

			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			function doGetSublistValue(sublistId, fieldId, line)
			{
				var isCommitted = true;
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var hasFieldExisted = hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, isCommitted);
				var value = !hasFieldExisted ? undef :
					getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId)
				};

				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(value, metadata);
			}

			this.doGetSublistValueForInstance = doGetSublistValueForInstance;


			function setSublistValue(options, fieldId, line, value)
			{
				implementation.setSublistValue(options, fieldId, line, value);
			}

			/**
			 * set the value of a sublist field (available for deferred dynamic only)
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 *
			 * @since 2015.2
			 */
			this.setSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setSublistValue,
				emitter: emitter
			});

			function doSetSublistValue(sublistId, fieldId, line, value)
			{
				var isCommitted = true;
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, isCommitted);
			}

			this.doSetSublistValue = doSetSublistValue;

			function finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, isCommitted)
			{
				if (isSublistValid(sublistId))
				{
					var valueObject = recordBehaviorDelegateService.createObjectToDoSetSublistValue(value, getSetFieldMetadata(sublistId, fieldId));
					getModelController()
						.setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, valueObject, isCommitted);
					recordBehaviorDelegateService.postDoSetSublistValueForInstance(that, sublistId, fieldId, lineInstanceId, isCommitted);
				}
			}

			function doSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, fireFieldChange, isCommitted, isInteractive, allowPercentage, noValidationAndFormatting)
			{
				if (!isCommitted)
				{
					doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, false, isInteractive, allowPercentage, noValidationAndFormatting);
				}
				else
				{
					finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, isCommitted);
				}
				getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted).useTextApi = false;
			}

			this.doSetSublistValueForInstance = doSetSublistValueForInstance;

			function getSetFieldMetadata(sublistId, fieldId)
			{
				//TODO
				return {
					isValidField: isValidField(sublistId, fieldId),
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
					isSelect: isFieldSelectType(sublistId, fieldId),
					isRadio: isFieldRadio(sublistId, fieldId),
					isNumeric: isFieldNumeric(sublistId, fieldId),
					isCurrency: isFieldCurrency(sublistId, fieldId),
					type: getFieldType(sublistId, fieldId)
				};
			}

			this.getSetFieldMetadata = getSetFieldMetadata;

			function getSublistText(options, fieldId, line)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistText'));
				return doGetSublistText(sublistId, fieldId, line);
			}

			/**
			 * return value of a sublist field in text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 *
			 * @since 2015.2
			 */
			this.getSublistText = getSublistText;

			function doGetSublistText(sublistId, fieldId, line)
			{
				var isCommitted = true;
				var fieldState = getSublistFieldState(sublistId, fieldId, line, isCommitted);
				validateTextApi(true, fieldState, 'setSublistValue', 'getSublistValue');
				validateLineIndex_MLB(line, sublistId, false);
				var value = undef;
				if (line >= 0)
				{
					var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
					var lineDefinitionObject = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
					value = lineDefinitionObject.doGetText(fieldId);
				}
				return value;
			}

			function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				return implementation.doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator);
			}

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			function setSublistText(options, fieldId, line, text)
			{
				implementation.setSublistText(options, fieldId, line, text);
			}

			/**
			 * set the value of a sublist field in text representation (available for deferred dynamic only)
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 *
			 * @since 2015.2
			 */
			this.setSublistText = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setSublistText,
				emitter: emitter
			});

			function doSetSublistTextForInstance(sublistId, fieldId, lineInstanceId, text, fireFieldChange, noSlaving, noValidationAndFormatting, isCommitted, isInteractive)
			{
				if (!isCommitted)
				{
					var metadata = {
						isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
						isSelect: isFieldSelectType(sublistId, fieldId),
						isRadio: isFieldRadio(sublistId, fieldId),
						radioSet: getRadioSet(fieldId),
						isValidField: isValidField(sublistId, fieldId)
					};
					var value = recordBehaviorDelegateService.convertTextToValueForSetText(that, sublistId, fieldId, lineInstanceId, text, metadata, isCommitted);
					if (metadata.isMultiSelect || metadata.isSelect || metadata.isRadio)
					{
						doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, metadata.isRadio, noValidationAndFormatting, isCommitted);
					}
					else
					{
						doSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, value, fireFieldChange, isCommitted, isInteractive, true, noValidationAndFormatting);
					}
				}
				else
				{
					finishSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, text, isCommitted);
				}
				getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted).useTextApi = true;
			}

			this.doSetSublistTextForInstance = doSetSublistTextForInstance;

			function getLineCount(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getLineCount'));
				return doGetLineCount(sublistId);
			}

			/**
			 * return line count of sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {number}
			 *
			 * @since 2015.2
			 */
			this.getLineCount = getLineCount;

			function doGetLineCount(sublistId)
			{
				return isSublistValid(sublistId) ? getModelController().getSublistLineCount(sublistId) : -1;
			}

			this.doGetLineCount = doGetLineCount;

			function insertLine(options, line)
			{
				var sublistId, beforeLineInstanceId, lineObj, ignoreRecalc = false;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					beforeLineInstanceId = options.beforeLineInstanceId;
					ignoreRecalc = options.ignoreRecalc || false;
				}

				if(isMultilineEditable(sublistId))
				{
					return insertLine_MLB(sublistId, line, beforeLineInstanceId, ignoreRecalc);
				}

				utilityFunctions.checkMutuallyExclusiveArguments(line, beforeLineInstanceId, 'line', 'beforeLineInstanceId');

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));
				if (line !== undef)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('insertLine'));
					lineObj = doInsertLine(sublistId, line, ignoreRecalc);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, beforeLineInstanceId], ['sublistId', 'beforeLineInstanceId'], getMissingArgumentErrorMessageFillerValue('insertLine'));
					lineObj = doInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc);
				}
				return !lineObj ? null : lineObj.proxy();
			}

			/*
			 * This function is intended to be used only when MultiLineBuffer feature is enabled.
			 *
			 * @param sublistId
			 * @param line
			 * @param beforeLineInstanceId
			 * @param ignoreRecalc
			 * @returns lineObject
			 */
			function insertLine_MLB(sublistId, line, beforeLineInstanceId, ignoreRecalc)
			{
				var lineObj;

				utilityFunctions.checkMutuallyExclusiveArguments(line, beforeLineInstanceId, 'line', 'beforeLineInstanceId');

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));

				if(beforeLineInstanceId === undef)
				{
					beforeLineInstanceId = getModelController().getSpecifiedLineInstanceIdByIndex(sublistId, line);
				}

				utilityFunctions.checkArgs([sublistId, beforeLineInstanceId], ['sublistId', 'beforeLineInstanceId'], getMissingArgumentErrorMessageFillerValue('insertLine'));
				lineObj = doInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc);

				return !lineObj ? null : lineObj.proxy();
			}

			/**
			 * insert a sublist line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {string} options.beforeLineInstanceId
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @return {Line} [new line object]
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and beforeLineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and beforeLineInstanceId
			 *     are missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not
			 *     editable or before exists and before is an instanceId that does not point to a line in the sublist.
			 *
			 * @since 2015.2
			 */
			this.insertLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: insertLine,
				emitter: emitter
			});

			function doInsertLine(sublistId, line, ignoreRecalc)
			{
				var isCommitted = true;
				var lineInstanceId = null;
				if (ignoreRecalc === undef)
				{
					ignoreRecalc = false;
				}

				if (isSublistAnEditMachine(sublistId))
				{
					validateLineIndex_MLB(line, sublistId, true);
					preInsertLine(sublistId, line);
					insertSublistLine(sublistId, line);
					postInsertLine(sublistId, line, ignoreRecalc);
					setSublistIsChanged(sublistId, true);
					if (!!getLineInstanceId(sublistId, line, false/*isCommitted*/))
					{
						isCommitted = false;
					}
				}
				else
				{
					isCommitted = true;
				}
				lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
			}

			this.doInsertLine = doInsertLine;

			function doInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc)
			{
				var lineObj = null;
				if (ignoreRecalc === undef)
				{
					ignoreRecalc = false;
				}

				if (isSublistAnEditMachine(sublistId))
				{
					var isCommitted = !isMultilineEditable(sublistId);
					validateLineInstanceId(sublistId, beforeLineInstanceId, isCommitted, isMultilineEditable(sublistId));
					beforeLineInstanceId = preInsertLineForInstance(sublistId, beforeLineInstanceId);
					var lineInstanceId = insertSublistLineForInstance(sublistId, beforeLineInstanceId);
					postInsertLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
					setSublistIsChanged(sublistId, true);
					lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
				}
				return lineObj;
			}

			this.doInsertLineForInstance = doInsertLineForInstance;

			function insertSublistLine(sublistId, line)
			{
				getModelController().insertSublistLine(sublistId, line);
				getSublistState(sublistId).insertLine(line, true);
				subrecord_updateFieldState(true);
			}

			function insertSublistLineForInstance(sublistId, beforeLineInstanceId)
			{
				var isCommitted = false;
				var lineInstanceId = getModelController().insertSublistLineForInstance(sublistId, beforeLineInstanceId, isMultilineEditable(sublistId));
				getSublistState(sublistId).insertLineForInstance(lineInstanceId, isCommitted, true);
				subrecord_updateFieldState(true);
				return lineInstanceId;
			}

			function preInsertLine(sublistId, line)
			{
				implementation.preInsertLine(sublistId, line);
			}

			function preInsertLineForInstance(sublistId, beforeLineInstanceId)
			{
				return implementation.preInsertLineForInstance(sublistId, beforeLineInstanceId);
			}

			function postInsertLine(sublistId, line, ignoreRecalc)
			{
				return implementation.postInsertLine(sublistId, line, ignoreRecalc);
			}

			function postInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc)
			{
				return implementation.postInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc);
			}

			function makeCopyForInstance(sublistId, lineInstanceId, isCommitted)
			{
				var returnMe;
				if (!isMultilineEditable(sublistId))
				{
					returnMe = doCopyLine(sublistId, lineInstanceId, isCommitted);
				}
				else
				{
					var lineToCopy = getModelController().getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
					var noCopyToDefaultMap = getNoCopyToDefaultMapForSublist(sublistId);
					var newLineId = getModelController()
						.makeCopyForInstance(sublistId, lineToCopy, isMultilineEditable(sublistId), noCopyToDefaultMap);
					getSublistState(sublistId).cloneLineStateToLineCopy(lineInstanceId, isCommitted, newLineId);
					var isCommitted = false;
					var copiedLine = getLineObjectFromCache(sublistId, newLineId, isCommitted);
					returnMe = !copiedLine ? null : copiedLine.proxy();
				}
				return returnMe;
			}
			this.makeCopyForInstance = makeCopyForInstance;

			function doCopyLine(sublistId, currInstanceId, isCommitted)
			{
				commitLine(sublistId);

				var lineToCopy = getModelController().getSublistLineForInstance(sublistId, currInstanceId, isCommitted);
				var noCopyToDefaultMap = getNoCopyToDefaultMapForSublist(sublistId);
				var newLineId = getModelController().updateNewLineBufferWithCopy(sublistId, lineToCopy, noCopyToDefaultMap);
				getSublistState(sublistId).cloneLineStateToLineCopy(currInstanceId, true, newLineId);
				return undef;
			}

			function copyLine(options)
			{
				var isCommitted = true;
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("copyLine"));
				var currIdx = doGetCurrentSublistIndex(sublistId);
				var currInstanceId = getLineInstanceId(sublistId, currIdx, isCommitted);

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId) && (currInstanceId != null));

				//dynamicRecord.js needs to be able to tell the difference to return a record proxy or line proxy... Better option?
				return isMultilineEditable(sublistId) ? makeCopyForInstance(sublistId, currInstanceId, isCommitted)
													  : doCopyLine(sublistId, currInstanceId, isCommitted);
			}

			/*
			 * Commits and copies the currently selected line into a new line, which will be the new selected line.
			 *
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
			 */
			this.copyLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: copyLine,
				emitter: emitter
			});

			function doResetSublistLine(sublistId, line, data)
			{
				getModelController().resetSublistLine(sublistId, line, data);
			}

			this.doResetSublistLine = doResetSublistLine;

			function doResetSublistLineForInstance(sublistId, lineInstanceId, data)
			{
				var isCommitted = false;
				getModelController().resetSublistLineForInstance(sublistId, lineInstanceId, data, isCommitted);
			}

			this.doResetSublistLineForInstance = doResetSublistLineForInstance;

			function removeLine(options, line)
			{
				var sublistId, lineInstanceId, ignoreRecalc = false;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					lineInstanceId = options.lineInstanceId;
					ignoreRecalc = options.ignoreRecalc || false;
				}
				utilityFunctions.checkMutuallyExclusiveArguments(line, lineInstanceId, 'line', 'lineInstanceId');

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));
				if (isMultilineEditable(sublistId))
				{
					if (line !== undef)
						lineInstanceId = getLineInstanceId(sublistId, line, true);
					doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
				}
				else if (line !== undef)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('removeLine'));
					doRemoveLine(sublistId, line, ignoreRecalc);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], getMissingArgumentErrorMessageFillerValue('removeLine'));
					doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
				}
			}

			/**
			 * remove a sublist line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {string} options.lineInstanceId
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and lineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and lineInstanceId are
			 *     missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not
			 *     editable
			 *
			 * @since 2015.2
			 */
			this.removeLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeLine,
				emitter: emitter
			});

			function doRemoveLine(sublistId, line, ignoreRecalc, noValidation)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					validateLineIndex_MLB(line, sublistId, false);
					removeSublistLine(sublistId, line, ignoreRecalc, noValidation);
					postRemoveLine(sublistId, line);
					setSublistIsChanged(sublistId, true);
				}
			}

			this.doRemoveLine = doRemoveLine;

			function doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					var isCommitted = true;
					if (!getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted))
					{
						validateLineInstanceId(sublistId, lineInstanceId, !isCommitted);
						functionallyCancelLineForInstance(sublistId, lineInstanceId);
					}
					else
					{
						removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
						postRemoveLineForInstance(sublistId, lineInstanceId, isCommitted);
						setSublistIsChanged(sublistId, true);
					}
				}
			}

			function removeSublistLine(sublistId, line, ignoreRecalc, noValidation)
			{
				implementation.removeSublistLine(sublistId, line, ignoreRecalc, noValidation);
			}

			function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc, noValidation)
			{
				implementation.removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc, noValidation);
			}

			function doRemoveSublistLine(sublistId, line)
			{
				var lineInstanceId = getModelController().removeSublistLine(sublistId, line);
				getSublistState(sublistId).removeLineForInstance(lineInstanceId);
				subrecord_updateFieldState(true);
				removeLineObjectFromCache(sublistId, lineInstanceId);
				return lineInstanceId;
			}

			this.doRemoveSublistLine = doRemoveSublistLine;

			function doRemoveSublistLineForInstance(sublistId, lineInstanceId)
			{
				getModelController().removeSublistLineForInstance(sublistId, lineInstanceId);
				getSublistState(sublistId).removeLineForInstance(lineInstanceId);
				subrecord_updateFieldState(true);
				removeLineObjectFromCache(sublistId, lineInstanceId);
				return lineInstanceId;
			}

			this.doRemoveSublistLineForInstance = doRemoveSublistLineForInstance;

			function postRemoveLine(sublistId, line)
			{
				implementation.postRemoveLine(sublistId, line, isMultilineEditable(sublistId));
			}

			function postRemoveLineForInstance(sublistId, lineInstanceId, isCommitted)
			{
				implementation.postRemoveLineForInstance(sublistId, lineInstanceId, isCommitted);
			}

			/**
			 * return the line number of current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			function getCurrentSublistIndex(options)
			{
				var sublistId;
				sublistId = options !== undef && options !== null && !util.isString(options) ? options.sublistId : options;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistIndex'));
				return doGetCurrentSublistIndex(sublistId);
			}

			this.getCurrentSublistIndex = getCurrentSublistIndex;

			function doGetCurrentSublistIndex(sublistId)
			{
				return getModelController().getCurrentSublistLineIndex(sublistId);
			}

			this.doGetCurrentSublistIndex = doGetCurrentSublistIndex;

			function doGetCurrentSublistLineInstanceId(sublistId)
			{
				return getModelController().getSublistSelectedLineInstanceId(sublistId);
			}

			this.doGetCurrentSublistLineInstanceId = doGetCurrentSublistLineInstanceId;

			/**
			 * select line
			 *
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {String} options.lineInstanceId
			 * @return {Line} [requested line object]
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and lineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and lineInstanceId are
			 *     missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			function selectLine(options, line)
			{
				var lineObj = implementation.selectLine(options, line);
				return !lineObj ? null : lineObj.proxy();
			}

			this.selectLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: selectLine,
				emitter: emitter
			});

			function doSelectLine(sublistId, line)
			{
				var lineInstanceId;
				if (line === doGetCurrentSublistIndex(sublistId))
				{
					lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				}
				else
				{
					validateLineIndex_MLB(line, sublistId, false);
					if (isMultilineEditable(sublistId) && getModelController().lineIndexIsNewLine_MLB(sublistId, line))
					{
						lineInstanceId = getModelController().updateCurrentLineToANewLine_MLB(sublistId, line);
					}
					else
					{
						lineInstanceId = handleSelectSublistLine(sublistId, line);
						triggerLineInitScript(sublistId);
					}
				}
				return getLineObjectFromCache(sublistId, lineInstanceId, false);
			}
			this.doSelectLine = doSelectLine;

			function doSelectLineForInstance(sublistId, lineInstanceId)
			{
				return doSelectLine(sublistId, getLineIndexFromInstanceId(sublistId, lineInstanceId, false));
			}

			this.doSelectLineForInstance = doSelectLineForInstance;

			function handleSelectSublistLine(sublistId, line)
			{
				var modelController = getModelController();
				var currentLineIndex = modelController.getCurrentSublistLineIndex(sublistId);
				var isMLB = isMultilineEditable(sublistId);
				if (!isMLB) {
					if (getSublistState(sublistId).isLineInserted(currentLineIndex)) {
						doRemoveSublistLine(sublistId, currentLineIndex);
						if (currentLineIndex <  line)
							line--;
					}
					getSublistState(sublistId).removeCurrentLineState();
				}
				var lineInstanceId = modelController.selectSublistLine(sublistId, line, isMLB);
				getSublistState(sublistId).resetCurrentLineState(line);
				subrecord_updateFieldState(true);
				return lineInstanceId;
			}

			function selectNewLine(options)
			{
				var lineObj = implementation.selectNewLine(options);
				return !lineObj ? null : lineObj.proxy();
			}

			/**
			 * select a new line at the end of sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} [new line object]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.selectNewLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: selectNewLine,
				emitter: emitter
			});

			function doSelectNewLine(sublistId, ignoreLineInit)
			{
				ignoreLineInit = ignoreLineInit || false;
				var lineObj = null;

				if (isSublistAnEditMachine(sublistId))
				{
					if(isMultilineEditable(sublistId))
					{
						// selectNewLine = addNewLine + selectLine
						lineObj = doAddNewLine(sublistId);
						getModelController().updateCurrentLineToANewLine_MLB(sublistId, lineObj.sequence);
					}
					else
					{
						var lineInstanceId = handleSelectNewSublistLine(sublistId);
						if (!ignoreLineInit)
						{
							triggerLineInitScript(sublistId);
						}

						lineObj = getLineObjectFromCache(sublistId, lineInstanceId, false);
					}
				}
				return lineObj;
			}

			this.doSelectNewLine = doSelectNewLine;

			function handleSelectNewSublistLine(sublistId)
			{
				var modelController = getModelController();
				var currentLineIndex = modelController.getCurrentSublistLineIndex(sublistId);
				if (currentLineIndex !== modelController.getNewLineIndex(sublistId)) {
					if (!isMultilineEditable(sublistId)) {
						if (getSublistState(sublistId).isLineInserted(currentLineIndex)) {
							doRemoveSublistLine(sublistId, currentLineIndex);
						}
						getSublistState(sublistId).removeCurrentLineState();
					}
					modelController.selectNewSublistLine(sublistId, _metadata.getSublistDefaultValue(sublistId));
					getSublistState(sublistId).resetCurrentLineState(doGetLineCount(sublistId));
					subrecord_updateFieldState(true);
				}
				return modelController.getSublistSelectedLineInstanceId(sublistId);
			}

			function validateGetLineOperation(sublistId, isCommitted)
			{
				utilityFunctions.assertTrue(isSublistValid(sublistId), error.Type.INVALID_SUBLIST_OPERATION);
				utilityFunctions.assertTrue(isCommitted || getIsDynamicRecord(), error.Type.INVALID_SUBLIST_OPERATION);
			}

			function getLine(options)
			{
				var sublistId;
				var lineInstanceId;
				var isCommitted;

				if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					lineInstanceId = options.lineInstanceId;
					isCommitted = util.isBoolean(options.isCommitted) ? options.isCommitted : false;
				}
				utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], getMissingArgumentErrorMessageFillerValue('getLine'));
				validateGetLineOperation(sublistId, isCommitted);

				// Update once everything is calm and settled. Safer this way than updating all old APIs.
				var allowFallback = true;
				var lineExists = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted, allowFallback);
				if (!lineExists)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
				}

				var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
				return !lineObj ? null : lineObj.proxy();
			}
			this.getLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getLine,
				emitter: emitter
			});



			function getLinesIterator(options)
			{
				var sublistId;
				var isCommitted;

				if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					isCommitted = util.isBoolean(options.isCommitted) ? options.isCommitted : false;
				}
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getLinesIterator'));
				validateGetLineOperation(sublistId, isCommitted);
				// Update once everything is calm and settled. Safer this way than updating all old APIs.
				var result = {
					each: function (func)
					{
						var instanceIds = getModelController().getSublistLineInstanceIds(sublistId, isCommitted);
						instanceIds.forEach(function(lineInstanceId) {
							var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
							func(lineObj.proxy());
						})
					},
					next: (function ()
					{
						var index = 0;
						var done = false;
						var instanceIds = getModelController().getSublistLineInstanceIds(sublistId, isCommitted);

						return function ()
						{
							var lineInstanceId, lineObj;
							var result = {done: done};
							if (!done)
							{
								done = !(index < instanceIds.length);
								if (!done)
								{
									lineInstanceId = instanceIds[index];
									lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
									index += 1;
									result.value = lineObj.proxy();
								}
							}
							result.done = done;
							return result;
						};
					})()
				};

				return Object.freeze(result);
			}

			this.getLinesIterator = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getLinesIterator,
				emitter: emitter
			});

			function getLines(options) {
				if (options === undef || options === null)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "getLines", "options");
				}

				var sublistId = options.sublistId;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getLines'));

				var orderBy = options.orderBy;

				utilityFunctions.checkMutuallyExclusiveArguments(options.isCommitted, options.currentState, 'isCommitted', 'currentState');
				var isCommitted = util.isBoolean(options.isCommitted) ? options.isCommitted : false;
				var currentState = util.isBoolean(options.currentState) ? options.currentState : false;

				validateGetLineOperation(sublistId, isCommitted);

				var lineInstanceIds = getModelController().getSublistLineInstanceIds(sublistId, isCommitted);
				var lines = lineInstanceIds.map(function (lineInstanceId) {
					var lineObj = null;
					if (currentState)
					{
						var linePkg = getExistingLineObjectFromCache(sublistId, lineInstanceId);
						if (!!linePkg.line)
						{
							lineObj = linePkg.line.proxy();
							lineObj._state = linePkg.state;
						}
						return lineObj;
					}
					else
					{
						lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
						return !lineObj ? null : lineObj.proxy();
					}
				});

				if (orderBy === undef || orderBy === null)
					return lines; // return non-sorted version
				else
					return doSortingForLines(lines, orderBy, sublistId);
			}

			function doSortingForLines(lines, orderBy, sublistId) {

				if (!getIsReadOnlyRecord())
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				}
				if (!(util.isString(orderBy) || util.isArray(orderBy)))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
				}

				// multiple field sort not yet supported
				var sortFieldId = util.isString(orderBy) ? orderBy : (util.isArray(orderBy) && orderBy.length === 1) ? orderBy[0].fieldId : null;
				if (!sortFieldId) {
					return lines; // return non-sorted version
				}

				var sortFieldType = _metadata.getFieldMetadata(sublistId, sortFieldId).type;
				var sortAscending = (util.isArray(orderBy) && orderBy.length === 1 && typeof orderBy[0].ascending !== 'undefined') ? orderBy[0].ascending : true;
				if (!util.isBoolean(sortAscending)) {
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
				}

				lines.sort(getSortFunction(sortFieldType, sortFieldId, sortAscending));
				return lines;
			}

			/*
			 * This is a helper function that returns a sorter for the given fieldType, fieldId and order
			 */
			var getSortFunction = (function () {
				var TEXT_API = 'getText';
				var VALUE_API = 'getValue';

				function lineSorter(apiCall, comparator, fieldType, fieldId, order, line1, line2) {
					return order * comparator(line1[apiCall](fieldId), line2[apiCall](fieldId), fieldType);
				}

				var sortFunctions = {};
				sortFunctions[fieldTypeConstants.Type.TEXT]             = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);
				sortFunctions[fieldTypeConstants.Type.TEXTAREA]         = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);
				sortFunctions[fieldTypeConstants.Type.EMAIL]            = lineSorter.bind(null, TEXT_API,  formatter.comparators.emailComaparator);
				sortFunctions[fieldTypeConstants.Type.DOCUMENT]         = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);

				sortFunctions[fieldTypeConstants.Type.INTEGER]          = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.POSINTEGER]       = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.DYNAMICPRECISION]   	= lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.FLOAT]            = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.POSFLOAT]         = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.NONNEGFLOAT]      = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.RATE]             = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.RATEHIGHPRECISION]= lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.PERCENT]          = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.CURRENCY]         = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.CURRENCY2]        = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.PHONE]            = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);

				sortFunctions[fieldTypeConstants.Type.SELECT]           = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);
				sortFunctions[fieldTypeConstants.Type.CHECKBOX]         = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);

				sortFunctions[fieldTypeConstants.Type.TIME]             = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.TIMETRACK]        = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);

				sortFunctions[fieldTypeConstants.Type.DATE]             = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.MMYYDATE]         = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.DATETIME]         = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.DATETIMETZ]       = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.TIMEOFDAY]        = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);

				return (
					function getSortFunctionsByFieldType(fieldType, fieldId, ascOrder) {
						var order = !!ascOrder ? 1 : -1;
						if (sortFunctions[fieldType]) {
							return sortFunctions[fieldType].bind(null, fieldType, fieldId, order);
						}
						else {
							//field type isn't supported yet.
							utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
						}
					}
				);
			})();

			/*
			 * return an array of sublist lines in a sorted order
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {(string|Array)} options.orderBy
			 * @return {Array} array of line objects
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION if ascending is missing or undefined or not a boolean when orderBy is an array.
			 * @restriction only available in readonly record
			 */
			this.getLines = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: getLines,
				emitter: emitter
			});

			function doAddNewLine(sublistId)
			{
				var isCommitted = false;
				var lineObj = null;

				if (!isMultilineEditable(sublistId))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);

				if (isSublistAnEditMachine(sublistId))
				{
					var lineInstanceId = getModelController().addNewSublistLine(sublistId, _metadata.getSublistDefaultValue(sublistId));
					getSublistState(sublistId).resetBufferLineStateForInstance(lineInstanceId, isCommitted);
					getModelController().runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, triggerLineInitScript, implementation, [sublistId]);
					lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
				}
				return lineObj;
			}
			this.doAddNewLine = doAddNewLine;

			function addNewLine(options)
			{
				var lineObj = implementation.addNewLine(options);
				return !lineObj ? null : lineObj.proxy();
			}
			/*
			 * Creates a new line to the specified sublist and adds it to the end of the sublist sequentially.
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} the Line object that was created.
			 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {error.SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			this.addNewLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: addNewLine,
				emitter: emitter
			});

			function cancelLine(options)
			{
				implementation.cancelLine(options);
			}

			/**
			 * cancel the current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.cancelLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: cancelLine,
				emitter: emitter
			});

			function doCancelLine(sublistId)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					var line = doGetCurrentSublistIndex(sublistId);
					validateLineIndex_MLB(line, sublistId, true);
					var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
					doCancelLineForInstance(sublistId, lineInstanceId);
				}
			}

			this.doCancelLine = doCancelLine;

			function cancelLineForInstance(sublistId, lineInstanceId)
			{
				implementation.cancelLineForInstance(sublistId, lineInstanceId);
			}

			this.cancelLineForInstance = cancelLineForInstance;

			function functionallyCancelLineForInstance(sublistId, lineInstanceId)
			{
                doCancelLineForInstance(sublistId, lineInstanceId, true)
			}

			function doCancelLineForInstance(sublistId, lineInstanceId, originNotCancel)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					var isCommitted = true;
					var lineIndex = getLineIndexFromInstanceId(sublistId, lineInstanceId, !isCommitted);
					var isMLB = isMultilineEditable(sublistId);
					dereferencedSublistLineSubrecords(sublistId, lineInstanceId, !isCommitted);
					if (!isMLB && getSublistState(sublistId).isLineInsertedForInstance(lineInstanceId, isCommitted))
					{
						doRemoveSublistLineForInstance(sublistId, lineInstanceId);
					}
					else
					{
						getSublistState(sublistId).removeSublistLineState(lineInstanceId, !isCommitted);
					}
					getModelController().cancelSublistLineForInstance(sublistId, lineInstanceId, originNotCancel);
					subrecord_updateFieldState(true);

					if(!isMLB)
					{
						postCancelLine(sublistId, lineIndex);
					}
				}
			}

			this.doCancelLineForInstance = doCancelLineForInstance;

			function postCancelLine(sublistId, line)
			{
				var lineObj = null;

				if (line < doGetLineCount(sublistId))
				{
					lineObj = doSelectLine(sublistId, line);
				}
				else
				{
					lineObj = doSelectNewLine(sublistId);
				}

				return lineObj;
			}

			function commitLine(options)
			{
				var modelController = getModelController();
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("commitLine"));
				var lineInstanceId = modelController.getSublistSelectedLineInstanceId(sublistId);
				var isCommittable = modelController.isSelectedLineCommittable(lineInstanceId);
				if (isCommittable) {
					implementation.commitLine(options);
				} else {
					return null;
				}
			}

			/**
			 * commit the current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.commitLine = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: commitLine,
				emitter: emitter
			});

			function doCommitLine(sublistId, ignoreRecalc)
			{
				if (isSublistEditable(sublistId))
				{
					var line = doGetCurrentSublistIndex(sublistId);
					validateLineIndex_MLB(line, sublistId, true);
					var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
					doCommitLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
					if (isSublistAnEditMachine(sublistId) && !isMultilineEditable(sublistId))
					{
						doSelectNewLine(sublistId);
					}
				}
			}

			this.doCommitLine = doCommitLine;

			function commitLineForInstance(sublistId, lineInstanceId)
			{
				implementation.commitLineForInstance(sublistId, lineInstanceId);
			}

			this.commitLineForInstance = commitLineForInstance;

			function doCommitLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				if (isSublistEditable(sublistId))
				{
					var isCommitted = false;
					triggerValidateLineScript(sublistId);
					getModelController().validateCurrentSublistSubrecordsForInstance(sublistId, lineInstanceId);
					getSublistState(sublistId).commitLineForInstance(lineInstanceId);
					getModelController().commitSublistLineForInstance(sublistId, lineInstanceId, isMultilineEditable(sublistId));
					subrecord_updateFieldState(true);
					if (!ignoreRecalc)
					{
						triggerRecalcScript(sublistId, false, 'commit');
					}
					if (isSublistAnEditMachine(sublistId))
					{
						triggerLineCommitScriptForInstance(sublistId, lineInstanceId, isCommitted);
					}
				}
			}

			this.doCommitLineForInstance = doCommitLineForInstance;

			function constructLineObject(sublistId, lineInstanceId, isCommitted)
			{
				var lineObj;
				var lineOptions = {
					unproxiedRecord: that,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					fromBuffer: !isCommitted,
					isReadOnly: getIsReadOnlyRecord() || (getIsDynamicRecord() && isCommitted)
				};
				lineObj = new lineDefinition(lineOptions);
				return lineObj;
			}

			function constructPostSetObject(sublistId, fieldId, dbValue, fireFieldChange, noSlaving, noValidation)
			{
				return {
					sublistId: sublistId,
					fieldId: fieldId,
					dbValue: dbValue,
					fireFieldChange: fireFieldChange,
					noSlaving: noSlaving,
					noValidation: noValidation
				};
			}

			function getCurrentSublistValue(options, fieldId)
			{
				return implementation.getCurrentSublistValue(options, fieldId);
			}

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistValue = getCurrentSublistValue;

			function doGetCurrentSublistValue(sublistId, fieldId)
			{
				var hasFieldExisted = hasCurrentSublistFieldValueOrSublistFieldExisted(sublistId, fieldId);
				var value = !hasFieldExisted ? undef : getModelController().getCurrentSublistLineValue(sublistId, fieldId);
				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId)
				};
				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(value, metadata);
			}

			function setCurrentSublistValue(options, fieldId, value, isInteractive)
			{
				implementation.setCurrentSublistValue(options, fieldId, value, isInteractive);
			}

			//!!@ Issue 446030 - this API appears to be unused. Scott will investigate.
			function setSublistBufferValue(options)
			{
				implementation.setSublistBufferValue(options);
			}

			this.setSublistBufferValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setSublistBufferValue,
				emitter: emitter
			});

			/**
			 * set the value for field in the current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD
			 *     if user tries to edit readonly sublist field
			 *
			 * @since 2015.2
			 */
			this.setCurrentSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setCurrentSublistValue,
				emitter: emitter
			});

			function doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting);
			}

			this.doSetCurrentSublistValue = doSetCurrentSublistValue;

			function doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting)
			{
				var isCommitted = false;
				validateIfSublistIdEditableAndInstanceIdValid(sublistId, lineInstanceId, isCommitted);
				var validatedValue = value;
				if (!skipInternalOptionValidaton(sublistId, fieldId, doGetCurrentSublistIndex(sublistId)))
				{
					value = recordUtil.emptyIfNullOrUndefined(value);
					if (isFieldMultiSelect(sublistId, fieldId))
						value = recordUtil.formatValueToArrayType(value);
					else if (isFieldRadio(sublistId, fieldId))
						value = String(value);
					validatedValue = noValidationAndFormatting ? value : validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, value, isInteractive, allowPercentage);
				}
				var valueIsFormattedAsString = false;
				doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, validatedValue, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidationAndFormatting, isCommitted);
			}

			this.doSetSublistBufferValue = doSetSublistBufferValue;

			function validateIfSublistIdEditableAndInstanceIdValid(sublistId, instanceId, isCommitted)
			{
				var sublistMetadata = getSublistMetadata(sublistId);

				recordUtil.assertValidSublistOperation(sublistMetadata !== null);
				if (sublistMetadata.displayOnly)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD, sublistId);
				}
				var allowFallback = true;
				validateLineInstanceId(sublistId, instanceId, isCommitted, allowFallback);
			}

			this.validateIfSublistIdEditableAndInstanceIdValid = validateIfSublistIdEditableAndInstanceIdValid;

			function doSetCurrentSublistFieldValue(sublistId, fieldId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidation)
			{
				var isCommitted = false;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidation, isCommitted);
			}

			this.doSetCurrentSublistFieldValue = doSetCurrentSublistFieldValue;

			function doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidation, isCommitted)
			{
				var relevantMetadata = getSetFieldMetadata(sublistId, fieldId);
				relevantMetadata.valueIsFormattedAsString = valueIsFormattedAsString;
				var valueObject = recordBehaviorDelegateService.createObjectToDoSetValue(value, relevantMetadata);
				getModelController().setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, valueObject, isCommitted);
				var postSetObject = constructPostSetObject(sublistId, fieldId, valueObject.legacyStringValue,
					fireFieldChange, noSlaving, noValidation);
				var fieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				fieldState.isParsed = !valueIsFormattedAsString;
				fieldState.isChanged = true;
				recordBehaviorDelegateService.postDoSetValueForInstance(that, postSetObject, lineInstanceId, isCommitted);
			}

			this.doSetSublistBufferFieldValue = doSetSublistBufferFieldValue;

			function getCurrentSublistText(options, fieldId)
			{
				return implementation.getCurrentSublistText(options, fieldId);
			}

			/**
			 * return the value for field in the current selected line by text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistText = getCurrentSublistText;

			function setCurrentSublistText(options, fieldId, text, isInteractive)
			{
				implementation.setCurrentSublistText(options, fieldId, text, isInteractive);
			}

			/**
			 * set the value for field in the current selected line by text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD
			 *     if user tries to edit readonly sublist field
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.setCurrentSublistText = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: setCurrentSublistText,
				emitter: emitter
			});

			function doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting, isInteractive)
			{
				var isCommitted = false;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doSetSublistTextForInstance(sublistId, fieldId, lineInstanceId, text, fireFieldChange, noSlaving, noValidationAndFormatting, isCommitted, isInteractive);
			}

			this.doSetCurrentSublistText = doSetCurrentSublistText;

			function overwriteSublistState(clonedSublistState, sourceSublistState)
			{
				clonedSublistState.isDisplay = sourceSublistState.isDisplay;
				clonedSublistState.isChanged = sourceSublistState.isChanged;
				clonedSublistState.isHidden = sourceSublistState.isHidden;

				for (var i = 0; i < sourceSublistState.getLineCount(); i++)
				{
					var lineFields = sourceSublistState.getAllLineFields(i) || [];
					lineFields.forEach(function (v, i, a)
					{
						overwriteFieldState(clonedSublistState.getFieldState(v, i), sourceSublistState.getFieldState(v, i), false);
					});
				}

				return clonedSublistState;
			}

			function overwriteSublistsState(sink, source)
			{
				source.getAllSublists().forEach(function (sublistId, i, a)
				{
					overwriteSublistState(sink.getSublistState(sublistId), source.getSublistState(sublistId));
				});

				return sink;
			}

			function overwriteFieldState(clonedFieldState, sourceFieldState)
			{
				clonedFieldState.useTextApi = sourceFieldState.useTextApi;
				clonedFieldState.isParsed = sourceFieldState.isParsed;
				clonedFieldState.isMandatory = sourceFieldState.isMandatory;
				clonedFieldState.isHidden = sourceFieldState.isHidden;
				clonedFieldState.isDisabled = sourceFieldState.isDisabled;
				clonedFieldState.isVisible = sourceFieldState.isVisible;
				clonedFieldState.isDisplay = sourceFieldState.isDisplay;
				clonedFieldState.isReadOnly = sourceFieldState.isReadOnly;
				clonedFieldState.ignoreSlaving = sourceFieldState.ignoreSlaving;
				clonedFieldState.isChanged = sourceFieldState.isChanged;
				clonedFieldState.label = sourceFieldState.label;
				clonedFieldState.id = sourceFieldState.id;

				return clonedFieldState;
			}

			function overwriteFieldsState(clonedRecordStateController, sourceRecordStateController)
			{
				sourceRecordStateController.getAllFields().forEach(function (fieldId, i, a)
				{
					overwriteFieldState(clonedRecordStateController.getFieldState(fieldId), sourceRecordStateController.getFieldState(fieldId));
				});

				return clonedRecordStateController;
			}

			function overwriteRecordState(clonedRecordStateController, sourceRecordStateController)
			{
				overwriteFieldsState(clonedRecordStateController, sourceRecordStateController);
				overwriteSublistsState(clonedRecordStateController, sourceRecordStateController);

				return clonedRecordStateController;
			}

			function clone(options)
			{
				options = options || {};
				options.cloneable = options.cloneable !== undefined ? !!options.cloneable : true;
				options.mergeable = options.mergeable !== undefined ? !!options.mergeable : false;

				var clonedModelController = getModelController().clone(),
					clonedMetadata = getMetadata().clone(),
					clonedState = overwriteRecordState(recordStateController.create({
						metadata: clonedMetadata,
						data: clonedModelController,
						// TODO this may not be sufficient
						getModelController: function ()
						{
							return clonedModelController;
						}
					}), getRecordStateController());

				var R = {
					id: that.id,
					data: clonedModelController,
					metadata: clonedMetadata,
					state: clonedState,
					isDynamic: true,
					isSubrecord: true,
					isUserEvent: false,
					recordContext: util.extend({}, _recordRequestContext)
				};
				var recordClone = new Record({
					recordObj: R,
					cloneable: options.cloneable,
					merge: (options.mergeable ? function ()
					{
						return merge(recordClone);
					} : undef)
				});

				if (getIsSubrecord())
				{
					recordClone.link(subrecordParent, subrecordSublistId, subrecordFieldId);
				}
				freshCopies.add(recordClone);

				return recordClone;
			}

			function merge(copy)
			{
				if (!freshCopies.contains(copy))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBRECORD_MERGE);
				}
				else
				{
					var sysId = getValue(subrecordUtil.SYS_ID);
					var sysParentId = getValue(subrecordUtil.SYS_PARENT_ID);

					copy.validate();

					var clonedMetadata = copy.getMetadata().clone();
					setMetadata(clonedMetadata);

					var clonedModelController = copy.getModelController().clone();
					setModelController(clonedModelController);

					var newRecordState = overwriteRecordState(
						recordStateController.create({
							metadata: clonedMetadata,
							data: clonedModelController,
							getModelController: getModelController
						}),
						copy.getRecordStateController());

					setRecordStateController(newRecordState);

					// TODO figure out why these are getting lost so they dont need to be reset
					copy.setValue(subrecordUtil.SYS_ID, sysId);
					copy.setValue(subrecordUtil.SYS_PARENT_ID, sysParentId);
					that.setValue(subrecordUtil.SYS_ID, sysId);
					that.setValue(subrecordUtil.SYS_PARENT_ID, sysParentId);

					freshCopies.add(copy);
				}
			}

			/* synchronization */
			/*
			 * synchronize the line removal;
			 * @param {Record} record
			 * @return {Record} same record, for chaining
			 */
			function synchronization_removelines(dynamicRecord)
			{
				var sublists = getModelController().getSublists();
				for (var i = 0; i < sublists.length; i++)
				{
					var sublistId = sublists[i];
					var sublistState = getSublistState(sublistId);
					if (!sublistState && shouldValidateFieldPermissions())
					{
						utilityFunctions.throwSuiteScriptError(error.Type.WS_NO_PERMISSIONS_TO_SET_VALUE, sublistId);
					}
					if (!sublistState || !sublistState.isChanged)
					{
						continue;
					}

					for (var lineNum = dynamicRecord.doGetLineCount(sublistId) - 1; lineNum >= 0; lineNum--)
					{

						if (dynamicRecord.getSublistState(sublistId) && dynamicRecord.getSublistState(sublistId)
								.isLineInserted(lineNum))
						{
							continue;
						}
						if (sublistState.isLineRemoved(lineNum))
						{
							dynamicRecord.doSelectLine(sublistId, lineNum);
							dynamicRecord.doRemoveLine(sublistId, dynamicRecord.doGetCurrentSublistIndex(sublistId));
						}
					}
				}

				return dynamicRecord;
			}

			function synchronize(deferredDynamicRecordState, record)
			{
				deferredDynamicRecordState = deferredDynamicRecordState || _state;

				var fieldId,
					fieldLevelMetadata,
					fieldState,
					fieldChanged,
					isSubrecordField,
					deferredSubrecord,
					subrecord,
					sysIdsUpdated;

				if (!record) // synchronize self
				{
					var newRecordObj = util.extend({}, recordObj);
					newRecordObj.isDynamic = true;
					record = new Record({'recordObj': newRecordObj});
				}

				//1a body field changes
				var sorted_bodyFields = _metadata.sortedFields;
				for (var i = 0; i < sorted_bodyFields.length; i++)
				{
					fieldId = sorted_bodyFields[i];
					fieldLevelMetadata = _metadata.getFieldMetadata(null, fieldId);
					isSubrecordField = !!fieldLevelMetadata && fieldLevelMetadata.type === 'summary';
					fieldState = deferredDynamicRecordState.getFieldState(fieldId);
					fieldChanged = !!fieldState && fieldState.isChanged;

					if (isSubrecordField)
					{
						if (!sysIdsUpdated)
						{
							record.setValue(subrecordUtil.SYS_ID, getValue(subrecordUtil.SYS_ID));
							record.setValue(subrecordUtil.SYS_PARENT_ID, getValue(subrecordUtil.SYS_PARENT_ID));
							sysIdsUpdated = true;
						}

						deferredSubrecord = getModelController().getSubrecord(fieldId);

						if (fieldChanged)
						{
							record.doRemoveSubrecord(fieldId);
						}
						if (!!deferredSubrecord)
						{
							subrecord = record.doGetBodySubrecord(fieldId);
							subrecord = deferredSubrecord.synchronize(deferredSubrecord.getRecordStateController(), subrecord);
							subrecord.validate();
						}
					}
					else
					{
						if (fieldChanged)
						{
							if (fieldState.useTextApi)
							{
								record.setText(fieldId, getText(fieldId));
							}
							else
							{
								record.setValue(fieldId, getValue(fieldId));
							}
						}
					}
				}
				//1b non standard field changes
				var fields = deferredDynamicRecordState.getAllFields();
				for (var j = 0; j < fields.length; j++)
				{
					fieldId = fields[j];
					fieldLevelMetadata = _metadata.getFieldMetadata(undef, fieldId);
					fieldState = deferredDynamicRecordState.getFieldState(fieldId);
					fieldChanged = !!fieldState && fieldState.isChanged;

					if (fieldLevelMetadata == null && fieldChanged)
					{
						if (fieldState.useTextApi)
						{
							record.setText(fieldId, getText(fieldId));
						}
						else
						{
							record.setValue(fieldId, getValue(fieldId));
						}
					}
				}

				//2 Remove any pre-existing sublist lines changed by the script/program/client
				record = synchronization_removelines(record);
				//3 Apply sublists` changes in the order they naturally occur in the record. Apply sublist field changes based on
				// dependency graph and logical order
				var sublists = _metadata.sortedSublists;
				for (var k = 0; k < sublists.length; k++)
				{
					var sublistId = sublists[k];
					var sublistState = getSublistState(sublistId);
					var sublistMetadata = getSublistMetadata(sublistId);

					if (!sublistState || !sublistState.isChanged || !sublistMetadata)
					{
						continue;
					}

					if (sublistMetadata)
					{
						for (var deferredDynamicRecordLineNum = 0, dynamicRecordLineNum = 0;
							deferredDynamicRecordLineNum < doGetLineCount(sublistId);
							deferredDynamicRecordLineNum++, dynamicRecordLineNum++)
						{
							var dynamicRecordLineCount = record.doGetLineCount(sublistId);
							var lineObj = null;
							if (sublistState.isLineInserted(deferredDynamicRecordLineNum))
							{
								if (record.doGetLineCount(sublistId) < dynamicRecordLineNum)
								{
									lineObj = record.doSelectNewLine(sublistId);
								}
								else
								{
									lineObj = record.doInsertLine(sublistId, dynamicRecordLineNum, sublistMetadata.isRecalcDeferred);
								}
							}
							else if (sublistState.isLineChanged(deferredDynamicRecordLineNum))
							{
								lineObj = record.doSelectLine(sublistId, dynamicRecordLineNum);
							}
							else
							{
								continue;
							}

							//TODO: update subrecord "thereWereRecordsToUpdate"
							var sys_id = doGetSublistValue(sublistId, subrecordUtil.SYS_ID, deferredDynamicRecordLineNum);
							if (!utilityFunctions.isValEmpty(sys_id))
							{
								record.doSetCurrentSublistFieldValue(sublistId, subrecordUtil.SYS_ID, sys_id, false);
							}
							// 3a : set any changed/submitted fields on the line
							var sortedFields = sublistMetadata.sortedFields;
							for (var l = 0; l < sortedFields.length; l++)
							{
								fieldId = sortedFields[l];
								fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
								isSubrecordField = !!fieldLevelMetadata && fieldLevelMetadata.type === 'summary';
								fieldState = sublistState.getFieldState(fieldId, deferredDynamicRecordLineNum);
								fieldChanged = !!fieldState && fieldState.isChanged;
								if (isSubrecordField)
								{
									if (!sysIdsUpdated)
									{
										record.doSetCurrentSublistFieldValue(sublistId, subrecordUtil.SYS_ID, doGetSublistValue(sublistId, subrecordUtil.SYS_ID, deferredDynamicRecordLineNum), false);
										record.doSetCurrentSublistFieldValue(sublistId, subrecordUtil.SYS_PARENT_ID, doGetSublistValue(sublistId, subrecordUtil.SYS_PARENT_ID, deferredDynamicRecordLineNum), false);
										sysIdsUpdated = true;
									}

									deferredSubrecord = getModelController()
										.getSublistSubrecord(sublistId, fieldId, deferredDynamicRecordLineNum);

									if (fieldChanged)
									{
										record.removeCurrentSublistSubrecord(sublistId, fieldId);
									}
									if (!!deferredSubrecord)
									{
										subrecord = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
										subrecord = deferredSubrecord.synchronize(deferredSubrecord.getRecordStateController(), subrecord);
										subrecord.validate();
									}
								}
								else
								{
									if (fieldChanged)
									{
										if (fieldState.useTextApi)
										{
											record.doSetCurrentSublistText(sublistId, fieldId, getSublistText(sublistId, fieldId, deferredDynamicRecordLineNum));
										}
										else
										{
											record.doSetCurrentSublistValue(sublistId, fieldId, getSublistValue(sublistId, fieldId, deferredDynamicRecordLineNum));
										}
									}
								}
							}

							var backwardCompatibilityFieldNames = sublistMetadata.backwardCompatibilityFieldNamesForSubrecord;
							var sublistFields = sublistState.getAllFields();
							for (var m = 0; m < sublistFields.length; m++)
							{
								var sublistFieldName = sublistFields[m];
								if (backwardCompatibilityFieldNames.indexOf(sublistFieldName) == -1 &&
									sublistMetadata.getFieldMetadata(sublistFieldName) == null &&
									sublistState.getFieldState(sublistFieldName, deferredDynamicRecordLineNum).isChanged)
								{
									if (sublistState.getFieldState(fieldId, deferredDynamicRecordLineNum).useTextApi)
									{
										record.doSetCurrentSublistText(sublistId, fieldId, getSublistText(sublistId, sublistFieldName, deferredDynamicRecordLineNum), false);
									}
									else
									{
										record.doSetCurrentSublistValue(sublistId, sublistFieldName, getSublistValue(sublistId, sublistFieldName, deferredDynamicRecordLineNum), false);
									}
								}
							}

							record.doCommitLine(sublistId, sublistMetadata.isRecalcDeferred);
							var linesAddedInThisIteration = record.doGetLineCount(sublistId) - dynamicRecordLineCount;

							// In some cases when a line is committed, more that one line is added to the
							// machine.  For example, when an item group is set on a line, its members
							// are expanded.
							// We need to account for this by incrementing the dynamic record line number by the
							// number of lines beyond one.
							if (linesAddedInThisIteration > 1)
							{
								dynamicRecordLineNum = dynamicRecordLineNum + linesAddedInThisIteration - 1;
							}
						}

						if (sublistMetadata.isRecalcDeferred)
						{
							record.triggerRecalcScript(sublistId, false, 'batchcommit');
						}
					}
				}

				return record;
			}

			this.synchronize = synchronize;

			function getQuery()
			{
				return slaving.cleanupQueryURL(_metadata.queryUrl);
			}

			function save(options, returnFetchedObject)
			{
				options = options || {};
				if (returnFetchedObject)
				{
					options.returnLabel = true;
					options.returnMessage = true;
				}
				else
					delete options.isFormSave; // allow this only in saveAndFetch (which is only available in interactive mode)

				/* It's not allowed to save the current record from within a client script. */
				if (getIsCurrentRecord() && scope.isExecutionWithinAClientScript())
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				}

				var argList = doSave(options);
				var result = invoker(remoteApi, 'submitDynamicClientRecord', argList);
				try
				{
					return returnFetchedObject ? saveResult.create(options, result) : parseInt(result.recordData.id, 10);
				}
				finally
				{
					dereferencedBodySubrecords();
				}
			}

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {number} id of submitted record
			 *
			 * @since 2015.2
			 */
			this.save = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return save(options, false); },
				emitter: emitter
			});

			/*
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Object} contains id of submitted record
			 */
			this.saveAndFetch = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return save(options, true); },
				emitter: emitter
			});

			function promiseToSave(options, returnFetchedObject)
			{
				options = options || {};
				if (returnFetchedObject)
				{
					options.returnLabel = true;
					options.returnMessage = true;
				}
				else
					delete options.isFormSave; // allow this only in saveAndFetch (which is only available in interactive mode)

				function preSubmitDynamicClientRecord(promiseCallbacks)
				{
					var argList = doSave(options);
					invoker(remoteApi, 'submitDynamicClientRecord', argList, postSubmitDynamicClientRecord.bind(this, promiseCallbacks));
				}

				function postSubmitDynamicClientRecord(promiseCallbacks, result, exception)
				{
					try
					{
						if (exception == undef)
						{
							dereferencedBodySubrecords();
							promiseCallbacks.resolve(returnFetchedObject ? saveResult.create(options, result) : parseInt(result.recordData.id, 10));
						}
						else
						{
							promiseCallbacks.reject(exception);
						}
					}
					catch (e)
					{
						promiseCallbacks.reject(e);
					}
				}

				var myPromise = getModelController().getPendingSavePromise({delegateFunction: preSubmitDynamicClientRecord});
				return myPromise;
			}

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Promise} id of submitted record
			 *
			 * @since 2015.2
			 */
			this.save.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return promiseToSave(options, false); },
				emitter: emitter
			});

			/*
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Promise} Object containing id of submitted record
			 */
			this.saveAndFetch.promise = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: function(options) { return promiseToSave(options, true); },
				emitter: emitter
			});

			function doSave(options)
			{
				options = options || {};
				var submitOptions = {
					enablesourcing: options['enableSourcing'] === true,
					disabletriggers: options['disableTriggers'] === true,
					ignoremandatoryfields: options['ignoreMandatoryFields'] === true,
					returnlabel: options['returnLabel'] === true,
					returnmessage: options['returnMessage'] !== false,
					failOnAfterSubmitScriptError: options['returnMessage'] === false
				};
				if (options.hasOwnProperty('isFormSave'))
					submitOptions.isFormSave = options.isFormSave === true;

				handleRecordSpecificSaveOptions(getRecordType(), options, submitOptions);

				var dynamicRecordToBeSubmitted = getIsDynamicRecord() ? that : synchronize(_state);

				dynamicRecordToBeSubmitted.commitSubrecords();
				getModelController().setSaveRecordScriptTriggered();
				dynamicRecordToBeSubmitted.triggerSaveRecordScript(submitOptions.ignoremandatoryfields);
				getModelController().unsetSaveRecordScriptTriggered();
				var data = dynamicRecordToBeSubmitted.getRecordData();
				return [getRecordType(), data.fields, data.sublists, submitOptions];
			}

			function handleRecordSpecificSaveOptions(recType, options, submitOptions)
			{
				var possibleSaveOptions = RECORD_SPECIFIC_SAVE_OPTIONS[recType];
				if (utilityFunctions.isObject(options) && util.isArray(possibleSaveOptions))
				{
					for (var i = 0; i < possibleSaveOptions.length; i++)
					{
						var thisPossibleOption = possibleSaveOptions[i];
						if (options.hasOwnProperty(thisPossibleOption))
						{
							submitOptions[thisPossibleOption] = options[thisPossibleOption];
						}
					}
				}
			}

			function commitSubrecords()
			{
				var bodyFields = getModelController().getBodyFieldIds();
				bodyFields.forEach(function (fieldId)
				{
					var fieldType = getFieldType(undef, fieldId);
					if (recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE === fieldType && getModelController().hasSubrecord(fieldId))
					{
						var subrecord = getModelController().getSubrecord(fieldId);
						if (!!subrecord)
						{
							subrecord.validate();
						}
					}
				});
			}

			this.commitSubrecords = commitSubrecords;

			function dereferencedBodySubrecords()
			{
				var bodyFields = getModelController().getBodyFieldIds();
				bodyFields.forEach(function (fieldId)
				{
					var fieldType = getFieldType(undef, fieldId);
					if (recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE === fieldType && getModelController().hasSubrecord(fieldId))
					{
						var subrecord = getModelController().getSubrecord(fieldId);
						if (!!subrecord)
						{
							subrecord.setDereferencedFromParent(true);
						}
					}
				});
			}

			function dereferencedSublistLineSubrecords(sublistId, lineInstanceId, isCommitted)
			{
				var sublistLineFieldIds = getModelController().getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted);
				sublistLineFieldIds.forEach(function (fieldId)
				{
					var fieldType = getFieldType(sublistId, fieldId);
					if (recordUtil.FIELD_TYPE.SUBRECORD_FIELD_TYPE === fieldType && getModelController()
							.hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted))
					{
						var subrecord = getModelController()
							.doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
						if (!!subrecord)
						{
							subrecord.setDereferencedFromParent(true);
						}
					}
				});
			}

			function getRecordData()
			{
				var CREATE = 'CREATE', EDIT = 'EDIT', VIEW = 'VIEW';

				var body = {},
					sublists = {},
					mainFieldNames = getFields(),
					sublistNames = _metadata.sublistIds;

				mainFieldNames.forEach(function (fieldId)
				{
					var value = getValueAsLegacyString(fieldId);
					if (value !== undef)
					{
						body[fieldId] = recordUtil.emptyIfNullOrUndefined(value);
					}
				});

				var subrecordData = getModelController().getSubrecordDataForSubmission();
				if (subrecordData)
				{
					Object.keys(subrecordData).forEach(function (v, i, a)
					{
						sublists[v] = subrecordData[v];
						body['next' + v + 'idx'] = String(subrecordData[v].size + 1);
					});
				}

				sublistNames.forEach(function (sublistId)
				{
					var sublistData = {};
					sublistData.fields = _metadata.getAllSublistFields(sublistId);
					if (sublistData.fields.length > 0) // skip sublist without field information
					{
						if (subrecordData)
						{
							sublistData.fields.splice(0, 0, subrecordUtil.SYS_PARENT_ID, subrecordUtil.SYS_ID, subrecordUtil.SYS_OP);
						}
						sublistData.size = doGetLineCount(sublistId);
						sublistData.data = doGetLineCount(sublistId) > 0 ? [] : null;
						for (var ln = 0; ln < doGetLineCount(sublistId); ln++)
						{
							var sublistLine = sublistData.fields.map(function (fieldId)
							{
								if (fieldId === subrecordUtil.SYS_OP)
								{
									var operation = EDIT;
									if (!getSublistState(sublistId).isLineChanged(ln))
									{
										operation = VIEW;
									}
									if (getSublistState(sublistId).isLineInserted(ln))
									{
										operation = CREATE;
									}
									return operation;
								}
								return recordUtil.emptyIfNullOrUndefined(getSublistLineValueAsLegacyString(sublistId, fieldId, ln));
							});

							sublistData.data[ln] = sublistLine;
						}

						sublists[sublistId] = sublistData;
					}
				});

				return {fields: body, sublists: sublists};
			}

			this.getRecordData = getRecordData;

			function handleChangeCall(params)
			{
				if (getIsDynamicRecord())
				{
					var sysId = doGetValue(subrecordUtil.SYS_ID),
						sysParentId = doGetValue(subrecordUtil.SYS_PARENT_ID);
					var context = getRecordRequestContext();
					var params = utilityFunctions.addParameterToMap(context, params);
					params.recordmode = 'dynamic';

					//noinspection JSUnresolvedVariable
					var nsrecord = invoker(remoteApi, 'handleChangeCall', [getRecordType(), getId(), params, true /*isClientRecord*/]);

					// reset Record Metadata and Data
					_recordRequestContext = nsrecord.recordContext;
					_recordScriptingV1Scope = scope.create({
						record: that,
						libraryScript: getMetadata().libraryScript,
						staticScript: getMetadata().staticScript,
						uiFormScript: getMetadata().uiFormScript,
						workflowScript: getMetadata().workflowScript,
						completeInternalInit: setIsInited,
						completePageInit: completePageInit
					});

					setMetadata(metadata.create(nsrecord.metadata));
					setModelController(modelController.create({
						type: _metadata.type,
						data: nsrecord.data
					}));
					setRecordStateController(recordStateController.create({
						metadata: _metadata,
						data: getModelController(),
						getModelController: getModelController
					}));

					doSetFieldValue(subrecordUtil.SYS_ID, sysId, true, false);
					doSetFieldValue(subrecordUtil.SYS_PARENT_ID, sysParentId, true, false);


					implementation.initRecord(that, _recordScriptingV1Scope);
					recordDefinitionEvent.emitUpdateAll(emitter, that);
				}
			}

			this.handleChangeCall = handleChangeCall;

			function callRestrictedMethod(options)
			{
				options = options || {};
				utilityFunctions.checkArgs([options.token, options.methodName], ['token', 'methodName'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));

				if ((options.token != null && options.token === recordObj.token) || options.methodName === 'inboundShipmentHack')
				{
					this[options.methodName].apply(this, options.args || []);
				}
			}

			this.callRestrictedMethod = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: callRestrictedMethod,
				emitter: emitter
			});

			this.runLegacyScript = function runLegacyScript(script)
			{
				return _recordScriptingV1Scope.runLegacyScript(script);
			};

			/* Subrecord APIs */
			function subrecord_link(parent, sublistId, fieldId)
			{
				subrecordParent = parent;
				subrecordSublistId = sublistId;
				subrecordFieldId = fieldId;
			}

			function subrecord_linkParentState(parentSublistState, parentFieldState)
			{
				subrecordSublistState = parentSublistState;
				subrecordFieldState = parentFieldState;
			}

			function subrecord_updateFieldState(isChanged)
			{
				if (subrecordSublistState != null)
				{
					subrecordSublistState.isChanged = isChanged;
				}
				if (subrecordFieldState != null)
				{
					subrecordFieldState.isChanged = isChanged;
				}
			}

			function getSubrecordSublistState()
			{
				return subrecordSublistState;
			}

			this.getSubrecordSublistState = getSubrecordSublistState;

			function getSubrecordFieldState()
			{
				return subrecordFieldState;
			}

			this.getSubrecordFieldState = getSubrecordFieldState;

			//TODO move to subrecord wrapper
			function subrecord_abandon()
			{
				subrecordParent = null;
				subrecordDead = true;
				invalidateSubrecordClones();
				doSetFieldValue(subrecordUtil.SYS_PARENT_ID, null, false, true);
			}

			//TODO move to subrecord wrapper
			function subrecord_isValidated()
			{
				return !!subrecordValidated;
			}

			//TODO move to subrecord wrapper
			function subrecord_setDereferencedFromParent(dereferencedFromParent)
			{
				subrecordIsDereferencedFromParent = dereferencedFromParent;
				if (dereferencedFromParent)
				{
					subrecord_abandon();
				}
			}

			//TODO move to subrecord wrapper
			function subrecord_isDereferencedFromParent()
			{
				return subrecordIsDereferencedFromParent;
			}

			function subrecord_validate()
			{
				if (!subrecordValidated)
				{
					triggerSaveRecordScript(false);
					subrecord_triggerPostValidationEventOnParent();

					subrecordValidated = true;
				}
			}

			function subrecord_triggerPostValidationEventOnParent()
			{
				var line = -1;
				var value = null;

				if (!subrecordSublistId)
				{
					value = subrecordParent.getValue(subrecordFieldId);
				}
				else
				{
					line = subrecordParent.getCurrentSublistIndex(subrecordSublistId);
					value = subrecordParent.getCurrentSublistValue(subrecordSublistId, subrecordFieldId);
				}

				if (_recordScriptingV1Scope)
				{
					_recordScriptingV1Scope.invalidateSubrecordCache(subrecordSublistId, subrecordFieldId, line);
				}

				subrecordParent.triggerFieldChangeEvent(subrecordSublistId, subrecordFieldId, line, String(value), false);
			}

			function subrecord_setReadonly(value)
			{
				subrecordReadOnly = getIsSubrecord() && !!value;
			}

			this.setReadonly = subrecord_setReadonly;

			function getSubrecordRedirect(sublistId, fieldId)
			{
				var subrecordFieldIds = !!sublistId ? subrecordCompatibility.sublist[sublistId] || [] : subrecordCompatibility.body;
				subrecordFieldIds = subrecordFieldIds.reduce(function (p, c, i, a)
				{
					var subrecordFieldId = c;
					var subrecordCompatibilityMap = _metadata.getFieldMetadata(sublistId, subrecordFieldId).subrecordCompatibilityMap;

					if (!!subrecordCompatibilityMap && subrecordCompatibilityMap.hasOwnProperty(fieldId))
					{
						p.push({
							subrecordFieldId: subrecordFieldId,
							fieldId: subrecordCompatibilityMap[fieldId]
						});
					}

					return p;
				}, []);

				return subrecordFieldIds[0] || null;
			}

			this.getSubrecordRedirect = getSubrecordRedirect;

			function hasSubrecordRedirect(sublistId, fieldId)
			{
				return !!getSubrecordRedirect(sublistId, fieldId);
			}

			function doGetSubrecordInitialParamsInfo(sublistId, fieldId)
			{
				var fieldMetadata = _metadata.getFieldMetadata(sublistId, fieldId),
					initialParams = fieldMetadata.subrecordInitialParameters || [];

				return initialParams;
			}

			function getSystemId()
			{
				return getModelController().getSystemId();
			}

			this.getSystemId = getSystemId;

			function getSublistSystemId(sublistId, line)
			{
				return getModelController().getSublistSystemId(sublistId, line);
			}

			function getCurrentSublistSystemId(sublistId)
			{
				return getModelController().getCurrentSublistSystemId(sublistId);
			}

			function doGetSubrecordInitialParamsForInstance(field, lineInstanceId, isCommitted)
			{
				var result = {},
					sublistId = field.getSublistName(),
					fieldId = field.getName(),
					initialParams = doGetSubrecordInitialParamsInfo(sublistId, fieldId);

				initialParams.forEach(function (v, i, a)
				{
					var param = v.param,
						path = v.path.split('.'),
						mandatory = v.mandatory,
						value = path.length === 1 && path[0] || null;

					if (path.length > 1)
					{
						if (!!sublistId)
						{
							if (path.length === 2)
							{
								value = getModelController()
									.getSublistLineValueAsLegacyStringForInstance(sublistId, path[1], lineInstanceId, isCommitted);
							}
							else
							{
								value = doGetValue(path[2]);
							}
						}
						else
						{
							value = doGetValue(path[1]);
						}
					}

					if (mandatory || value !== undef && value !== null && value !== '')
					{
						result[param] = value;
					}
				});

				if (getIsDynamicRecord())
				{
					result.recordmode = 'dynamic';
				}

				return result;
			}

			function doGetSubrecordFromServerForInstance(field, id, lineInstanceId, isCommitted)
			{
				var result, sublistId, fieldId, type, nsrecord, initializedParams;

				if (field === null || field.getType() !== 'summary')
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, field.getName());
				}
				else
				{
					sublistId = field.getSublistName();
					fieldId = field.getName();
					type = field.getSubrecordType();
					initializedParams = doGetSubrecordInitialParamsForInstance(field, lineInstanceId, isCommitted);
					var parentSystemId = getModelController().getParentSystemIdForInstance(sublistId, lineInstanceId, isCommitted);

					if (!!id)
					{
						nsrecord = invoker(apiBridge, 'loadRecord', [type, String(id), initializedParams]);
						nsrecord.isReadOnly = getIsReadOnlyRecord();
						nsrecord.isCurrentRecord = getIsCurrentRecord();
						nsrecord.data.initialization = {
							method: 'loadRecord',
							params: {
								type: type,
								id: String(id),
								defaults: initializedParams
							}
						};
						nsrecord.data.bodyField.sys_parentid = [parentSystemId];


						result = new Record({
							recordObj: nsrecord
						});
					}
					else
					{
						triggerCanCreateSubrecordScriptForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
						nsrecord = invoker(apiBridge, 'createRecord', [type, initializedParams]);
						nsrecord.isReadOnly = getIsReadOnlyRecord();
						nsrecord.isCurrentRecord = getIsCurrentRecord();
						nsrecord.data.initialization = {
							method: 'createRecord',
							params: {
								type: type,
								defaults: initializedParams
							}
						};
						nsrecord.data.bodyField.sys_parentid = [parentSystemId];

						result = new Record({
							recordObj: nsrecord
						});
					}

					result.link(that, sublistId, fieldId);
					var sublistFieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					result.linkParentState(getSublistState(sublistId), sublistFieldState);
				}

				return result;
			}

			function hasSubrecord(options)
			{
				var isCommitted = true;
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('hasSubrecord'));
				return doHasSubrecord(undef, fieldId, -1, isCommitted);
			}

			/**
			 * return a value indicating if the field has a subrecord
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {boolean}
			 *
			 * @since 2015.2
			 */
			this.hasSubrecord = hasSubrecord;

			function getSubrecord(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('getSubrecord'));
				var subrecord = doGetBodySubrecord(fieldId);
				return subrecord;
			}

			/**
			 * get the subrecord for the associated field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} [client-side subrecord implementation]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 *
			 * @since 2015.2
			 */
			this.getSubrecord = getSubrecord;

			function removeSubrecord(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('removeSubrecord'));

				if (!hasFieldValueOrFieldExisted(fieldId))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				doRemoveSubrecord(fieldId);
			}

			/**
			 * remove the subrecord for the associated field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} same record, for chaining
			 *
			 * @2015.2
			 */
			this.removeSubrecord = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeSubrecord,
				emitter: emitter
			});

			function performSubrecordRemoval(fieldId)
			{
				var isCommitted = true;
				var sublistId = undef;
				var lineInstanceId = null;
				doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				getModelController().removeFieldValue(fieldId);
			}

			this.performSubrecordRemoval = performSubrecordRemoval;

			function doRemoveSubrecord(fieldId)
			{
				var sublistId = undef;
				performSubrecordRemoval(fieldId);
				var subrecordKeyFieldId = getSubrecordKeyFieldId(sublistId, fieldId);
				if (!!subrecordKeyFieldId)
				{
					var keyFieldId = subrecordKeyFieldId[0];
					var value = '';
					var fireFieldChanged = true;
					var noSlaving = false;
					doSetFieldValue(keyFieldId, value, fireFieldChanged, noSlaving);
				}
			}

			this.doRemoveSubrecord = doRemoveSubrecord;

			function doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!!subrecord)
				{
					subrecord.setDereferencedFromParent(true);
					subrecord.abandon();
				}
				getModelController().clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				invalidateSubrecordClones();
			}

			function doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				getModelController().clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!!subrecord)
				{
					subrecord.setDereferencedFromParent(true);
					subrecord.abandon();
				}
				postRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.doRemoveSublistSubrecordForInstance = doRemoveSublistSubrecordForInstance;

			function postRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var value = null;
				if (!isCommitted)
				{
					var fireFieldChanged = true;
					doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged);
					var subrecordKeyFieldId = getSubrecordKeyFieldId(sublistId, fieldId);
					if (!!subrecordKeyFieldId)
					{
						setCurrentSublistValue(sublistId, subrecordKeyFieldId[0], '');
					}
				}
				else
				{
					invalidateSubrecordClones();
					getModelController().setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, value, isCommitted);
				}
			}

			function getSubrecordKeyFieldId(sublistId, fieldId)
			{
				var subrecordKeyFieldId = doGetSubrecordInitialParamsInfo(sublistId, fieldId).reduce(function (p, c, i, a)
				{
					return p || (c.param === 'id' && c.path) || null;
				}, null);

				return SUBRECORD_KEY_FIELDID_REGEX.test(subrecordKeyFieldId) && subrecordKeyFieldId.split('.').slice(-1) || null;
			}

			function hasSublistSubrecord(options, fieldId, line)
			{
				var isCommitted = true;
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));
				return doHasSubrecord(sublistId, fieldId, line, isCommitted);
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @goverannce 0
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {boolean}
			 *
			 * @since 2015.2
			 */
			this.hasSublistSubrecord = hasSublistSubrecord;

			function doHasSubrecord(sublistId, fieldId, line, isCommitted)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);
				return getModelController().hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.doHasSubrecordForInstance = doHasSubrecordForInstance;

			function getSublistSubrecord(options, fieldId, line)
			{
				var sublistId, field, id;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistSubrecord'));
				var subrecord = implementation.getSublistSubrecord(sublistId, fieldId, line);
				return subrecord;
			}

			/**
			 * get the subrecord for the associated sublist field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Record} [client-side subrecord implementation]
			 *
			 * @since 2015.2
			 */
			this.getSublistSubrecord = getSublistSubrecord;

			function doGetSublistSubrecord(sublistId, fieldId, line)
			{
				var isCommitted = true;
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.doGetSublistSubrecord = doGetSublistSubrecord;

			function doGetBodySubrecord(fieldId)
			{
				var subrecord, field, id;
				var sublistId = undef;
				var lineInstanceId = null;
				var isCommitted = true;

				field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				subrecord = _modelController.getSubrecord(fieldId);
				if (!subrecord)
				{
					id = _modelController.getFieldValue(fieldId);
					subrecord = doGetSubrecordFromServerForInstance(field, id, lineInstanceId, isCommitted);
					getModelController().cacheSubrecord(fieldId, subrecord);
					invalidateSubrecordClones();
				}
				return subrecord;
			}

			this.doGetBodySubrecord = doGetBodySubrecord;


			function tryToGetSublistSubrecord(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!subrecord && !isCommitted)
				{
					subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, !isCommitted);
				}
				return subrecord;
			}

			function doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				var subrecord = tryToGetSublistSubrecord(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!subrecord)
				{
					var id = getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					subrecord = doGetSubrecordFromServerForInstance(field, id, lineInstanceId, isCommitted);
					getModelController()
						.cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
					invalidateSubrecordClones();
				}
				return subrecord;
			}

			this.doGetSublistSubrecordForInstance = doGetSublistSubrecordForInstance;

			function removeSublistSubrecord(options, fieldId, line)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('removeSublistSubrecord'));

				if (!hasSublistFieldValueOrSublistFieldExisted(sublistId, fieldId, line))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				var isCommitted = true;
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			/**
			 * remove the subrecord for the associated sublist field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.removeSublistSubrecord = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeSublistSubrecord,
				emitter: emitter
			});


			function hasCurrentSublistSubrecord(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('hasCurrentSublistSubrecord'));
				return doHasCurrentSublistSubrecord(sublistId, fieldId);
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord on the current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {boolean}
			 *
			 * @2015.2
			 */
			this.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

			function doHasCurrentSublistSubrecord(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var isCommitted = false;
				return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function getCurrentSublistSubrecord(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistSubrecord'));

				var subrecord = doGetCurrentSublistSubrecord(sublistId, fieldId);
				return subrecord;
			}

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Record} [client-side subrecord implementation]
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistSubrecord = getCurrentSublistSubrecord;

			function doGetCurrentSublistSubrecord(sublistId, fieldId)
			{
				var isCommitted = false;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);
				var subrecord = getModelController().getCurrentSublistSubrecord(sublistId, fieldId);

				if (!subrecord)
				{
					getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					var isSameSubrecordReference = doGetCurrentSublistIndex(sublistId) < doGetLineCount(sublistId) &&
						getModelController().getCurrentSublistLineValue(sublistId, fieldId) == getModelController()
							.getSublistLineValue(sublistId, fieldId, doGetCurrentSublistIndex(sublistId));

					if (getModelController()
							.hasNewlyCommittedSublistSubrecord(getModelController()
								.getCurrentSublistSystemId(sublistId), fieldId) && isSameSubrecordReference)
					{
						subrecord = doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
						subrecord = subrecord.internalClone();
						subrecord.linkParentState(getSublistState(sublistId), getSublistState(sublistId)
							.getCurrentLineFieldState(fieldId));
					}

					if (!subrecord)
					{
						var id = getModelController().getCurrentSublistLineValue(sublistId, fieldId);
						subrecord = doGetSubrecordFromServerForInstance(field, id, lineInstanceId, isCommitted);
					}

					getModelController().setCurrentSublistSubrecord(sublistId, fieldId, subrecord);
				}

				return subrecord;
			}

			this.doGetCurrentSublistSubrecord = doGetCurrentSublistSubrecord;

			function removeCurrentSublistSubrecord(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('removeCurrentSublistSubrecord'));

				if (!hasCurrentSublistFieldValueOrSublistFieldExisted(sublistId, fieldId))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				var isCommitted = false;
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			/**
			 * remove the subrecord for the associated sublist field on the current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.removeCurrentSublistSubrecord = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: removeCurrentSublistSubrecord,
				emitter: emitter
			});

			/* Record Scripting */
			function triggerPageInitScript()
			{
				implementation.triggerPageInitScript();
			}

			function triggerLineInitScript(sublistId)
			{
				implementation.triggerLineInitScript(sublistId);
			}

			function postDeleteLine(sublistId, line_0)
			{
				implementation.triggerPostDeleteLineScript(sublistId, recordUtil.getOneBasedIndex(line_0));
			}

			this.postDeleteLine = postDeleteLine;

			function postDeleteLineForInstance(sublistId, lineInstanceId, isCommitted)
			{
				var line_0 = getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted);
				postDeleteLine(sublistId, line_0);
			}

			this.postDeleteLineForInstance = postDeleteLineForInstance;

			function triggerLineCommitScript(sublistId, line)
			{
				implementation.triggerLineCommitScript(sublistId, line);
			}

			function triggerLineCommitScriptForInstance(sublistId, lineInstanceId, isCommitted)
			{
				var line_0 = getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted);
				triggerLineCommitScript(sublistId, recordUtil.getOneBasedIndex(line_0));
			}

			function triggerValidateLineScript(sublistId)
			{
				recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					sublistId: sublistId,
					func: implementation.triggerValidateLineScript,
					emitter: emitter
				})(sublistId);
			}

			function triggerValidateInsertScript(sublistId)
			{
				recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					sublistId: sublistId,
					func: implementation.triggerValidateInsertScript,
					emitter: emitter
				})(sublistId);
			}

			this.triggerValidateInsertScript = triggerValidateInsertScript;

			function triggerValidateDeleteScript(sublistId)
			{
				recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					sublistId: sublistId,
					func: implementation.triggerValidateDeleteScript,
					emitter: emitter
				})(sublistId);
			}

			this.triggerValidateDeleteScript = triggerValidateDeleteScript;

			function triggerValidateFieldScript(sublistId, fieldId, line)
			{
				var lineItemMatrixFieldMetadata = line >= 0 && matrix.parseMatrixLineField(that, fieldId, sublistId) || null;
				var fieldId = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.fieldname || fieldId;
				var matrixColumn = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.column || -1;
				recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					func: implementation.triggerValidateFieldScript,
					sublistId: sublistId,
					fieldId: fieldId,
					emitter: emitter
				})(sublistId, fieldId, line, matrixColumn);
			}

			this.triggerValidateFieldScript = triggerValidateFieldScript;

			function triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving)
			{
				implementation.triggerFieldChangeEvent(sublistId, fieldId, line, value, noSlaving);
			}

			this.triggerFieldChangeEvent = triggerFieldChangeEvent;

			function triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving)
			{
				implementation.triggerFieldChangeEventForInstance(sublistId, fieldId, line, lineInstanceId, value, noSlaving);
			}

			this.triggerFieldChangeEventForInstance = triggerFieldChangeEventForInstance;

			function triggerFieldChangeScript(sublistId, field, line)
			{
				var lineItemMatrixFieldMetadata = line > 0 && matrix.parseMatrixLineField(that, field, sublistId) || null;
				var matrixColumn = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.column || -1;
				var fieldId = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.fieldname || field;
				implementation.triggerFieldChangeScript(sublistId, fieldId, line, matrixColumn);
			}

			this.triggerFieldChangeScript = triggerFieldChangeScript;

			function triggerCanCreateSubrecordScript(sublistId, fieldId, line)
			{
				implementation.triggerCanCreateSubrecordScript(sublistId, fieldId, line);
			}

			function triggerCanCreateSubrecordScriptForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var line_0 = getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted);
				implementation.triggerCanCreateSubrecordScript(sublistId, fieldId, recordUtil.getOneBasedIndex(line_0));
			}

			function triggerSaveRecordScript(ignoreMandatoryFields)
			{
				recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					func: implementation.triggerSaveRecordScript,
					emitter: emitter
				})(ignoreMandatoryFields);
			}

			this.triggerSaveRecordScript = triggerSaveRecordScript;

			function triggerRecalcScript(sublistId, localRecalc, operation)
			{
				implementation.triggerRecalcScript(sublistId, localRecalc, operation);
			}

			this.triggerRecalcScript = triggerRecalcScript;


			function getValueAsLegacyString(fieldId)
			{
				return getModelController().getValueAsLegacyString(fieldId);
			}

			this.getValueAsLegacyString = getValueAsLegacyString;

			function getValueAsLegacyStringArray(fieldId)
			{
				return recordUtil.formatValueToArrayType(getValueAsLegacyString(fieldId));
			}

			this.getValueAsLegacyStringArray = getValueAsLegacyStringArray;

			function doSetFieldValueWithoutFormatValue(fieldId, value, fireFieldChange, noSlaving, noValidation)
			{
				doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true, noValidation);
			}

			this.doSetFieldValueWithoutFormatValue = doSetFieldValueWithoutFormatValue;

			function doSetCurrentSublistFieldValueWithoutFormatValue(sublistId, fieldId, value, fireFieldChange, noSlaving, noValidation)
			{
				doSetCurrentSublistFieldValue(sublistId, fieldId, value, fireFieldChange, noSlaving, true, noValidation);
			}

			this.doSetCurrentSublistFieldValueWithoutFormatValue = doSetCurrentSublistFieldValueWithoutFormatValue;

			function setValueAsLegacyString(fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				if (isInternal())
				{
					doSetFieldValueWithoutFormatValue(fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting);
					getFieldState(fieldId).isParsed = false;
				}
				else
				{
					value = recordUtil.formatArrayToStringType(value);
					var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
					var parsedValue = recordUtil.parseValue(isValidBodyField(fieldId), fieldLevelMetadata, value);
					doSetValue(fieldId, parsedValue, fireFieldChange, noSlaving, undefined, undefined, noValidationAndFormatting);
				}
			}

			function setCurrentSublistValueAsLegacyString(sublistId, fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				if (isInternal())
				{
					var isCommitted = false;
					var currentLineIdx = doGetCurrentSublistIndex(sublistId);
					if (currentLineIdx === -1 && isMultilineEditable(sublistId))
					{
						warnAboutMLBCurrentIndexProblem("Internal Call is attempting to setCurrentSublistValueAsLegacyString on Multiline Enabled sublist but there is no current line index! Set IGNORED");
					}
					else
					{
						doSetCurrentSublistFieldValueWithoutFormatValue(sublistId, fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting);
						getSublistFieldState(sublistId, fieldId, currentLineIdx, isCommitted).isParsed = false;
					}
				}
				else
				{
					value = recordUtil.formatArrayToStringType(value);

					var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
					var parsedValue = recordUtil.parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, value);
					doSetCurrentSublistValue(sublistId, fieldId, parsedValue, fireFieldChange, noSlaving, undefined, undefined, noValidationAndFormatting);
				}
			}

			//TODO: move to RecordImplV1, but need to add subrecord V1 ..etc
			function setFieldValue(fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				value = String(recordUtil.emptyIfNullOrUndefined(value));
				setValueAsLegacyString(fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting);
			}

			this.setFieldValue = setFieldValue;

			function setFieldText(fieldId, text, fireFieldChange, noValidationAndFormatting)
			{
				if (isFieldSelectType(null, fieldId))
				{
					if (util.isArray(text))
					{
						text.forEach(function (txt)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, txt);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, text);
					}

					doSetText(fieldId, text, fireFieldChange, undefined, noValidationAndFormatting);
				}
			}

			this.setFieldtext = setFieldText;

			//TODO: for subrecord v1
			function getFieldValue(fieldId)
			{
				return recordUtil.emptyIfNullOrUndefined(getValueAsLegacyString(fieldId));
			}

			this.getFieldValue = getFieldValue;

			function setFieldValues(fieldId, values, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				if (isFieldMultiSelect(undef, fieldId))
				{
					if (util.isArray(values))
					{
						values.forEach(function (value)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, value);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, values);
					}

					values = util.isArray(values) ? values : [values];
					values = recordUtil.formatArrayToStringType(values);
					setFieldValue(fieldId, values, fireFieldChange, noSlaving, noValidationAndFormatting);
				}
			}

			this.setFieldValues = setFieldValues;

			function setFieldTexts(fieldId, texts, fireFieldChange, noValidation)
			{
				if (isFieldMultiSelect(fieldId))
				{
					doSetTexts(fieldId, texts, fireFieldChange, undefined, noValidation);
				}
			}

			this.setFieldTexts = setFieldTexts;

			function getSublistLineValueAsLegacyString(sublistId, fieldId, line)
			{
				return getModelController().getSublistLineValueAsLegacyString(sublistId, fieldId, line);
			}

			this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

			function getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				return getModelController()
					.getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.getSublistLineValueAsLegacyStringForInstance = getSublistLineValueAsLegacyStringForInstance;

			function getSublistLineValueAsLegacyStringArray(sublistId, fieldId, line)
			{
				return recordUtil.formatValueToArrayType(getSublistLineValueAsLegacyString(sublistId, fieldId, line));
			}

			this.getSublistLineValueAsLegacyStringArray = getSublistLineValueAsLegacyStringArray;

			function getCurrentSublistLineValueAsLegacyString(sublistId, fieldId)
			{
				return getModelController().getCurrentSublistLineValueAsLegacyString(sublistId, fieldId);
			}

			this.getCurrentSublistLineValueAsLegacyString = getCurrentSublistLineValueAsLegacyString;

			var slavingCache = (function(){
				var SlavingCache = function (){
					var useCachedSourcing = false;
					var cache = [];
					this.get = function (request) {
						return (useCachedSourcing ? cache[JSON.stringify(request)] : null) || null;
					};
					this.put = function (request, response) {
						if (request && response)
							cache[JSON.stringify(request)] = response;
					};
					Object.defineProperty(this, 'useCachedSourcing', {
						get: function () { return useCachedSourcing; },
						set: function (bool) { useCachedSourcing = bool; }
					});
				};
				return new SlavingCache();
			})();
			this.useCachedSourcing = slavingCache.useCachedSourcing;

			var skipValidation = false;
			this.inboundShipmentHack = function(bool) {
				if (getRecordType() === 'inboundShipment')
					slavingCache.useCachedSourcing = skipValidation = bool;
			};

			function skipInternalOptionValidaton(sublistId, fieldId, line_0)
			{
				if (skipValidation && sublistId === 'items') {
					var fld = getSublistField(sublistId, fieldId, line_0);
					return (fld && (fld.type === 'select' || fld.isPopup)); // skip validation for popups on inbound shipment machine
				}
				return false;
			}

			function setLineItemValue(sublistId, fieldId, line_0, value, noValidationAndFormatting)
			{
				if (isSublistValid(sublistId))
				{
					recordUtil.validateAgainstSqlInjection(fieldId, value);


					var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
					var parsedValue = recordUtil.parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, value);
					var validatedValue = noValidationAndFormatting ? parsedValue : validateAndFormatFieldValue(sublistId, fieldId, parsedValue);
					doSetSublistValue(sublistId, fieldId, line_0, validatedValue);
				}
			}

			this.setLineItemValue = setLineItemValue;

			function setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting)
			{
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				value = String(recordUtil.emptyIfNullOrUndefined(value));
				setCurrentSublistValueAsLegacyString(sublistId, fieldId, value, fireFieldChange, noSlaving, noValidationAndFormatting);
			}

			this.setCurrentLineItemValue = setCurrentLineItemValue;

			function setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange, noValidationAndFormatting)
			{
				if (isFieldSelectType(sublistId, fieldId))
				{
					if (util.isArray(text))
					{
						text.forEach(function (txt)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, txt);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, text);
					}

					doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChange, undefined, noValidationAndFormatting);
				}
			}

			this.setCurrentLineItemText = setCurrentLineItemText;


			/* Sublist APIs */

			function getSublist(options)
			{
				var sublistId;
				sublistId = options !== undef && options !== null && !util.isString(options) ? options.sublistId : options;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getSublist'));
				return doGetSublist(sublistId);
			}

			/**
			 * returns the specified sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Sublist} [requested sublist]
			 *
			 * @since 2015.2
			 */
			this.getSublist = getSublist;

			function doGetSublist(sublistId)
			{
				function createSublist(type, state, fields)
				{
					var _sublist = sublist.create({
						type: type,
						sublistState: state,
						sublistFields: fields
					});

					return _sublist;
				}

				var sublistLevelMetadata = getSublistMetadata(sublistId);
				var jsSublist = (sublistLevelMetadata != null)
					? createSublist(sublistLevelMetadata.nlobjSublistConstructorType, _state.getSublistState(sublistId), sublistLevelMetadata.fieldMetadata)
					: null;
				if (jsSublist !== null)
				{
					jsSublist = sublistMD.wrap({delegate: jsSublist, category: getSublistDefinitionCategory()});
				}

				return jsSublist;
			}

			function getSublistDefinitionCategory()
			{
				return getIsReadOnlyRecord() ? sublistMD.Category.READ_ONLY : sublistMD.Category.REMOTE;
			}

			function getSublistFields(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getSublistFields'));
				var allSublistFields = null;

				var sublistfields = _metadata.getAllSublistFields(sublistId);
				if (sublistfields)
				{
					allSublistFields = [];
					var setOfSublistFields = {};
					/* by current line data */
					var sublistData = getModelController().getCurrentSublistFieldIds(sublistId);
					if (util.isArray(sublistData))
					{
						sublistData.forEach(function (fieldId) { setOfSublistFields[fieldId] = ''; });
					}

					/* by metadata line data */
					sublistfields.forEach(function (fieldId) { setOfSublistFields[fieldId] = ''; });

					allSublistFields = Object.keys(setOfSublistFields);
				}

				return allSublistFields;
			}

			/**
			 * return array of names of all fields in a sublist﻿
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined﻿
			 *
			 * @since 2015.2
			 */
			this.getSublistFields = getSublistFields;

			/* Field APIs */
			function getField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('getField'));
				return doGetField(undef, fieldId, -1, true);
			}

			/**
			 * return field object from record
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Field}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.getField = getField;

			function doGetField(sublistId, fieldId, line, isCommitted)
			{
				if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return doGetFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function doGetFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var returnedField;
				if (getModelController().hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted))
				{
					returnedField = getModelController().getUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				}
				else
				{
					var recordField = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					returnedField = recordField ? fieldMetadata.wrap({
						delegate: field.create(recordField),
						category: fieldMetadata.Category.getInstance({
							isSublistField: sublistId !== undef,
							isDynamic: getIsDynamicRecord(),
							isReadOnly: getIsReadOnlyRecord()
						}),
						current: getIsCurrentRecord()
					}) : null;
					getModelController().cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, returnedField, isCommitted);
				}
				return returnedField;
			}

			this.doGetFieldForInstance = doGetFieldForInstance;

			function getSublistField(options, fieldId, line)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}
				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistField'));
				return doGetSublistField(sublistId, fieldId, line);
			}

			/**
			 * return field object from record's sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 *
			 * @since 2015.2
			 */
			this.getSublistField = getSublistField;

			function doGetSublistField(sublistId, fieldId, line)
			{
				var isCommitted = true;
				recordUtil.assertValidSublistOperation(isWithinValidLineRangeForFieldOnly(sublistId, line));
				if (line === doGetLineCount(sublistId) && isValidSublistField(sublistId, fieldId)){
					isCommitted = false;
				}
				return doGetField(sublistId, fieldId, line, isCommitted);
			}

			function getCurrentSublistField(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistField'));
				return doGetCurrentSublistField(sublistId, fieldId);
			}

			/**
			 * return field object from record's sublist current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {Field}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistField = getCurrentSublistField;

			function doGetCurrentSublistField(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var isCommitted = false;
				return doGetFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}


			/*
			 * get cached RecordField object
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line -1 if target is current sublist line
			 * @param {boolean} isCommitted
			 * @return {*}
			 */
			function getCachedRecordField(sublistId, fieldId, line, isCommitted)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line, isCommitted);
				return getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.getCachedRecordField = getCachedRecordField;

			function getCurrentCachedRecordField(sublistId, fieldId)
			{
				var lineInstanceId = getModelController().getSublistSelectedLineInstanceId(sublistId);
				var isCommitted = false;
				return getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.getCurrentCachedRecordField = getCurrentCachedRecordField;

			function getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var recordField = getModelController().getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (recordField != null)
				{
					if (!!sublistId && !!lineInstanceId)
					{
						var lineIndex = getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted);
						recordField.setLine(parseInt(lineIndex, 10));
					}
				}
				else
				{
					var fieldConstructorObject = getFieldConstructorObjectForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					if (fieldConstructorObject)
					{
						recordField = recordfield.create(fieldConstructorObject);
						recordDefinitionEvent.forwardRecordFieldEvents(emitter, that, recordField);
						getModelController()
							.cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, recordField, isCommitted);
					}
					else
					{
						recordField = null;
					}
				}
				return recordField;
			}

			this.getCachedRecordFieldForInstance = getCachedRecordFieldForInstance;

			function flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineNum, isCurrentLine)
			{
				var isCommitted = false;
				var lineInstanceId = null;
				if (!!sublistId)
				{
					lineInstanceId = isCurrentLine ? getModelController().getSublistSelectedLineInstanceId(sublistId)
						: getLineInstanceId(sublistId, lineNum, isCommitted);
				}
				getModelController().flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId);
			}

			this.flushBufferCacheForFieldStateUpdate = flushBufferCacheForFieldStateUpdate;

			function updateSelectOptions(sublistId, fieldId, line, opts, value, text, selected)
			{
				getModelController().cacheSelectOptions(sublistId, fieldId, line, opts);
				getModelController().cacheSelectOptionText(sublistId, fieldId, value, text);
				if (selected)
				{
					if (isFieldMultiSelect(sublistId, fieldId))
					{
						value = (sublistId ? getCurrentSublistValue(sublistId, fieldId) : doGetValue(fieldId)).concat([value]);
					}
					if (!!sublistId)
					{
						setCurrentSublistValue(sublistId, fieldId, value);
					}
					else
					{
						doSetValue(fieldId, value);
					}
				}
			}

			function getFieldConstructorObjectForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var fieldObj = null;
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);

				if (metadata != null)
				{
					var lineIndex = !!sublistId && !!lineInstanceId ? getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted) : null;
					var fieldState = !!sublistId ? getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted) : getFieldState(fieldId);
					fieldObj = {
						fieldState: fieldState,
						metadata: metadata,
						record: that,
						isRecordDynamic: getIsDynamicRecord(),
						isCurrentRecord: getIsCurrentRecord(),
						sublistId: sublistId,
						lineNum: lineIndex,
						recordFunctions: {
							getRadioSet: getRadioSet,
							getQueryRequest: getQueryRequest,
							isInternal: isInternal,
							getFieldOptions: getSelectOptionCache,
							updateSelectOptions: updateSelectOptions
						}
					};
				}
				return fieldObj;
			}

			function getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted)
			{
				return getModelController().getSublistLineValueForInstance(sublistId, '_sequence', lineInstanceId, isCommitted);
			}
			this.getLineIndexFromInstanceId = getLineIndexFromInstanceId;

			function getQueryRequest()
			{
				var req = slaving.cleanupQueryURL(_metadata.queryUrl);
				if (getIsCurrentRecord())
				{
					req.payload.isCurrentRecord = true;
				}
				return req;
			}

			function getRadioSet(fieldId)
			{
				var metadata = _metadata.getFieldMetadata(null, fieldId);
				return (metadata) ? metadata.radioSet : null;
			}

			function getSelectOptionCache()
			{
				var selectOptionCache = getModelController().getSelectOptionCache();
				var result = {
					commitFromSublistBufferToSublist: selectOptionCache.commitFromSublistBufferToSublist,
					fields: selectOptionCache.fields,
					get: selectOptionCache.get,
					getSublist: selectOptionCache.getSublist,
					getSublistBuffer: selectOptionCache.getSublistBuffer,
					has: selectOptionCache.has,
					invalidate: selectOptionCache.invalidate,
					invalidateSublist: selectOptionCache.invalidateSublist,
					migrateFromSublistToSublistBuffer: selectOptionCache.migrateFromSublistToSublistBuffer,
					put: function (sublistId, fieldId, line, newOptions, action, data)
					{
						if (!action && !selectOptionCache.has(sublistId, fieldId, line))
						{
							action = 'init';
							data = newOptions;
						}
						selectOptionCache.put(sublistId, fieldId, line, newOptions);
						if (!!sublistId && that.getSublist(sublistId).isMultilineEditable)
						{
							var lineInstanceId = getLineInstanceId(sublistId, line, false);
							recordDefinitionEvent.emitUpdateFieldOptions(emitter, that, sublistId, fieldId, line, action, data, that.getSublist(sublistId).isMultilineEditable, lineInstanceId);
						}
						else
							recordDefinitionEvent.emitUpdateFieldOptions(emitter, that, sublistId, fieldId, line, action, data);
					},
					removeLine: selectOptionCache.removeLine
				};
				return result;
			}

			function warnAboutMLBCurrentIndexProblem(msg)
			{
				if (!!console && !!console.warn)
					console.warn(msg);
			}

			function getFieldSelectOption(field, lookupBind)
			{
				if (field.isPopup())
				{
					return field.getSelectOptions('', '', lookupBind);
				}
				else
				{
					return field.getSelectOptions();
				}
			}


			/**
			 * set the value for the associated header in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @param {string} options.value the value to set it to
			 * @param {boolean} [options.ignoreFieldChange] Ignore the field change script (default false)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.setMatrixHeaderValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: matrix.setMatrixHeaderValue.bind(that, that),
				emitter: emitter
			});

			/**
			 * get the value for the associated header in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number|Date|string}
			 *
			 * @since 2015.2
			 */
			this.getMatrixHeaderValue = matrix.getMatrixHeaderValue.bind(that, that);

			/**
			 * set the value for the associated field in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.line the line number for the field
			 * @param {number} options.column the column number for the field
			 * @param {string} options.value the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in deferred dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.setMatrixSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: matrix.setMatrixSublistValue.bind(that, that),
				emitter: emitter
			});

			/**
			 * get the value for the associated field in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.line the line number for the field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number|Date|string}
			 *
			 * @since 2015.2
			 */
			this.getMatrixSublistValue = matrix.getMatrixSublistValue.bind(that, that);

			/**
			 * get the field for the specified header in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Field} [requested field]
			 *
			 * @since 2015.2
			 */
			this.getMatrixHeaderField = matrix.getMatrixHeaderField.bind(that, that);

			/**
			 * get the field for the specified sublist in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @param {number} options.line the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Field} [requested field]
			 *
			 * @since 2015.2
			 */
			this.getMatrixSublistField = matrix.getMatrixSublistField.bind(that, that);

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.value the column number for the field
			 * @param {number} options.column the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number}
			 *
			 * @since 2015.2
			 */
			this.findMatrixSublistLineWithValue = matrix.findMatrixSublistLineWithValue.bind(that, that);

			/**
			 * returns the number of columns for the specified matrix.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number}
			 *
			 * @since 2015.2
			 */
			this.getMatrixHeaderCount = matrix.getMatrixHeaderCount.bind(that, that);
			/**
			 * set the value for the line currently selected in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} options.ignoreFieldChange (optional) - Ignore the field change script (default false)
			 * @param {boolean} options.fireSlavingSync (optional) - Flag to perform slaving synchronously (default false)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.setCurrentMatrixSublistValue = recordDefinitionEvent.wrapEmitError({
				record: that,
				func: matrix.setCurrentMatrixSublistValue.bind(that, that),
				emitter: emitter
			});
			/**
			 * get the value for the line currently selected in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @return {number|Date|string}
			 *
			 * @since 2015.2
			 */
			this.getCurrentMatrixSublistValue = matrix.getCurrentMatrixSublistValue.bind(that, that);

			/*
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback requestCallback
			 * @param {Object} event
			 */
			/*
			 * Start listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @return {Object} record
			 */
			this.on = function on(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('on'));
				emitter.on({
					types: types,
					listener: listener
				});
			};
			/*
			 * Stop listening to events
			 * @param {Object} options
			 * @param {string[]} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @return {Object} record
			 */
			this.off = function off(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('off'));
				emitter.off({
					types: types,
					listener: listener
				});
			};

			function toString() { return constants.RECORD_UNDERLYING_IMPL_NAME.CLIENT_DYNAMIC_RECORD; }

			this.toString = toString;

			function toJSON()
			{
				return {
					id: that.id,
					type: that.type,
					isDynamic: that.isDynamic,
					fields: getModelController().getData().body,
					sublists: getModelController().getSublistData()
				};
			}

			this.toJSON = toJSON;

			/* This method is used only by unit tests, to re-cast the record object into a different kind of proxy interface type on the fly. */
			function reCreateExposedRecordProxy(isSubrecord_param, isDynamic_param, isReadOnly_param, isInteractive_param)
			{
				recordObj.isSubrecord = isSubrecord_param;
				recordObj.isReadOnly = isReadOnly_param;
				recordObj.isDynamic = isDynamic_param;

				return that.proxy({isInteractive: isInteractive_param});
			}

			this.reCreateExposedRecordProxy = reCreateExposedRecordProxy;

			this.locale = localeContext.createLocaleContext({defaultLocale: recordObj.metadata.defaultLocale, recordType: recordObj.metadata.type});

			function completePageInit()
			{
				var event = {type: recordDefinitionEvent.Type.RECORD_INITIALIZED, record: that};
				emitter.emit(event);
				implementation.triggerLocalizationContextChange();
			}

			(function processOptions(options)
			{
				implementation = recordImplementation.create(getIsDynamicRecord(), that);

				_recordRequestContext = options.recordContext;
				setMetadata(metadata.isInstance(options.metadata)
					? options.metadata
					: metadata.create(options.metadata));

				var shouldTriggerCustomFormLevelScript = getIsCurrentRecord() && getIsDynamicRecord() && !!options.formLevelScriptPayload;
				var formLevelScriptComponent = shouldTriggerCustomFormLevelScript ? {
					libraryScript: options.formLevelScriptPayload,
					script: options.formLevelScriptMetadata.superScript
				} : {};

				var shouldTriggerCustomClientScript = getIsCurrentRecord() && getIsDynamicRecord() && !!options.clientScriptPayload;
				var clientScriptComponent = shouldTriggerCustomClientScript ? {
					libraryScript: options.clientScriptPayload,
					scriptList: options.clientScriptMetadata.superScriptList,
					pageMode: options.pageInitMode
				} : {};

				setModelController(
					modelController.isInstance(options.data) ?
						options.data :
						modelController.create({
							type: _metadata.type,
							data: options.data
						})
				);

				setRecordStateController(
					recordStateController.isInstance(options.state) ?
						options.state :
						recordStateController.create({
							metadata: _metadata,
							data: getModelController(),
							getModelController: getModelController
						})
				);

				subrecordCompatibility = (function ()
				{
					var result = {body: null, sublist: {}};

					result.body = _metadata.subrecordFieldIds;

					_metadata.sublistIds.forEach(function (v, i, a)
					{
						var sublistId = v;
						result.sublist[sublistId] = _metadata.getAllSublistSubrecordFields(sublistId);
					});

					return result;

				}());

				v1ScopeOptions = {
					record: that,
					libraryScript: getMetadata().libraryScript,
					staticScript: getMetadata().staticScript,
					uiFormScript: getMetadata().uiFormScript,
					workflowScript: getMetadata().workflowScript,
					shouldTriggerCustomFormLevelScript: shouldTriggerCustomFormLevelScript,
					formLevelScriptComponent: formLevelScriptComponent,
					shouldTriggerCustomClientScript: shouldTriggerCustomClientScript,
					clientScriptComponent: clientScriptComponent,
					completeInternalInit: setIsInited,
					completePageInit: completePageInit,
				};
			}(recordObj));

			/* --- Proxy cache mechanism setup --- */

			this.proxy = recordProxy.initialize(this, recordObj);

			/* --- End of proxy cache mechanism --- */

			this.internalClone = function ()
			{
				return clone({
					cloneable: true,
					mergeable: true
				});
			};
			if (options.cloneable === undefined || !!options.cloneable)
			{
				this.clone = recordDefinitionEvent.wrapEmitError({
					record: that,
					func: function ()
					{
						return clone({
							cloneable: false,
							mergeable: true
						});
					},
					emitter: emitter
				});
			}
			if (typeof options.merge === 'function')
			{
				this.merge = recordDefinitionEvent.wrapEmitError({
					record: that,
					func: options.merge,
					emitter: emitter
				});
			}
			if (getIsSubrecord())
			{
				this.abandon = subrecord_abandon;
				this.validate = recordDefinitionEvent.wrapEmitError({
					record: that,
					func: subrecord_validate,
					emitter: emitter
				});
				this.setReadonly = subrecord_setReadonly;
				this.link = subrecord_link;
				this.linkParentState = subrecord_linkParentState;
				this.isValidated = subrecord_isValidated;
				this.setDereferencedFromParent = subrecord_setDereferencedFromParent;
				this.isDereferencedFromParent = subrecord_isDereferencedFromParent;
			}

			/* This lets us establish currentRecord before pageInit() is called, making it possible to use currentRecord
			 * module from within pageInit(). */
			if (recordObj.initCallback)
			{
				recordObj.initCallback(that);
			}

			_recordScriptingV1Scope = v1ScopeOptions ? scope.create(v1ScopeOptions) : null;

			/* Call pageInit() */
			implementation.initRecord(that, _recordScriptingV1Scope);

			if (getIsReadOnlyRecord()) {
				setIsInited();
				completePageInit();
			}

			return that;
		}

		return Record;
	});

/**
 * SuiteScript record service module (Client Side)
 *
 * @private
 * @module N/record/recordService
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordService',['N/common/record/recordDefinition', 'N/record/recordProxy', 'N/util'],
	function (recordDefinition, recordProxy, util)
	{

		function create(rawRecordOrCreateOptions)
		{
			/* Make a copy of the args, as we will make changes to our copy. */
			var recordOptions = util.extend({}, rawRecordOrCreateOptions);

			/* Create a dynamic, deferred-dynamic, or read-only record instance. */
			var record = create_raw(recordOptions);

			return record.proxy({isInteractive: recordOptions.isInteractive});
		}

		function create_raw(recordOptions)
		{
			/* Add required isClientRecord=true, so the engine knows this is not intended to be a server-side record */
			recordOptions = util.extend({isClientRecord: true}, recordOptions);

			return new recordDefinition({recordObj: recordOptions});
		}


		return Object.freeze({
			create: create,
			create_raw: create_raw
		});
	});




/**
 * SuiteScript record util module
 *
 * @private
 * @module N/record/recordUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/record/recordUtil',['N/record/recordService', 'N/utilityFunctions', 'N/record/recordConstants', 'N/util'],
	function (recordService, utilityFunctions, constants, util)
	{
		var undef = undefined;

		// ==================== HELPERS ====================

		function getEventsParam(options)
		{
			var result = {};
			result.compress = !!options && typeof options.compressEvents !== 'undefined' ? !!options.compressEvents : true;

			return result;
		}

		function extractProxyCreateOptions(options)
		{
			var result = {};
			if (options !== undef && options !== null)
			{
				/* Pull out the parameters used only on the client side (for proxy wrapping the record) */
				if (util.isBoolean(options.isReadOnly))
				{
					result.isReadOnly = !!options.isReadOnly;
				}
				if (util.isBoolean(options.isInteractive))
				{
					result.isInteractive = !!options.isInteractive;
				}

				/* Remove these, as the server-side record engine does not recognize them and will throw an error if present */
				delete options.isReadOnly;
				delete options.isInteractive;
			}
			return result;
		}

		function createRecordInstance(nsrecord, doNotProxy)
		{
			var record;
			if (!!doNotProxy)
			{
				record = recordService.create_raw(nsrecord);
			}
			else
			{
				record = recordService.create(nsrecord);
			}
			return record;
		}

		// ==================== CREATE ====================

		function getCreateParams(options, isPromise)
		{
			var type, defaultValues, isCurrent,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
				isCurrent = options.isCurrent || false;
			}
			var moduleName = (isPromise) ? 'create.promise' : 'create';
			utilityFunctions.checkArgs([type], ['type'], moduleName);
			return {type: type, defaults: defaultValues, current: isCurrent, compressEvents: events.compress};
		}

		function doCreateRecord(createArgs, nsrecord, isPromise) { return doCreateRecord_impl(createArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doCreateRecord_raw(createArgs, nsrecord, isPromise) { return doCreateRecord_impl(createArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doCreateRecord_impl(createArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'createRecord',
					params: createArgs
				};

				if (!isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			utilityFunctions.assertTrue(createArgs.type.toLowerCase() === record.type.toLowerCase(), 'SSS_RECORD_TYPE_MISMATCH');
			return record;
		}

		// ==================== COPY ====================

		function getCopyParams(options, isPromise)
		{
			var type, id, defaultValues,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
			}
			var moduleName = (isPromise) ? 'copy.promise' : 'copy';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id), defaults: defaultValues, compressEvents: events.compress};
		}

		function validateCopyRecord(type, record)
		{
			utilityFunctions.assertTrue(type.toLowerCase() === record.type.toLowerCase()
				|| (type.toLowerCase() === 'customer' && /(prospect|lead|customer)/
					.test(record.type.toLowerCase())), 'SSS_RECORD_TYPE_MISMATCH');
		}

		function doCopyRecord(copyArgs, nsrecord, isPromise) { return doCopyRecord_impl(copyArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doCopyRecord_raw(copyArgs, nsrecord, isPromise) { return doCopyRecord_impl(copyArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doCopyRecord_impl(copyArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'copyRecord',
					params: copyArgs
				};

				if (!isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			validateCopyRecord(copyArgs.type, record);
			return record;
		}

		// ==================== LOAD ====================

		function getLoadParams(options, isPromise)
		{
			var type, id, defaultValues, isCurrent,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
				isCurrent = options.isCurrent || false;
			}
			var moduleName = (isPromise) ? 'load.promise' : 'load';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id), defaults: defaultValues, current: isCurrent, compressEvents: events.compress};
		}

		function validateLoadRecord(type, record)
		{
			utilityFunctions.assertTrue(type.toLowerCase() === record.type.toLowerCase() ||
				(type.toLowerCase() === 'assemblyitem' && /.*assemblyitem/.test(record.type.toLowerCase())) ||
				(type.toLowerCase() === 'inventoryitem' && /.*inventoryitem/.test(record.type.toLowerCase())) ||
				(type.toLowerCase() === 'customer' && /(prospect|lead|customer)/.test(record.type.toLowerCase())), 'SSS_RECORD_TYPE_MISMATCH');
		}

		function doLoadRecord(loadArgs, nsrecord, isPromise) { return doLoadRecord_impl(loadArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doLoadRecord_raw(loadArgs, nsrecord, isPromise) { return doLoadRecord_impl(loadArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doLoadRecord_impl(loadArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'loadRecord',
					params: loadArgs
				};

				if (!isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			validateLoadRecord(loadArgs.type, record);
			return record;
		}

		// ==================== TRANSFORM ====================

		function getTransformParams(options, isPromise)
		{
			var fromType, fromId, toType, defaultValues,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				fromType = options.fromType;
				fromId = options.fromId;
				toType = options.toType;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
			}
			var moduleName = (isPromise) ? 'transform.promise' : 'transform';
			utilityFunctions.checkArgs([fromType, fromId, toType], ['fromType', 'fromId', 'toType'], moduleName);
			return {
				type: fromType,
				id: String(fromId),
				transformType: toType,
				defaults: defaultValues,
				compressEvents: events.compress
			};
		}

		function doTransformRecord(transformArgs, nsrecord, isPromise) { return doTransformRecord_impl(transformArgs, nsrecord, isPromise, false/*doNotProxy*/); }

		function doTransformRecord_raw(transformArgs, nsrecord, isPromise) { return doTransformRecord_impl(transformArgs, nsrecord, isPromise, true/*doNotProxy*/); }

		function doTransformRecord_impl(transformArgs, nsrecord, isPromise, doNotProxy)
		{
			if (nsrecord.data)
			{
				nsrecord.data.initialization = {
					method: 'transformRecord',
					params: transformArgs
				};

				if (isPromise)
				{
					nsrecord.data.initialization.remoteId = nsrecord.remoteId;
				}
			}

			var record = createRecordInstance(nsrecord, doNotProxy);
			utilityFunctions.assertTrue(transformArgs.transformType.toLowerCase() === record.type.toLowerCase(), 'SSS_RECORD_TYPE_MISMATCH');
			return record;
		}

		// ==================== DELETE ====================

		function getDeleteParams(options, isPromise)
		{
			var type, id;
			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
			}
			var moduleName = (isPromise) ? 'delete.promise' : 'delete';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id)};
		}

		function doDeleteRecord(recordId)
		{
			return parseInt(recordId, 10);
		}

		// ==================== SUBMIT FIELDS ====================
		function getSubmitFieldsParams(option, isPromise)
		{
			option = option || {};
			var type = option.type, id = option.id, values = option.values, options = option.options;
			var moduleName = (isPromise) ? 'submitFields.promise' : 'submitFields';
			utilityFunctions.checkArgs([type, id, values], ['type', 'id', 'values'], moduleName);

			var submitOptions = {
				enablesourcing: (utilityFunctions.isObject(options) && options['enableSourcing'] === true) ? true : false,
				disabletriggers: (utilityFunctions.isObject(options) && options['disableTriggers'] === true) ? true : false,
				ignoremandatoryfields: (utilityFunctions.isObject(options) && options['ignoreMandatoryFields'] === true) ? true : false
			};

			var flds = [], vals = [];
			for (var field in values)
			{
				if (values.hasOwnProperty(field))
				{
					flds[flds.length] = field;
					vals[vals.length] = values[field];
				}
			}
			flds = flds.length > 0 ? flds : null;
			vals = vals.length > 0 ? vals : null;
			return [type, id, flds, vals, submitOptions];
		}

		function doSubmitFields(submitResponse)
		{
			return parseInt(submitResponse, 10);
		}

		// ==================== ATTACH ====================
		function getAttachParams(options, isPromise)
		{
			var record = options.record, to = options.to, attributes = options.attributes || null;
			var moduleName = (isPromise) ? 'attach.promise' : 'attach';
			utilityFunctions.checkArgs([record, to], ['record', 'to'], moduleName);

			var recordType = options.record.type, recordId = options.record.id,
				toType = options.to.type, toId = options.to.id;
			utilityFunctions.checkArgs([recordType, recordId, toType, toId], ['record.type', 'record.id', 'to.type', 'to.id'], moduleName);
			return [recordType, recordId, toType, toId, attributes];
		}

		// ==================== DETACH ====================
		function getDetachParams(options, isPromise)
		{
			var record = options.record, from = options.from, attributes = options.attributes || null;
			var moduleName = (isPromise) ? 'detach.promise' : 'detach';
			utilityFunctions.checkArgs([record, from], ['record', 'from'], moduleName);

			var recordType = options.record.type, recordId = options.record.id,
				fromType = options.from.type, fromId = options.from.id;
			utilityFunctions.checkArgs([recordType, recordId, fromType, fromId], ['record.type', 'record.id', 'from.type', 'from.id'], moduleName);
			return [recordType, recordId, fromType, fromId, attributes];
		}

		return Object.freeze({
			extractProxyCreateOptions: extractProxyCreateOptions,

			getCreateParams: getCreateParams,
			doCreateRecord: doCreateRecord,
			doCreateRecord_raw: doCreateRecord_raw,

			getCopyParams: getCopyParams,
			doCopyRecord: doCopyRecord,
			doCopyRecord_raw: doCopyRecord_raw,

			getLoadParams: getLoadParams,
			doLoadRecord: doLoadRecord,
			doLoadRecord_raw: doLoadRecord_raw,

			getTransformParams: getTransformParams,
			doTransformRecord: doTransformRecord,
			doTransformRecord_raw: doTransformRecord_raw,

			getDeleteParams: getDeleteParams,
			doDeleteRecord: doDeleteRecord,
			getSubmitFieldsParams: getSubmitFieldsParams,
			doSubmitFields: doSubmitFields,
			getAttachParams: getAttachParams,
			getDetachParams: getDetachParams
		});
	});

/**
 * SuiteScript record implementation common module.
 *
 * Implements the 4 primary methods that can create a record, and offers both a proxied and raw (unproxied) variant of each.
 *
 * @private
 * @module N/record/recordImpl
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordImpl',['N/restricted/recordApi', 'N/restricted/invoker', 'N/record/recordUtil'],
	function (api, invoker, recordUtil)
	{
		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(options) {return createRecord_impl(options, true/*doCreateProxy*/); }

		function createRecord_raw(options) { return createRecord_impl(options, false/*doCreateProxy*/); }

		function createRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var createArgs = recordUtil.getCreateParams(options, false);
			var nsrecord = invoker(api, 'createRecord', [createArgs.type, createArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doCreateRecord_raw(createArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doCreateRecord(createArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		function copyRecord(options) { return copyRecord_impl(options, true/*doCreateProxy*/); }

		function copyRecord_raw(options) { return copyRecord_impl(options, false/*doCreateProxy*/); }

		function copyRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var copyArgs = recordUtil.getCopyParams(options, false);
			var nsrecord = invoker(api, 'copyRecord', [copyArgs.type, copyArgs.id, copyArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doCopyRecord_raw(copyArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doCopyRecord(copyArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		function loadRecord(options) { return loadRecord_impl(options, true/*doCreateProxy*/); }

		function loadRecord_raw(options) { return loadRecord_impl(options, false/*doCreateProxy*/); }

		function loadRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var loadArgs = recordUtil.getLoadParams(options, false);
			var nsrecord = invoker(api, 'loadRecord', [loadArgs.type, loadArgs.id, loadArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doLoadRecord_raw(loadArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doLoadRecord(loadArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		function transformRecord(options) { return transformRecord_impl(options, true/*doCreateProxy*/); }

		function transformRecord_raw(options) { return transformRecord_impl(options, false/*doCreateProxy*/); }

		function transformRecord_impl(options, doCreateProxy)
		{
			var proxyOptions = recordUtil.extractProxyCreateOptions(options);
			var transformArgs = recordUtil.getTransformParams(options, false);
			var nsrecord = invoker(api, 'transformRecord', [transformArgs.type, transformArgs.id, transformArgs.transformType, transformArgs.defaults]);

			if (!doCreateProxy)
			{
				return recordUtil.doTransformRecord_raw(transformArgs, nsrecord, false);
			}
			else
			{
				return recordUtil.doTransformRecord(transformArgs, util.extend(nsrecord, proxyOptions), false);
			}
		}


		return Object.freeze({
			create: createRecord,
			create_raw: createRecord_raw,

			load: loadRecord,
			load_raw: loadRecord_raw,

			copy: copyRecord,
			copy_raw: copyRecord_raw,

			transform: transformRecord,
			transform_raw: transformRecord_raw
		});
	}
);

/**
 * SuiteScript record common module
 *
 * @module N/record
 * @suiteScriptVersion 2.x
 *
 */
define('N/record',['N/restricted/recordApi', 'N/restricted/invoker', 'N/record/recordImpl', 'N/record/recordUtil', 'N/record/recordEvent'],
	function (api, invoker, recordImpl, recordUtil, recordEvent)
	{
		var recordTypes;

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(options) {return recordImpl.create(options); }

        createRecord.promise = function createRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var createArgs = recordUtil.getCreateParams(options, true);
                        invoker(api, 'createRecord', [createArgs.type, createArgs.defaults], callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve(recordUtil.doCreateRecord(createArgs, result, true/*isPromise*/));
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		function copyRecord(options) { return recordImpl.copy(options); }

        copyRecord.promise = function copyRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var copyArgs = recordUtil.getCopyParams(options, true);
                        invoker(api, 'copyRecord', [copyArgs.type, copyArgs.id, copyArgs.defaults], callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve(recordUtil.doCopyRecord(copyArgs, result, true/*isPromise*/));
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		function loadRecord(options) { return recordImpl.load(options); }

        loadRecord.promise = function loadRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var args = recordUtil.getLoadParams(options, true);
                        invoker(api, 'loadRecord', [args.type, args.id, args.defaults], callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve(recordUtil.doLoadRecord(args, result, true/*isPromise*/));
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		function transformRecord(options) { return recordImpl.transform(options); }

        transformRecord.promise = function transformRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var transformArgs = recordUtil.getTransformParams(options, true);
                        invoker(api, 'transformRecord', [transformArgs.type, transformArgs.id, transformArgs.transformType, transformArgs.defaults], callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve(recordUtil.doTransformRecord(transformArgs, result, true/*isPromise*/));
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		function deleteRecord(options)
		{
			var deleteArgs = recordUtil.getDeleteParams(options, false);
			var recordID = invoker(api, 'nlapiDeleteRecord', [deleteArgs.type, deleteArgs.id, null]);

			return recordUtil.doDeleteRecord(recordID);
		}

        deleteRecord.promise = function deleteRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var args = recordUtil.getDeleteParams(options, true);
                        invoker(api, 'nlapiDeleteRecord', [args.type, args.id, null], callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve(recordUtil.doDeleteRecord(args, result));
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		function submitFields(options)
		{
			var argList = recordUtil.getSubmitFieldsParams(options, false);
			var submitResponse = invoker(api, 'nlapiSubmitField', argList);

			return recordUtil.doSubmitFields(submitResponse);
		}

        submitFields.promise = function submitFieldsPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var argList = recordUtil.getSubmitFieldsParams(options, true);
                        invoker(api, 'nlapiSubmitField', argList, callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve(recordUtil.doSubmitFields(result));
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		function attachRecord(options)
		{
			var argList = recordUtil.getAttachParams(options, false);
			invoker(api, 'nlapiAttachRecord', argList);
		}

        attachRecord.promise = function attachRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var argList = recordUtil.getAttachParams(options, true);
                        invoker(api, 'nlapiAttachRecord', argList, callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve();
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };

		function detachRecord(options)
		{
			var argList = recordUtil.getDetachParams(options, false);
			invoker(api, 'nlapiDetachRecord', argList);
		}

        detachRecord.promise = function detachRecordPromise(options)
        {
            return new Promise(
                function (resolve, reject)
                {
                    try
                    {
                        var argList = recordUtil.getDetachParams(options, true);
                        invoker(api, 'nlapiDetachRecord', argList, callback);
                    }
                    catch (e)
                    {
                        reject(e);
                    }

                    function callback(result, exception)
                    {
                        if (exception)
                        {
                            reject(exception);
                            return;
                        }
                        try
                        {
                            resolve();
                        }
                        catch (e)
                        {
                            reject(e);
                        }
                    }
                }
            );
        };


		return Object.freeze({
			Event: recordEvent.Type,

			/**
			 * Create a new record object based on provided type
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is created in dynamic mode.
			 * @param {Object} [options.defaultValues={}] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type is missing
			 *
			 * @since 2015.2
			 */
			create: createRecord,

			/**
			 * Load an existing nlobjRecord from the database based on provided type, id
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type The record type.
			 * @param {number|string} options.id The internal ID of the existing record instance to be loaded.
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is loaded in dynamic mode.
			 * @param {Object} [options.defaultValues={}] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			load: loadRecord,

			/**
			 * Copy a record object based on provided type, id
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type The record type.
			 * @param {number|string} options.id The internal ID of the existing record instance being copied.
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is created in dynamic mode.
			 * @param {Object} [options.defaultValues={}] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			copy: copyRecord,

			/**
			 * Transform a record into another type (i.e. salesOrder -> invoice -or- opportunity -> estimate)
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.fromType The record type of the existing record instance being transformed.
			 * @param {number|string} options.fromId The internal ID of the existing record instance being transformed.
			 * @param {string} options.toType The record type of the record returned when the transformation is complete.
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is created in dynamic mode.
			 * @param {Object} [options.defaultValues={}] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			transform: transformRecord,

			/**
			 * Delete a record object based on provided type, id and return the id of deleted record
			 *
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type The record type.
			 * @param {number|string} options.id The internal ID of the existing record instance to be deleted.
			 * @return {number} recordId
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
			 *
			 * @since 2015.2
			 */
			'delete': deleteRecord,

			/**
			 * Updates and submits one or more body fields on an existing record in NetSuite, and returns the internal ID of the parent record. When you use this method, you do not need to load or submit the parent record.
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 * @restriction only supported for records and fields where DLE (Direct List Editing) is supported
			 *
			 * @param {Object} options
			 * @param {string} options.type When working with an instance of a standard NetSuite record type, set this value by using the record.Type enum. When working with an instance of a custom record type, set this value by using the custom record type’s string ID.
			 * @param {number|string} options.id The internal ID of the existing record instance in NetSuite.
			 * @param {Object} options.values The ID-value pairs for each field you want to edit and submit.
			 * @param {Object} [options.options] additonal flags for submission
			 * @param {boolean} [options.options.enablesourcing=true] enable sourcing during record update
			 * @param {boolean} [options.options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 *
			 * @return {number} id of submitted record
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
			 *
			 * @since 2015.2
			 */
			submitFields: submitFields,

			/**
			 * Attaches a record to another record.
			 *
			 * @governance 10 units
			 *
			 * @param {Object} options
			 * @param {Object} options.record record to be attached
			 * @param {Object} options.record.type The type of record to attach.
			 * @param {number|string} options.record.id The internal ID of the record to attach.
			 * @param {Object} options.to The record that the options.record gets attached to.
			 * @param {string} options.to.type The record type of the record to attach to.
			 * @param {number|string} options.to.id The id of the destination
			 * @param {Object} [options.attributes=null] name/value pairs containing attributes
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any of record or to (and their type and id) are missing
			 *
			 * @since 2015.2
			 */
			attach: attachRecord,

			/**
			 * detach record from another record
			 *
			 * @governance 10 units
			 *
			 * @param {Object} options
			 * @param {Object} options.record record to be detached
			 * @param {Object} options.record.type The type of record to be detached.
			 * @param {number|string} options.record.id The id of the record to be detached
			 * @param {Object} options.from The destination record where options.record will be detached from
			 * @param {string} options.from.type The type of the destination
			 * @param {number|string} options.from.id The id of the destination
			 * @param {Object} [options.attributes=null] name/value pairs containing attributes
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any of record or from (and their type and id) are missing
			 *
			 * @since 2015.2
			 */
			detach: detachRecord,

			/*
			 * module enums
			 */
			get Type()
			{
				if (!recordTypes)
				{
					recordTypes = invoker(api, 'getRecordTypeEnumMap', []);
				}
				return recordTypes;
			}
		});
	}
);

/**
 * @private
 * @module N/rawCurrentRecord
 * @suiteScriptVersion 2.x
 */
define('N/rawCurrentRecord',[], function () {
	var theRecord;

	function get() {
		return theRecord;
	}

	function set(record) {
		theRecord = record;
	}

	return Object.freeze({
		get: get,
		set: set
	});
});

/**
 * SuiteScript Form Record Bootstrap Module
 *
 * @module N/currentRecordBootstrap
 * @suiteScriptVersion 2.x
 *
 */
define('N/currentRecordBootstrap',['N/record/recordService', 'N/error', 'N/utilityFunctions', 'N/environment', 'N/msgRouter', 'N/rawCurrentRecord'],
	function (recordService, error, utilityFunctions, environment, msgRouter, rawCurrentRecord)
	{
		var undef = undefined;

		function isSuiteScriptError(obj)
		{
			return (obj && obj.toJSON && obj.toJSON().type === 'error.SuiteScriptError') ||
				(obj && obj.constructor && utilityFunctions.getConstructorName(obj) === 'nlobjError');
		}

		var currentRecord = undef;

		/**
		 * Return {Record} [singleton DR-based current record object, if one was already created by a prior call to
		 * getModuleInstance(), otherwise, returnes undefined]
		 */
		function getCurrentRecord()
		{
			return currentRecord;
		}

		/**
		 * Create current record using promise
		 *
		 * @return {Record|SuiteScriptError}
		 */
		function getModuleInstance(rawRecord)
		{
			var currentRecordModule = {};
			var toRet;

			if (!isSuiteScriptError(rawRecord))
			{
				try
				{
					environment.setInNewUI();
					var isInteractive = true;

					rawRecord.isClientRecord = true;
					rawRecord.isCurrentRecord = true;
					rawRecord.isInteractive = isInteractive;
					rawRecord.data = rawRecord.data || {};
					rawRecord.data.initialization = {
						method: rawRecord.id ? 'loadRecord' : 'createRecord',
						params: {
							type: rawRecord.metadata.recordType,
							defaults: {}
						}
					};
					/* This will set our currentRecord from within the record creation code, right before pageInit() is called.
					 * That allows currentRecord module to be used inside of pageInit(). */
					rawRecord.initCallback = function initCallback(recordBeingCreated)
					{
						rawCurrentRecord.set(recordBeingCreated);
						currentRecord = recordBeingCreated.proxy({isInteractive: isInteractive});
					};
					/* Set our currentRecord again once the record has been fully created. */
					toRet = recordService.create(rawRecord);
					currentRecord = toRet;
					msgRouter.showMessagesFromBeforeLoad({currentRecord: currentRecord});
				}
				catch (err)
				{
					if (err.csError != null)
						toRet = err;
					else
						toRet = utilityFunctions.createSuiteScriptError(error.Type.CANNOT_CREATE_RECORD_INSTANCE);
					rawCurrentRecord.set(undef);
					currentRecord = undef;
				}
			}
			else
			{
				if (rawRecord === null || rawRecord === undef)
				{
					toRet = utilityFunctions.createSuiteScriptError(error.Type.CANNOT_CREATE_RECORD_INSTANCE);
				}
				else
				{
					toRet = rawRecord;
				}
			}


			currentRecordModule.get = function ()
			{
				if (isSuiteScriptError(toRet))
				{
					throw toRet;
				}
				return toRet;
			};
			currentRecordModule.get.promise = function ()
			{
				return new Promise(function (resolve, reject)
				{
					if (isSuiteScriptError(toRet))
					{
						reject(toRet);
					}
					else
					{
						resolve(toRet);
					}
				});
			};

			return utilityFunctions.freezeObjectIfPossible(currentRecordModule);
		}

		return {
			getModuleInstance: getModuleInstance,
			getCurrentRecord: getCurrentRecord
		}
	}
);

/**
 * SuiteScript currentField module
 *
 * @private
 * @module N/currentRecord/currentField
 * @NApiVersion 2.x
 *
 */
define('N/currentRecord/currentField',['N/nsobject', 'N/error', 'N/utilityFunctions', 'N/fieldUtil', 'N/eventEmitter', 'N/runtime'], function(nsobject, error, utilityFunctions, fieldUtil, eventEmitter, runtime) {

    /**
     * Return a wrapped nlobjField used for accessing and manipulating the fields on the current record
     *
     * @classDescription Encapsulation of fields on the currentRecord
     * @return {CurrentRecordField}
     * @constructor
     *
     * @since 2015.2
     */
    function nlobjFieldCurrentRecordField(fieldObj)
    {
        /**
         * Return label of the field
         * @name CurrentRecordField#label
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return fieldObj.getLabel();
            },
            set: function (label)
            {
                var sublistId = fieldObj.getSubList();
                if (!sublistId)
                {
                    setLabel(fieldObj.getName() + "_fs", label);
                    fieldObj.label = label;
                }
                else
                {
                    if (hasMachine(sublistId))
                    {
                        var mch = eval( String(sublistId) + '_machine');
                        var fldnam = fieldObj.getName();
                        var possibleLabel = mch.getFormElementLabel(mch.getArrayPosition(fldnam));
                        var useDisplay = false;
                        if (possibleLabel === "")
                        {
                            // If the existing column is hidden, we won't display it. Go see if the _display version exists.

                            var displayLabel = mch.getFormElementLabel(mch.getArrayPosition(fldnam + "_display"));
                            if (displayLabel !== "" && displayLabel !== undefined)
                            {
                                // update the object, then the actual value on the machine, then update the array that is used to initialize the objects
                                fieldObj.label = label;
                                mch.setFormElementLabel(fldnam + "_display", label);
                                window.lineitemFieldlabelArray[sublistId][fldnam] = label;
                                window.lineitemFieldlabelArray[sublistId][fldnam + "_display"] = label;
                            }
                            // if it still a hidden field (or doesn't exist), then don't do anything.
                        }
                        else if (possibleLabel !== undefined)
                        {
                            fieldObj.label = label;
                            mch.setFormElementLabel(fldnam, label);
                            window.lineitemFieldlabelArray[sublistId][fldnam] = label;
                        }
                    }
                    else
                    {
                        // No implementation for list machines.
                    }
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return id of the field
         * @name CurrentRecordField#id
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                return fieldObj.getName();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return type of the field
         * @name CurrentRecordField#type
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'type', {
            get: function ()
            {
                return fieldObj.getType();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return sublist Id of the field, undefined if not applicable
         * @name CurrentRecordField#sublistId
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'sublistId', {
            get: function ()
            {
                return fieldObj.getSubList();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'sublistId' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is mandatory
         * @name CurrentRecordField#isMandatory
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isMandatory', {
            get: function ()
            {
                return !!fieldObj.isMandatory();
            },
            set: function (required)
            {
                if (!fieldObj.getSubList())
                {
                    var fldnam = fieldObj.getName();
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    if (nsapiIsInternal() || /cust(entity|item|body|column|record|itemnumber|page|event).+/.test(fldnam))
                        setRequired(getFormElement(form, getFieldName(fldnam)), required);
                    fieldObj.required = required;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Disabled
         * @name CurrentRecordField#isDisabled
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisabled', {
            get: function ()
            {
                return !!fieldObj.isDisabled();
            },
            set: function (val)
            {
                var sublist = fieldObj.getSubList();
                var fldnam = fieldObj.getName();
                if (!sublist)
                {
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    disableField(getFormElement(form, getFieldName(fldnam)), val);
                    if (typeof(ftabs) == 'undefined' || ftabs[getFieldName(fldnam)] == null || ftabs[getFieldName(fldnam)] == "main")
                        nsDisabledFields[fldnam] = val;
                }
                else
                {
                    var fld = getFormElement(document.forms[sublist.toLowerCase() + '_form'], getFieldName(fldnam));
                    if (fld == null)
                        fld = getFormElement(document.forms[sublist.toLowerCase() + '_form'], getFieldName(fldnam) + fieldObj.getLine())
                    disableField(fld, val);
                }
                fieldObj.disabled = val;
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is a Popup
         * @name CurrentRecordField#isPopup
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isPopup', {
            get: function ()
            {
                return !!fieldObj.isPopup();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isPopup' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Displayed (false means, unlike Visible, the space where it used to be is also not visible)
         * @name CurrentRecordField#isDisplay
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
            get: function ()
            {
                return !!fieldObj.isDisplay();
            },
            set: function (show)
            {
                var sublist = fieldObj.getSubList();
                var fldnam = fieldObj.getName();
                if (!sublist)
                {
                    showFieldAndLabel(fldnam + "_fs", show)
                    if (typeof(ftabs) != 'undefined')
                    {
                        var tabName = ftabs[getFieldName(fldnam)];
                        ns_tabUtils.updateTabVisibility(tabName);
                    }
                    fieldObj.display = show;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Visible (false means, unlike Display, the space where it used to be is still there, just the field itself is not visible)
         * @name CurrentRecordField#isVisible
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return !!fieldObj.isVisible();
            },
            set: function (show)
            {
                if (!fieldObj.getSubList())
                {
                    setFieldAndLabelVisibility(fieldObj.getName() + "_fs", show);
                    fieldObj.visible = show;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is ReadOnly
         * @name CurrentRecordField#isReadOnly
         * @type string
         * @since 2015.2
         */
        Object.defineProperty(this, 'isReadOnly', {
            get: function ()
            {
                return !!fieldObj.isReadOnly();
            },
            set: function (val)
            {
                if (!fieldObj.getSubList())
                {
                    var fldnam = fieldObj.getName();
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    var fld = getFormElement(form, getFieldName(fldnam));
                    if (fld != null)
                    {
                        if (fieldObj.getType() !== "textarea")
                        {
                            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly' );
                        }
                        else
                        {
                            setFieldReadOnly(fld, val);
                            fieldObj.readonly = !!fld.readOnly;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: false
        });

	    if (fieldUtil.isSelectType(fieldObj.getType()))
	    {
		    this.getSelectOptions = getSelectOptions;
		    this.insertSelectOption = insertSelectOption;
		    this.removeSelectOption = removeSelectOption;
	    }

	    /**
	     * Returns a list of available options on a select field. This API can be used on both standard and custom select fields. Only the first 1,000 available options will be returned by this API. Does nothing if this field is not a select/multiselect
	     * @param {string} [filter] Will not filter if not present.
	     * @param {string} [filteroperator] Supported operators are contains | is | startswith. If not specified, defaults to the contains operator.
	     * @return {Array}
	     *
	     */
        function getSelectOptions(filter, filteroperator)
        {
	        if (utilityFunctions.isObject(filter))
	        {
		        filteroperator = filter.operator;
		        filter = filter.filter;
	        }

            var sOptions = [];
            var uiField = fieldObj.getUIField();
            var dropdown = (fieldObj.getType() === "select") ? getDropdown(uiField) : getMultiDropdown(uiField);
            if (dropdown)
            {
                var optionValues = dropdown.valueArray;
                var optionTexts = dropdown.textArray;
                var filterfunction = null;
                if (!!filter)
                {
                    filteroperator = filteroperator || "contains";
                    if (filteroperator === "is")
                    {
                        filterfunction = function (v) { return ("" + v).length === filter.length && ("" + v).search(new RegExp(filter, "i")) === 0; };
                    }
                    else if (filteroperator === "startswith")
                    {
                        filterfunction = function (v) { return ("" + v).search(new RegExp(filter, "i")) === 0; }
                    }
                    else if (filteroperator === "contains")
                    {
                        filterfunction = function (v) { return ("" + v).search(new RegExp(filter, "i")) !== -1;}
                    }
                }
                for (var i = 0; i < optionValues.length; i++)
                {
                    if ((filterfunction === null) || filterfunction(optionTexts[i]))
                        sOptions[sOptions.length] = {
                            value: optionValues[i],
                            text: optionTexts[i]
                        };
                }
            }
            return sOptions;
        }

	    var isPrefixedWithCustPage = fieldUtil.isPrefixedWithCustPage(fieldObj.getName());

	    var selectOptionError;
	    if (!isPrefixedWithCustPage)
	    {
		    selectOptionError = utilityFunctions.throwSuiteScriptError;
	    }
	    else if (typeof console !== 'undefined' && console.warn)
	    {
		    selectOptionError = function ()
		    {
			    try
			    {
				    utilityFunctions.throwSuiteScriptError.apply(this, arguments);
			    }
			    catch (e)
			    {
				    console.warn(e);
			    }
		    }
	    }
	    else
	    {
		    selectOptionError = function () {};
	    }

	    function isInternal()
	    {
		    var scriptId = runtime.getCurrentScript().id;
		    return scriptId == null || scriptId === 'internal';
	    }

	    function checkUpdateSelectOptions()
	    {
		    if (!isInternal() && !isPrefixedWithCustPage)
		    {
			    selectOptionError(error.Type.SSS_INVALID_UI_OBJECT_TYPE);
			    return false;
		    }
		    if (fieldObj.isPopup())
		    {
			    selectOptionError(error.Type.SSS_NOT_YET_SUPPORTED, "update popup select options");
		    	return false;
		    }
		    return true;
	    }

        var localSelectOptions = {};

	    /**
	     * Inserts a select option to a select/multiselect field added via script.
	     *
	     * @restriction This API can only be used if this field is a select/multiselect and was added via the UI Objects API (e.g. Suitelets or beforeLoad user events)
	     *
	     * @param {Object} options
	     * @param {string} options.value a unique value for the added select option
	     * @param {string} options.text the display name of the added select option
	     * @param {string} [options.isSelected=false] if true, sets this option to be the default selected option.
	     * @throws SSS_INVALID_UI_OBJECT_TYPE when attempting to use this on a field not added via the UI Objects API
	     */
	    function insertSelectOption(options, text)
	    {
		    var value,
			    selected = false,
			    undef = undefined,
			    eventToken;

		    if (text !== undef)
		    {
			    value = options;
		    }
		    else if (options !== undef && options !== null)
		    {
			    value = options.value;
			    text = options.text;
			    selected = options.isSelected || false;
			    eventToken = options._eventToken;
		    }

		    return eventEmitter.callWithToken(eventToken, function ()
		    {
			    if (!checkUpdateSelectOptions())
			    	return;
			    utilityFunctions.checkArgs([value, text], ['value', 'text'], 'CurrentField.insertSelectOption');
			    value = String(value);

			    var uiField = fieldObj.getUIField();
			    var isSingleSelect = (fieldObj.getType() === "select");
			    var dropdown = isSingleSelect ? getDropdown(uiField) : getMultiDropdown(uiField);
			    if (Object.prototype.hasOwnProperty.call(dropdown.valueToIndexMap, value))
				    selectOptionError(error.Type.SELECT_OPTION_ALREADY_PRESENT, value);

			    if (isSingleSelect)
			    {
				    dropdown.addOption(text, value);
				    if (selected)
				    {
					    var newIdx = dropdown.getIndexForValue(value);
					    dropdown.setIndex(newIdx, true);
				    }
			    }
			    else
			    {
				    dropdown.addOption(text, value, selected);
			    }

			    localSelectOptions[value] = true;
		    });
	    }

	    /**
	     * Removes a select option to a select/multiselect field added via script.
	     *
	     * @restriction This API can only be used if this field is a select/multiselect and was added via the UI Objects API (e.g. Suitelets or beforeLoad user events)
	     *
	     * @param {Object} options
	     * @param {string} options.value the value of the select option to be removed, or null to delete all options.
	     * @throws SSS_INVALID_UI_OBJECT_TYPE when attempting to use this on a field not added via the UI Objects API
	     */
	    function removeSelectOption(options)
	    {
		    var undef = undefined,
			    value,
		        eventToken;

		    if (options !== undef && options !== null && options.value !== undef)
		    {
			    value = options.value;
			    eventToken = options._eventToken;
		    }
		    else
		    {
			    value = options;
		    }

		    return eventEmitter.callWithToken(eventToken, function ()
		    {
			    if (!checkUpdateSelectOptions())
				    return;
			    if (!isPrefixedWithCustPage)
				    utilityFunctions.checkArgs([value], ['value'], 'CurrentField.removeSelectOption');

			    var uiField = fieldObj.getUIField();
			    var dropdown = (fieldObj.getType() === "select") ? getDropdown(uiField) : getMultiDropdown(uiField);

			    if (value !== null)
			    {
				    value = String(value);

				    var allowRemove = localSelectOptions[value] || isPrefixedWithCustPage || isInternal();
				    if (!allowRemove || !Object.prototype.hasOwnProperty.call(dropdown.valueToIndexMap, value))
					    selectOptionError(error.Type.SELECT_OPTION_NOT_FOUND, value);

				    delete localSelectOptions[value];
				    dropdown.deleteOneOption(value);
			    }
			    else
			    {
				    dropdown.deleteAllOptions();
			    }
		    });
	    }
    }

    function pojsoCurrentRecordField(fieldObj)
    {
        var internalField = {};

        Object.defineProperty(this, 'label', {
            get: function(){ return fieldObj.label; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'id', {
            get: function(){ return fieldObj.name; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'type', {
            get: function(){ return fieldObj.type; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'sublistId', {
            get: function(){ return fieldObj.machinename; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'sublistId' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isMandatory', {
            get: function(){ return fieldObj.required;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isMandatory' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisabled', {
            get: function(){ return fieldObj.isDisabled;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isDisabled' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isPopup', {
            get: function(){ return fieldObj.isPopup;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isPopup' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisplay', {
            get: function(){ return fieldObj.isDisplay;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isDisplay' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isVisible', {
            get: function(){ return fieldObj.isVisible;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isVisible' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isReadOnly', {
            get: function(){ return fieldObj.readonly;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly' ); },
            enumerable: true,
            configurable: false
        });
        this.getSelectOptions = fieldObj.getSelectOptions;
	    this.insertSelectOption = fieldObj.insertSelectOption;
	    this.removeSelectOption = fieldObj.removeSelectOption;
    }
    /*
     noSlaving
     isDisabled
     isPopup
     isDisplay
     isVisible
     */


    function CurrentRecordField(fieldObj)
    {
        var that = this,
                internalField = fieldObj instanceof nlobjField ? new nlobjFieldCurrentRecordField(fieldObj) : new pojsoCurrentRecordField(fieldObj);

        Object.defineProperty(this, 'label', {
            get: function () { return internalField.label;},
            set: function (value) { internalField.label = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'id', {
            get: function () { return internalField.id;},
            set: function (value) { internalField.id = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'type', {
            get: function () { return internalField.type;},
            set: function (value) { internalField.type = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'sublistId', {
            get: function () { return internalField.sublistId;},
            set: function (value) { internalField.sublistId = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isMandatory', {
            get: function () { return internalField.isMandatory;},
            set: function (value) { internalField.isMandatory = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisabled', {
            get: function () { return internalField.isDisabled;},
            set: function (value) { return internalField.isDisabled = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isPopup', {
            get: function () { return internalField.isPopup;},
            set: function (value) { return internalField.isPopup = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisplay', {
            get: function () { return internalField.isDisplay;},
            set: function (value) { return internalField.isDisplay = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isVisible', {
            get: function () { return internalField.isVisible;},
            set: function (value) { return internalField.isVisible = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isReadOnly', {
            get: function () { return internalField.isReadOnly;},
            set: function (value) { internalField.isReadOnly = value;},
            enumerable: true,
            configurable: false
        });
        this.getSelectOptions = internalField.getSelectOptions;
	    this.insertSelectOption = internalField.insertSelectOption;
	    this.removeSelectOption = internalField.removeSelectOption;
        this.toJSON = function ()
        {
            return {
                id: that.id,
                label: that.label,
                type: that.type,
                sublistId: that.sublistId,
                isMandatory: that.isMandatory,
                isDisabled: that.isDisabled,
                isPopup: that.isPopup,
                isDisplay: that.isDisplay,
                isVisible: that.isVisible,
                isReadOnly: that.isReadOnly
            };
        };
        this.toString = function ()
        {
            return "currentRecordField";
        };
    }
    CurrentRecordField.prototype = nsobject.getNewInstance();
    Object.freeze(CurrentRecordField);

    return Object.freeze({
        /**
         * return a new instance of field object
         * @param {Object} fieldObj
         * @returns {CurrentRecordField}
         */
        create: function(fieldObj)
        {
            return !fieldObj ? null : new CurrentRecordField(fieldObj);
        },
        isSelectType: fieldUtil.isSelectType,
        Type: fieldUtil.SELECT_FIELD_TYPES
    });
});

/**
 * SuiteScript currentSublist module
 *
 * @private
 * @module N/currentRecord/currentSublist
 * @NApiVersion 2.x
 *
 */
define('N/currentRecord/currentSublist',['N/nsobject', 'N/error', 'N/utilityFunctions'], function(nsobject, error, utilityFunctions) {
    var SUBLIST_TYPE = Object.freeze({
        INLINE_EDITOR : 'inlineeditor',
        EDITOR : 'editor',
        STATIC_LIST : 'staticlist',
        LIST: 'list'
    });

    /**
     * Return a wrapped nlobjSublist used for accessing and manipulating the sublists on the current record
     *
     * @classDescription Encapsulation of sublists on the currentRecord
     * @return {CurrentRecordSublist}
     * @constructor
     *
     * @since 2015.2
     */
    function CurrentRecordSublist( sublistObj )
    {

        /**
         * Return the label of the given field's column
         * @name CurrentRecordField#getFieldLabel
         * @param fieldId the field that the label is associated with
         * @return {String} the label of the given field. null if sublist or fieldId doesn't exist.
         * @since 2015.2
         */
        this.getFieldLabel = function(options) //fieldId)
        {
            var fieldId = options.fieldId;
            var sublistName = sublistObj.getName();
            if (hasMachine(sublistName))
            {
                var mch = eval( String(sublistName) + '_machine');
                return mch.getFormElementLabel(mch.getArrayPosition(fieldId));
            }
            return null;
        };

        /**
         * Set the label of the given field's column
         * @name CurrentRecordField#setFieldLabel
         * @param fieldId the field that the label is associated with
         * @param label the new label name to set
         * @since 2015.2
         */
        this.setFieldLabel = function (options) //fieldId, label)
        {
            var fieldId = options.fieldId;
            var label = options.label;
            var sublistName = sublistObj.getName();
            if (isEditMachine(sublistName))
            {
                var mch = eval(String(sublistName) + '_machine');
                mch.setFormElementLabel(fieldId, label);
            }
        };

        /**
         * Return the id of the sublist
         * @name CurrentRecordField#id
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.getName = function() { return sublistObj.getName(); };

        /**
         * Return the type of the sublist
         * @name CurrentRecordField#type
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.getType = function() { return sublistObj.getType(); };

        /**
         * Return whether the sublist is hidden or not.
         * @name CurrentRecordField#isHidden
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isHidden = function() { return sublistObj.isHidden(); };

        /**
         * Return whether the sublist is displayed or not.
         * @name CurrentRecordField#isDisplay
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isDisplay = function() { return sublistObj.isDisplay(); };

	    /**
	     * Return that the sublist is NOT multi-line enabled (it should never be from this context.)
	     * @name CurrentRecordField#isMultilineEditable
	     * @readonly
	     * @throws READ_ONLY when setting the property is attempted
	     * @type boolean
	     * @since 2018.2
	     */
	    this.isMultilineEditable = function() { return false; };

        /**
         * Return whether the sublist has been changed or not.
         * For List machines, it will return true when ANY field has changed
         * For Edit machines, once any line change is committed to the hidden fields of the machine.
         * @name CurrentRecordField#isChanged
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isChanged = function() { return wasMachineChanged(sublistObj.getName()); };

        /**
         * Return whether the current Line of the sublist has been changed or not.
         * For List machines, it will return true when ANY field has changed
         * For Edit machines, when ANY field on the CURRENT line is changed. Once that line is committed, it returns false again.
         * @name CurrentRecordField#isCurrentLineChanged
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type string
         * @since 2015.2
         */
        this.isCurrentLineChanged = function() { return  isMachineChanged(sublistObj.getName()); };

        this.getColumn = function(options)
        {
            var undef = undefined,
                fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options,
                returnMe = null;

            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSublist.getColumn');
            var fieldInfo = nlapiGetLineItemField(sublistObj.getName(), fieldId);
            if (fieldInfo !== null)
            {
                returnMe = {
                              getName: function() { return fieldInfo.name; },
                              getType: function() { return fieldInfo.type; },
                              getLabel: function() { return fieldInfo.label; },
                              setLabel: function() {},
                              getSublistId: function() { return sublistObj.getName()}
                           };
            }

            return returnMe;
        };

        // Functions for debugger
        this.toJSON = function ()
        {
            return {
                id: this.getName(),
                type: this.getType(),
                isChanged: this.isChanged(),
                isDisplay: this.isDisplay()
            };
        };

        this.toString = function ()
        {
            return "currentRecordSublist";
        };
    }
    CurrentRecordSublist.prototype = nsobject.getNewInstance();
    Object.freeze(CurrentRecordSublist);

    return Object.freeze({
        /**
         * return a new instance of sublist object
         * @param {Object} sublistObj
         * @returns {CurrentRecordSublist}
         */
        create: function(sublistObj) { return new CurrentRecordSublist(sublistObj); },
        /**
         * @enum
         */
        Type: SUBLIST_TYPE
    });
});

/**
 * SuiteScript currentSubrecord module
 *
 * This is the V1/V2 implementation for all record methods, executed against the legacy DOM current record
 *
 * @private
 * @module N/currentRecord/currentSubrecord
 * @NApiVersion 2.x
 *
 */
define(
	'N/currentRecord/currentSubrecord',['N/utilityFunctions', 'N/error', 'N/util/formatter', 'N/currentRecord/currentField', 'N/currentRecord/currentSublist', 'N/record/recordUtilityFunctions',
	 'N/record/recordProxy', 'N/record/recordConstants'],
	function (utilityFunctions, error, formatter, field, sublist, recordUtil,
			  recordProxy, constants)
	{
		/**
		 * Current Subrecord interface
		 * @return {CurrentSubrecord}
		 * @constructor
		 * @since 2015.2
		 */
		function CurrentSubrecord(subrecordParent, subrecordObj)
		{
			var subrecordParent = subrecordParent;

			var recordOptions = {
				isClientRecord: true,
				isDynamic : true,
				isReadOnly : false,
				isCurrentRecord : true,
				isSubrecord : true
			};

			var that = this;

			/**
			 * The id of the record
			 * @name Record#id
			 * @type number
			 * @readonly
			 */
			this.id = null;

			/**
			 * The type of the record
			 * @name Record#type
			 * @type string
			 * @readonly
			 */
			this.type = null;

			/**
			 * return true if record is a dynamic record
			 * @name Record#isDynamic
			 * @type boolean
			 * @readonly
			 */
			this.isDynamic = true;

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = function ()
			{
				var result = {};

				result.type = this.type;
				result.id = this.id;
				result.isDynamic = true;

				result.fields = subrecordObj.recordmanager.getFieldNames().reduce(function (p, c, i, a)
																				  {
																					  p[c] = subrecordObj.recordmanager.getFieldValue(c);

																					  return p;
																				  }, {});

				return result;
			};
			/**
			 * Returns the object type name for the implementation.
			 * @returns {string}
			 */
			function toString()
			{
				return constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD;
			}

			this.toString = toString;

			/**
			 * remove body field data﻿
			 * @param {string} fieldId﻿
			 * @return {CurrentSubrecord}
			 */
			this.removeField = function (options)
			{
				var undef = undefined,
					fieldId;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.removeField');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeField');
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @return {array}﻿
			 */
			this.getFields = function ()
			{
				return subrecordObj.recordmanager.getFieldNames();
			};

			/**
			 * return array of names of all sublist﻿s
			 * @return {array}﻿
			 */
			this.getSublists = function ()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getSublists');
			};

			/**
			 * return array of names of all fields in a sublist﻿
			 * @param {string} sublistId
			 * @return {array}﻿
			 */
			this.getSublistFields = function (options)
			{
				var undef = undefined,
					result,
					sublistId, sublist;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.getValue');

				sublist = subrecordObj.getChildMachineRecordManager(sublistId);

				result = !!sublist && sublist.getFieldNames() || null;

				return result;
			};

			/**
			 * return value of the field
			 *﻿
			 * @param {string} fieldId
			 * @return {number|date|string|array}﻿
			 *﻿﻿
			 */
			this.getValue = function (options)
			{
				var undef = undefined,
					fieldId,
					value, field;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.getValue');

				value = subrecordObj.getFieldValue(fieldId);
				field = subrecordObj.recordmanager.getField(fieldId);

				return !field ? undefined : formatter.parse(value, field.type, field.isNumeric, field.isCurrency, field.validationType);
			};

			/**
			 * set value of the field
			 *﻿
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @return {CurrentSubrecord}﻿
			 *﻿
			 */
			this.setValue = function (options, value)
			{
				var undef = undefined,
					fieldId;

				if (value !== undef)
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([fieldId, value], ['fieldId', 'value'], 'CurrentSubrecord.setValue');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setValue');
			};

			/**
			 * get value of the field in text representation﻿
			 * @param {string} fieldId﻿
			 * @return {string}﻿
			 */
			this.getText = function (options)
			{
				var undef = undefined,
					fieldId,
					value, field;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.getText');

				value = subrecordObj.getFieldValue(fieldId);
				field = subrecordObj.recordmanager.getField(fieldId);

				if (!!field && field.type === 'select')
				{
					utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getText');
				}

				return !field ? undefined : formatter.format(value, field.type, field.isNumeric, field.isCurrency);
			};

			/**
			 * set value of the field by text representation
			 *
			 * @param {string} fieldId
			 * @param {string} value
			 * @return {CurrentSubrecord}
			 */
			this.setText = function (options, value)
			{
				var undef = undefined,
					fieldId;

				if (value !== undef)
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([fieldId, value], ['fieldId', 'value'], 'CurrentSubrecord.setText');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setText');
			};

			/**
			 * return field object from record
			 * @param {string} fieldId
			 * @return {Field}
			 */
			this.getField = function (options)
			{
				var undef = undefined,
					fieldId, fldObj;

				fieldId = options !== undef && options !== null && options.fieldId !== undef ? options.fieldId : options;

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.getField');

				fldObj = subrecordObj.recordmanager.getField(fieldId);

				return !fldObj ? undefined : field.create(fldObj);
			};

			/**
			 * return field object from record
			 * return field object from record's sublist
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line
			 * @return {Field}
			 */
			this.getSublistField = function (options, fieldId, line)
			{
				var undef = undefined,
					sublistId,
					fldObj;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentSubrecord.getSublistField');

				fldObj = subrecordObj.getChildMachineRecordManager(sublistId).getField(fieldId);

				return !fldObj ? undef : field.create(fldObj);
			};

			/**
			 * return line count of sublist
			 * @param {Object|string} options
			 * @param {string} options.sublistId
			 * @return {number}﻿
			 */
			this.getLineCount = function (options)
			{
				var undef = undefined,
					result,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.getLineCount');

				try
				{
					result = subrecordObj.getLineItemCount(sublistId);
				}
				catch (e)
				{
					result = -1;
				}

				return result;
			};

			/**
			 * insert a sublist line
			 * @param {string} sublistId
			 * @param {number} line
			 * @param {boolean} [ignoreRecalc=false] ignore recalc scripting
			 * @return {CurrentSubrecord}
			 */
			this.insertLine = function (options, line)
			{
				var undef = undefined,
					sublistId,
					ignoreRecalc = false;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					ignoreRecalc = !!options.ignoreRecalc;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentRecord.insertLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.insertLine');
			};

			/**
			 * remove a sublist line
			 * @param {string} sublistId
			 * @param {number} line
			 * @param {boolean} [ignoreRecalc=false] ignore recalc scripting
			 * @return {CurrentSubrecord}
			 */
			this.removeLine = function (options, line)
			{
				var undef = undefined,
					sublistId,
					ignoreRecalc = false;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					ignoreRecalc = !!options.ignoreRecalc;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentRecord.removeLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeLine');
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @return {number}
			 */
			this.findSublistLineWithValue = function (options, fieldId, value)
			{
				var undef = undefined,
					result = -1,
					sublistId,
					field,
					i, v;

				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, value], ['sublistId', 'fieldId', 'value'], 'CurrentSubrecord.findSublistLineWithValue');

				field = subrecordObj.recordmanager.getField(fieldId);
				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!field && !!sublist)
				{
					for (i = 0; i < sublist.rows.length; i++)
					{
						v = formatter.parse(sublist.rows[i][sublist.fldIdx[fieldId]], field.type, field.isNumeric, field.isCurrency, field.validationType);

						if (v === value)
						{
							result = i;
							break;
						}
					}
				}

				return result;
			};

			/**
			 * cancel the current selected line
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}﻿
			 */
			this.cancelLine = function (options)
			{
				var undef = undefined,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.cancelLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.cancelLine');
			};

			/**
			 * commit the current selected line
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}﻿
			 */
			this.commitLine = function (options)
			{
				var undef = undefined,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.commitLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.commitLine');
			};

			/**
			 * select line
			 * @param {string} sublistId
			 * @param {number} line
			 * @return {CurrentSubrecord}﻿
			 */
			this.selectLine = function (options, line)
			{
				var undef = undefined,
					sublistId;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentRecord.selectLine');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.selectLine", subrecordObj.getLineItemCount(sublistId));
				subrecordObj.selectLineItem(sublistId, line);
			};

			/**
			 * select a new line at the end of sublist
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}﻿
			 */
			this.selectNewLine = function (options)
			{
				var undef = undefined,
					sublistId;

				sublistId = options !== undef && options !== null && options.sublistId !== undef ? options.sublistId : options;

				utilityFunctions.checkArgs([sublistId], ['sublistId'], 'CurrentSubrecord.selectNewLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.selectNewLine');
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @return {number|date|string|array}﻿
			 */
			this.getCurrentSublistValue = function (options, fieldId)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistValue');

				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId);
					field = sublist.getField(fieldId);
				}

				return !field ? undefined : formatter.parse(value, field.type, field.isNumeric, field.isCurrency, field.validationType);
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {string} line
			 * @return {number|date|string|array}﻿
			 */
			this.getSublistValue = function (options, fieldId, line)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.getSublistValue');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistValue", subrecordObj.getLineItemCount(sublistId));
				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId, line);
					field = sublist.getField(fieldId);
				}

				return !field ? undefined : formatter.parse(value, field.type, field.isNumeric, field.isCurrency, field.validationType);
			};

			/**
			 * set the value for field in the current selected line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array}﻿ value
			 * @returns {CurrentSubrecord}
			 */
			this.setCurrentSublistValue = function (options, fieldId, value)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, value], ['sublistId', 'fieldId', 'value'], 'CurrentSubrecord.setCurrentSublistValue');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setCurrentSublistValue');
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @returns {string}
			 */
			this.getCurrentSublistText = function (options, fieldId)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistText');

				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId);
					field = sublist.getField(fieldId);

					if (!!field && field.type === 'select')
					{
						utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getCurrentSublistText');
					}
				}

				return !field ? undefined : formatter.format(value, field.type, field.isNumeric, field.isCurrency);
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line
			 * @returns {string}
			 */
			this.getSublistText = function (options, fieldId, line)
			{
				var undef = undefined,
					sublistId, sublist,
					value, field;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.getSublistText');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistText", subrecordObj.getLineItemCount(sublistId));
				sublist = subrecordObj.getChildMachineRecordManager(sublistId);
				if (!!sublist)
				{
					value = sublist.getFieldValue(fieldId, line);
					field = sublist.getField(fieldId);

					if (!!field && field.type === 'select')
					{
						utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getSublistText');
					}
				}

				return !field ? undefined : formatter.format(value, field.type, field.isNumeric, field.isCurrency);
			};

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @returns {CurrentSubrecord}
			 */
			this.setCurrentSublistText = function (options, fieldId)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentSubrecord.setCurrentSublistText');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setCurrentSublistText');
			};

			/**
			 * return the line number of current selected line
			 * @param {string} sublistId
			 * @type {number}
			 */
			this.getCurrentSublistIndex = function ()
			{
				var lineNum = subrecordObj.linenum;
				return recordUtil.getZeroBasedIndex(lineNum);
			};

			/**
			 * copy the subrecord inorder to perform cancellable actions
			 * @returns {CurrentSubrecord}
			 */
			//this.copy = function()
			//{
			//    throw error.create({name: 'NOT_DONE_YET', message: 'CurrentSubrecord.copy'});
			//};

			/**
			 * merge changes into original subrecord
			 * @returns {CurrentSubrecord}
			 */
			//this.merge = function()
			//{
			//    throw error.create({name: 'NOT_DONE_YET', message: 'CurrentSubrecord.merge'});
			//};

			/* --- Start of proxy cache mechanism --- */

			this.proxy = recordProxy.initialize(this, recordOptions);

			/* --- End of proxy cache mechanism --- */

			return that;
		}

		/**
		 * return a new instance of field object
		 * @param {Object} subrecordParent
		 * @param {Object} subrecordObj
		 * @returns {CurrentSubrecord}
		 */
		function create(subrecordParent, subrecordObj)
		{
			if (!subrecordObj)
				return undefined;
			else
			{
				var subrecord = new CurrentSubrecord(subrecordParent, subrecordObj);
				return subrecord;
			}
		}

		return Object.freeze({create: create});
	});

/**
 * SuiteScript module
 *
 * This is the V1/V2 implementation for all record methods, executed against the legacy DOM current record
 *
 * @private
 * @module N/domCurrentRecord
 * @NApiVersion 2.x
 */
define(
	'N/domCurrentRecord',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/restricted/bridge', 'N/action', 'N/restricted/invoker',
	 'N/record/recordProxy', 'N/record/recordConstants',
	 'N/util/formatter', 'N/util/validator', 'N/currentRecord/currentField', 'N/currentRecord/currentSublist',
	 'N/currentRecord/currentSubrecord', 'N/metadata/fieldMetadata',
	 'N/metadata/sublistMetadata', 'N/msgRouter', 'N/macro', 'N/fieldTypeConstants', 'N/record/subrecordUtilityFunctions', 'N/rawCurrentRecord'],
	function (error, utilityFunctions, recordUtil, apiBridge, action, invoker,
			  recordProxy, constants,
			  formatter, validator, field, sublist,
			  domSubrecord, fieldMetadata,
			  sublistMetadata, msgRouter, macro, fieldTypeConstants, subrecordUtilityFunctions, rawCurrentRecord)
	{
		var V1api = null;
		var currentRecord = {};
		var sysId;

		var recordOptions = {
			isClientRecord: true,
			isSubrecord: false,
			isDynamic: true,
			isReadOnly: false,
			isCurrentRecord: true
		};

		/*
		 * This provides us with a set of all the needed API's for V1, getting them from the only available source,
		 * currentRecord.js (and only once).  That class has special-case built for it (mostly located in NsRequre.js)
		 * which ehsures ONLY currentRecord.js is given access to the full V1 API in the V2 world. That made it a bit
		 * harder here.
		 *
		 * I moved all DOM-related record implementation code out of currentRecord, as a matter of cleanup, to give
		 * that class only a single reason to change, and creted domCurrentRecord, which specializes in being a V2-like
		 * record implementation built on V1 calls.
		 *
		 * For complex reasons that I don't fully understand, currentRecord will not be given have assess to the V1 API's
		 * at module instantiation time, but much later, right before record methods get nivoked. Therefore, I had to
		 * defer the mechanism whereby domCurrentRecord gets the set of needed V1 API's from currentRecord until the
		 * point right before any V1 code is called.
		 */
		function getV1api()
		{
			return V1api;
		}

		/**
		 * Returns the object type name for the implementation.
		 * @returns {string}
		 */
		function toString()
		{
			return constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD;
		}

		currentRecord.toString = toString;

		var messageService;
		currentRecord.getMessageService = function getMessageService()
		{
			if (!messageService)
				messageService = msgRouter.getMessageServiceInstance(currentRecord);
			return messageService;
		};

		currentRecord.getScriptingContext = getScriptingContext;

		function getScriptingContext() {
			return typeof _scriptingContext !== 'undefined' ? _scriptingContext : null;
		}

		currentRecord.getEventHandlerModules = getEventHandlerModules;

		function getEventHandlerModules() {
			return typeof _eventHandlerModules !== 'undefined' ? _eventHandlerModules : null;
		}

		function getMacroMetadata()
		{
			return typeof _macro !== 'undefined' && _macro.macroMetadata || [];
		}
		currentRecord.getMacroMetadata = getMacroMetadata;

		currentRecord.getMacros = macro.getMacros.bind(currentRecord);
		currentRecord.getMacro = macro.getMacro.bind(currentRecord);
		currentRecord.executeMacro = macro.executeMacro.bind(currentRecord);
		currentRecord.executeMacro.promise = macro.executeMacro.promise.bind(currentRecord);

		currentRecord.executeAction = action.execute.bind(currentRecord);
		currentRecord.executeAction.promise = action.execute.promise.bind(currentRecord);
		currentRecord.getActions = action.find.bind(currentRecord);
		currentRecord.getActions.promise = action.find.promise.bind(currentRecord);
		currentRecord.getAction = action.get.bind(currentRecord);
		currentRecord.getAction.promise = action.get.promise.bind(currentRecord);

		function getMissingArgumentErrorMessageFillerValue(methodName)
		{
			return 'CurrentRecord.' + methodName;
		}
		currentRecord.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

		function validateAndFormat(id, type, value, allowPercentage)
		{
			var undef = undefined;
			validator.validateField(id, type, value, undef, undef, undef, undef, undef, undef, undef, undef, allowPercentage);
			if (!fieldTypeConstants.isNumeric(type) && !fieldTypeConstants.isCurrency(type))
				value = formatter.format(value, type);
			return value;
		}

		function checkAndFormatForSetText(text, fldType, fieldId)
		{
			var value = formatter.parse(text, fldType);
			return validateAndFormat(fieldId, fldType, value, true);
		}

		// ==== set/get fieldValue
		function setValue(options, value)
		{
			var fieldId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (value !== undef)
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.setValue");
			if (forceSyncSourcing) {
				doSetValue(fieldId, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetValue(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
			return currentRecord;
		}

		currentRecord.setValue = setValue;

		function doSetValue(fieldId, value, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = getV1api().nlapiGetField(fieldId);
			if (fieldObj !== null)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
				getV1api().nlapiSetFieldValue.v2(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getValue(options)
		{
			var fieldId;

			fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.getValue");
			getV1api().nsapiAssertTrue(!isSubrecordField(null, fieldId), 'SSS_INVALID_OPERATION_USING_SUBRECORD_FIELD');

			return doGetValue(fieldId);
		}

		currentRecord.getValue = getValue;

		function doGetValue(fieldId)
		{
			var fieldObj = getV1api().nlapiGetField(fieldId);
			var value;
			if (fieldObj == null)
				return undefined;

			if (fieldObj.type === "multiselect")
			{
				if (fieldObj.isHidden)
					value = getV1api().nlapiGetFieldValue(fieldId).split(String.fromCharCode(5));
				else
					value = getV1api().nlapiGetFieldValues(fieldId);
			}
			else
			{
				value = (fieldObj !== null) ? handlePossiblyAlreadyParsedValue(getV1api().nlapiGetFieldValue(fieldId), fieldId, fieldObj.type) : undefined;
			}
			return value == null ? undefined : value;
		}

		function handlePossiblyAlreadyParsedValue(fieldValue, fieldId, fieldType)
		{
			var returnMe;
			if (isValEmpty(fieldValue))
			{
				returnMe = (fieldType === fieldTypeConstants.Type.CHECKBOX) ? false : fieldValue;
			}
			else if (!isNaN(fieldValue) && getFieldFromDocument(fieldId + "_formattedValue") !== null)
				returnMe = parseFloat(fieldValue);
			else
				returnMe = formatter.parse(fieldValue, fieldType, undefined, undefined, undefined, undefined, true);
			return returnMe;
		}

		function getFieldFromDocument(fieldName)
		{
			return !!document ? document.getElementById(fieldName) : null;
		}

		// ==== set/get matrixValue
		function setMatrixHeaderValue(options, fieldId, column, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;

				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.setMatrixHeaderValue');
			if (forceSyncSourcing) {
				doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
			return currentRecord;
		}

		currentRecord.setMatrixHeaderValue = setMatrixHeaderValue;

		function doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		{
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setMatrixHeaderValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = getV1api().nlapiGetMatrixField(sublistId, fieldId, column);
			if (fieldObj !== null)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
				getV1api().nlapiSetMatrixValue.v2(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getMatrixHeaderValue(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.getMatrixHeaderValue');
			return doGetMatrixHeaderValue(sublistId, fieldId, column)
		}

		currentRecord.getMatrixHeaderValue = getMatrixHeaderValue;

		function doGetMatrixHeaderValue(sublistId, fieldId, column)
		{
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixHeaderValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = getV1api().nlapiGetMatrixField(sublistId, fieldId, column);
			var value;

			if (fieldObj == null)
				return undefined;

			value = formatter.parse(getV1api().nlapiGetMatrixValue(sublistId, fieldId, column), fieldObj.type);

			return value == null ? undefined : value;
		}

		// ==== set/get fieldText
		function setText(options, text)
		{
			var fieldId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (text !== undef)
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.setText");
			if (forceSyncSourcing) {
				doSetText(fieldId, text, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetText(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			return currentRecord;
		}

		currentRecord.setText = setText;

		function doSetText(fieldId, text, fireFieldChanged, fireSlavingSync)
		{
			var fldObj = getV1api().nlapiGetField(fieldId);
			if (fldObj == null)
				return;

			if (fldObj.type === "multiselect")
			{
				text = (!Array.isArray(text)) ? text.split(String.fromCharCode(5)) : text;
				getV1api().nlapiSetFieldTexts.v2(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else if (fldObj.type.indexOf("select") !== -1)
			{
				getV1api().nlapiSetFieldText.v2(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else
			{
				var value = checkAndFormatForSetText(text, fldObj.type, fieldId);
				getV1api().nlapiSetFieldValue.v2(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getText(options)
		{
			var fieldId;
			fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.getText");

			return doGetText(fieldId);
		}

		currentRecord.getText = getText;

		function doGetText(fieldId)
		{
			var fieldObj = getV1api().nlapiGetField(fieldId);
			if (fieldObj == null)
				return undefined;
			var text;
			if (fieldObj.type === "multiselect")
			{
				text = getV1api().nlapiGetFieldTexts(fieldId);
			}
			else if (fieldObj.type.indexOf("select") !== -1)
			{
				text = getV1api().nlapiGetFieldText(fieldId);
			}
			else
			{
				text = formatter.format(getV1api().nlapiGetFieldValue(fieldId), fieldObj.type);
			}
			return text == null ? undefined : text;
		}

		// ==== get sublist information
		function getSublistValue(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], "CurrentRecord.getSublistValue");
			return doGetSublistValue(sublistId, fieldId, line)
		}

		currentRecord.getSublistValue = getSublistValue;

		function doGetSublistValue(sublistId, fieldId, line)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistValue", getV1api().nlapiGetLineItemCount(sublistId));

			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			var value = fieldType ? handlePossiblyAlreadyParsedValue(getV1api().nlapiGetLineItemValue(sublistId, fieldId, line), fieldId, fieldType) : null;

			return value == null ? undefined : value;
		}

		function getSublistText(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], "CurrentRecord.getSublistText");
			return doGetSublistText(sublistId, fieldId, line)
		}

		currentRecord.getSublistText = getSublistText;

		function doGetSublistText(sublistId, fieldId, line)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistText", getV1api().nlapiGetLineItemCount(sublistId));

			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			if (fieldType === null)
				return undefined;
			var text;
			if (fieldType === "multiselect")
				text = getV1api().nlapiGetLineItemTexts(sublistId, fieldId, line);
			else if (fieldType.indexOf("select") !== -1)
				text = getV1api().nlapiGetLineItemText(sublistId, fieldId, line);
			else
				text = formatter.format(getV1api().nlapiGetLineItemValue(sublistId, fieldId, line), fieldType);

			return text == null ? undefined : text;
		}

		function setMatrixSublistValue(options, fieldId, line, column, value)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
				column = options.column;
				value = options.value;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line, column], ['sublistId', 'fieldId', 'line', 'column'], 'CurrentRecord.setMatrixSublistValue');
			doSetMatrixSublistValue(sublistId, fieldId, line, column, value)
		}

		currentRecord.setMatrixSublistValue = setMatrixSublistValue;

		function doSetMatrixSublistValue(sublistId, fieldId, line, column, value)
		{
			validateMatrixField(sublistId, fieldId);
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.setMatrixSublistValue", getV1api().nlapiGetLineItemCount(sublistId));
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setMatrixSublistValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			if (fieldObj !== null)
			{
				validator.validateField(fieldId, fieldObj.type, value);
				getV1api().nlapiSetLineItemMatrixValue(sublistId, fieldId, line, column, value);
			}
		}

		function getMatrixSublistValue(options, fieldId, line, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line, column], ['sublistId', 'fieldId', 'line', 'column'], 'CurrentRecord.getMatrixSublistValue');
			return doGetMatrixSublistValue(sublistId, fieldId, line, column);
		}

		currentRecord.getMatrixSublistValue = getMatrixSublistValue;

		function doGetMatrixSublistValue(sublistId, fieldId, line, column)
		{
			validateMatrixField(sublistId, fieldId);
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getMatrixSublistValue", getV1api().nlapiGetLineItemCount(sublistId));
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixSublistValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			if (fieldObj == null)
				return undefined;
			var value = formatter.parse(getV1api().nlapiGetLineItemMatrixValue(sublistId, fieldId, line, column), fieldObj.type);

			return value == null ? undefined : value;
		}

		// === set/get currentLineItemValue
		function setCurrentSublistValue(options, fieldId, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], "CurrentRecord.setCurrentSublistValue");
			if (forceSyncSourcing) {
				doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			}
			return currentRecord;
		}

		currentRecord.setCurrentSublistValue = setCurrentSublistValue;

		function doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync)
		{
			function adjustValue(thisValue)
			{
				var	fieldType = getEncodedFieldType(sublistId, fieldId, true);
				if (Array.isArray(thisValue))
				{
					thisValue = thisValue.join(String.fromCharCode(5));
				}
				else if (!!fieldType && fieldType.indexOf("select") === -1)
				{
					thisValue = validateAndFormat(fieldId, fieldType, thisValue);
				}
				return thisValue;
			}

			var fieldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));

			if (fieldObj == null)
			{
				var sublistObj = getSublist(sublistId);
				if (!!sublistObj && sublistObj.type === "list")
				{
					var oneBasedlineIndex = getV1api().nlapiGetCurrentLineItemIndex(sublistId);
					getV1api().nlapiSetLineItemValue(sublistId, fieldId, oneBasedlineIndex, adjustValue(value));
				}
				return undefined;
			}
			else
			{
				getV1api().nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, adjustValue(value), fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentSublistValue(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], "CurrentRecord.getCurrentSublistValue");
			return doGetCurrentSublistValue(sublistId, fieldId);
		}

		currentRecord.getCurrentSublistValue = getCurrentSublistValue;

		function doGetCurrentSublistValue(sublistId, fieldId)
		{
			var fieldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			var fieldType = getEncodedFieldType(sublistId, fieldId, true) === fieldTypeConstants.Type.CHECKBOX ? fieldTypeConstants.Type.CHECKBOX : (fieldObj ? fieldObj.type : null);
			var value = fieldType ? handlePossiblyAlreadyParsedValue(getV1api().nlapiGetCurrentLineItemValue(sublistId, fieldId), fieldId, fieldType) : null;
			return value == null ? undefined : value;
		}

		// === set/get currentLineItemMatrixValue
		function setCurrentMatrixSublistValue(options, fieldId, column, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.setCurrentMatrixSublistValue');
			if (forceSyncSourcing) {
				doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		currentRecord.setCurrentMatrixSublistValue = setCurrentMatrixSublistValue;

		function doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		{
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setCurrentMatrixSublistValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj !== null)
			{
				validator.validateField(fieldId, fieldObj.type, value);
				getV1api().nlapiSetCurrentLineItemMatrixValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentMatrixSublistValue(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.getCurrentMatrixSublistValue');
			var currLine = getV1api().nlapiGetCurrentLineItemIndex(sublistId);
			if (currLine > 0)
				currLine = currLine - 1;

			return doGetMatrixSublistValue(sublistId, fieldId, currLine, column);
		}

		currentRecord.getCurrentMatrixSublistValue = getCurrentMatrixSublistValue;

		// === set/get currentLineItemText
		function setCurrentSublistText(options, fieldId, text)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && text !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.setCurrentSublistText');
			if (forceSyncSourcing) {
				doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			return currentRecord;
		}

		currentRecord.setCurrentSublistText = setCurrentSublistText;

		function doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj === null)
				return;

			if (fieldObj.type.indexOf("select") !== -1)
			{
				getV1api().nlapiSetCurrentLineItemText.v2(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else
			{
				var value = checkAndFormatForSetText(text, getEncodedFieldType(sublistId, fieldId, true) || fieldObj.type, fieldId);
				getV1api().nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentSublistText(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistText');
			return doGetCurrentSublistText(sublistId, fieldId);
		}

		currentRecord.getCurrentSublistText = getCurrentSublistText;

		function doGetCurrentSublistText(sublistId, fieldId)
		{
			var fldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : getV1api().nlapiGetCurrentLineItemIndex(sublistId));
			if (fldObj === null)
				return undefined;

			var text;
			if (fldObj.type.indexOf("select") !== -1)
			{
				text = getV1api().nlapiGetCurrentLineItemText(sublistId, fieldId);
			}
			else
			{
				text = formatter.format(getV1api().nlapiGetCurrentLineItemValue(sublistId, fieldId), fldObj.type);
			}
			return text == null ? undefined : text;
		}

		function fixMissingProperties(obj)
		{
			if (obj != null)
			{
				obj.visible = true;
				obj.display = true;
			}
			return obj;
		}

		// === Get Fields
		function getField(options)
		{
			var fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], "CurrentRecord.getField");

			var fldObj = getV1api().nlapiGetField(fieldId);

			//nlapiGetField and nlapiGetLineItemField (and their matrix counterparts do not properly initialize
			//isDisplay and isVisible. We should make sure they get the proper values for them.
			var fieldElement = getFieldFromDocument(fieldId + "_fs");
			if (fldObj !== null && fieldElement !== null && fieldElement.style !== null)
			{
				fldObj.visible = fieldElement.style.visibility !== "hidden";
				fldObj.display = fieldElement.style.display !== "none";
			}

			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_BODY
													   }) : null;
		}

		currentRecord.getField = getField;

		function getSublist(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.getSublist");

			var sublistObj = getV1api().nlapiGetSubList(sublistId);
			return sublistObj != null ? sublistMetadata.wrap({
																 delegate: sublist.create(sublistObj),
																 category: sublistMetadata.Category.CURRENT
															 }) : null;
		}

		currentRecord.getSublist = getSublist;

		function isMultilineEditable(sublistId)
		{
			return false;
		}
		currentRecord.isMultilineEditable = isMultilineEditable;

		function getMatrixHeaderField(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.getMatrixHeaderField');
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixHeaderField", getMatrixHeaderCount(sublistId, fieldId));

			var fldObj = getV1api().nlapiGetMatrixField(sublistId, fieldId, column);
			fldObj = fixMissingProperties(fldObj);
			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_BODY
													   }) : null;
		}

		currentRecord.getMatrixHeaderField = getMatrixHeaderField;

		function getSublistField(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.getSublistField');
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistField", getV1api().nlapiGetLineItemCount(sublistId));

			var fldObj = getV1api().nlapiGetLineItemField(sublistId, fieldId, line);
			if (fldObj && fldObj.type === fieldTypeConstants.Type.TEXT && getEncodedFieldType(sublistId, fieldId, true) === fieldTypeConstants.Type.CHECKBOX)
				fldObj.type = fieldTypeConstants.Type.CHECKBOX;
			fldObj = fixMissingProperties(fldObj);
			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_SUBLIST
													   }) : null;
		}

		currentRecord.getSublistField = getSublistField;

		function getMatrixSublistField(options, fieldId, column, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column, line], ['sublistId', 'fieldId', 'column', 'line'], 'CurrentRecord.getMatrixSublistField');
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixSublistField", getMatrixHeaderCount(sublistId, fieldId));
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getMatrixSublistField", getV1api().nlapiGetLineItemCount(sublistId));

			var fldObj = getV1api().nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			fldObj = fixMissingProperties(fldObj);
			return fldObj != null ? fieldMetadata.wrap({
														   delegate: field.create(fldObj),
														   category: fieldMetadata.Category.CURRENT_SUBLIST
													   }) : null;
		}

		currentRecord.getMatrixSublistField = getMatrixSublistField;

		function getCurrentSublistIndex(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.getCurrentSublistIndex");

			var currIndex = getV1api().nlapiGetCurrentLineItemIndex(sublistId);
			return recordUtil.getZeroBasedIndex(currIndex);
		}

		currentRecord.getCurrentSublistIndex = getCurrentSublistIndex;

		// === Find Values
		function findSublistLineWithValue(options, fieldId, value)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.findSublistLineWithValue');
			return recordUtil.getZeroBasedIndex(getV1api().nlapiFindLineItemValue(sublistId, fieldId, value));
		}

		currentRecord.findSublistLineWithValue = findSublistLineWithValue;

		function findMatrixSublistLineWithValue(options, fieldId, value, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && value !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], 'CurrentRecord.findMatrixSublistLineWithValue');
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.findMatrixSublistLineWithValue", getMatrixHeaderCount(sublistId, fieldId));
			return recordUtil.getZeroBasedIndex(getV1api().nlapiFindLineItemMatrixValue(sublistId, fieldId, value, column));
		}

		currentRecord.findMatrixSublistLineWithValue = findMatrixSublistLineWithValue;

		function selectLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], "CurrentRecord.selectLine");

			if (recordUtil.getZeroBasedIndex(getV1api().nlapiGetCurrentLineItemIndex(sublistId)) !== line)
			{
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.selectLine", getV1api().nlapiGetLineItemCount(sublistId));
				getV1api().nlapiSelectLineItem(sublistId, line);
			}
			return currentRecord;
		}

		currentRecord.selectLine = selectLine;

		function commitLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.commitLine");
			getV1api().nlapiCommitLineItem(sublistId);
			return currentRecord;
		}

		currentRecord.commitLine = commitLine;

		function insertLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], "CurrentRecord.insertLine");
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.insertLine", getV1api().nlapiGetLineItemCount(sublistId) + 1); //+1 because you can insert on the newest line

			getV1api().nlapiInsertLineItem(sublistId, line);
			return currentRecord;
		}

		currentRecord.insertLine = insertLine;

		function removeLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], "CurrentRecord.removeLine");
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.removeLine", getV1api().nlapiGetLineItemCount(sublistId));

			getV1api().nlapiRemoveLineItem(sublistId, line);
			return currentRecord;
		}

		currentRecord.removeLine = removeLine;

		function cancelLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.cancelLine");
			getV1api().nlapiCancelLineItem(sublistId);
			return currentRecord;
		}

		currentRecord.cancelLine = cancelLine;

		function selectNewLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.selectNewLine");
			getV1api().nlapiSelectNewLineItem(sublistId);
			return currentRecord;
		}

		currentRecord.selectNewLine = selectNewLine;

		function getLineCount(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], "CurrentRecord.getLineCount");
			return getV1api().nlapiGetLineItemCount(sublistId);
		}

		currentRecord.getLineCount = getLineCount;

		function getMatrixHeaderCount(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getMatrixHeaderCount');
			return getV1api().nlapiGetMatrixCount(sublistId, fieldId);
		}

		currentRecord.getMatrixHeaderCount = getMatrixHeaderCount;

		function getRecordType()
		{
			return getV1api().nlapiGetRecordType();
		}

		function validateMatrixField(sublistId, fieldName)
		{
			if (!getMatrixHeaderCount(sublistId, fieldName) || getMatrixHeaderCount(sublistId, fieldName) < 0)
				utilityFunctions.throwSuiteScriptError(error.Type.METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD);
		}

		utilityFunctions.addReadOnlyProperty(currentRecord, 'type', getRecordType);

		function getId()
		{
			var id = getV1api().nlapiGetRecordId();
			return (id == null || id === '') ? id : parseInt(id);
		}

		utilityFunctions.addReadOnlyProperty(currentRecord, 'id', getId);

		function getIsDynamic () { return !recordOptions.isReadOnly; }

		utilityFunctions.addReadOnlyProperty(currentRecord, 'isDynamic', getIsDynamic);

		function getSystemId() { return sysId; }

		currentRecord.getSystemId = getSystemId;

		function getIsCurrentRecord () { return recordOptions.isCurrentRecord; }

		function hasSubrecord(options)
		{
			var undef = undefined, result, fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentRecord.hasSubrecord');

			return getV1api().nlapiViewSubrecord(fieldId) !== null;
		}

		currentRecord.hasSubrecord = hasSubrecord;

		function oldGetSubrecord(options)
		{
			var undef = undefined,
				fieldId,
				subrecordObj;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentRecord.getSubrecord');

			subrecordObj = getV1api().nlapiViewSubrecord(fieldId);

			return subrecordObj === null ? null : domSubrecord.create(currentRecord, subrecordObj);
		}

		currentRecord.getSubrecord = oldGetSubrecord;

		function oldRemoveSubrecord(options)
		{
			var undef = undefined,
				fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentRecord.removeSubrecord');

			getV1api().nlapiRemoveSubrecord(fieldId);

			return currentRecord;
		}

		currentRecord.removeSubrecord = oldRemoveSubrecord;

		function hasSublistSubrecord(options, fieldId, line)
		{
			var undef = undefined,
				result,
				sublistId;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentRecord.hasSublistSubrecord');
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.hasSublistSubrecord", getV1api().nlapiGetLineItemCount(sublistId));

			result = getV1api().nlapiViewLineItemSubrecord(sublistId, fieldId, line) !== null;

			return result;
		}

		currentRecord.hasSublistSubrecord = hasSublistSubrecord;

		function hasCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				result,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.hasCurrentSublistSubrecord');

			result = getV1api().nlapiViewCurrentLineItemSubrecord(sublistId, fieldId) !== null;

			return result;
		}

		currentRecord.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

		function oldGetCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId,
				subrecordObj;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.getCurrentSublistSubrecord');

			subrecordObj = getV1api().nlapiViewCurrentLineItemSubrecord(sublistId, fieldId);
			if (!!subrecordObj)
			{
				subrecordObj = domSubrecord.create(currentRecord, subrecordObj);
			}

			return subrecordObj;
		}

		currentRecord.getCurrentSublistSubrecord = oldGetCurrentSublistSubrecord;

		function oldRemoveCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentRecord.removeCurrentSublistSubrecord');

			getV1api().nlapiRemoveCurrentLineItemSubrecord(sublistId, fieldId);

			return currentRecord;
		}

		currentRecord.removeCurrentSublistSubrecord = oldRemoveCurrentSublistSubrecord;

		/* --- Proxy cache mechanism setup --- */

		currentRecord.proxy = recordProxy.initialize(currentRecord, recordOptions);

		/* --- End of proxy cache mechanism --- */


		function getSingletonDomCurrentRecordImpl(V1apiGetterCallback, isReadOnly)
		{
			/* Save the method that provide us the lazy-loaded slab of V1 API calls, which we eill need when DOM record methods are called. */
			if (!V1api)
				V1api = V1apiGetterCallback();

			if (!sysId)
				sysId = subrecordUtilityFunctions.getNextSysId(!getId());

			rawCurrentRecord.set(currentRecord);

			recordOptions.isReadOnly = isReadOnly;

			/*
			 * Now, wrap this DOM current record object so that it's a proper record object, including making sure all
			 * methods that return the record object do return the proxied record, and not the inner record object.
			 */
			/* Wrap it, removing API's which must not be exposed for current record, and also let it keep its legacy name. */

			var wrappedRecord = currentRecord.proxy({isInteractive: false}); // domCurrentRecord is always non-interactive
			return wrappedRecord;
		}

		return {
			getSingletonDomCurrentRecordImpl: getSingletonDomCurrentRecordImpl
		}
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/currentRecord
 * @NApiVersion 2.x
 */
define(
	'N/currentRecord',['N/nsobject', 'N/currentRecordBootstrap', 'N/domCurrentRecord'],
	function (nsobject, currentRecordBootstrap, domCurrentRecord)
	{
		var undef = undefined;

		function createCurrentRecordByWrappingNewDynamicRecordOrDomRecord()
		{
			// 1. Try to get the currentRecord in the form of a a dynamicRecord from currentRecordBootstrap.
			//
			// If there's a bootstrapped currentRecord on this page (will be the case on new UI record pages), then use that dynamicRecord for the currentRecord.
			// This prevents attempts to use the NLAPI methods when we have a dynamic record available. The NLAPI methods don't exist, and the singleton dynamicRecord
			// that was created for the currentRecord will be the common source of truth everywhere.
			var dynamicRecord = currentRecordBootstrap.getCurrentRecord();
			if (!!dynamicRecord)
				return dynamicRecord;

			// 2. If dynamicRecord is null at this point, then there's no currentRecord available in the form of a dynamicRecord.
			//
			// We revert to the V1/V2 old UI behavior, and delegate all record API calls to the DOM currentRecord via legacy NLAPI method calls.
			if (pageHasV1Api())
			{
				var isReadOnly = isPageViewMode();
				var domRecord = domCurrentRecord.getSingletonDomCurrentRecordImpl(V1apiGetterFunc, isReadOnly);
				if (!!domRecord)
					return domRecord;
			}

			// 3. If no current record is available, then the caller must retry until one has been created by
			//    currentRecordBootstrap. This will happen when trying to get the current record from scripting
			//    inside the pageInit script of a record that is the current record. Return undefined in that case.
			return undef;
		}


		function isPageViewMode()
		{
			return !(document && document.forms['main_form'] && document.forms['main_form'].onsubmit);
		}

		function pageHasV1Api()
		{
			try
			{
				return !!nlapiGetField;
			}
			catch (e)
			{
				return false;
			}
		}

		/* This is a callback that lazy-creates and returns a copy of needed methods from the V1 API only as soon as theyre needed. */
		function V1apiGetterFunc()
		{
			/*
			 * N/NsRequire.js has some special code that lets only N/currentRecord have access to the V1 API.
			 * So here, we scrape the API, and pass it along to domCurrentRecord, so it may use the V1 API's
			 * to implelemt a V2-like record interface, delegating to legacy V1 implementations. That big
			 * body of code used to be part of this class, causing confusion. I moved it out of here to clearly
			 * separate concerns. Welcome to the much smaller currentRecord.js
			 */
			var V1api = {
				nlapiCancelLineItem: nlapiCancelLineItem,
				nlapiCommitLineItem: nlapiCommitLineItem,
				nlapiFindLineItemMatrixValue: nlapiFindLineItemMatrixValue,
				nlapiFindLineItemValue: nlapiFindLineItemValue,
				nlapiGetCurrentLineItemIndex: nlapiGetCurrentLineItemIndex,
				nlapiGetCurrentLineItemText: nlapiGetCurrentLineItemText,
				nlapiGetCurrentLineItemValue: nlapiGetCurrentLineItemValue,
				nlapiGetField: nlapiGetField,
				nlapiGetFieldText: nlapiGetFieldText,
				nlapiGetFieldTexts: nlapiGetFieldTexts,
				nlapiGetFieldValue: nlapiGetFieldValue,
				nlapiGetFieldValues: nlapiGetFieldValues,
				nlapiGetLineItemCount: nlapiGetLineItemCount,
				nlapiGetLineItemField: nlapiGetLineItemField,
				nlapiGetLineItemMatrixField: nlapiGetLineItemMatrixField,
				nlapiGetLineItemMatrixValue: nlapiGetLineItemMatrixValue,
				nlapiGetLineItemText: nlapiGetLineItemText,
				nlapiGetLineItemTexts: nlapiGetLineItemTexts,
				nlapiGetLineItemValue: nlapiGetLineItemValue,
				nlapiGetMatrixCount: nlapiGetMatrixCount,
				nlapiGetMatrixField: nlapiGetMatrixField,
				nlapiGetMatrixValue: nlapiGetMatrixValue,
				nlapiGetRecordId: nlapiGetRecordId,
				nlapiGetRecordType: nlapiGetRecordType,
				nlapiGetSubList: nlapiGetSubList,
				nlapiInsertLineItem: nlapiInsertLineItem,
				nlapiRemoveCurrentLineItemSubrecord: nlapiRemoveCurrentLineItemSubrecord,
				nlapiRemoveLineItem: nlapiRemoveLineItem,
				nlapiRemoveSubrecord: nlapiRemoveSubrecord,
				nlapiSelectLineItem: nlapiSelectLineItem,
				nlapiSelectNewLineItem: nlapiSelectNewLineItem,
				nlapiSetCurrentLineItemMatrixValue: nlapiSetCurrentLineItemMatrixValue,
				nlapiSetCurrentLineItemText: nlapiSetCurrentLineItemText,
				nlapiSetCurrentLineItemValue: nlapiSetCurrentLineItemValue,
				nlapiSetFieldText: nlapiSetFieldText,
				nlapiSetFieldTexts: nlapiSetFieldTexts,
				nlapiSetFieldValue: nlapiSetFieldValue,
				nlapiSetLineItemValue: nlapiSetLineItemValue,
				nlapiSetLineItemMatrixValue: nlapiSetLineItemMatrixValue,
				nlapiSetMatrixValue: nlapiSetMatrixValue,
				nlapiViewCurrentLineItemSubrecord: nlapiViewCurrentLineItemSubrecord,
				nlapiViewLineItemSubrecord: nlapiViewLineItemSubrecord,
				nlapiViewSubrecord: nlapiViewSubrecord,
				nsapiIsInternal: nsapiIsInternal,
				nsapiSetIsInternal: nsapiSetIsInternal,
				nsapiAssertTrue: nsapiAssertTrue
			};
			return V1api;
		}


		var currentRecordModule = {
			get: function ()
			{
				var currentRecord = createCurrentRecordByWrappingNewDynamicRecordOrDomRecord();
				return currentRecord;
			}
		};
		currentRecordModule.get.promise = function ()
		{
			return new Promise(function (resolve, reject)
			{
				var currentRecord = createCurrentRecordByWrappingNewDynamicRecordOrDomRecord();
				if (currentRecord != null)
				{
					resolve(currentRecord);
				}
			});
		};

		return Object.freeze(currentRecordModule);
	});

define('N',['N/nsobject', 'N/error','N/util','N/log','N/xml','N/format','N/currency','N/runtime','N/action','N/query','N/http','N/portlet','N/https','N/search','N/transaction','N/email','N/ui','N/url','N/record','N/currentRecord'],
	function (nsobject, error,util,log,xml,format,currency,runtime,action,query,http,portlet,https,search,transaction,email,ui,url,record,currentRecord){
		function ModuleConfiguration(){
			this.create = function(module){
				return {
					value: module,
					enumerable: true,
					configurable: false,
					writable: false
				};
			};
		}
		var moduleConfiguration = new ModuleConfiguration();

		return Object.create(nsobject.getNewInstance(), {
				error: moduleConfiguration.create(error),
				util: moduleConfiguration.create(util),
				log: moduleConfiguration.create(log),
				xml: moduleConfiguration.create(xml),
				format: moduleConfiguration.create(format),
				currency: moduleConfiguration.create(currency),
				runtime: moduleConfiguration.create(runtime),
				action: moduleConfiguration.create(action),
				query: moduleConfiguration.create(query),
				http: moduleConfiguration.create(http),
				portlet: moduleConfiguration.create(portlet),
				https: moduleConfiguration.create(https),
				search: moduleConfiguration.create(search),
				transaction: moduleConfiguration.create(transaction),
				email: moduleConfiguration.create(email),
				ui: moduleConfiguration.create(ui),
				url: moduleConfiguration.create(url),
				record: moduleConfiguration.create(record),
				currentRecord: moduleConfiguration.create(currentRecord)
		});
	},
	{internal: ['FieldValidationHelper','environment','nsobject','utilityFunctions','fieldUtil','util/platformResponse','util/currencyUtility','util/date','util/callRecordScript','util/recordScripting','util/slaving','util/sqlInjectionFilter','util/formatter','fieldTypeConstants','util/validator','util/uuid','field','msgRouter','creationFunctionWrapper','formatI18nCommon','dateTimeZone','metadata/fieldMetadata','metadata/fieldDefinition','metadata/fieldPermissions','metadata/sublistMetadata','metadata/sublistDefinition','metadata/sublistPermissions','http/httpUtil','record/recordImpl','record/recordUtil','search/searchUtil','search/searchObject','search/pagingUtil','suiteletContext','transaction/transactionUtil','common/pattern/iterator','common/record/recordActualWork','common/record/recordDefinition','common/record/recordDefinitionEvent','common/record/recordDefinitionEventCompressor','common/record/line/lineDefinition','emptyModule','pagination/paginationObject','util/serverWidgetUtility','searchDefinition','scope','eventEmitter','macro','queryInternal','notification','saveResult','exampleCommon','contextSwitch','localization','scriptLoader','localeContext','search/searchPaging','file','restricted/invoker','restricted/reflet','utilityFunctionsImpl','restricted/scriptArguments','restricted/exampleBridge','restricted/queryApiBridge','restricted/actionApi','restricted/translationBridge','restricted/formatApi','restricted/localizationApiBridge','restricted/bridge','restricted/scriptSessionContext','restricted/scriptWorkQueueContext','restricted/remoteApiBridge','restricted/scriptDeploymentContext','restricted/scriptSessionObjectService','restricted/clientScriptHandler','restricted/recordRemoteApiBridge','restricted/fieldClientScriptHandler','restricted/scopeRemoteApiBridge','restricted/urlApi','restricted/xmlApi','restricted/fileApi','restricted/errorApi','restricted/httpApi','restricted/csvApi','restricted/scheduledScriptApi','restricted/mapReduceApi','restricted/currencyApi','restricted/searchApi','restricted/searchTaskApi','restricted/entityDedupTaskApi','restricted/workflowTriggerTaskApi','restricted/emailApi','restricted/transactionApi','restricted/dateTimeZoneApi','restricted/marshalUtil','restricted/recordApi','restricted/commerceOrderApi','scriptPerformanceMarker','record/proxy/dynamicRecord','record/proxy/deferredDynamicRecord','record/proxy/readOnlyRecord','record/proxy/dynamicSubrecord','record/proxy/deferredDynamicSubrecord','record/proxy/readOnlySubrecord','record/recordProxy','record/recordConstants','record/sublist','record/matrix','record/recordField','record/recordFieldEvent','record/recordEvent','record/relatedRecord','record/actionInternal','record/recordUtilityFunctions','record/subrecordUtilityFunctions','record/line/lineProxy','record/line/deferredDynamicLine','record/line/dynamicLine','record/line/readOnlyLine','record/line/sublistLineImpl','record/line/sublistLineBufferImpl','record/line/sublistLineImplementation','record/recordService','record/modelController','record/sublistLine','record/sublistLineEvent','record/recordCache','record/recordCacheController','record/model','record/modelEvent','record/metadata','record/metadataEvent','record/fieldLevelMetadata','record/fieldLevelMetadataEvent','record/sublistLevelMetadata','record/sublistLevelMetadataEvent','record/recordStateController','record/recordStateControllerEvent','record/fieldState','record/fieldStateEvent','record/sublistState','record/sublistStateEvent','record/sublistLineState','record/sublistLineStateEvent','record/recordImplementation','record/dynamicRecordImpl','record/deferredDynamicRecordImpl','record/recordScriptingScope','record/recordImplV1','record/recordImplV1Util','record/legacyNLObjects','record/subrecordController','record/subrecordImplV1Util','record/selectFieldOptionTextCache','rawCurrentRecord','domCurrentRecord','currentRecord/currentSublist','currentRecord/currentField','currentRecord/currentSubrecord'], devonly: ['N/errorHandlerTestApi','N/exampleApi','N/javaExampleApi']}
);

window._N_define = define;

// Issue 547060 UI team will manage when to remove define from global scope
;
